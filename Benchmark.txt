Total duration: 35.0988s
File: D:\Thèse\Codes\Articles\MPDHP\MPDHP.py
File duration: 13.7016s (39.04%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import os
     2|         0|            0|            0|  0.00%|import pickle
     3|         0|            0|            0|  0.00%|import sys
     4|         0|            0|            0|  0.00%|import time
     5|         0|            0|            0|  0.00%|from utils import *
     6|         0|            0|            0|  0.00%|from sklearn.metrics import normalized_mutual_info_score as NMI
     7|         0|            0|            0|  0.00%|import gzip
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|np.random.seed(12345)
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|"""
    12|         0|            0|            0|  0.00%|import pprofile
    13|         0|            0|            0|  0.00%|profiler = pprofile.Profile()
    14|         0|            0|            0|  0.00%|with profiler:
    15|         0|            0|            0|  0.00%|    RhovsT(g, 0.1, 0.28999, 1, 1000)
    16|         0|            0|            0|  0.00%|profiler.print_stats()
    17|         0|            0|            0|  0.00%|profiler.dump_stats("Benchmark.txt")
    18|         0|            0|            0|  0.00%|pause()
    19|         0|            0|            0|  0.00%|"""
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|class Dirichlet_Hawkes_Process(object):
    22|         0|            0|            0|  0.00%|	"""docstring for Dirichlet Hawkes Prcess"""
    23|         3|            0|            0|  0.00%|	def __init__(self, particle_num, base_intensity, theta0, alpha0, reference_time, vocabulary_size, bandwidth, sample_num, r, multivariate, folder_output=None, name_output=None):
    24|         3|            0|            0|  0.00%|		super(Dirichlet_Hawkes_Process, self).__init__()
    25|         3|            0|            0|  0.00%|		self.r = r
    26|         3|            0|            0|  0.00%|		self.multivariate = multivariate
    27|         3|            0|            0|  0.00%|		self.particle_num = particle_num
    28|         3|            0|            0|  0.00%|		self.base_intensity = base_intensity
    29|         3|            0|            0|  0.00%|		self.theta0 = theta0
    30|         3|            0|            0|  0.00%|		self.alpha0 = alpha0
    31|         3|            0|            0|  0.00%|		self.reference_time = reference_time
    32|         3|            0|            0|  0.00%|		self.vocabulary_size = vocabulary_size
    33|         3|            0|            0|  0.00%|		self.bandwidth = bandwidth
    34|         3|  0.000995398|  0.000331799|  0.00%|		self.horizon = (max(self.reference_time)+max(self.bandwidth))
    35|         3|            0|            0|  0.00%|		self.sample_num = sample_num
    36|         3|            0|            0|  0.00%|		self.particles = []
    37|        18|            0|            0|  0.00%|		for i in range(particle_num):
    38|        15|            0|            0|  0.00%|			self.particles.append(Particle(i, 1.0 / self.particle_num, alpha0, sample_num, len(reference_time)))
(call)|        15|   0.00199485|   0.00013299|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:43 __init__
    39|         0|            0|            0|  0.00%|
    40|         3|            0|            0|  0.00%|		self.folder_output = folder_output
    41|         3|            0|            0|  0.00%|		self.name_output = name_output
    42|         0|            0|            0|  0.00%|
    43|         3|            0|            0|  0.00%|		self.active_interval = None
    44|         0|            0|            0|  0.00%|
    45|      1002|   0.00199676|  1.99277e-06|  0.01%|	def sequential_monte_carlo(self, doc, threshold):
    46|         0|            0|            0|  0.00%|		# Set relevant time interval
    47|      1002|   0.00817299|  8.15668e-06|  0.02%|		tu = EfficientImplementation(doc.timestamp, self.reference_time, self.bandwidth, epsilon=1e-10)
(call)|      1002|     0.028455|  2.83982e-05|  0.08%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:123 EfficientImplementation
    48|      1002|   0.00295329|   2.9474e-06|  0.01%|		T = doc.timestamp + self.horizon  # So that Gaussian RBF kernel is fully computed; needed to correctly compute the integral part of the likelihood
    49|      1002|   0.00299168|   2.9857e-06|  0.01%|		self.active_interval = [tu, T]
    50|         0|            0|            0|  0.00%|
    51|      1002|   0.00199366|  1.98968e-06|  0.01%|		particles = []
    52|      6012|    0.0192595|   3.2035e-06|  0.05%|		for particle in self.particles:
    53|      5010|    0.0349433|  6.97472e-06|  0.10%|			particles.append(self.particle_sampler(particle, doc))
(call)|      5010|      32.2966|   0.00644643| 92.02%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:60 particle_sampler
    54|         0|            0|            0|  0.00%|
    55|      1002|   0.00416851|  4.16019e-06|  0.01%|		self.particles = particles
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|		# Resample particules whose weight is below the given threshold
    58|      1002|       0.0142|  1.41716e-05|  0.04%|		self.particles = self.particles_normal_resampling(self.particles, threshold)
(call)|      1002|     0.532047|  0.000530985|  1.52%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:311 particles_normal_resampling
    59|         0|            0|            0|  0.00%|
    60|      5010|    0.0110624|  2.20806e-06|  0.03%|	def particle_sampler(self, particle, doc):
    61|         0|            0|            0|  0.00%|		# Sample cluster label
    62|      5010|    0.0667276|  1.33189e-05|  0.19%|		particle, selected_cluster_index = self.sampling_cluster_label(particle, doc)
(call)|      5010|      19.8407|   0.00396023| 56.53%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:70 sampling_cluster_label
    63|      5010|    0.0102303|  2.04198e-06|  0.03%|		if not (self.r>-1e-5 and self.r<1e-5):
    64|         0|            0|            0|  0.00%|			# Update the triggering kernel
    65|      5010|     0.036459|  7.27724e-06|  0.10%|			particle.clusters[selected_cluster_index].alpha = self.parameter_estimation(particle, selected_cluster_index)
(call)|      5010|      11.3804|   0.00227153| 32.42%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:238 parameter_estimation
    66|         0|            0|            0|  0.00%|		# Calculate the weight update probability ; + bc log form
    67|      5010|    0.0501242|  1.00048e-05|  0.14%|		particle.log_update_prob = self.calculate_particle_log_update_prob(particle, selected_cluster_index, doc)
(call)|      5010|     0.889786|  0.000177602|  2.54%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:292 calculate_particle_log_update_prob
    68|      5010|    0.0111077|   2.2171e-06|  0.03%|		return particle
    69|         0|            0|            0|  0.00%|
    70|      5010|    0.0270145|  5.39211e-06|  0.08%|	def sampling_cluster_label(self, particle, doc):
    71|      5010|    0.0326424|  6.51544e-06|  0.09%|		if len(particle.clusters) == 0: # The first document is observed
    72|         5|            0|            0|  0.00%|			particle.cluster_num_by_now += 1
    73|         5|            0|            0|  0.00%|			selected_cluster_index = particle.cluster_num_by_now
    74|         5|            0|            0|  0.00%|			particle.active_clusters[selected_cluster_index] = [doc.timestamp]
    75|        20|            0|            0|  0.00%|			particle.active_clus_to_ind = {int(c): i for i,c in enumerate(sorted(particle.active_clusters))}
(call)|         5|            0|            0|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:75 <dictcomp>
    76|         5|            0|            0|  0.00%|			particle.active_timestamps = np.array([[selected_cluster_index, doc.timestamp]])
    77|         5|            0|            0|  0.00%|			selected_cluster = Cluster(index = selected_cluster_index, num_samples=self.sample_num)
(call)|         5|            0|            0|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:16 __init__
    78|         5|            0|            0|  0.00%|			selected_cluster.add_document(doc)
(call)|         5|            0|            0|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:30 add_document
    79|         5|            0|            0|  0.00%|			particle.clusters[selected_cluster_index] = selected_cluster #.append(selected_cluster)
    80|         5|   0.00099802|  0.000199604|  0.00%|			particle.docs2cluster_ID.append(selected_cluster_index)
    81|         5|            0|            0|  0.00%|			self.active_cluster_logrates = {0:0, 1:0}
    82|         0|            0|            0|  0.00%|
    83|         5|            0|            0|  0.00%|			if not (self.r>-1e-5 and self.r<1e-5):
    84|         5|            0|            0|  0.00%|				particle = self.update_clusters_samples_particle(particle)
(call)|         5|            0|            0|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:218 update_clusters_samples_particle
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|		else: # A new document arrives
    87|      5005|    0.0273275|  5.46005e-06|  0.08%|			active_cluster_indexes = [0] # Zero for new cluster
    88|      5005|    0.0337775|  6.74875e-06|  0.10%|			active_cluster_rates = [self.base_intensity]
    89|     10010|    0.0956793|  9.55837e-06|  0.27%|			cls0_log_dirichlet_multinomial_distribution = log_dirichlet_multinomial_distribution(doc.word_distribution, doc.word_distribution,\
(call)|      5005|     0.610251|  0.000121928|  1.74%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:303 log_dirichlet_multinomial_distribution
    90|      5005|    0.0352104|  7.03504e-06|  0.10%|			 doc.word_count, doc.word_count, self.vocabulary_size, self.theta0)
    91|      5005|    0.0272999|  5.45452e-06|  0.08%|			active_cluster_textual_probs = [cls0_log_dirichlet_multinomial_distribution]
    92|         0|            0|            0|  0.00%|			# Update list of relevant timestamps
    93|      5005|    0.0680513|  1.35967e-05|  0.19%|			particle = self.update_active_clusters(particle)
(call)|      5005|      1.43795|  0.000287303|  4.10%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:255 update_active_clusters
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|			# Posterior probability for each cluster
    96|      5005|    0.0644059|  1.28683e-05|  0.18%|			clusters_timeseq = particle.active_timestamps[particle.active_timestamps[:, 1]<doc.timestamp, 0]
    97|      5005|    0.0693498|  1.38561e-05|  0.20%|			timeseq = doc.timestamp - particle.active_timestamps[particle.active_timestamps[:, 1]<doc.timestamp, 1]
    98|     73156|     0.197821|  2.70409e-06|  0.56%|			particle.active_clus_to_ind = {int(c): i for i,c in enumerate(sorted(particle.active_clusters))}
(call)|      5005|     0.132416|  2.64568e-05|  0.38%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:98 <dictcomp>
    99|      5005|    0.0323656|  6.46665e-06|  0.09%|			if len(timeseq)==0:  # Because kernels are rigorously null at this point, making this the only possible choice
   100|         5|            0|            0|  0.00%|				selected_cluster_index=0
   101|         0|            0|            0|  0.00%|			else:
   102|      5000|    0.0575335|  1.15067e-05|  0.16%|				RBF = RBF_kernel(self.reference_time, timeseq, self.bandwidth)  # num_time_points, size_kernel
(call)|      5000|     0.227512|  4.55023e-05|  0.65%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:168 RBF_kernel
   103|      5000|    0.0325458|  6.50916e-06|  0.09%|				unweighted_triggering_kernel = np.zeros((len(particle.active_clusters), len(self.reference_time)))
   104|     63136|     0.337108|  5.33939e-06|  0.96%|				for clus in set(clusters_timeseq):
   105|     58136|      0.27307|  4.69709e-06|  0.78%|					indclus = particle.active_clus_to_ind[int(clus)]
   106|     58136|     0.586376|  1.00863e-05|  1.67%|					trigg = RBF[clusters_timeseq==clus]
   107|     58136|     0.260822|  4.48641e-06|  0.74%|					nb = len(trigg)
   108|     58136|     0.245154|   4.2169e-06|  0.70%|					if nb==1:
   109|      1932|    0.0104699|  5.41921e-06|  0.03%|						unweighted_triggering_kernel[indclus] = trigg[0]
   110|      1932|   0.00609946|  3.15707e-06|  0.02%|						continue
   111|     56204|     0.233194|  4.14906e-06|  0.66%|					if nb not in ones: ones[nb] = np.ones((nb))
   112|     56204|     0.368675|  6.55959e-06|  1.05%|					unweighted_triggering_kernel[indclus] = ones[nb].dot(trigg)
   113|         0|            0|            0|  0.00%|
   114|     63136|     0.263819|  4.17859e-06|  0.75%|				for active_cluster_index in particle.active_clusters:
   115|     58136|     0.228842|  3.93632e-06|  0.65%|					active_cluster_indexes.append(active_cluster_index)
   116|         0|            0|            0|  0.00%|
   117|     58136|     0.262873|  4.52169e-06|  0.75%|					if not (self.r>-1e-5 and self.r<1e-5):
   118|     58136|     0.234405|    4.032e-06|  0.67%|						alpha = particle.clusters[active_cluster_index].alpha
   119|         0|            0|            0|  0.00%|
   120|     58136|     0.280064|  4.81739e-06|  0.80%|						mat=unweighted_triggering_kernel*alpha
   121|     58136|     0.219738|  3.77972e-06|  0.63%|						lg = mat.shape[0]
   122|     58136|     0.236086|  4.06092e-06|  0.67%|						if lg not in ones: ones[lg] = np.ones((lg))
   123|     58136|     0.315264|  5.42287e-06|  0.90%|						mat = ones[lg].dot(mat)
   124|     58136|     0.215525|  3.70725e-06|  0.61%|						lg = mat.shape[0]
   125|     58136|     0.204182|  3.51215e-06|  0.58%|						if lg not in ones: ones[lg] = np.ones((lg))
   126|     58136|     0.301705|  5.18964e-06|  0.86%|						mat = ones[lg].dot(mat)
   127|     58136|     0.221751|  3.81435e-06|  0.63%|						rate = mat
   128|         0|            0|            0|  0.00%|					else:
   129|         0|            0|            0|  0.00%|						rate = 0.
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|					# Powered Dirichlet-Hawkes prior
   132|     58136|     0.214212|  3.68467e-06|  0.61%|					active_cluster_rates.append(rate)
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|					# Language model likelihood
   135|     58136|     0.420428|   7.2318e-06|  1.20%|					cls_word_distribution = particle.clusters[active_cluster_index].word_distribution + doc.word_distribution
   136|     58136|     0.264013|   4.5413e-06|  0.75%|					cls_word_count = particle.clusters[active_cluster_index].word_count + doc.word_count
   137|     58136|     0.583308|  1.00335e-05|  1.66%|					cls_log_dirichlet_multinomial_distribution = log_dirichlet_multinomial_distribution(cls_word_distribution, doc.word_distribution, cls_word_count, doc.word_count, self.vocabulary_size, self.theta0)
(call)|     58136|      6.79674|  0.000116911| 19.36%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:303 log_dirichlet_multinomial_distribution
   138|     58136|     0.232267|  3.99523e-06|  0.66%|					active_cluster_textual_probs.append(cls_log_dirichlet_multinomial_distribution)
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|				# Posteriors to probabilities
   141|      5000|    0.0687633|  1.37527e-05|  0.20%|				active_cluster_logrates = self.r*np.log(np.array(active_cluster_rates)+1e-100)
   142|     73136|      0.23062|   3.1533e-06|  0.66%|				self.active_cluster_logrates = {c: active_cluster_logrates[i+1] for i, c in enumerate(particle.active_clusters)}
(call)|      5000|     0.160434|  3.20868e-05|  0.46%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:142 <dictcomp>
   143|      5000|     0.012255|  2.45099e-06|  0.03%|				self.active_cluster_logrates[0] = active_cluster_logrates[0]
   144|      5000|    0.0490849|  9.81698e-06|  0.14%|				cluster_selection_probs = active_cluster_logrates + active_cluster_textual_probs # in log scale
   145|      5000|    0.0544751|   1.0895e-05|  0.16%|				cluster_selection_probs = cluster_selection_probs - max(cluster_selection_probs) # prevent overflow
   146|      5000|    0.0334873|  6.69746e-06|  0.10%|				cluster_selection_probs = np.exp(cluster_selection_probs)
   147|      5000|    0.0861354|  1.72271e-05|  0.25%|				cluster_selection_probs = cluster_selection_probs / np.ones((len(cluster_selection_probs))).dot(cluster_selection_probs)  # Normalize
(call)|      5000|      0.21784|   4.3568e-05|  0.62%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:149 ones
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|				# print(cluster_selection_probs, active_cluster_indexes)
   150|         0|            0|            0|  0.00%|				# # Random cluster selection
   151|         0|            0|            0|  0.00%|				# selected_cluster_array = multinomial(exp_num = 1, probabilities = cluster_selection_probs)
   152|         0|            0|            0|  0.00%|				# selected_cluster_index = np.array(active_cluster_indexes)[np.nonzero(selected_cluster_array)][0]
   153|         0|            0|            0|  0.00%|
   154|      5000|    0.0481992|  9.63984e-06|  0.14%|				endo_exo_probs = [cluster_selection_probs[0], sum(cluster_selection_probs[1:])]
   155|      5000|     0.245612|  4.91224e-05|  0.70%|				endo_exo = np.random.choice([0,1], p=endo_exo_probs)
(call)|      5000|    0.0974967|  1.94993e-05|  0.28%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:457 __new__
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|				# Answers the vanishing prior problem
   158|      5000|    0.0282683|  5.65367e-06|  0.08%|				selected_cluster_index = None
   159|      5000|    0.0173256|  3.46513e-06|  0.05%|				if endo_exo==0:
   160|        96|  8.01086e-05|  8.34465e-07|  0.00%|					selected_cluster_index = 0
   161|      4904|    0.0190735|  3.88937e-06|  0.05%|				elif endo_exo==1:
   162|      4904|    0.0285311|  5.81792e-06|  0.08%|					lg = len(cluster_selection_probs[1:])
   163|      4904|    0.0347219|  7.08031e-06|  0.10%|					cluster_selection_probs = cluster_selection_probs[1:]/cluster_selection_probs[1:].dot(ones[lg])
   164|      4904|    0.0205164|   4.1836e-06|  0.06%|					active_cluster_indexes = active_cluster_indexes[1:]
   165|      4904|     0.279993|  5.70948e-05|  0.80%|					selected_cluster_index = np.random.choice(active_cluster_indexes, p=cluster_selection_probs)  # Categorical distribution
(call)|      9808|     0.152684|  1.55673e-05|  0.44%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:457 __new__
(call)|      4904|     0.167384|  3.41321e-05|  0.48%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:356 issubdtype
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|				# selected_cluster_index = np.random.choice(active_cluster_indexes, p=cluster_selection_probs)
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|			# New cluster drawn
   170|      5005|    0.0291462|  5.82342e-06|  0.08%|			if selected_cluster_index == 0:
   171|       101|  0.000105858|   1.0481e-06|  0.00%|				particle.cluster_num_by_now += 1
   172|       101|  1.85966e-05|  1.84125e-07|  0.00%|				selected_cluster_index = particle.cluster_num_by_now
   173|       101|            0|            0|  0.00%|				self.active_cluster_logrates[selected_cluster_index] = self.active_cluster_logrates[0]
   174|       101|            0|            0|  0.00%|				particle.active_clusters[selected_cluster_index] = [doc.timestamp]
   175|      1172|   0.00408769|  3.48779e-06|  0.01%|				particle.active_clus_to_ind = {int(c): i for i,c in enumerate(sorted(particle.active_clusters))}
(call)|       101|   0.00100374|  9.93804e-06|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:175 <dictcomp>
   176|       101|  0.000997066|  9.87195e-06|  0.00%|				selected_cluster = Cluster(index = selected_cluster_index, num_samples=self.sample_num)
(call)|       101|    0.0109763|  0.000108676|  0.03%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:16 __init__
   177|       101|  0.000998259|  9.88375e-06|  0.00%|				selected_cluster.add_document(doc)
(call)|       101|   0.00514054|  5.08965e-05|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:30 add_document
   178|       101|   0.00103712|  1.02685e-05|  0.00%|				particle.clusters[selected_cluster_index] = selected_cluster
   179|       101|   0.00195694|  1.93756e-05|  0.01%|				particle.docs2cluster_ID.append(selected_cluster_index)
   180|         0|            0|            0|  0.00%|
   181|       101|            0|            0|  0.00%|				if not (self.r>-1e-5 and self.r<1e-5):
   182|       101|  0.000996351|  9.86486e-06|  0.00%|					particle = self.update_clusters_samples_particle(particle)
(call)|       101|    0.0466156|  0.000461541|  0.13%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:218 update_clusters_samples_particle
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|			# Existing cluster drawn
   185|         0|            0|            0|  0.00%|			else:
   186|      4904|    0.0203204|  4.14364e-06|  0.06%|				selected_cluster = particle.clusters[selected_cluster_index]
   187|      4904|    0.0493772|  1.00688e-05|  0.14%|				selected_cluster.add_document(doc)
(call)|      4904|    0.0711899|  1.45167e-05|  0.20%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:30 add_document
   188|      4904|    0.0143461|  2.92539e-06|  0.04%|				particle.docs2cluster_ID.append(selected_cluster_index)
   189|      4904|    0.0152478|  3.10926e-06|  0.04%|				particle.active_clusters[selected_cluster_index].append(doc.timestamp)
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|			# Initialized in if==0
   192|      5005|    0.0563164|   1.1252e-05|  0.16%|			particle.active_timestamps = np.vstack((particle.active_timestamps, [selected_cluster_index, doc.timestamp]))
(call)|      5005|     0.684898|  0.000136843|  1.95%|# <__array_function__ internals>:177 vstack
   193|         0|            0|            0|  0.00%|
   194|      5010|    0.0204167|   4.0752e-06|  0.06%|		particle.all_timestamps.append(doc.timestamp)
   195|         0|            0|            0|  0.00%|
   196|      5010|    0.0200734|  4.00667e-06|  0.06%|		return particle, selected_cluster_index
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|	def update_clusters_samples(self, particle):
   199|         0|            0|            0|  0.00%|		for cluster_index in particle.active_clusters:
   200|         0|            0|            0|  0.00%|			if particle.clusters[cluster_index].alphas.shape[1] == len(particle.active_clusters):
   201|         0|            0|            0|  0.00%|				continue
   202|         0|            0|            0|  0.00%|			newVec, newPriors = draw_vectors(self.alpha0, self.sample_num, [0], len(self.reference_time), return_priors=True)
   203|         0|            0|            0|  0.00%|			newVec = newVec.squeeze()
   204|         0|            0|            0|  0.00%|			if not self.multivariate:
   205|         0|            0|            0|  0.00%|				newVec *= 0.
   206|         0|            0|            0|  0.00%|				newVec += 1e-10
   207|         0|            0|            0|  0.00%|				newPriors *= 0.
   208|         0|            0|            0|  0.00%|			particle.clusters[cluster_index].log_priors = particle.clusters[cluster_index].log_priors + newPriors
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|			particle.clusters[cluster_index].alphas = np.concatenate((particle.clusters[cluster_index].alphas, newVec[:, None, :]), axis=1)
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|			if particle.clusters[cluster_index].alpha is not None:
   213|         0|            0|            0|  0.00%|				particle.clusters[cluster_index].alpha = np.concatenate((particle.clusters[cluster_index].alpha, newVec[0, None, :]), axis=0)
   214|         0|            0|            0|  0.00%|			else:
   215|         0|            0|            0|  0.00%|				particle.clusters[cluster_index].alpha = newVec[0, None, :]
   216|         0|            0|            0|  0.00%|		return particle.clusters
   217|         0|            0|            0|  0.00%|
   218|       106|            0|            0|  0.00%|	def update_clusters_samples_particle(self, particle):
   219|       106|            0|            0|  0.00%|		if particle.alphas.shape[1] == len(particle.active_clusters):
   220|         5|            0|            0|  0.00%|			return particle
   221|         0|            0|            0|  0.00%|
   222|       101|  0.000990868|  9.81057e-06|  0.00%|		newVec, newPriors = draw_vectors(self.alpha0, self.sample_num, [0], len(self.reference_time), return_priors=True)
(call)|       101|    0.0101943|  0.000100934|  0.03%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:63 draw_vectors
   223|       101|            0|            0|  0.00%|		if not self.multivariate:
   224|         0|            0|            0|  0.00%|			newVec *= 0.
   225|         0|            0|            0|  0.00%|			newVec += 1e-10
   226|         0|            0|            0|  0.00%|			newPriors *= 0.
   227|         0|            0|            0|  0.00%|
   228|       101|   0.00199366|  1.97392e-05|  0.01%|		particle.alphas = np.concatenate((particle.alphas, newVec), axis=1)
(call)|       101|   0.00306082|  3.03051e-05|  0.01%|# <__array_function__ internals>:177 concatenate
   229|       101|    0.0010376|  1.02732e-05|  0.00%|		particle.log_priors = particle.log_priors + newPriors
   230|         0|            0|            0|  0.00%|
   231|       970|   0.00300694|  3.09993e-06|  0.01%|		for cluster_index in particle.active_clusters:
   232|       869|   0.00740385|  8.51997e-06|  0.02%|				if particle.clusters[cluster_index].alpha is not None:
   233|       768|   0.00694323|  9.04066e-06|  0.02%|					particle.clusters[cluster_index].alpha = np.concatenate((particle.clusters[cluster_index].alpha, newVec[np.random.randint(0,self.sample_num)]), axis=0)
(call)|       768|   0.00998664|  1.30034e-05|  0.03%|# <__array_function__ internals>:177 concatenate
   234|         0|            0|            0|  0.00%|				else:
   235|       101|   0.00199771|  1.97793e-05|  0.01%|					particle.clusters[cluster_index].alpha = newVec[np.random.randint(0,self.sample_num), 0, :]
   236|       101|            0|            0|  0.00%|		return particle
   237|         0|            0|            0|  0.00%|
   238|      5010|    0.0110312|  2.20183e-06|  0.03%|	def parameter_estimation(self, particle, selected_cluster_index):
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|		# Observation is alone in the cluster => the cluster is new => random initialization of alpha
   241|         0|            0|            0|  0.00%|		# Note that it cannot be a previously filled cluster since it would have 0 chance to get selected (see sampling_cluster_label)
   242|         0|            0|            0|  0.00%|		# if particle.clusters[selected_cluster_index].alpha is None:
   243|         0|            0|            0|  0.00%|		# 	alpha = draw_vectors(self.alpha0, num_samples=1, active_clusters=particle.active_clusters, size_kernel=len(self.reference_time))
   244|         0|            0|            0|  0.00%|		# 	return alpha
   245|         0|            0|            0|  0.00%|
   246|      5010|    0.0164669|   3.2868e-06|  0.05%|		T = self.active_interval[1]
   247|      5010|    0.0597894|   1.1934e-05|  0.17%|		particle.clusters[selected_cluster_index] = update_cluster_likelihoods(particle.active_timestamps, particle, particle.clusters[selected_cluster_index], self.reference_time, self.bandwidth, self.base_intensity, T)
(call)|      5010|      9.00677|   0.00179776| 25.66%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:236 update_cluster_likelihoods
   248|      5010|    0.0379021|  7.56529e-06|  0.11%|		alpha = update_triggering_kernel_optim(particle, particle.clusters[selected_cluster_index])
(call)|      5010|       1.9536|   0.00038994|  5.57%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:270 update_triggering_kernel_optim
   249|         0|            0|            0|  0.00%|
   250|     63257|      0.12395|  1.95946e-06|  0.35%|		for clus in particle.active_clusters:
   251|     58247|     0.162744|  2.79403e-06|  0.46%|			particle.clusters[selected_cluster_index].alpha_final[clus] = alpha[particle.active_clus_to_ind[clus]]
   252|         0|            0|            0|  0.00%|
   253|      5010|    0.0081284|  1.62244e-06|  0.02%|		return alpha
   254|         0|            0|            0|  0.00%|
   255|      5005|    0.0163517|  3.26707e-06|  0.05%|	def update_active_clusters(self, particle):
   256|      5005|    0.0210786|  4.21151e-06|  0.06%|		tu = self.active_interval[0]
   257|      5005|    0.0306032|  6.11452e-06|  0.09%|		keys = list(particle.active_clusters.keys())
   258|      5005|    0.0948884|  1.89587e-05|  0.27%|		particle.active_timestamps = particle.active_timestamps[particle.active_timestamps[:, 1]>tu]
   259|      5005|    0.0163422|  3.26517e-06|  0.05%|		toRem = []
   260|     63181|     0.148037|  2.34307e-06|  0.42%|		for cluster_index in keys:
   261|     58176|     0.231387|  3.97736e-06|  0.66%|			timeseq = np.array(particle.active_clusters[cluster_index])
   262|         0|            0|            0|  0.00%|			# active_timeseq = [t for t in timeseq if t > tu]
   263|     58176|     0.321076|  5.51905e-06|  0.91%|			active_timeseq = timeseq[timeseq>tu]
   264|     58176|     0.153614|   2.6405e-06|  0.44%|			if active_timeseq.size==0:
   265|        35|            0|            0|  0.00%|				toRem.append(cluster_index)
   266|         0|            0|            0|  0.00%|			else:
   267|     58141|       0.2279|  3.91978e-06|  0.65%|				particle.active_clusters[cluster_index] = list(active_timeseq)
   268|         0|            0|            0|  0.00%|
   269|      5040|    0.0274673|  5.44985e-06|  0.08%|		for cluster_index in sorted(toRem, reverse=True):
   270|        35|  0.000997543|  2.85012e-05|  0.00%|			del particle.active_clusters[cluster_index]  # If no observation is relevant anymore, the cluster has 0 chance to get chosen => we remove it from the calculations
   271|         0|            0|            0|  0.00%|			# if self.r != 0:
   272|         0|            0|            0|  0.00%|			# 	del particle.clusters[cluster_index].alpha
   273|         0|            0|            0|  0.00%|			# del particle.clusters[cluster_index].likelihood_samples
   274|         0|            0|            0|  0.00%|			# del particle.clusters[cluster_index].likelihood_samples_sansLambda
   275|         0|            0|            0|  0.00%|			# del particle.clusters[cluster_index].triggers
   276|         0|            0|            0|  0.00%|			# del particle.clusters[cluster_index].integ_triggers
   277|         0|            0|            0|  0.00%|
   278|        35|            0|            0|  0.00%|			if not (self.r>-1e-5 and self.r<1e-5):
   279|        35|            0|            0|  0.00%|				particle.alphas = np.delete(particle.alphas, particle.active_clus_to_ind[cluster_index], axis=1)
(call)|        35|   0.00409842|  0.000117098|  0.01%|# <__array_function__ internals>:177 delete
   280|         0|            0|            0|  0.00%|
   281|       378|            0|            0|  0.00%|				for cluster_index_left in keys:
   282|       343|  0.000997305|  2.90759e-06|  0.00%|					if cluster_index_left not in toRem:
   283|       302|   0.00395751|  1.31043e-05|  0.01%|						particle.clusters[cluster_index_left].alpha = np.delete(particle.clusters[cluster_index_left].alpha, particle.active_clus_to_ind[cluster_index], axis=0)
(call)|       302|    0.0312085|  0.000103339|  0.09%|# <__array_function__ internals>:177 delete
   284|         0|            0|            0|  0.00%|
   285|        35|            0|            0|  0.00%|			file_cluster = writeClusters(particle.clusters[cluster_index], self.r, particle.index, self.folder_output, self.name_output)
(call)|        35|    0.0899429|    0.0025698|  0.26%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:594 writeClusters
(call)|        35|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:308 closed
   286|        35|            0|            0|  0.00%|			particle.files_clusters.append((cluster_index, file_cluster))
   287|         0|            0|            0|  0.00%|
   288|        35|            0|            0|  0.00%|			del particle.clusters[cluster_index]
   289|         0|            0|            0|  0.00%|
   290|      5005|    0.0180054|  3.59748e-06|  0.05%|		return particle
   291|         0|            0|            0|  0.00%|
   292|      5010|    0.0171251|  3.41819e-06|  0.05%|	def calculate_particle_log_update_prob(self, particle, selected_cluster_index, doc):
   293|      5010|    0.0142641|  2.84713e-06|  0.04%|		cls_word_distribution = particle.clusters[selected_cluster_index].word_distribution
   294|      5010|    0.0120335|  2.40189e-06|  0.03%|		cls_word_count = particle.clusters[selected_cluster_index].word_count
   295|      5010|    0.0122876|  2.45262e-06|  0.04%|		doc_word_distribution = doc.word_distribution
   296|      5010|    0.0130031|  2.59543e-06|  0.04%|		doc_word_count = doc.word_count
   297|         0|            0|            0|  0.00%|
   298|      5010|    0.0516241|  1.03042e-05|  0.15%|		log_update_prob = log_dirichlet_multinomial_distribution(cls_word_distribution, doc_word_distribution, cls_word_count, doc_word_count, self.vocabulary_size, self.theta0)
(call)|      5010|     0.632332|  0.000126214|  1.80%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:303 log_dirichlet_multinomial_distribution
   299|         0|            0|            0|  0.00%|
   300|      5010|    0.0177484|  3.54259e-06|  0.05%|		div = self.active_cluster_logrates.values()
   301|      5010|    0.0183277|  3.65823e-06|  0.05%|		lg = len(div)
   302|      5010|    0.0142009|  2.83452e-06|  0.04%|		if lg not in ones: ones[lg] = np.ones((lg))
   303|         0|            0|            0|  0.00%|
   304|      5010|    0.0200322|  3.99844e-06|  0.06%|		lograte = self.active_cluster_logrates[selected_cluster_index]
   305|      5010|    0.0576041|  1.14978e-05|  0.16%|		lograte = lograte - np.log(ones[lg].dot(np.exp(list(self.active_cluster_logrates.values()))))
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|		#log_update_prob += lograte
   308|         0|            0|            0|  0.00%|
   309|      5010|   0.00920343|  1.83701e-06|  0.03%|		return log_update_prob
   310|         0|            0|            0|  0.00%|
   311|      1002|    0.0049715|  4.96158e-06|  0.01%|	def particles_normal_resampling(self, particles, threshold):
   312|      1002|   0.00307035|  3.06423e-06|  0.01%|		weights = []; log_update_probs = []
   313|      6012|    0.0352626|  5.86537e-06|  0.10%|		for particle in particles:
   314|      5010|    0.0254169|  5.07322e-06|  0.07%|			weights.append(particle.weight)
   315|      5010|    0.0105343|  2.10265e-06|  0.03%|			log_update_probs.append(particle.log_update_prob)
   316|      1002|   0.00620413|  6.19174e-06|  0.02%|		weights = np.array(weights)
   317|      1002|  0.000997543|  9.95552e-07|  0.00%|		log_update_probs = np.array(log_update_probs)
   318|      1002|    0.0219994|  2.19554e-05|  0.06%|		log_update_probs = log_update_probs - max(log_update_probs) # Prevents overflow
   319|      1002|   0.00712872|  7.11449e-06|  0.02%|		update_probs = np.exp(log_update_probs)
   320|      1002|   0.00803733|  8.02129e-06|  0.02%|		weights = weights * update_probs
   321|      1002|    0.0151715|  1.51412e-05|  0.04%|		weights = weights / np.sum(weights) # normalization
(call)|      1002|    0.0794334|  7.92749e-05|  0.23%|# <__array_function__ internals>:177 sum
   322|         0|            0|            0|  0.00%|		# if len(self.particles[0].active_clusters)==1:
   323|         0|            0|            0|  0.00%|		# 	print(np.round(update_probs, 2))
   324|         0|            0|            0|  0.00%|		# 	print(np.round(weights, 4))
   325|         0|            0|            0|  0.00%|		# 	print([len(part.active_clusters) for part in self.particles])
   326|         0|            0|            0|  0.00%|		# 	print()
   327|      1002|    0.0163441|  1.63114e-05|  0.05%|		resample_num = len(np.where(weights + 1e-5 < threshold)[0])
(call)|      1002|    0.0184481|  1.84113e-05|  0.05%|# <__array_function__ internals>:177 where
   328|         0|            0|            0|  0.00%|
   329|      1002|    0.0061667|  6.15439e-06|  0.02%|		if resample_num == 0: # No need to resample particle, but still need to assign the updated weights to particles
   330|      5748|    0.0204785|  3.56272e-06|  0.06%|			for i, particle in enumerate(particles):
   331|      4790|    0.0283017|   5.9085e-06|  0.08%|				particle.weight = weights[i]
   332|       958|   0.00601578|  6.27952e-06|  0.02%|			return particles
   333|         0|            0|            0|  0.00%|		else:
   334|       352|    0.0011487|  3.26335e-06|  0.00%|			remaining_particles = [particle for i, particle in enumerate(particles) if weights[i] + 1e-5 > threshold ]
(call)|        44|   0.00099659|  2.26498e-05|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:334 <listcomp>
   335|       352|   0.00211954|  6.02142e-06|  0.01%|			removed_particles = [particle for i, particle in enumerate(particles) if weights[i] + 1e-5 <= threshold ]
(call)|        44|  0.000998497|  2.26931e-05|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:335 <listcomp>
   336|       179|  0.000997305|  5.57154e-06|  0.00%|			removed_indexes = [particle.index for particle in removed_particles]
(call)|        44|            0|            0|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:336 <listcomp>
   337|        44|            0|            0|  0.00%|			remaining_files = []
   338|       217|            0|            0|  0.00%|			for remaining_particle in remaining_particles:
   339|      1171|   0.00199795|  1.70619e-06|  0.01%|				for file in remaining_particle.files_clusters:
   340|       998|  0.000124931|  1.25182e-07|  0.00%|					remaining_files.append(file)
   341|        91|   0.00199437|  2.19162e-05|  0.01%|			for removed_particle in removed_particles:
   342|       307|   0.00200319|  6.52506e-06|  0.01%|				for file in removed_particle.files_clusters:
   343|       260|            0|            0|  0.00%|					if file not in remaining_files:
   344|        26|   0.00492001|  0.000189231|  0.01%|						os.remove(file[1])  # file[0] = index
   345|        26|            0|            0|  0.00%|						remaining_files.append(file)
   346|         0|            0|            0|  0.00%|
   347|        44|   0.00203228|  4.61882e-05|  0.01%|			resample_probs = weights[np.where(weights + 1e-5 > threshold)]
(call)|        44|  0.000997305|   2.2666e-05|  0.00%|# <__array_function__ internals>:177 where
   348|        44|            0|            0|  0.00%|			resample_probs = resample_probs/np.sum(resample_probs)
(call)|        44|    0.0043366|   9.8559e-05|  0.01%|# <__array_function__ internals>:177 sum
   349|        44|   0.00199509|  4.53429e-05|  0.01%|			remaining_particle_weights = weights[np.where(weights + 1e-5 > threshold)]
(call)|        44|            0|            0|  0.00%|# <__array_function__ internals>:177 where
   350|       217|            0|            0|  0.00%|			for i,_ in enumerate(remaining_particles):
   351|       173|            0|            0|  0.00%|				remaining_particles[i].weight = remaining_particle_weights[i]
   352|         0|            0|            0|  0.00%|
   353|        44|            0|            0|  0.00%|			resample_distribution = multinomial(exp_num = resample_num, probabilities = resample_probs)
(call)|        44|   0.00511217|  0.000116186|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:114 multinomial
   354|        44|            0|            0|  0.00%|			if not resample_distribution.shape: # The case of only one particle left
   355|         0|            0|            0|  0.00%|				for idx in removed_indexes:
   356|         0|            0|            0|  0.00%|					new_particle = self.copy_particle(remaining_particles[0], idx)
   357|         0|            0|            0|  0.00%|					remaining_particles.append(new_particle)
   358|         0|            0|            0|  0.00%|			else: # The case of more than one particle left
   359|        44|            0|            0|  0.00%|				j = 0
   360|       217|            0|            0|  0.00%|				for i, resample_times in enumerate(resample_distribution):
   361|       220|  3.21865e-05|  1.46302e-07|  0.00%|					for _ in range(resample_times):
   362|        47|            0|            0|  0.00%|						new_particle = self.copy_particle(remaining_particles[i], removed_indexes[j])
(call)|        47|     0.181137|   0.00385398|  0.52%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:374 copy_particle
   363|        47|            0|            0|  0.00%|						remaining_particles.append(new_particle)
   364|        47|            0|            0|  0.00%|						j += 1
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|			# Normalize the particle weights
   367|       352|    0.0019896|  5.65228e-06|  0.01%|			update_weights = np.array([particle.weight for particle in remaining_particles]); update_weights = update_weights / np.sum(update_weights)
(call)|        44|            0|            0|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:367 <listcomp>
(call)|        44|   0.00402594|  9.14985e-05|  0.01%|# <__array_function__ internals>:177 sum
   368|       264|  0.000102758|  3.89236e-07|  0.00%|			for i, particle in enumerate(remaining_particles):
   369|       220|  0.000997305|   4.5332e-06|  0.00%|				particle.weight = update_weights[i]
   370|         0|            0|            0|  0.00%|
   371|        44|            0|            0|  0.00%|			self.particles = None
   372|        44|            0|            0|  0.00%|			return remaining_particles
   373|         0|            0|            0|  0.00%|
   374|        47|            0|            0|  0.00%|	def copy_particle(self, particle, index=None):
   375|        47|            0|            0|  0.00%|		if index is None: index = particle.index
   376|        47|            0|            0|  0.00%|		part_copy = Particle(index, particle.weight, self.alpha0, 0, 0)
(call)|        47|   0.00501394|   0.00010668|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:43 __init__
   377|         0|            0|            0|  0.00%|
   378|        47|  0.000998259|  2.12395e-05|  0.00%|		part_copy.log_update_prob = particle.log_update_prob
   379|        47|            0|            0|  0.00%|		part_copy.cluster_num_by_now = particle.cluster_num_by_now
   380|         0|            0|            0|  0.00%|
   381|       665|            0|            0|  0.00%|		for c in particle.clusters:
   382|       618|   0.00109315|  1.76885e-06|  0.00%|			clus = particle.clusters[c]
   383|       618|   0.00200582|  3.24566e-06|  0.01%|			part_copy.clusters[c] = Cluster(clus.index, self.sample_num)
(call)|       618|    0.0903306|  0.000146166|  0.26%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:16 __init__
   384|         0|            0|            0|  0.00%|
   385|       618|            0|            0|  0.00%|			if not (self.r>-1e-5 and self.r<1e-5):
   386|       618|  0.000986099|  1.59563e-06|  0.00%|				part_copy.clusters[c].alpha = particle.clusters[c].alpha.copy()
   387|         0|            0|            0|  0.00%|
   388|     10367|    0.0221848|  2.13995e-06|  0.06%|				for c2 in particle.clusters[c].alpha_final:
   389|      9749|    0.0311227|   3.1924e-06|  0.09%|					part_copy.clusters[c].alpha_final[c2] = particle.clusters[c].alpha_final[c2].copy()
   390|         0|            0|            0|  0.00%|
   391|       618|   0.00707674|   1.1451e-05|  0.02%|			part_copy.clusters[c].word_distribution = particle.clusters[c].word_distribution.copy()
   392|       618|   0.00203538|  3.29349e-06|  0.01%|			part_copy.clusters[c].word_count = particle.clusters[c].word_count
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|
   395|        47|   0.00098896|  2.10417e-05|  0.00%|		part_copy.docs2cluster_ID = particle.docs2cluster_ID + []
   396|        47|  0.000998259|  2.12395e-05|  0.00%|		part_copy.all_timestamps = particle.all_timestamps + []
   397|        47|            0|            0|  0.00%|		part_copy.files_clusters = particle.files_clusters + []
   398|         0|            0|            0|  0.00%|
   399|       665|   0.00201559|  3.03096e-06|  0.01%|		for c in particle.active_clusters:
   400|       618|   0.00197601|  3.19743e-06|  0.01%|			part_copy.active_clusters[c] = particle.active_clusters[c].copy()
   401|         0|            0|            0|  0.00%|
   402|       618|   0.00298882|  4.83627e-06|  0.01%|			part_copy.clusters[c].likelihood_samples = particle.clusters[c].likelihood_samples.copy()
   403|       618|   0.00211143|  3.41656e-06|  0.01%|			part_copy.clusters[c].likelihood_samples_sansLambda = particle.clusters[c].likelihood_samples_sansLambda.copy()
   404|       618|   0.00202465|  3.27613e-06|  0.01%|			part_copy.clusters[c].triggers = particle.clusters[c].triggers.copy()
   405|       618|   0.00108814|  1.76075e-06|  0.00%|			part_copy.clusters[c].integ_triggers = particle.clusters[c].integ_triggers.copy()
   406|         0|            0|            0|  0.00%|
   407|        47|            0|            0|  0.00%|		part_copy.active_timestamps = particle.active_timestamps.copy()
   408|       665|   0.00400686|  6.02536e-06|  0.01%|		for c in particle.active_clus_to_ind:
   409|       618|  9.05991e-05|    1.466e-07|  0.00%|			part_copy.active_clus_to_ind[c] = particle.active_clus_to_ind[c]
   410|         0|            0|            0|  0.00%|
   411|        47|            0|            0|  0.00%|		if not (self.r>-1e-5 and self.r<1e-5):
   412|        47|            0|            0|  0.00%|			part_copy.alphas = particle.alphas.copy()
   413|        47|            0|            0|  0.00%|			part_copy.log_priors = particle.log_priors.copy()
   414|         0|            0|            0|  0.00%|
   415|        47|            0|            0|  0.00%|		return part_copy
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|def getArgs(args):
   419|         0|            0|            0|  0.00%|	import re
   420|         0|            0|            0|  0.00%|	dataFile, kernelFile, outputFolder, r, nbRuns, theta0, alpha0, sample_num, particle_num, printRes = [None]*10
   421|         0|            0|            0|  0.00%|	for a in args:
   422|         0|            0|            0|  0.00%|		print(a)
   423|         0|            0|            0|  0.00%|		try: dataFile = re.findall("(?<=data_file=)(.*)(?=)", a)[0]
   424|         0|            0|            0|  0.00%|		except: pass
   425|         0|            0|            0|  0.00%|		try: kernelFile = re.findall("(?<=kernel_file=)(.*)(?=)", a)[0]
   426|         0|            0|            0|  0.00%|		except: pass
   427|         0|            0|            0|  0.00%|		try: outputFolder = re.findall("(?<=output_folder=)(.*)(?=)", a)[0]
   428|         0|            0|            0|  0.00%|		except: pass
   429|         0|            0|            0|  0.00%|		try: r = re.findall("(?<=r=)(.*)(?=)", a)[0]
   430|         0|            0|            0|  0.00%|		except: pass
   431|         0|            0|            0|  0.00%|		try: nbRuns = int(re.findall("(?<=runs=)(.*)(?=)", a)[0])
   432|         0|            0|            0|  0.00%|		except: pass
   433|         0|            0|            0|  0.00%|		try: theta0 = float(re.findall("(?<=theta0=)(.*)(?=)", a)[0])
   434|         0|            0|            0|  0.00%|		except: pass
   435|         0|            0|            0|  0.00%|		try: alpha0 = float(re.findall("(?<=alpha0=)(.*)(?=)", a)[0])
   436|         0|            0|            0|  0.00%|		except: pass
   437|         0|            0|            0|  0.00%|		try: sample_num = int(re.findall("(?<=number_samples=)(.*)(?=)", a)[0])
   438|         0|            0|            0|  0.00%|		except: pass
   439|         0|            0|            0|  0.00%|		try: particle_num = int(re.findall("(?<=number_particles=)(.*)(?=)", a)[0])
   440|         0|            0|            0|  0.00%|		except: pass
   441|         0|            0|            0|  0.00%|		try: printRes = bool(re.findall("(?<=print_progress=)(.*)(?=)", a)[0])
   442|         0|            0|            0|  0.00%|		except: pass
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|	if dataFile is None:
   445|         0|            0|            0|  0.00%|		sys.exit("Enter a valid value for data_file")
   446|         0|            0|            0|  0.00%|	if kernelFile is None:
   447|         0|            0|            0|  0.00%|		sys.exit("Enter a valid value for kernel_file")
   448|         0|            0|            0|  0.00%|	if outputFolder is None:
   449|         0|            0|            0|  0.00%|		sys.exit("Enter a valid value for output_folder")
   450|         0|            0|            0|  0.00%|	if r is None: print("r value not found; defaulted to 1"); r="1"
   451|         0|            0|            0|  0.00%|	if nbRuns is None: print("nbRuns value not found; defaulted to 1"); nbRuns=1
   452|         0|            0|            0|  0.00%|	if theta0 is None: print("theta0 value not found; defaulted to 0.01"); theta0=0.01
   453|         0|            0|            0|  0.00%|	if alpha0 is None: print("alpha0 value not found; defaulted to 0.5"); alpha0=0.5
   454|         0|            0|            0|  0.00%|	if sample_num is None: print("sample_num value not found; defaulted to 2000"); sample_num=2000
   455|         0|            0|            0|  0.00%|	if particle_num is None: print("particle_num value not found; defaulted to 8"); particle_num=8
   456|         0|            0|            0|  0.00%|	if printRes is None: print("printRes value not found; defaulted to True"); printRes=True
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|	with open(kernelFile, 'r') as f:
   459|         0|            0|            0|  0.00%|		i=0
   460|         0|            0|            0|  0.00%|		tabMeans, tabSigs = [], []
   461|         0|            0|            0|  0.00%|		for line in f:
   462|         0|            0|            0|  0.00%|			if line=="\n":
   463|         0|            0|            0|  0.00%|				i += 1
   464|         0|            0|            0|  0.00%|				continue
   465|         0|            0|            0|  0.00%|			if i==0:
   466|         0|            0|            0|  0.00%|				lamb0 = float(line.replace("\n", ""))
   467|         0|            0|            0|  0.00%|			if i==1:
   468|         0|            0|            0|  0.00%|				tabMeans.append(float(line.replace("\n", "")))
   469|         0|            0|            0|  0.00%|			if i==2:
   470|         0|            0|            0|  0.00%|				tabSigs.append(float(line.replace("\n", "")))
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|	ensureFolder(outputFolder)
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|	if len(tabMeans)!=len(tabSigs):
   475|         0|            0|            0|  0.00%|		sys.exit("The means and standard deviation do not match. Please check the parameters file.\n"
   476|         0|            0|            0|  0.00%|				 "The values should be organized as follows:\n[lambda_0]\n\n[mean_1]\n[mean_2]\n...\n[mean_K]\n\n[sigma_1]\n[sigma_2]\n...\n[sigma_K]\n")
   477|         0|            0|            0|  0.00%|	means = np.array(tabMeans)
   478|         0|            0|            0|  0.00%|	sigs = np.array(tabSigs)
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|	rarr = []
   481|         0|            0|            0|  0.00%|	for rstr in r.split(","):
   482|         0|            0|            0|  0.00%|		rarr.append(float(rstr))
   483|         0|            0|            0|  0.00%|	return dataFile, outputFolder, means, sigs, lamb0, rarr, nbRuns, theta0, alpha0, sample_num, particle_num, printRes
   484|         0|            0|            0|  0.00%|
   485|       119|            0|            0|  0.00%|def ensureFolder(folder):
   486|       119|            0|            0|  0.00%|	curfol = "./"
   487|       712|   0.00192165|  2.69895e-06|  0.01%|	for fol in folder.split("/")[:-1]:
   488|       593|    0.0277686|  4.68273e-05|  0.08%|		if fol not in os.listdir(curfol) and fol!="":
   489|         0|            0|            0|  0.00%|			os.mkdir(curfol+fol)
   490|       593|   0.00301814|  5.08961e-06|  0.01%|		curfol += fol+"/"
   491|         0|            0|            0|  0.00%|
   492|      1002|   0.00199366|  1.98968e-06|  0.01%|def parse_newsitem_2_doc(news_item, vocabulary_size):
   493|      1002|            0|            0|  0.00%|	index = news_item[0]
   494|      1002|   0.00407171|  4.06359e-06|  0.01%|	timestamp = news_item[1]
   495|      1002|  0.000998259|  9.96266e-07|  0.00%|	word_id = news_item [2][0]
   496|      1002|   0.00299215|  2.98618e-06|  0.01%|	count = news_item[2][1]
   497|      1002|   0.00509858|   5.0884e-06|  0.01%|	word_distribution = np.zeros(vocabulary_size)
   498|      1002|   0.00507259|  5.06247e-06|  0.01%|	word_distribution[word_id] = count
   499|      1002|   0.00698042|  6.96649e-06|  0.02%|	word_count = np.sum(count)
(call)|      1002|    0.0761654|  7.60134e-05|  0.22%|# <__array_function__ internals>:177 sum
   500|      1002|    0.0109849|   1.0963e-05|  0.03%|	doc = Document(index, timestamp, word_distribution, word_count)
(call)|      1002|    0.0250087|  2.49588e-05|  0.07%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:8 __init__
   501|      1002|   0.00500298|  4.99299e-06|  0.01%|	return doc
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|def readObservations(folder, name, outputFolder):
   504|         0|            0|            0|  0.00%|	dataFile = folder+name+"_events.txt"
   505|         0|            0|            0|  0.00%|	observations = []
   506|         0|            0|            0|  0.00%|	wdToIndex, index = {}, 0
   507|         0|            0|            0|  0.00%|	with open(dataFile, "r", encoding="utf-8") as f:
   508|         0|            0|            0|  0.00%|		for i, line in enumerate(f):
   509|         0|            0|            0|  0.00%|			l = line.replace("\n", "").split("\t")
   510|         0|            0|            0|  0.00%|			timestamp = float(l[0])
   511|         0|            0|            0|  0.00%|			words = l[1].split(",")
   512|         0|            0|            0|  0.00%|			try:
   513|         0|            0|            0|  0.00%|				clusTxt = l[2]
   514|         0|            0|            0|  0.00%|				clusTmp = l[3]
   515|         0|            0|            0|  0.00%|			except:
   516|         0|            0|            0|  0.00%|				clusTxt = None
   517|         0|            0|            0|  0.00%|				clusTmp = None
   518|         0|            0|            0|  0.00%|			uniquewords, cntwords = np.unique(words, return_counts=True)
   519|         0|            0|            0|  0.00%|			for un in uniquewords:
   520|         0|            0|            0|  0.00%|				if un not in wdToIndex:
   521|         0|            0|            0|  0.00%|					wdToIndex[un] = index
   522|         0|            0|            0|  0.00%|					index += 1
   523|         0|            0|            0|  0.00%|			uniquewords = [wdToIndex[un] for un in uniquewords]
   524|         0|            0|            0|  0.00%|			uniquewords, cntwords = np.array(uniquewords, dtype=int), np.array(cntwords, dtype=int)
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|			tup = (i, timestamp, (uniquewords, cntwords), (clusTxt, clusTmp))
   527|         0|            0|            0|  0.00%|			observations.append(tup)
   528|         0|            0|            0|  0.00%|	with open(outputFolder+name+"_indexWords.txt", "w+", encoding="utf-8") as f:
   529|         0|            0|            0|  0.00%|		for wd in wdToIndex:
   530|         0|            0|            0|  0.00%|			f.write(f"{wdToIndex[wd]}\t{wd}\n")
   531|         0|            0|            0|  0.00%|	V = len(wdToIndex)
   532|         0|            0|            0|  0.00%|	indexToWd = {idx: wd for wd, idx in wdToIndex.items()}
   533|         0|            0|            0|  0.00%|	return observations, V, indexToWd
   534|         0|            0|            0|  0.00%|
   535|         2|            0|            0|  0.00%|def saveDHP(DHP, folderOut, nameOut, date=-1):
   536|         0|            0|            0|  0.00%|	while True:
   537|         2|            0|            0|  0.00%|		try:
   538|         2|            0|            0|  0.00%|			writeParticles(DHP, folderOut, nameOut, date)
(call)|         2|     0.308571|     0.154285|  0.88%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:545 writeParticles
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:308 closed
   539|         2|            0|            0|  0.00%|			break
   540|         0|            0|            0|  0.00%|		except Exception as e:
   541|         0|            0|            0|  0.00%|			print("ERREUR", e)
   542|         0|            0|            0|  0.00%|			time.sleep(10)
   543|         0|            0|            0|  0.00%|			continue
   544|         0|            0|            0|  0.00%|
   545|         2|            0|            0|  0.00%|def writeParticles(DHP, folderOut, nameOut, time):
   546|         4|            0|            0|  0.00%|	DHP_copy = Dirichlet_Hawkes_Process(DHP.particle_num, DHP.base_intensity, DHP.theta0, DHP.alpha0,
(call)|         2|    0.0019927|  0.000996351|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:23 __init__
   547|         2|            0|            0|  0.00%|										DHP.reference_time, DHP.vocabulary_size, DHP.bandwidth,
   548|         2|            0|            0|  0.00%|										DHP.sample_num, DHP.r, DHP.multivariate, DHP.folder_output, DHP.name_output)
   549|         0|            0|            0|  0.00%|
   550|         2|            0|            0|  0.00%|	DHP_copy.particles = []
   551|        12|            0|            0|  0.00%|	for particle in DHP.particles:
   552|        10|            0|            0|  0.00%|		part_copy = Particle(particle.index, particle.weight, DHP.alpha0, 0, 0)
(call)|        10|  0.000998497|  9.98497e-05|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:43 __init__
   553|         0|            0|            0|  0.00%|
   554|        10|            0|            0|  0.00%|		part_copy.log_update_prob = particle.log_update_prob
   555|        10|            0|            0|  0.00%|		part_copy.cluster_num_by_now = particle.cluster_num_by_now
   556|        10|            0|            0|  0.00%|		part_copy.docs2cluster_ID = particle.docs2cluster_ID + []
   557|        10|            0|            0|  0.00%|		part_copy.all_timestamps = particle.all_timestamps + []
   558|        10|            0|            0|  0.00%|		part_copy.files_clusters = particle.files_clusters + []
   559|         0|            0|            0|  0.00%|
   560|        10|            0|            0|  0.00%|		DHP_copy.particles.append(part_copy)
   561|         0|            0|            0|  0.00%|
   562|        12|   0.00095892|    7.991e-05|  0.00%|	for i in range(len(DHP.particles)):
   563|        93|            0|            0|  0.00%|		for clus in DHP.particles[i].clusters:  # Only active clusters here
   564|        83|   0.00298429|  3.59552e-05|  0.01%|			file_cluster = writeClusters(DHP.particles[i].clusters[clus], DHP.r, DHP.particles[i].index, DHP.folder_output, DHP.name_output)
(call)|        83|     0.287408|   0.00346275|  0.82%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:594 writeClusters
(call)|        83|  0.000961781|  1.15877e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:308 closed
   565|        83|   0.00101113|  1.21823e-05|  0.00%|			DHP_copy.particles[i].files_clusters.append((clus, file_cluster))
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|	# from copy import deepcopy as copy
   568|         0|            0|            0|  0.00%|	# DHP_copy = copy(DHP)
   569|         0|            0|            0|  0.00%|	# for i in range(len(DHP_copy.particles)):
   570|         0|            0|            0|  0.00%|	# 	for c in DHP_copy.particles[i].clusters:
   571|         0|            0|            0|  0.00%|	# 		del DHP_copy.particles[i].clusters[c]
   572|         0|            0|            0|  0.00%|	# 		if c in DHP_copy.particles[i].active_clusters:
   573|         0|            0|            0|  0.00%|	# 			del DHP_copy.particles[i].active_clusters[c]
   574|         0|            0|            0|  0.00%|	#
   575|         0|            0|            0|  0.00%|	# 			# if DHP.r != 0:
   576|         0|            0|            0|  0.00%|	# 			# 	del DHP_copy.particles[i].clusters[c].alpha
   577|         0|            0|            0|  0.00%|	# 			#
   578|         0|            0|            0|  0.00%|	# 			# del DHP_copy.particles[i].clusters[c].likelihood_samples
   579|         0|            0|            0|  0.00%|	# 			# del DHP_copy.particles[i].clusters[c].likelihood_samples_sansLambda
   580|         0|            0|            0|  0.00%|	# 			# del DHP_copy.particles[i].clusters[c].triggers
   581|         0|            0|            0|  0.00%|	# 			# del DHP_copy.particles[i].clusters[c].integ_triggers
   582|         0|            0|            0|  0.00%|	#
   583|         0|            0|            0|  0.00%|	# 	if DHP.r != 0:
   584|         0|            0|            0|  0.00%|	# 		del DHP_copy.particles[i].alphas
   585|         0|            0|            0|  0.00%|	# 	del DHP_copy.particles[i].log_priors
   586|         0|            0|            0|  0.00%|	# 	del DHP_copy.particles[i].active_clus_to_ind
   587|         0|            0|            0|  0.00%|
   588|         2|            0|            0|  0.00%|	if time==-1: txtTime = "_final"
   589|         0|            0|            0|  0.00%|	else: txtTime = f"_obs={int(time)}"
   590|         0|            0|            0|  0.00%|
   591|         2|            0|            0|  0.00%|	with gzip.open(folderOut+nameOut+txtTime+"_particles.pkl.gz", "w+") as f:
(call)|         2|    0.0019908|  0.000995398|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:25 open
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:308 closed
   592|         2|   0.00404716|   0.00202358|  0.01%|		pickle.dump(DHP_copy, f)
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\copyreg.py:99 _slotnames
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\__init__.py:144 _DType_reduce
(call)|         3|   0.00621724|   0.00207241|  0.02%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:257 write
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:312 close
   593|         0|            0|            0|  0.00%|
   594|       118|  0.000998497|  8.46184e-06|  0.00%|def writeClusters(cluster, r, particle_num, folderOut, nameOut):
   595|       118|   0.00099802|   8.4578e-06|  0.00%|	ensureFolder(folderOut+"/Clusters/")
(call)|       118|    0.0317109|  0.000268736|  0.09%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:485 ensureFolder
   596|       118|   0.00102305|  8.66995e-06|  0.00%|	cluster_copy = Cluster(cluster.index, num_samples=-1)
(call)|       118|   0.00216198|  1.83219e-05|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:16 __init__
   597|         0|            0|            0|  0.00%|
   598|       118|  0.000988007|  8.37294e-06|  0.00%|	finaldir = folderOut+"/Clusters/"+nameOut+f"_particle={particle_num}_cluster={cluster.index}.pkl.gz"
   599|         0|            0|            0|  0.00%|
   600|       118|            0|            0|  0.00%|	if not (r>-1e-5 and r<1e-5):
   601|       118|   0.00199723|  1.69257e-05|  0.01%|		cluster_copy.alpha = cluster.alpha.copy()
   602|         0|            0|            0|  0.00%|
   603|      1813|   0.00610137|  3.36534e-06|  0.02%|		for c2 in cluster.alpha_final:
   604|      1695|   0.00706983|  4.17099e-06|  0.02%|			cluster_copy.alpha_final[c2] = cluster.alpha_final[c2].copy()
   605|         0|            0|            0|  0.00%|
   606|       118|  7.65324e-05|  6.48579e-07|  0.00%|	cluster_copy.word_distribution = cluster.word_distribution.copy()
   607|       118|            0|            0|  0.00%|	cluster_copy.word_count = cluster.word_count
   608|         0|            0|            0|  0.00%|
   609|       118|   0.00207591|  1.75925e-05|  0.01%|	with gzip.open(finaldir, "w+") as f:
(call)|       118|     0.158696|   0.00134488|  0.45%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:25 open
(call)|       118|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:308 closed
   610|       118|    0.0234568|  0.000198787|  0.07%|		pickle.dump(cluster_copy, f)
(call)|         1|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\copyreg.py:99 _slotnames
(call)|       118|   0.00206757|  1.75217e-05|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\__init__.py:144 _DType_reduce
(call)|       118|     0.103563|  0.000877651|  0.30%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:257 write
(call)|       118|    0.0343668|  0.000291244|  0.10%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:312 close
   611|         0|            0|            0|  0.00%|
   612|       118|            0|            0|  0.00%|	return finaldir
   613|         0|            0|            0|  0.00%|
   614|         1|            0|            0|  0.00%|def run_fit(observations, folderOut, nameOut, lamb0, means, sigs, r=1., theta0=None, alpha0 = None, sample_num=2000, particle_num=8, printRes=False, vocabulary_size=None, multivariate=True, eval_on_go=False, indexToWd=None):
   615|         0|            0|            0|  0.00%|	"""
   616|         0|            0|            0|  0.00%|	observations = ([array int] index_obs, [array float] timestamp, ([array int] unique_words, [array int] count_words), [opt, int] temporal_cluster, [opt, int] textual_cluster)
   617|         0|            0|            0|  0.00%|	folderOut = Output folder for the results
   618|         0|            0|            0|  0.00%|	nameOut = Name of the file to which _particles_compressed.pklbz2 will be added
   619|         0|            0|            0|  0.00%|	lamb0 = base intensity
   620|         0|            0|            0|  0.00%|	means, sigs = means and sigmas of the gaussian RBF kernel
   621|         0|            0|            0|  0.00%|	r = exponent parameter of the Powered Dirichlet process; defaults to 1. (standard Dirichlet process)
   622|         0|            0|            0|  0.00%|	theta0 = value of the language model symmetric Dirichlet prior
   623|         0|            0|            0|  0.00%|	alpha0 = symmetric Dirichlet prior from which samples used in Gibbs sampling are drawn (estimation of alpha)
   624|         0|            0|            0|  0.00%|	sample_num = number of samples used in Gibbs sampling
   625|         0|            0|            0|  0.00%|	particle_num = number of particles used in the Sequential Monte-Carlo algorithm
   626|         0|            0|            0|  0.00%|	printRes = whether to print the results according to ground-truth (optional parameters of observations and alpha)
   627|         0|            0|            0|  0.00%|	alphaTrue = ground truth alpha matrix used to generate the observations from gaussian RBF kernel
   628|         0|            0|            0|  0.00%|	"""
   629|         0|            0|            0|  0.00%|
   630|         1|            0|            0|  0.00%|	ensureFolder(folderOut)
(call)|         1|  0.000997543|  0.000997543|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:485 ensureFolder
   631|         0|            0|            0|  0.00%|
   632|         1|            0|            0|  0.00%|	if vocabulary_size is None:
   633|         0|            0|            0|  0.00%|		allWds = set()
   634|         0|            0|            0|  0.00%|		for a in observations:
   635|         0|            0|            0|  0.00%|			for w in a[2][0]:
   636|         0|            0|            0|  0.00%|				allWds.add(w)
   637|         0|            0|            0|  0.00%|		vocabulary_size = len(list(allWds))+2
   638|         1|            0|            0|  0.00%|	if theta0 is None: theta0 = 1.
   639|         1|            0|            0|  0.00%|	if alpha0 is None: alpha0 = 1.
   640|         0|            0|            0|  0.00%|
   641|         1|            0|            0|  0.00%|	particle_num = particle_num
   642|         1|            0|            0|  0.00%|	base_intensity = lamb0
   643|         1|            0|            0|  0.00%|	reference_time = means
   644|         1|            0|            0|  0.00%|	bandwidth = sigs
   645|      1548|   0.00201321|  1.30052e-06|  0.01%|	theta0 = np.array([theta0 for _ in range(vocabulary_size)])
(call)|         1|   0.00201321|   0.00201321|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:645 <listcomp>
   646|         1|            0|            0|  0.00%|	sample_num = sample_num
   647|         1|            0|            0|  0.00%|	threshold = 1.0 / (particle_num*2.)
   648|         0|            0|            0|  0.00%|
   649|         2|            0|            0|  0.00%|	DHP = Dirichlet_Hawkes_Process(particle_num = particle_num, base_intensity = base_intensity, theta0 = theta0,
(call)|         1|  0.000997543|  0.000997543|  0.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:23 __init__
   650|         1|            0|            0|  0.00%|								   alpha0 = alpha0, reference_time = reference_time, vocabulary_size = vocabulary_size,
   651|         1|            0|            0|  0.00%|								   bandwidth = bandwidth, sample_num = sample_num, r=r, multivariate=multivariate,
   652|         1|            0|            0|  0.00%|								   folder_output=folderOut, name_output=nameOut)
   653|         0|            0|            0|  0.00%|
   654|         1|            0|            0|  0.00%|	t = time.time()
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|
   657|         1|            0|            0|  0.00%|	lgObs = len(observations)
   658|         1|            0|            0|  0.00%|	trueClus = []
   659|      1003|   0.00307703|  3.06783e-06|  0.01%|	for i, news_item in enumerate(observations):
   660|      1002|   0.00907516|  9.05705e-06|  0.03%|		doc = parse_newsitem_2_doc(news_item = news_item, vocabulary_size = vocabulary_size)
(call)|      1002|     0.144369|  0.000144081|  0.41%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:492 parse_newsitem_2_doc
   661|      1002|    0.0132654|  1.32389e-05|  0.04%|		DHP.sequential_monte_carlo(doc, threshold)
(call)|      1002|      32.9478|     0.032882| 93.87%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:45 sequential_monte_carlo
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|
   664|      1002|   0.00119781|  1.19542e-06|  0.00%|		if (i%1000==1 and printRes) or (i>0 and not eval_on_go):
   665|         2|            0|            0|  0.00%|			print(f'r={r} - Handling document {i}/{lgObs} (t={np.round(news_item[1]-observations[0][1], 1)}) - '
(call)|         6|  0.000998497|  0.000166416|  0.00%|# <__array_function__ internals>:177 round_
   666|         0|            0|            0|  0.00%|				  f'Average time : {np.round((time.time()-t)*1000/(i), 0)}ms - '
   667|         0|            0|            0|  0.00%|				  f'Remaining time : {np.round((time.time()-t)*(len(observations)-i)/(i*3600), 2)}h - '
   668|         0|            0|            0|  0.00%|				  f'ClusTot={DHP.particles[0].cluster_num_by_now} - ActiveClus = {len(DHP.particles[0].active_clusters)}')
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|
   671|      1002|  0.000997543|  9.95552e-07|  0.00%|		if eval_on_go and printRes:
   672|      1002|   0.00509477|   5.0846e-06|  0.01%|			trueClus.append(int(float(news_item[-1][0])))
   673|      1002|    0.0039897|  3.98173e-06|  0.01%|			if (i%1000==1 and printRes) or (i>0 and False):
   674|         2|            0|            0|  0.00%|				inferredClus = DHP.particles[0].docs2cluster_ID
   675|         2|            0|            0|  0.00%|				print("NMI", NMI(trueClus, inferredClus), " - NMI_last", NMI(trueClus[-1000:], inferredClus[-1000:]))
(call)|         4|    0.0515783|    0.0128946|  0.15%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\metrics\cluster\_supervised.py:943 normalized_mutual_info_score
   676|         0|            0|            0|  0.00%|
   677|      1002|   0.00301147|  3.00545e-06|  0.01%|			keys = DHP.particles[0].active_clusters.keys()
   678|     12889|     0.044405|  3.44518e-06|  0.13%|			for c in keys:
   679|    163118|     0.523749|  3.21086e-06|  1.49%|				for c2 in keys:
   680|    151231|     0.532756|   3.5228e-06|  1.52%|					if c2 in DHP.particles[0].clusters[c].alpha_final:
   681|    148910|     0.495854|  3.32989e-06|  1.41%|						pass
   682|         0|            0|            0|  0.00%|						#print(c, c2, DHP.particles[0].clusters[c].alpha_final[c2])
   683|         0|            0|            0|  0.00%|
   684|      1002|   0.00404263|  4.03456e-06|  0.01%|		if i%5000==1:
   685|         1|            0|            0|  0.00%|			saveDHP(DHP, folderOut, nameOut, date=-1)
(call)|         1|    0.0232961|    0.0232961|  0.07%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:535 saveDHP
   686|         0|            0|            0|  0.00%|
   687|         1|            0|            0|  0.00%|	saveDHP(DHP, folderOut, nameOut, date=-1)
(call)|         1|     0.285275|     0.285275|  0.81%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:535 saveDHP
   688|         1|            0|            0|  0.00%|	return DHP
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|if __name__ == '__main__':
   692|         0|            0|            0|  0.00%|	try:
   693|         0|            0|            0|  0.00%|		dataFile, outputFolder, means, sigs, lamb0, arrR, nbRuns, theta0, alpha0, sample_num, particle_num, printRes = getArgs(sys.argv)
   694|         0|            0|            0|  0.00%|	except:
   695|         0|            0|            0|  0.00%|		nbClasses = 2
   696|         0|            0|            0|  0.00%|		num_obs = 500
   697|         0|            0|            0|  0.00%|		XP = "Overlap"
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|		overlap_voc = 0.5  # Proportion of voc in common between a clusters and its direct neighbours
   700|         0|            0|            0|  0.00%|		overlap_temp = 0.05  # Overlap between the kernels of the simulating process
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|		voc_per_class = 1000  # Number of words available for each cluster
   703|         0|            0|            0|  0.00%|		perc_rand = 0.  # Percentage of events to which assign random textual cluster
   704|         0|            0|            0|  0.00%|		words_per_obs = 10
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|		DS = 0
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|		lamb0 = 0.035  # Cannot be inferred
   709|         0|            0|            0|  0.00%|		theta0 = 10.  # Has already been documented for RW in LDA like models, DHP, etc ~0.01, 0.001
   710|         0|            0|            0|  0.00%|		alpha0 = 1.  # Uniform beta or Dirichlet prior
   711|         0|            0|            0|  0.00%|		means = np.array([3, 5, 7, 11, 13])
   712|         0|            0|            0|  0.00%|		sigs = np.array([0.5, 0.5, 0.5, 0.5, 0.5])
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|		folder = "data/Synth/"
   715|         0|            0|            0|  0.00%|		nameData = f"Obs_nbclasses={nbClasses}_lg={num_obs}_overlapvoc={overlap_voc}_overlaptemp={overlap_temp}" \
   716|         0|            0|            0|  0.00%|				   f"_percrandomizedclus={perc_rand}_vocperclass={voc_per_class}_wordsperevent={words_per_obs}_DS={DS}"
   717|         0|            0|            0|  0.00%|		dataFile = folder+nameData+"_events.txt"
   718|         0|            0|            0|  0.00%|		outputFolder = folder.replace("data/", "output/")
   719|         0|            0|            0|  0.00%|		alpha_true = np.load(folder+nameData+"_alpha.npy")
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|		arrR = [1.]
   722|         0|            0|            0|  0.00%|		nbRuns = 1
   723|         0|            0|            0|  0.00%|		sample_num = 2000
   724|         0|            0|            0|  0.00%|		particle_num = 8
   725|         0|            0|            0|  0.00%|		multivariate = True
   726|         0|            0|            0|  0.00%|		printRes = True
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|	observations, V, indexToWd = readObservations(folder, nameData, outputFolder)
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|	t = time.time()
   732|         0|            0|            0|  0.00%|	i = 0
   733|         0|            0|            0|  0.00%|	nbRunsTot = nbRuns*len(arrR)
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|	for run in range(nbRuns):
   737|         0|            0|            0|  0.00%|		for r in arrR:
   738|         0|            0|            0|  0.00%|			name = f"{dataFile[dataFile.rfind('/'):].replace('_events.txt', '')}_r={r}" \
   739|         0|            0|            0|  0.00%|				   f"_theta0={theta0}_alpha0={alpha0}_lamb0={lamb0}" \
   740|         0|            0|            0|  0.00%|				   f"_samplenum={sample_num}_particlenum={particle_num}_run={run}"
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|			# import pprofile
   743|         0|            0|            0|  0.00%|			# profiler = pprofile.Profile()
   744|         0|            0|            0|  0.00%|			# with profiler:
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|			run_fit(observations, outputFolder, name, lamb0, means, sigs, r=r, theta0=theta0, alpha0=alpha0,
   747|         0|            0|            0|  0.00%|					sample_num=sample_num, particle_num=particle_num, printRes=printRes,
   748|         0|            0|            0|  0.00%|					vocabulary_size=V, multivariate=multivariate, alpha_true=alpha_true, indexToWd=indexToWd)
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|			# profiler.print_stats()
   751|         0|            0|            0|  0.00%|			# profiler.dump_stats("Benchmark.txt")
   752|         0|            0|            0|  0.00%|			# pause()
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|			print(f"r={r} - RUN {run}/{nbRuns} COMPLETE - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   755|         0|            0|            0|  0.00%|			i += 1
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|
File: D:\Thèse\Codes\Articles\MPDHP\utils.py
File duration: 10.7866s (30.73%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import os
     2|         0|            0|            0|  0.00%|import numpy as np
     3|         0|            0|            0|  0.00%|from scipy.special import erfc, gammaln
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|ones = {i: np.ones((i)) for i in range(1, 100)}
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|class Document(object):
     8|      1002|  0.000996351|  9.94363e-07|  0.00%|	def __init__(self, index, timestamp, word_distribution, word_count):
     9|      1002|   0.00404119|  4.03313e-06|  0.01%|		super(Document, self).__init__()
    10|      1002|  0.000997543|  9.95552e-07|  0.00%|		self.index = index
    11|      1002|    0.0040307|  4.02266e-06|  0.01%|		self.timestamp = timestamp
    12|      1002|   0.00995803|  9.93815e-06|  0.03%|		self.word_distribution = np.array(word_distribution, dtype=int)
    13|      1002|   0.00498486|  4.97491e-06|  0.01%|		self.word_count = np.array(word_count, dtype=int)
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|class Cluster(object):
    16|       842|   0.00100994|  1.19945e-06|  0.00%|	def __init__(self, index, num_samples):# alpha, word_distribution, documents, word_count):
    17|       842|   0.00498557|  5.92111e-06|  0.01%|		super(Cluster, self).__init__()
    18|       842|            0|            0|  0.00%|		self.index = index
    19|       842|   0.00212741|  2.52661e-06|  0.01%|		self.alpha = None
    20|       842|   0.00306153|  3.63602e-06|  0.01%|		self.alpha_final = {}
    21|       842|   0.00303054|  3.59921e-06|  0.01%|		self.word_distribution = None
    22|       842|   0.00409293|  4.86096e-06|  0.01%|		self.word_count = 0
    23|         0|            0|            0|  0.00%|
    24|       842|            0|            0|  0.00%|		if num_samples != -1:
    25|       724|   0.00806475|  1.11392e-05|  0.02%|			self.likelihood_samples = zeros = np.zeros((num_samples), dtype=np.float)
(call)|       724|    0.0152633|  2.10819e-05|  0.04%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\__init__.py:278 __getattr__
    26|       724|    0.0080688|  1.11448e-05|  0.02%|			self.likelihood_samples_sansLambda = zeros = np.zeros((num_samples), dtype=np.float)
(call)|       724|    0.0114369|  1.57969e-05|  0.03%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\__init__.py:278 __getattr__
    27|       724|   0.00598574|  8.26759e-06|  0.02%|			self.triggers = zeros = np.zeros((num_samples), dtype=np.float)
(call)|       724|    0.0150521|  2.07902e-05|  0.04%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\__init__.py:278 __getattr__
    28|       724|   0.00300813|  4.15487e-06|  0.01%|			self.integ_triggers = zeros = np.zeros((num_samples), dtype=np.float)
(call)|       724|    0.0182812|  2.52503e-05|  0.05%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\__init__.py:278 __getattr__
    29|         0|            0|            0|  0.00%|
    30|      5010|     0.016238|  3.24111e-06|  0.05%|	def add_document(self, doc):
    31|      5010|   0.00815725|  1.62819e-06|  0.02%|		if self.word_distribution is None:
    32|       106|  0.000997782|  9.41304e-06|  0.00%|			self.word_distribution = np.copy(doc.word_distribution)
(call)|       106|   0.00214648|  2.02498e-05|  0.01%|# <__array_function__ internals>:177 copy
    33|         0|            0|            0|  0.00%|		else:
    34|      4904|    0.0336418|  6.86008e-06|  0.10%|			self.word_distribution += doc.word_distribution
    35|      5010|    0.0151491|  3.02378e-06|  0.04%|		self.word_count += doc.word_count
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|	# def __repr__(self):
    38|         0|            0|            0|  0.00%|	# 	return 'cluster index:' + str(self.index) + '\n' +'word_count: ' + str(self.word_count) \
    39|         0|            0|            0|  0.00%|	# 	+ '\nalpha:' + str(self.alpha)+"\n"
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|class Particle(object):
    42|         0|            0|            0|  0.00%|	"""docstring for Particle"""
    43|        72|            0|            0|  0.00%|	def __init__(self, index, weight, alpha0, sample_num, size_kernel):
    44|        72|            0|            0|  0.00%|		super(Particle, self).__init__()
    45|        72|            0|            0|  0.00%|		self.index = index
    46|        72|            0|            0|  0.00%|		self.weight = weight
    47|        72|   0.00101662|  1.41197e-05|  0.00%|		self.log_update_prob = 0
    48|        72|            0|            0|  0.00%|		self.clusters = {}  # can be stored in the process for efficient memory implementation, key = cluster_index, value = cluster object
    49|        72|            0|            0|  0.00%|		self.docs2cluster_ID = []  # the element is the cluster index of a sequence of document ordered by the index of document
    50|        72|            0|            0|  0.00%|		self.all_timestamps = []  # same order as docs2cluster_ID
    51|        72|            0|            0|  0.00%|		self.active_clusters = {}  # dict key = cluster_index, value = list of timestamps in specific cluster (queue)
    52|        72|  0.000996351|  1.38382e-05|  0.00%|		self.active_timestamps = None  # list of tuples (time, cluster)
    53|        72|            0|            0|  0.00%|		self.cluster_num_by_now = 0
    54|        72|            0|            0|  0.00%|		self.active_clus_to_ind = {}  # Links the order of active clusters to their position in cluster.alpha
    55|        72|            0|            0|  0.00%|		self.files_clusters = []
    56|         0|            0|            0|  0.00%|
    57|        72|   0.00100017|  1.38912e-05|  0.00%|		self.alphas, self.log_priors = draw_vectors(alpha0, sample_num, [0], size_kernel, return_priors=True)
(call)|        72|   0.00499415|  6.93632e-05|  0.01%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:63 draw_vectors
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|	def __repr__(self):
    60|         0|            0|            0|  0.00%|		return 'particle document list to cluster IDs: ' + str(self.docs2cluster_ID) + '\n' + 'weight: ' + str(self.weight)
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|       173|            0|            0|  0.00%|def draw_vectors(alpha0, num_samples, active_clusters, size_kernel, method="beta", return_priors=False, multivariate=True, index_cluster=None):
    64|       173|            0|            0|  0.00%|	vec = None
    65|       173|            0|            0|  0.00%|	prior = None
    66|       173|  0.000995874|   5.7565e-06|  0.00%|	if alpha0==1.:
    67|       173|   0.00199342|  1.15226e-05|  0.01%|		vec = np.random.random((num_samples, len(active_clusters), size_kernel))
    68|         0|            0|            0|  0.00%|	elif method=="dirichlet":
    69|         0|            0|            0|  0.00%|		vec = dirichlet(alpha0, num_samples, active_clusters, size_kernel)
    70|         0|            0|            0|  0.00%|	elif method=="beta":
    71|         0|            0|            0|  0.00%|		vec = beta(alpha0, num_samples, active_clusters, size_kernel)
    72|         0|            0|            0|  0.00%|
    73|       173|   0.00199604|  1.15378e-05|  0.01%|	vecPriors = vec
    74|       173|  0.000996828|  5.76201e-06|  0.00%|	if not multivariate:
    75|         0|            0|            0|  0.00%|		allOthers = list(range(vec.shape[1]))
    76|         0|            0|            0|  0.00%|		allOthers.remove(index_cluster)
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|		vec[:, allOthers] *= 0
    79|         0|            0|            0|  0.00%|		vecPriors = vec[:, index_cluster]
    80|         0|            0|            0|  0.00%|
    81|       173|   0.00311971|   1.8033e-05|  0.01%|	vec[vec==0.] = 1e-10
    82|       173|   0.00199485|  1.15309e-05|  0.01%|	vec[vec==1.] = 1-1e-10
    83|         0|            0|            0|  0.00%|
    84|       173|   0.00102234|  5.90947e-06|  0.00%|	if return_priors:
    85|       173|  0.000983953|  5.68759e-06|  0.00%|		if alpha0==1.:
    86|       173|   0.00108242|  6.25677e-06|  0.00%|			prior = np.zeros((num_samples))
    87|         0|            0|            0|  0.00%|		elif method=="dirichlet":
    88|         0|            0|            0|  0.00%|			prior = log_dirichlet_PDF(vecPriors, alpha0)
    89|         0|            0|            0|  0.00%|		elif method=="beta":
    90|         0|            0|            0|  0.00%|			prior = log_beta_prior(vecPriors, alpha0)
    91|         0|            0|            0|  0.00%|
    92|       173|   0.00100303|  5.79784e-06|  0.00%|	if not return_priors:
    93|         0|            0|            0|  0.00%|		return vec
    94|         0|            0|            0|  0.00%|	else:
    95|       173|            0|            0|  0.00%|		return vec, prior
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|def dirichlet(prior, num_samples, active_clusters, size_kernel):
    98|         0|            0|            0|  0.00%|	''' Draw 1-D samples from a dirichlet distribution
    99|         0|            0|            0|  0.00%|	'''
   100|         0|            0|            0|  0.00%|	draws = np.random.dirichlet([prior]*(size_kernel), size=(num_samples, len(active_clusters)))
   101|         0|            0|            0|  0.00%|	if num_samples==1:
   102|         0|            0|            0|  0.00%|		draws=draws[0]
   103|         0|            0|            0|  0.00%|	return draws
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|def beta(alpha0, num_samples, active_clusters, size_kernel):
   106|         0|            0|            0|  0.00%|	''' Draw 1-D samples from a dirichlet distribution
   107|         0|            0|            0|  0.00%|	'''
   108|         0|            0|            0|  0.00%|	skew = 1
   109|         0|            0|            0|  0.00%|	draws = np.random.beta(alpha0, skew*alpha0, size=(num_samples, len(active_clusters), size_kernel))
   110|         0|            0|            0|  0.00%|	if num_samples==1:
   111|         0|            0|            0|  0.00%|		draws=draws[0]
   112|         0|            0|            0|  0.00%|	return draws
   113|         0|            0|            0|  0.00%|
   114|        44|            0|            0|  0.00%|def multinomial(exp_num, probabilities):
   115|         0|            0|            0|  0.00%|	''' Draw samples from a multinomial distribution.
   116|         0|            0|            0|  0.00%|		@param:
   117|         0|            0|            0|  0.00%|			1. exp_num: Number of experiments.
   118|         0|            0|            0|  0.00%|			2. probabilities: multinomial probability distribution (sequence of floats).
   119|         0|            0|            0|  0.00%|		@rtype: 1-D numpy array
   120|         0|            0|            0|  0.00%|	'''
   121|        44|  0.000997305|   2.2666e-05|  0.00%|	return np.random.multinomial(exp_num, probabilities).squeeze()
(call)|        88|   0.00411487|  4.67598e-05|  0.01%|# <__array_function__ internals>:177 all
   122|         0|            0|            0|  0.00%|
   123|      1002|   0.00299978|  2.99379e-06|  0.01%|def EfficientImplementation(tn, reference_time, bandwidth, epsilon = 1e-5):
   124|         0|            0|            0|  0.00%|	''' return the time we need to compute to update the triggering kernel
   125|         0|            0|            0|  0.00%|		@param:
   126|         0|            0|            0|  0.00%|			1.tn: float, current document time
   127|         0|            0|            0|  0.00%|			2.reference_time: list, reference_time for triggering_kernel
   128|         0|            0|            0|  0.00%|			3.bandwidth: int, bandwidth for triggering_kernel
   129|         0|            0|            0|  0.00%|			4.epsilon: float, error tolerance
   130|         0|            0|            0|  0.00%|		@rtype: float
   131|         0|            0|            0|  0.00%|	'''
   132|      1002|   0.00811052|  8.09433e-06|  0.02%|	max_ref_time = max(reference_time)
   133|      1002|   0.00299478|   2.9888e-06|  0.01%|	max_bandwidth = max(bandwidth)
   134|      1002|    0.0133133|  1.32867e-05|  0.04%|	tu = tn - ( max_ref_time + np.sqrt( -2 * max_bandwidth * np.log(0.5 * epsilon * np.sqrt(2 * np.pi * max_bandwidth**2)) ))
   135|      1002|   0.00103664|  1.03457e-06|  0.00%|	return tu
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|def log_dirichlet_PDF(alpha, alpha0):
   138|         0|            0|            0|  0.00%|	''' return the logpdf for each entry of a list of dirichlet draws
   139|         0|            0|            0|  0.00%|	'''
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|	lg = alpha.shape[-1]
   142|         0|            0|            0|  0.00%|	if lg not in ones: ones[lg] = np.ones((lg))
   143|         0|            0|            0|  0.00%|	priors = (np.log(alpha)*(alpha0-1)).dot(ones[lg]) + gammaln(alpha0*lg) - gammaln(alpha0)*lg
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|	lg = priors.shape[-1]
   146|         0|            0|            0|  0.00%|	if lg not in ones: ones[lg] = np.ones((lg))
   147|         0|            0|            0|  0.00%|	priors = priors.dot(ones[lg])
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|	return priors
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|def log_beta_prior(alpha, alpha0):
   152|         0|            0|            0|  0.00%|	''' return the logpdf for each entry of a list of dirichlet draws
   153|         0|            0|            0|  0.00%|	'''
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|	skew = 1
   156|         0|            0|            0|  0.00%|	priors = np.log(alpha)*(alpha0-1) + np.log(1-alpha)*(skew*alpha0-1) + gammaln(alpha0+skew*alpha0) - gammaln(alpha0) - gammaln(skew*alpha0)
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|	lg = priors.shape[-1]
   159|         0|            0|            0|  0.00%|	if lg not in ones: ones[lg] = np.ones((lg))
   160|         0|            0|            0|  0.00%|	priors = priors.dot(ones[lg])
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|	lg = priors.shape[-1]
   163|         0|            0|            0|  0.00%|	if lg not in ones: ones[lg] = np.ones((lg))
   164|         0|            0|            0|  0.00%|	priors = priors.dot(ones[lg])
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|	return priors
   167|         0|            0|            0|  0.00%|
   168|     10000|     0.033478|   3.3478e-06|  0.10%|def RBF_kernel(reference_time, time_interval, bandwidth):
   169|         0|            0|            0|  0.00%|	''' RBF kernel for Hawkes process.
   170|         0|            0|            0|  0.00%|		@param:
   171|         0|            0|            0|  0.00%|			1.reference_time: np.array, entries larger than 0.
   172|         0|            0|            0|  0.00%|			2.time_interval: float/np.array, entry must be the same.
   173|         0|            0|            0|  0.00%|			3. bandwidth: np.array, entries larger than 0.
   174|         0|            0|            0|  0.00%|		@rtype: np.array
   175|         0|            0|            0|  0.00%|	'''
   176|     10000|     0.230512|  2.30512e-05|  0.66%|	numerator = - (time_interval[:, None] - reference_time[None, :]) ** 2 / (2 * bandwidth[None, :] ** 2)
   177|     10000|    0.0801835|  8.01835e-06|  0.23%|	denominator = (2 * np.pi * bandwidth[None, :] ** 2 ) ** 0.5
   178|     10000|    0.0955129|  9.55129e-06|  0.27%|	return np.exp(numerator) / denominator
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|def triggering_kernel(alpha, reference_time, time_intervals, bandwidth):
   181|         0|            0|            0|  0.00%|	''' triggering kernel for Hawkes porcess.
   182|         0|            0|            0|  0.00%|		@param:
   183|         0|            0|            0|  0.00%|			1. alpha: np.array, entres larger than 0
   184|         0|            0|            0|  0.00%|			2. reference_time: np.array, entries larger than 0.
   185|         0|            0|            0|  0.00%|			3. time_intervals: float/np.array, entry must be the same.
   186|         0|            0|            0|  0.00%|			4. bandwidth: np.array, entries larger than 0.
   187|         0|            0|            0|  0.00%|		@rtype: np.array
   188|         0|            0|            0|  0.00%|	'''
   189|         0|            0|            0|  0.00%|	#if len(alpha) != len(reference_time):
   190|         0|            0|            0|  0.00%|		#raise Exception("length of alpha and length of reference time must equal")
   191|         0|            0|            0|  0.00%|	#time_intervals = time_intervals.reshape(-1, 1)
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|	if len(alpha.shape) == 3:
   194|         0|            0|            0|  0.00%|		RBF = RBF_kernel(reference_time, time_intervals, bandwidth)  # num_time_points, size_kernel
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|		lg = RBF.shape[0]
   197|         0|            0|            0|  0.00%|		if lg not in ones: ones[lg] = np.ones((lg))
   198|         0|            0|            0|  0.00%|		rbfdotted = alpha.dot(ones[lg].dot(RBF))
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|		return rbfdotted[0]
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|	else:
   203|         0|            0|            0|  0.00%|		RBF = RBF_kernel(reference_time, time_intervals, bandwidth)  # num_time_points, size_kernel
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|		rbfdotted = RBF.dot(alpha.T)  # num_time_points, num_active_clusters
   206|         0|            0|            0|  0.00%|		lg = len(rbfdotted)
   207|         0|            0|            0|  0.00%|		if lg==1:
   208|         0|            0|            0|  0.00%|			rbfdotted = rbfdotted[0]
   209|         0|            0|            0|  0.00%|		else:
   210|         0|            0|            0|  0.00%|			if lg not in ones: ones[lg] = np.ones((lg))
   211|         0|            0|            0|  0.00%|			rbfdotted = ones[lg].dot(rbfdotted)
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|		lg = len(rbfdotted)
   214|         0|            0|            0|  0.00%|		if lg==1:
   215|         0|            0|            0|  0.00%|			return rbfdotted[0]
   216|         0|            0|            0|  0.00%|		if lg not in ones: ones[lg] = np.ones((lg))
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|		rbfdotted = ones[lg].dot(rbfdotted)
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|		return rbfdotted
   221|         0|            0|            0|  0.00%|
   222|      5010|    0.0122476|  2.44462e-06|  0.03%|def g_theta(timeseq, reference_time, bandwidth, max_time):
   223|         0|            0|            0|  0.00%|	''' g_theta for DHP
   224|         0|            0|            0|  0.00%|		@param:
   225|         0|            0|            0|  0.00%|			2. timeseq: 1-D np array time sequence before current time
   226|         0|            0|            0|  0.00%|			3. base_intensity: float
   227|         0|            0|            0|  0.00%|			4. reference_time: 1-D np.array
   228|         0|            0|            0|  0.00%|			5. bandwidth: 1-D np.array
   229|         0|            0|            0|  0.00%|		@rtype: np.array, shape(3,)
   230|         0|            0|            0|  0.00%|	'''
   231|      5010|    0.0170588|  3.40496e-06|  0.05%|	timeseq = np.array(timeseq)
   232|      5010|     0.180152|  3.59586e-05|  0.51%|	results = 0.5 * ( erfc( (- reference_time[None, :]) / (2 * bandwidth[None, :] ** 2) ** 0.5) - erfc( (max_time - timeseq[:, None] - reference_time[None, :]) / (2 * bandwidth[None, :] ** 2) **0.5) )
   233|         0|            0|            0|  0.00%|
   234|      5010|   0.00831079|  1.65884e-06|  0.02%|	return results
   235|         0|            0|            0|  0.00%|
   236|      5010|    0.0201225|  4.01647e-06|  0.06%|def update_cluster_likelihoods(active_timestamps, particle, cluster, reference_time, bandwidth, base_intensity, max_time):
   237|      5010|    0.0278771|  5.56429e-06|  0.08%|	timeseq = active_timestamps[:, 1]
   238|      5010|    0.0162528|  3.24406e-06|  0.05%|	clusseq = active_timestamps[:, 0]
   239|      5010|    0.0749767|  1.49654e-05|  0.21%|	num_active_clus = len(set(clusseq))
   240|         0|            0|            0|  0.00%|
   241|      5010|     0.028384|  5.66546e-06|  0.08%|	alphas = particle.alphas
   242|      5010|    0.0131891|  2.63255e-06|  0.04%|	Lambda_0 = base_intensity * max_time
   243|      5010|    0.0465751|  9.29642e-06|  0.13%|	integ_RBF = g_theta(np.array([timeseq[-1]]), reference_time, bandwidth, max_time)
(call)|      5010|      0.21777|   4.3467e-05|  0.62%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:222 g_theta
   244|      5010|    0.0221786|  4.42688e-06|  0.06%|	unweighted_integ_triggering_kernel = np.zeros((num_active_clus, len(reference_time)))
   245|     73277|     0.237188|  3.23687e-06|  0.68%|	indToClus = {int(c): i for i,c in enumerate(sorted(list(set(clusseq))))}
(call)|      5010|     0.136744|  2.72942e-05|  0.39%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:245 <dictcomp>
   246|     10020|    0.0464737|   4.6381e-06|  0.13%|	for (clus, integ_trig) in zip(clusseq, integ_RBF):
   247|      5010|    0.0211582|   4.2232e-06|  0.06%|		indclus = indToClus[int(clus)]
   248|      5010|    0.0301559|  6.01914e-06|  0.09%|		unweighted_integ_triggering_kernel[indclus] = unweighted_integ_triggering_kernel[indclus] + integ_trig
   249|         0|            0|            0|  0.00%|
   250|      5010|    0.0551801|   1.1014e-05|  0.16%|	alphas_times_gtheta = np.tensordot(alphas, unweighted_integ_triggering_kernel, axes=2)
(call)|      5010|      1.95308|  0.000389836|  5.56%|# <__array_function__ internals>:177 tensordot
   251|         0|            0|            0|  0.00%|
   252|      5010|      0.07512|   1.4994e-05|  0.21%|	time_intervals = timeseq[-1] - timeseq[timeseq<timeseq[-1]]
   253|      5010|    0.0198784|  3.96774e-06|  0.06%|	if len(time_intervals)!=0:
   254|      5000|    0.0415685|   8.3137e-06|  0.12%|		RBF = RBF_kernel(reference_time, time_intervals, bandwidth)  # num_time_points, size_kernel
(call)|      5000|     0.212175|   4.2435e-05|  0.60%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:168 RBF_kernel
   255|      5000|    0.0252728|  5.05457e-06|  0.07%|		unweighted_triggering_kernel = np.zeros((num_active_clus, len(reference_time)))
   256|     73232|     0.239074|  3.26461e-06|  0.68%|		indToClus = {int(c): i for i,c in enumerate(sorted(list(set(clusseq))))}
(call)|      5000|     0.136324|  2.72647e-05|  0.39%|# D:\Thèse\Codes\Articles\MPDHP\utils.py:256 <dictcomp>
   257|    346170|      1.03877|  3.00074e-06|  2.96%|		for (clus, trig) in zip(clusseq, RBF):
   258|    341170|      0.99519|  2.91699e-06|  2.84%|			indclus = indToClus[int(clus)]
   259|    341170|       1.4474|  4.24246e-06|  4.12%|			unweighted_triggering_kernel[indclus] = unweighted_triggering_kernel[indclus] + trig
   260|         0|            0|            0|  0.00%|
   261|      5000|    0.0609746|  1.21949e-05|  0.17%|		cluster.triggers = np.tensordot(alphas, unweighted_triggering_kernel, axes=2)
(call)|      5000|      1.89455|  0.000378909|  5.40%|# <__array_function__ internals>:177 tensordot
   262|      5000|    0.0626638|  1.25328e-05|  0.18%|		cluster.likelihood_samples_sansLambda += np.log(cluster.triggers + 1e-20)
   263|         0|            0|            0|  0.00%|
   264|      5010|    0.0252593|  5.04177e-06|  0.07%|	cluster.integ_triggers += alphas_times_gtheta
   265|         0|            0|            0|  0.00%|
   266|      5010|    0.0435398|  8.69057e-06|  0.12%|	cluster.likelihood_samples = -Lambda_0 - cluster.integ_triggers + cluster.likelihood_samples_sansLambda
   267|         0|            0|            0|  0.00%|
   268|      5010|    0.0147853|  2.95116e-06|  0.04%|	return cluster
   269|         0|            0|            0|  0.00%|
   270|      5010|    0.0111406|  2.22367e-06|  0.03%|def update_triggering_kernel_optim(particle, cluster):
   271|         0|            0|            0|  0.00%|	''' procedure of triggering kernel for SMC
   272|         0|            0|            0|  0.00%|		@param:
   273|         0|            0|            0|  0.00%|			1. timeseq: list, time sequence including current time
   274|         0|            0|            0|  0.00%|			2. alphas: 2-D np.array with shape (sample number, length of alpha)
   275|         0|            0|            0|  0.00%|			3. reference_time: np.array
   276|         0|            0|            0|  0.00%|			4. bandwidth: np.array
   277|         0|            0|            0|  0.00%|			5. log_priors: 1-D np.array with shape (sample number,), p(alpha, alpha_0)
   278|         0|            0|            0|  0.00%|			6. base_intensity: float
   279|         0|            0|            0|  0.00%|			7. max_time: float
   280|         0|            0|            0|  0.00%|		@rtype: 1-D numpy array with shape (length of alpha0,)
   281|         0|            0|            0|  0.00%|	'''
   282|      5010|    0.0144486|  2.88396e-06|  0.04%|	alphas = particle.alphas
   283|      5010|     0.018723|  3.73713e-06|  0.05%|	log_priors = particle.log_priors
   284|      5010|    0.0151236|  3.01868e-06|  0.04%|	logLikelihood = cluster.likelihood_samples
   285|      5010|    0.0104311|  2.08205e-06|  0.03%|	log_update_weight = log_priors + logLikelihood
   286|      5010|     0.045368|  9.05548e-06|  0.13%|	log_update_weight = log_update_weight - max(log_update_weight)  # Prevents overflow
   287|      5010|    0.0235546|  4.70151e-06|  0.07%|	update_weight = np.exp(log_update_weight)
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|	#update_weight[update_weight<np.mean(update_weight)]=0.  # Removes noise of obviously unfit alpha samples
   290|         0|            0|            0|  0.00%|
   291|      5010|    0.0142219|   2.8387e-06|  0.04%|	lg = len(update_weight)
   292|      5010|    0.0110161|  2.19883e-06|  0.03%|	if lg not in ones: ones[lg] = np.ones((lg))
   293|      5010|    0.0203583|  4.06354e-06|  0.06%|	sumUpdateWeight = update_weight.dot(ones[lg])
   294|      5010|    0.0273709|  5.46326e-06|  0.08%|	update_weight = update_weight / sumUpdateWeight
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|	#alpha = np.sum(update_weight.reshape(-1,1) * alphas, axis = 0)
   297|         0|            0|            0|  0.00%|	#alpha = update_weight.dot(alphas.transpose(1,0,2))
   298|      5010|    0.0435801|  8.69861e-06|  0.12%|	alpha = np.tensordot(update_weight, alphas, axes=1)
(call)|      5010|      1.69111|  0.000337547|  4.82%|# <__array_function__ internals>:177 tensordot
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|
   301|      5010|   0.00714898|  1.42694e-06|  0.02%|	return alpha
   302|         0|            0|            0|  0.00%|
   303|     68151|     0.187803|  2.75569e-06|  0.54%|def log_dirichlet_multinomial_distribution(cls_word_distribution, doc_word_distribution, cls_word_count, doc_word_count, vocabulary_size, priors):
   304|         0|            0|            0|  0.00%|	''' compute the log dirichlet multinomial distribution
   305|         0|            0|            0|  0.00%|		@param:
   306|         0|            0|            0|  0.00%|			1. cls_word_distribution: 1-D numpy array, including document word_distribution
   307|         0|            0|            0|  0.00%|			2. doc_word_distribution: 1-D numpy array
   308|         0|            0|            0|  0.00%|			3. cls_word_count: int, including document word_distribution
   309|         0|            0|            0|  0.00%|			4. doc_word_count: int
   310|         0|            0|            0|  0.00%|			5. vocabulary_size: int
   311|         0|            0|            0|  0.00%|			6. priors: 1-d np.array
   312|         0|            0|            0|  0.00%|		@rtype: float
   313|         0|            0|            0|  0.00%|	'''
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|	#arrones = np.ones((len(priors)))
   316|         0|            0|            0|  0.00%|	#priors_sum = np.sum(priors)
   317|         0|            0|            0|  0.00%|	#priors_sum = priors.dot(arrones)
   318|     68151|     0.245265|  3.59884e-06|  0.70%|	priors_sum = priors[0]*vocabulary_size  # ATTENTION PRIOR[0] SEULEMENT SI THETA0 EST SYMMETRIQUE !!!!
   319|     68151|     0.169166|  2.48222e-06|  0.48%|	log_prob = 0
   320|     68151|     0.571765|  8.38968e-06|  1.63%|	log_prob += gammaln(cls_word_count - doc_word_count + priors_sum)
   321|     68151|     0.446901|  6.55751e-06|  1.27%|	log_prob -= gammaln(cls_word_count + priors_sum)
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|	#log_prob += np.sum(gammaln(cls_word_distribution + priors))
   324|         0|            0|            0|  0.00%|	#log_prob -= np.sum(gammaln(cls_word_distribution - doc_word_distribution + priors))
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|	#log_prob += gammaln(cls_word_distribution + priors).dot(arrones)
   327|         0|            0|            0|  0.00%|	#log_prob -= gammaln(cls_word_distribution - doc_word_distribution + priors).dot(arrones)
   328|         0|            0|            0|  0.00%|
   329|     68151|     0.547279|  8.03039e-06|  1.56%|	cnt = np.bincount(cls_word_distribution)
(call)|     68151|      1.57876|  2.31657e-05|  4.50%|# <__array_function__ internals>:177 bincount
   330|     68151|      0.21017|  3.08388e-06|  0.60%|	un = cnt.nonzero()[0]
   331|     68151|     0.182114|  2.67222e-06|  0.52%|	cnt = cnt[un]
   332|         0|            0|            0|  0.00%|
   333|     68151|     0.588178|  8.63052e-06|  1.68%|	log_prob += gammaln(un + priors[0]).dot(cnt)  # ATTENTION SI PRIOR[0] SEULEMENT SI THETA0 EST SYMMETRIQUE !!!!
   334|         0|            0|            0|  0.00%|
   335|     68151|     0.667163|  9.78948e-06|  1.90%|	cnt = np.bincount(cls_word_distribution-doc_word_distribution)
(call)|     68151|      1.51334|  2.22057e-05|  4.31%|# <__array_function__ internals>:177 bincount
   336|     68151|     0.199372|  2.92544e-06|  0.57%|	un = cnt.nonzero()[0]
   337|     68151|     0.171374|  2.51462e-06|  0.49%|	cnt = cnt[un]
   338|         0|            0|            0|  0.00%|
   339|     68151|     0.586891|  8.61162e-06|  1.67%|	log_prob -= gammaln(un + priors[0]).dot(cnt)
   340|         0|            0|            0|  0.00%|
   341|     68151|     0.173778|  2.54989e-06|  0.50%|	return log_prob
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py
File duration: 4.93694s (14.07%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import functools
     2|         0|            0|            0|  0.00%|import itertools
     3|         0|            0|            0|  0.00%|import operator
     4|         0|            0|            0|  0.00%|import sys
     5|         0|            0|            0|  0.00%|import warnings
     6|         0|            0|            0|  0.00%|import numbers
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import numpy as np
     9|         0|            0|            0|  0.00%|from . import multiarray
    10|         0|            0|            0|  0.00%|from .multiarray import (
    11|         0|            0|            0|  0.00%|    _fastCopyAndTranspose as fastCopyAndTranspose, ALLOW_THREADS,
    12|         0|            0|            0|  0.00%|    BUFSIZE, CLIP, MAXDIMS, MAY_SHARE_BOUNDS, MAY_SHARE_EXACT, RAISE,
    13|         0|            0|            0|  0.00%|    WRAP, arange, array, asarray, asanyarray, ascontiguousarray,
    14|         0|            0|            0|  0.00%|    asfortranarray, broadcast, can_cast, compare_chararrays,
    15|         0|            0|            0|  0.00%|    concatenate, copyto, dot, dtype, empty,
    16|         0|            0|            0|  0.00%|    empty_like, flatiter, frombuffer, _from_dlpack, fromfile, fromiter,
    17|         0|            0|            0|  0.00%|    fromstring, inner, lexsort, matmul, may_share_memory,
    18|         0|            0|            0|  0.00%|    min_scalar_type, ndarray, nditer, nested_iters, promote_types,
    19|         0|            0|            0|  0.00%|    putmask, result_type, set_numeric_ops, shares_memory, vdot, where,
    20|         0|            0|            0|  0.00%|    zeros, normalize_axis_index)
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|from . import overrides
    23|         0|            0|            0|  0.00%|from . import umath
    24|         0|            0|            0|  0.00%|from . import shape_base
    25|         0|            0|            0|  0.00%|from .overrides import set_array_function_like_doc, set_module
    26|         0|            0|            0|  0.00%|from .umath import (multiply, invert, sin, PINF, NAN)
    27|         0|            0|            0|  0.00%|from . import numerictypes
    28|         0|            0|            0|  0.00%|from .numerictypes import longlong, intc, int_, float_, complex_, bool_
    29|         0|            0|            0|  0.00%|from ._exceptions import TooHardError, AxisError
    30|         0|            0|            0|  0.00%|from ._ufunc_config import errstate
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|bitwise_not = invert
    33|         0|            0|            0|  0.00%|ufunc = type(sin)
    34|         0|            0|            0|  0.00%|newaxis = None
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    37|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|__all__ = [
    41|         0|            0|            0|  0.00%|    'newaxis', 'ndarray', 'flatiter', 'nditer', 'nested_iters', 'ufunc',
    42|         0|            0|            0|  0.00%|    'arange', 'array', 'asarray', 'asanyarray', 'ascontiguousarray',
    43|         0|            0|            0|  0.00%|    'asfortranarray', 'zeros', 'count_nonzero', 'empty', 'broadcast', 'dtype',
    44|         0|            0|            0|  0.00%|    'fromstring', 'fromfile', 'frombuffer', '_from_dlpack', 'where',
    45|         0|            0|            0|  0.00%|    'argwhere', 'copyto', 'concatenate', 'fastCopyAndTranspose', 'lexsort',
    46|         0|            0|            0|  0.00%|    'set_numeric_ops', 'can_cast', 'promote_types', 'min_scalar_type',
    47|         0|            0|            0|  0.00%|    'result_type', 'isfortran', 'empty_like', 'zeros_like', 'ones_like',
    48|         0|            0|            0|  0.00%|    'correlate', 'convolve', 'inner', 'dot', 'outer', 'vdot', 'roll',
    49|         0|            0|            0|  0.00%|    'rollaxis', 'moveaxis', 'cross', 'tensordot', 'little_endian',
    50|         0|            0|            0|  0.00%|    'fromiter', 'array_equal', 'array_equiv', 'indices', 'fromfunction',
    51|         0|            0|            0|  0.00%|    'isclose', 'isscalar', 'binary_repr', 'base_repr', 'ones',
    52|         0|            0|            0|  0.00%|    'identity', 'allclose', 'compare_chararrays', 'putmask',
    53|         0|            0|            0|  0.00%|    'flatnonzero', 'Inf', 'inf', 'infty', 'Infinity', 'nan', 'NaN',
    54|         0|            0|            0|  0.00%|    'False_', 'True_', 'bitwise_not', 'CLIP', 'RAISE', 'WRAP', 'MAXDIMS',
    55|         0|            0|            0|  0.00%|    'BUFSIZE', 'ALLOW_THREADS', 'ComplexWarning', 'full', 'full_like',
    56|         0|            0|            0|  0.00%|    'matmul', 'shares_memory', 'may_share_memory', 'MAY_SHARE_BOUNDS',
    57|         0|            0|            0|  0.00%|    'MAY_SHARE_EXACT', 'TooHardError', 'AxisError']
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|@set_module('numpy')
    61|         0|            0|            0|  0.00%|class ComplexWarning(RuntimeWarning):
    62|         0|            0|            0|  0.00%|    """
    63|         0|            0|            0|  0.00%|    The warning raised when casting a complex dtype to a real dtype.
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    As implemented, casting a complex number to a real discards its imaginary
    66|         0|            0|            0|  0.00%|    part, but this behavior may not be what the user actually wants.
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    """
    69|         0|            0|            0|  0.00%|    pass
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|def _zeros_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):
    73|         0|            0|            0|  0.00%|    return (a,)
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|@array_function_dispatch(_zeros_like_dispatcher)
    77|         0|            0|            0|  0.00%|def zeros_like(a, dtype=None, order='K', subok=True, shape=None):
    78|         0|            0|            0|  0.00%|    """
    79|         0|            0|            0|  0.00%|    Return an array of zeros with the same shape and type as a given array.
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    Parameters
    82|         0|            0|            0|  0.00%|    ----------
    83|         0|            0|            0|  0.00%|    a : array_like
    84|         0|            0|            0|  0.00%|        The shape and data-type of `a` define these same attributes of
    85|         0|            0|            0|  0.00%|        the returned array.
    86|         0|            0|            0|  0.00%|    dtype : data-type, optional
    87|         0|            0|            0|  0.00%|        Overrides the data type of the result.
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
    90|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
    91|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
    92|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    93|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
    94|         0|            0|            0|  0.00%|        as possible.
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
    97|         0|            0|            0|  0.00%|    subok : bool, optional.
    98|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
    99|         0|            0|            0|  0.00%|        type of `a`, otherwise it will be a base-class array. Defaults
   100|         0|            0|            0|  0.00%|        to True.
   101|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   102|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   103|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   104|         0|            0|            0|  0.00%|        order='C' is implied.
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|    Returns
   109|         0|            0|            0|  0.00%|    -------
   110|         0|            0|            0|  0.00%|    out : ndarray
   111|         0|            0|            0|  0.00%|        Array of zeros with the same shape and type as `a`.
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    See Also
   114|         0|            0|            0|  0.00%|    --------
   115|         0|            0|            0|  0.00%|    empty_like : Return an empty array with shape and type of input.
   116|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   117|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   118|         0|            0|            0|  0.00%|    zeros : Return a new array setting values to zero.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    Examples
   121|         0|            0|            0|  0.00%|    --------
   122|         0|            0|            0|  0.00%|    >>> x = np.arange(6)
   123|         0|            0|            0|  0.00%|    >>> x = x.reshape((2, 3))
   124|         0|            0|            0|  0.00%|    >>> x
   125|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   126|         0|            0|            0|  0.00%|           [3, 4, 5]])
   127|         0|            0|            0|  0.00%|    >>> np.zeros_like(x)
   128|         0|            0|            0|  0.00%|    array([[0, 0, 0],
   129|         0|            0|            0|  0.00%|           [0, 0, 0]])
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|    >>> y = np.arange(3, dtype=float)
   132|         0|            0|            0|  0.00%|    >>> y
   133|         0|            0|            0|  0.00%|    array([0., 1., 2.])
   134|         0|            0|            0|  0.00%|    >>> np.zeros_like(y)
   135|         0|            0|            0|  0.00%|    array([0.,  0.,  0.])
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    """
   138|         0|            0|            0|  0.00%|    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)
   139|         0|            0|            0|  0.00%|    # needed instead of a 0 to get same result as zeros for for string dtypes
   140|         0|            0|            0|  0.00%|    z = zeros(1, dtype=res.dtype)
   141|         0|            0|            0|  0.00%|    multiarray.copyto(res, z, casting='unsafe')
   142|         0|            0|            0|  0.00%|    return res
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|def _ones_dispatcher(shape, dtype=None, order=None, *, like=None):
   146|         0|            0|            0|  0.00%|    return(like,)
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|      5012|    0.0172749|   3.4467e-06|  0.05%|@set_array_function_like_doc
   150|         0|            0|            0|  0.00%|@set_module('numpy')
   151|         0|            0|            0|  0.00%|def ones(shape, dtype=None, order='C', *, like=None):
   152|         0|            0|            0|  0.00%|    """
   153|         0|            0|            0|  0.00%|    Return a new array of given shape and type, filled with ones.
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    Parameters
   156|         0|            0|            0|  0.00%|    ----------
   157|         0|            0|            0|  0.00%|    shape : int or sequence of ints
   158|         0|            0|            0|  0.00%|        Shape of the new array, e.g., ``(2, 3)`` or ``2``.
   159|         0|            0|            0|  0.00%|    dtype : data-type, optional
   160|         0|            0|            0|  0.00%|        The desired data-type for the array, e.g., `numpy.int8`.  Default is
   161|         0|            0|            0|  0.00%|        `numpy.float64`.
   162|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional, default: C
   163|         0|            0|            0|  0.00%|        Whether to store multi-dimensional data in row-major
   164|         0|            0|            0|  0.00%|        (C-style) or column-major (Fortran-style) order in
   165|         0|            0|            0|  0.00%|        memory.
   166|         0|            0|            0|  0.00%|    ${ARRAY_FUNCTION_LIKE}
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    Returns
   171|         0|            0|            0|  0.00%|    -------
   172|         0|            0|            0|  0.00%|    out : ndarray
   173|         0|            0|            0|  0.00%|        Array of ones with the given shape, dtype, and order.
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    See Also
   176|         0|            0|            0|  0.00%|    --------
   177|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   178|         0|            0|            0|  0.00%|    empty : Return a new uninitialized array.
   179|         0|            0|            0|  0.00%|    zeros : Return a new array setting values to zero.
   180|         0|            0|            0|  0.00%|    full : Return a new array of given shape filled with value.
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    Examples
   184|         0|            0|            0|  0.00%|    --------
   185|         0|            0|            0|  0.00%|    >>> np.ones(5)
   186|         0|            0|            0|  0.00%|    array([1., 1., 1., 1., 1.])
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    >>> np.ones((5,), dtype=int)
   189|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1])
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|    >>> np.ones((2, 1))
   192|         0|            0|            0|  0.00%|    array([[1.],
   193|         0|            0|            0|  0.00%|           [1.]])
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|    >>> s = (2,2)
   196|         0|            0|            0|  0.00%|    >>> np.ones(s)
   197|         0|            0|            0|  0.00%|    array([[1.,  1.],
   198|         0|            0|            0|  0.00%|           [1.,  1.]])
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|    """
   201|      5012|    0.0140605|  2.80537e-06|  0.04%|    if like is not None:
   202|         0|            0|            0|  0.00%|        return _ones_with_like(shape, dtype=dtype, order=order, like=like)
   203|         0|            0|            0|  0.00%|
   204|      5012|    0.0203099|  4.05226e-06|  0.06%|    a = empty(shape, dtype, order)
   205|      5012|    0.0412815|  8.23652e-06|  0.12%|    multiarray.copyto(a, 1, casting='unsafe')
(call)|      5012|     0.116909|  2.33257e-05|  0.33%|# <__array_function__ internals>:177 copyto
   206|      5012|   0.00800467|   1.5971e-06|  0.02%|    return a
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|_ones_with_like = array_function_dispatch(
   210|         0|            0|            0|  0.00%|    _ones_dispatcher
   211|         0|            0|            0|  0.00%|)(ones)
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|def _ones_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):
   215|         0|            0|            0|  0.00%|    return (a,)
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|@array_function_dispatch(_ones_like_dispatcher)
   219|         0|            0|            0|  0.00%|def ones_like(a, dtype=None, order='K', subok=True, shape=None):
   220|         0|            0|            0|  0.00%|    """
   221|         0|            0|            0|  0.00%|    Return an array of ones with the same shape and type as a given array.
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    Parameters
   224|         0|            0|            0|  0.00%|    ----------
   225|         0|            0|            0|  0.00%|    a : array_like
   226|         0|            0|            0|  0.00%|        The shape and data-type of `a` define these same attributes of
   227|         0|            0|            0|  0.00%|        the returned array.
   228|         0|            0|            0|  0.00%|    dtype : data-type, optional
   229|         0|            0|            0|  0.00%|        Overrides the data type of the result.
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   232|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
   233|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
   234|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
   235|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
   236|         0|            0|            0|  0.00%|        as possible.
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   239|         0|            0|            0|  0.00%|    subok : bool, optional.
   240|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
   241|         0|            0|            0|  0.00%|        type of `a`, otherwise it will be a base-class array. Defaults
   242|         0|            0|            0|  0.00%|        to True.
   243|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   244|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   245|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   246|         0|            0|            0|  0.00%|        order='C' is implied.
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|    Returns
   251|         0|            0|            0|  0.00%|    -------
   252|         0|            0|            0|  0.00%|    out : ndarray
   253|         0|            0|            0|  0.00%|        Array of ones with the same shape and type as `a`.
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|    See Also
   256|         0|            0|            0|  0.00%|    --------
   257|         0|            0|            0|  0.00%|    empty_like : Return an empty array with shape and type of input.
   258|         0|            0|            0|  0.00%|    zeros_like : Return an array of zeros with shape and type of input.
   259|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   260|         0|            0|            0|  0.00%|    ones : Return a new array setting values to one.
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    Examples
   263|         0|            0|            0|  0.00%|    --------
   264|         0|            0|            0|  0.00%|    >>> x = np.arange(6)
   265|         0|            0|            0|  0.00%|    >>> x = x.reshape((2, 3))
   266|         0|            0|            0|  0.00%|    >>> x
   267|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   268|         0|            0|            0|  0.00%|           [3, 4, 5]])
   269|         0|            0|            0|  0.00%|    >>> np.ones_like(x)
   270|         0|            0|            0|  0.00%|    array([[1, 1, 1],
   271|         0|            0|            0|  0.00%|           [1, 1, 1]])
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    >>> y = np.arange(3, dtype=float)
   274|         0|            0|            0|  0.00%|    >>> y
   275|         0|            0|            0|  0.00%|    array([0., 1., 2.])
   276|         0|            0|            0|  0.00%|    >>> np.ones_like(y)
   277|         0|            0|            0|  0.00%|    array([1.,  1.,  1.])
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|    """
   280|         0|            0|            0|  0.00%|    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)
   281|         0|            0|            0|  0.00%|    multiarray.copyto(res, 1, casting='unsafe')
   282|         0|            0|            0|  0.00%|    return res
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|def _full_dispatcher(shape, fill_value, dtype=None, order=None, *, like=None):
   286|         0|            0|            0|  0.00%|    return(like,)
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|@set_array_function_like_doc
   290|         0|            0|            0|  0.00%|@set_module('numpy')
   291|         0|            0|            0|  0.00%|def full(shape, fill_value, dtype=None, order='C', *, like=None):
   292|         0|            0|            0|  0.00%|    """
   293|         0|            0|            0|  0.00%|    Return a new array of given shape and type, filled with `fill_value`.
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    Parameters
   296|         0|            0|            0|  0.00%|    ----------
   297|         0|            0|            0|  0.00%|    shape : int or sequence of ints
   298|         0|            0|            0|  0.00%|        Shape of the new array, e.g., ``(2, 3)`` or ``2``.
   299|         0|            0|            0|  0.00%|    fill_value : scalar or array_like
   300|         0|            0|            0|  0.00%|        Fill value.
   301|         0|            0|            0|  0.00%|    dtype : data-type, optional
   302|         0|            0|            0|  0.00%|        The desired data-type for the array  The default, None, means
   303|         0|            0|            0|  0.00%|         ``np.array(fill_value).dtype``.
   304|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
   305|         0|            0|            0|  0.00%|        Whether to store multidimensional data in C- or Fortran-contiguous
   306|         0|            0|            0|  0.00%|        (row- or column-wise) order in memory.
   307|         0|            0|            0|  0.00%|    ${ARRAY_FUNCTION_LIKE}
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    Returns
   312|         0|            0|            0|  0.00%|    -------
   313|         0|            0|            0|  0.00%|    out : ndarray
   314|         0|            0|            0|  0.00%|        Array of `fill_value` with the given shape, dtype, and order.
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    See Also
   317|         0|            0|            0|  0.00%|    --------
   318|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   319|         0|            0|            0|  0.00%|    empty : Return a new uninitialized array.
   320|         0|            0|            0|  0.00%|    ones : Return a new array setting values to one.
   321|         0|            0|            0|  0.00%|    zeros : Return a new array setting values to zero.
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    Examples
   324|         0|            0|            0|  0.00%|    --------
   325|         0|            0|            0|  0.00%|    >>> np.full((2, 2), np.inf)
   326|         0|            0|            0|  0.00%|    array([[inf, inf],
   327|         0|            0|            0|  0.00%|           [inf, inf]])
   328|         0|            0|            0|  0.00%|    >>> np.full((2, 2), 10)
   329|         0|            0|            0|  0.00%|    array([[10, 10],
   330|         0|            0|            0|  0.00%|           [10, 10]])
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|    >>> np.full((2, 2), [1, 2])
   333|         0|            0|            0|  0.00%|    array([[1, 2],
   334|         0|            0|            0|  0.00%|           [1, 2]])
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|    """
   337|         0|            0|            0|  0.00%|    if like is not None:
   338|         0|            0|            0|  0.00%|        return _full_with_like(shape, fill_value, dtype=dtype, order=order, like=like)
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|    if dtype is None:
   341|         0|            0|            0|  0.00%|        fill_value = asarray(fill_value)
   342|         0|            0|            0|  0.00%|        dtype = fill_value.dtype
   343|         0|            0|            0|  0.00%|    a = empty(shape, dtype, order)
   344|         0|            0|            0|  0.00%|    multiarray.copyto(a, fill_value, casting='unsafe')
   345|         0|            0|            0|  0.00%|    return a
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|_full_with_like = array_function_dispatch(
   349|         0|            0|            0|  0.00%|    _full_dispatcher
   350|         0|            0|            0|  0.00%|)(full)
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|def _full_like_dispatcher(a, fill_value, dtype=None, order=None, subok=None, shape=None):
   354|         0|            0|            0|  0.00%|    return (a,)
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|@array_function_dispatch(_full_like_dispatcher)
   358|         0|            0|            0|  0.00%|def full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None):
   359|         0|            0|            0|  0.00%|    """
   360|         0|            0|            0|  0.00%|    Return a full array with the same shape and type as a given array.
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    Parameters
   363|         0|            0|            0|  0.00%|    ----------
   364|         0|            0|            0|  0.00%|    a : array_like
   365|         0|            0|            0|  0.00%|        The shape and data-type of `a` define these same attributes of
   366|         0|            0|            0|  0.00%|        the returned array.
   367|         0|            0|            0|  0.00%|    fill_value : scalar
   368|         0|            0|            0|  0.00%|        Fill value.
   369|         0|            0|            0|  0.00%|    dtype : data-type, optional
   370|         0|            0|            0|  0.00%|        Overrides the data type of the result.
   371|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
   372|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
   373|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
   374|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
   375|         0|            0|            0|  0.00%|        as possible.
   376|         0|            0|            0|  0.00%|    subok : bool, optional.
   377|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
   378|         0|            0|            0|  0.00%|        type of `a`, otherwise it will be a base-class array. Defaults
   379|         0|            0|            0|  0.00%|        to True.
   380|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   381|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   382|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   383|         0|            0|            0|  0.00%|        order='C' is implied.
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    Returns
   388|         0|            0|            0|  0.00%|    -------
   389|         0|            0|            0|  0.00%|    out : ndarray
   390|         0|            0|            0|  0.00%|        Array of `fill_value` with the same shape and type as `a`.
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|    See Also
   393|         0|            0|            0|  0.00%|    --------
   394|         0|            0|            0|  0.00%|    empty_like : Return an empty array with shape and type of input.
   395|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   396|         0|            0|            0|  0.00%|    zeros_like : Return an array of zeros with shape and type of input.
   397|         0|            0|            0|  0.00%|    full : Return a new array of given shape filled with value.
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    Examples
   400|         0|            0|            0|  0.00%|    --------
   401|         0|            0|            0|  0.00%|    >>> x = np.arange(6, dtype=int)
   402|         0|            0|            0|  0.00%|    >>> np.full_like(x, 1)
   403|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1, 1])
   404|         0|            0|            0|  0.00%|    >>> np.full_like(x, 0.1)
   405|         0|            0|            0|  0.00%|    array([0, 0, 0, 0, 0, 0])
   406|         0|            0|            0|  0.00%|    >>> np.full_like(x, 0.1, dtype=np.double)
   407|         0|            0|            0|  0.00%|    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
   408|         0|            0|            0|  0.00%|    >>> np.full_like(x, np.nan, dtype=np.double)
   409|         0|            0|            0|  0.00%|    array([nan, nan, nan, nan, nan, nan])
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    >>> y = np.arange(6, dtype=np.double)
   412|         0|            0|            0|  0.00%|    >>> np.full_like(y, 0.1)
   413|         0|            0|            0|  0.00%|    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|    """
   416|         0|            0|            0|  0.00%|    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)
   417|         0|            0|            0|  0.00%|    multiarray.copyto(res, fill_value, casting='unsafe')
   418|         0|            0|            0|  0.00%|    return res
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|def _count_nonzero_dispatcher(a, axis=None, *, keepdims=None):
   422|         0|            0|            0|  0.00%|    return (a,)
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|@array_function_dispatch(_count_nonzero_dispatcher)
   426|         0|            0|            0|  0.00%|def count_nonzero(a, axis=None, *, keepdims=False):
   427|         0|            0|            0|  0.00%|    """
   428|         0|            0|            0|  0.00%|    Counts the number of non-zero values in the array ``a``.
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|    The word "non-zero" is in reference to the Python 2.x
   431|         0|            0|            0|  0.00%|    built-in method ``__nonzero__()`` (renamed ``__bool__()``
   432|         0|            0|            0|  0.00%|    in Python 3.x) of Python objects that tests an object's
   433|         0|            0|            0|  0.00%|    "truthfulness". For example, any number is considered
   434|         0|            0|            0|  0.00%|    truthful if it is nonzero, whereas any string is considered
   435|         0|            0|            0|  0.00%|    truthful if it is not the empty string. Thus, this function
   436|         0|            0|            0|  0.00%|    (recursively) counts how many elements in ``a`` (and in
   437|         0|            0|            0|  0.00%|    sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
   438|         0|            0|            0|  0.00%|    method evaluated to ``True``.
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|    Parameters
   441|         0|            0|            0|  0.00%|    ----------
   442|         0|            0|            0|  0.00%|    a : array_like
   443|         0|            0|            0|  0.00%|        The array for which to count non-zeros.
   444|         0|            0|            0|  0.00%|    axis : int or tuple, optional
   445|         0|            0|            0|  0.00%|        Axis or tuple of axes along which to count non-zeros.
   446|         0|            0|            0|  0.00%|        Default is None, meaning that non-zeros will be counted
   447|         0|            0|            0|  0.00%|        along a flattened version of ``a``.
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|        .. versionadded:: 1.12.0
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|    keepdims : bool, optional
   452|         0|            0|            0|  0.00%|        If this is set to True, the axes that are counted are left
   453|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
   454|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|        .. versionadded:: 1.19.0
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|    Returns
   459|         0|            0|            0|  0.00%|    -------
   460|         0|            0|            0|  0.00%|    count : int or array of int
   461|         0|            0|            0|  0.00%|        Number of non-zero values in the array along a given axis.
   462|         0|            0|            0|  0.00%|        Otherwise, the total number of non-zero values in the array
   463|         0|            0|            0|  0.00%|        is returned.
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    See Also
   466|         0|            0|            0|  0.00%|    --------
   467|         0|            0|            0|  0.00%|    nonzero : Return the coordinates of all the non-zero values.
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|    Examples
   470|         0|            0|            0|  0.00%|    --------
   471|         0|            0|            0|  0.00%|    >>> np.count_nonzero(np.eye(4))
   472|         0|            0|            0|  0.00%|    4
   473|         0|            0|            0|  0.00%|    >>> a = np.array([[0, 1, 7, 0],
   474|         0|            0|            0|  0.00%|    ...               [3, 0, 2, 19]])
   475|         0|            0|            0|  0.00%|    >>> np.count_nonzero(a)
   476|         0|            0|            0|  0.00%|    5
   477|         0|            0|            0|  0.00%|    >>> np.count_nonzero(a, axis=0)
   478|         0|            0|            0|  0.00%|    array([1, 1, 2, 1])
   479|         0|            0|            0|  0.00%|    >>> np.count_nonzero(a, axis=1)
   480|         0|            0|            0|  0.00%|    array([2, 3])
   481|         0|            0|            0|  0.00%|    >>> np.count_nonzero(a, axis=1, keepdims=True)
   482|         0|            0|            0|  0.00%|    array([[2],
   483|         0|            0|            0|  0.00%|           [3]])
   484|         0|            0|            0|  0.00%|    """
   485|         0|            0|            0|  0.00%|    if axis is None and not keepdims:
   486|         0|            0|            0|  0.00%|        return multiarray.count_nonzero(a)
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|    a = asanyarray(a)
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|    # TODO: this works around .astype(bool) not working properly (gh-9847)
   491|         0|            0|            0|  0.00%|    if np.issubdtype(a.dtype, np.character):
   492|         0|            0|            0|  0.00%|        a_bool = a != a.dtype.type()
   493|         0|            0|            0|  0.00%|    else:
   494|         0|            0|            0|  0.00%|        a_bool = a.astype(np.bool_, copy=False)
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    return a_bool.sum(axis=axis, dtype=np.intp, keepdims=keepdims)
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|@set_module('numpy')
   500|         0|            0|            0|  0.00%|def isfortran(a):
   501|         0|            0|            0|  0.00%|    """
   502|         0|            0|            0|  0.00%|    Check if the array is Fortran contiguous but *not* C contiguous.
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    This function is obsolete and, because of changes due to relaxed stride
   505|         0|            0|            0|  0.00%|    checking, its return value for the same array may differ for versions
   506|         0|            0|            0|  0.00%|    of NumPy >= 1.10.0 and previous versions. If you only want to check if an
   507|         0|            0|            0|  0.00%|    array is Fortran contiguous use ``a.flags.f_contiguous`` instead.
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    Parameters
   510|         0|            0|            0|  0.00%|    ----------
   511|         0|            0|            0|  0.00%|    a : ndarray
   512|         0|            0|            0|  0.00%|        Input array.
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|    Returns
   515|         0|            0|            0|  0.00%|    -------
   516|         0|            0|            0|  0.00%|    isfortran : bool
   517|         0|            0|            0|  0.00%|        Returns True if the array is Fortran contiguous but *not* C contiguous.
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|    Examples
   521|         0|            0|            0|  0.00%|    --------
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|    np.array allows to specify whether the array is written in C-contiguous
   524|         0|            0|            0|  0.00%|    order (last index varies the fastest), or FORTRAN-contiguous order in
   525|         0|            0|            0|  0.00%|    memory (first index varies the fastest).
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
   528|         0|            0|            0|  0.00%|    >>> a
   529|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   530|         0|            0|            0|  0.00%|           [4, 5, 6]])
   531|         0|            0|            0|  0.00%|    >>> np.isfortran(a)
   532|         0|            0|            0|  0.00%|    False
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')
   535|         0|            0|            0|  0.00%|    >>> b
   536|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   537|         0|            0|            0|  0.00%|           [4, 5, 6]])
   538|         0|            0|            0|  0.00%|    >>> np.isfortran(b)
   539|         0|            0|            0|  0.00%|    True
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|    The transpose of a C-ordered array is a FORTRAN-ordered array.
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
   545|         0|            0|            0|  0.00%|    >>> a
   546|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   547|         0|            0|            0|  0.00%|           [4, 5, 6]])
   548|         0|            0|            0|  0.00%|    >>> np.isfortran(a)
   549|         0|            0|            0|  0.00%|    False
   550|         0|            0|            0|  0.00%|    >>> b = a.T
   551|         0|            0|            0|  0.00%|    >>> b
   552|         0|            0|            0|  0.00%|    array([[1, 4],
   553|         0|            0|            0|  0.00%|           [2, 5],
   554|         0|            0|            0|  0.00%|           [3, 6]])
   555|         0|            0|            0|  0.00%|    >>> np.isfortran(b)
   556|         0|            0|            0|  0.00%|    True
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|    C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|    >>> np.isfortran(np.array([1, 2], order='F'))
   561|         0|            0|            0|  0.00%|    False
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|    """
   564|         0|            0|            0|  0.00%|    return a.flags.fnc
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|def _argwhere_dispatcher(a):
   568|         0|            0|            0|  0.00%|    return (a,)
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|@array_function_dispatch(_argwhere_dispatcher)
   572|         0|            0|            0|  0.00%|def argwhere(a):
   573|         0|            0|            0|  0.00%|    """
   574|         0|            0|            0|  0.00%|    Find the indices of array elements that are non-zero, grouped by element.
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|    Parameters
   577|         0|            0|            0|  0.00%|    ----------
   578|         0|            0|            0|  0.00%|    a : array_like
   579|         0|            0|            0|  0.00%|        Input data.
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|    Returns
   582|         0|            0|            0|  0.00%|    -------
   583|         0|            0|            0|  0.00%|    index_array : (N, a.ndim) ndarray
   584|         0|            0|            0|  0.00%|        Indices of elements that are non-zero. Indices are grouped by element.
   585|         0|            0|            0|  0.00%|        This array will have shape ``(N, a.ndim)`` where ``N`` is the number of
   586|         0|            0|            0|  0.00%|        non-zero items.
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|    See Also
   589|         0|            0|            0|  0.00%|    --------
   590|         0|            0|            0|  0.00%|    where, nonzero
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|    Notes
   593|         0|            0|            0|  0.00%|    -----
   594|         0|            0|            0|  0.00%|    ``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,
   595|         0|            0|            0|  0.00%|    but produces a result of the correct shape for a 0D array.
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    The output of ``argwhere`` is not suitable for indexing arrays.
   598|         0|            0|            0|  0.00%|    For this purpose use ``nonzero(a)`` instead.
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|    Examples
   601|         0|            0|            0|  0.00%|    --------
   602|         0|            0|            0|  0.00%|    >>> x = np.arange(6).reshape(2,3)
   603|         0|            0|            0|  0.00%|    >>> x
   604|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   605|         0|            0|            0|  0.00%|           [3, 4, 5]])
   606|         0|            0|            0|  0.00%|    >>> np.argwhere(x>1)
   607|         0|            0|            0|  0.00%|    array([[0, 2],
   608|         0|            0|            0|  0.00%|           [1, 0],
   609|         0|            0|            0|  0.00%|           [1, 1],
   610|         0|            0|            0|  0.00%|           [1, 2]])
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|    """
   613|         0|            0|            0|  0.00%|    # nonzero does not behave well on 0d, so promote to 1d
   614|         0|            0|            0|  0.00%|    if np.ndim(a) == 0:
   615|         0|            0|            0|  0.00%|        a = shape_base.atleast_1d(a)
   616|         0|            0|            0|  0.00%|        # then remove the added dimension
   617|         0|            0|            0|  0.00%|        return argwhere(a)[:,:0]
   618|         0|            0|            0|  0.00%|    return transpose(nonzero(a))
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|
   621|         4|            0|            0|  0.00%|def _flatnonzero_dispatcher(a):
   622|         4|            0|            0|  0.00%|    return (a,)
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|
   625|         4|            0|            0|  0.00%|@array_function_dispatch(_flatnonzero_dispatcher)
   626|         0|            0|            0|  0.00%|def flatnonzero(a):
   627|         0|            0|            0|  0.00%|    """
   628|         0|            0|            0|  0.00%|    Return indices that are non-zero in the flattened version of a.
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|    This is equivalent to np.nonzero(np.ravel(a))[0].
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|    Parameters
   633|         0|            0|            0|  0.00%|    ----------
   634|         0|            0|            0|  0.00%|    a : array_like
   635|         0|            0|            0|  0.00%|        Input data.
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|    Returns
   638|         0|            0|            0|  0.00%|    -------
   639|         0|            0|            0|  0.00%|    res : ndarray
   640|         0|            0|            0|  0.00%|        Output array, containing the indices of the elements of `a.ravel()`
   641|         0|            0|            0|  0.00%|        that are non-zero.
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    See Also
   644|         0|            0|            0|  0.00%|    --------
   645|         0|            0|            0|  0.00%|    nonzero : Return the indices of the non-zero elements of the input array.
   646|         0|            0|            0|  0.00%|    ravel : Return a 1-D array containing the elements of the input array.
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|    Examples
   649|         0|            0|            0|  0.00%|    --------
   650|         0|            0|            0|  0.00%|    >>> x = np.arange(-2, 3)
   651|         0|            0|            0|  0.00%|    >>> x
   652|         0|            0|            0|  0.00%|    array([-2, -1,  0,  1,  2])
   653|         0|            0|            0|  0.00%|    >>> np.flatnonzero(x)
   654|         0|            0|            0|  0.00%|    array([0, 1, 3, 4])
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|    Use the indices of the non-zero elements as an index array to extract
   657|         0|            0|            0|  0.00%|    these elements:
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|    >>> x.ravel()[np.flatnonzero(x)]
   660|         0|            0|            0|  0.00%|    array([-2, -1,  1,  2])
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|    """
   663|         4|            0|            0|  0.00%|    return np.nonzero(np.ravel(a))[0]
(call)|         4|  9.98974e-05|  2.49743e-05|  0.00%|# <__array_function__ internals>:177 ravel
(call)|         4|  7.55787e-05|  1.88947e-05|  0.00%|# <__array_function__ internals>:177 nonzero
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|def _correlate_dispatcher(a, v, mode=None):
   667|         0|            0|            0|  0.00%|    return (a, v)
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|@array_function_dispatch(_correlate_dispatcher)
   671|         0|            0|            0|  0.00%|def correlate(a, v, mode='valid'):
   672|         0|            0|            0|  0.00%|    """
   673|         0|            0|            0|  0.00%|    Cross-correlation of two 1-dimensional sequences.
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|    This function computes the correlation as generally defined in signal
   676|         0|            0|            0|  0.00%|    processing texts::
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|        c_{av}[k] = sum_n a[n+k] * conj(v[n])
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|    with a and v sequences being zero-padded where necessary and conj being
   681|         0|            0|            0|  0.00%|    the conjugate.
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|    Parameters
   684|         0|            0|            0|  0.00%|    ----------
   685|         0|            0|            0|  0.00%|    a, v : array_like
   686|         0|            0|            0|  0.00%|        Input sequences.
   687|         0|            0|            0|  0.00%|    mode : {'valid', 'same', 'full'}, optional
   688|         0|            0|            0|  0.00%|        Refer to the `convolve` docstring.  Note that the default
   689|         0|            0|            0|  0.00%|        is 'valid', unlike `convolve`, which uses 'full'.
   690|         0|            0|            0|  0.00%|    old_behavior : bool
   691|         0|            0|            0|  0.00%|        `old_behavior` was removed in NumPy 1.10. If you need the old
   692|         0|            0|            0|  0.00%|        behavior, use `multiarray.correlate`.
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|    Returns
   695|         0|            0|            0|  0.00%|    -------
   696|         0|            0|            0|  0.00%|    out : ndarray
   697|         0|            0|            0|  0.00%|        Discrete cross-correlation of `a` and `v`.
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|    See Also
   700|         0|            0|            0|  0.00%|    --------
   701|         0|            0|            0|  0.00%|    convolve : Discrete, linear convolution of two one-dimensional sequences.
   702|         0|            0|            0|  0.00%|    multiarray.correlate : Old, no conjugate, version of correlate.
   703|         0|            0|            0|  0.00%|    scipy.signal.correlate : uses FFT which has superior performance on large arrays.
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|    Notes
   706|         0|            0|            0|  0.00%|    -----
   707|         0|            0|            0|  0.00%|    The definition of correlation above is not unique and sometimes correlation
   708|         0|            0|            0|  0.00%|    may be defined differently. Another common definition is::
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|        c'_{av}[k] = sum_n a[n] conj(v[n+k])
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|    which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    `numpy.correlate` may perform slowly in large arrays (i.e. n = 1e5) because it does
   715|         0|            0|            0|  0.00%|    not use the FFT to compute the convolution; in that case, `scipy.signal.correlate` might
   716|         0|            0|            0|  0.00%|    be preferable.
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    Examples
   720|         0|            0|            0|  0.00%|    --------
   721|         0|            0|            0|  0.00%|    >>> np.correlate([1, 2, 3], [0, 1, 0.5])
   722|         0|            0|            0|  0.00%|    array([3.5])
   723|         0|            0|            0|  0.00%|    >>> np.correlate([1, 2, 3], [0, 1, 0.5], "same")
   724|         0|            0|            0|  0.00%|    array([2. ,  3.5,  3. ])
   725|         0|            0|            0|  0.00%|    >>> np.correlate([1, 2, 3], [0, 1, 0.5], "full")
   726|         0|            0|            0|  0.00%|    array([0.5,  2. ,  3.5,  3. ,  0. ])
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|    Using complex sequences:
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|    >>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
   731|         0|            0|            0|  0.00%|    array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|    Note that you get the time reversed, complex conjugated result
   734|         0|            0|            0|  0.00%|    when the two input sequences change places, i.e.,
   735|         0|            0|            0|  0.00%|    ``c_{va}[k] = c^{*}_{av}[-k]``:
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|    >>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
   738|         0|            0|            0|  0.00%|    array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|    """
   741|         0|            0|            0|  0.00%|    return multiarray.correlate2(a, v, mode)
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|def _convolve_dispatcher(a, v, mode=None):
   745|         0|            0|            0|  0.00%|    return (a, v)
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|@array_function_dispatch(_convolve_dispatcher)
   749|         0|            0|            0|  0.00%|def convolve(a, v, mode='full'):
   750|         0|            0|            0|  0.00%|    """
   751|         0|            0|            0|  0.00%|    Returns the discrete, linear convolution of two one-dimensional sequences.
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|    The convolution operator is often seen in signal processing, where it
   754|         0|            0|            0|  0.00%|    models the effect of a linear time-invariant system on a signal [1]_.  In
   755|         0|            0|            0|  0.00%|    probability theory, the sum of two independent random variables is
   756|         0|            0|            0|  0.00%|    distributed according to the convolution of their individual
   757|         0|            0|            0|  0.00%|    distributions.
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|    If `v` is longer than `a`, the arrays are swapped before computation.
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|    Parameters
   762|         0|            0|            0|  0.00%|    ----------
   763|         0|            0|            0|  0.00%|    a : (N,) array_like
   764|         0|            0|            0|  0.00%|        First one-dimensional input array.
   765|         0|            0|            0|  0.00%|    v : (M,) array_like
   766|         0|            0|            0|  0.00%|        Second one-dimensional input array.
   767|         0|            0|            0|  0.00%|    mode : {'full', 'valid', 'same'}, optional
   768|         0|            0|            0|  0.00%|        'full':
   769|         0|            0|            0|  0.00%|          By default, mode is 'full'.  This returns the convolution
   770|         0|            0|            0|  0.00%|          at each point of overlap, with an output shape of (N+M-1,). At
   771|         0|            0|            0|  0.00%|          the end-points of the convolution, the signals do not overlap
   772|         0|            0|            0|  0.00%|          completely, and boundary effects may be seen.
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|        'same':
   775|         0|            0|            0|  0.00%|          Mode 'same' returns output of length ``max(M, N)``.  Boundary
   776|         0|            0|            0|  0.00%|          effects are still visible.
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|        'valid':
   779|         0|            0|            0|  0.00%|          Mode 'valid' returns output of length
   780|         0|            0|            0|  0.00%|          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
   781|         0|            0|            0|  0.00%|          for points where the signals overlap completely.  Values outside
   782|         0|            0|            0|  0.00%|          the signal boundary have no effect.
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|    Returns
   785|         0|            0|            0|  0.00%|    -------
   786|         0|            0|            0|  0.00%|    out : ndarray
   787|         0|            0|            0|  0.00%|        Discrete, linear convolution of `a` and `v`.
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|    See Also
   790|         0|            0|            0|  0.00%|    --------
   791|         0|            0|            0|  0.00%|    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
   792|         0|            0|            0|  0.00%|                               Transform.
   793|         0|            0|            0|  0.00%|    scipy.linalg.toeplitz : Used to construct the convolution operator.
   794|         0|            0|            0|  0.00%|    polymul : Polynomial multiplication. Same output as convolve, but also
   795|         0|            0|            0|  0.00%|              accepts poly1d objects as input.
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|    Notes
   798|         0|            0|            0|  0.00%|    -----
   799|         0|            0|            0|  0.00%|    The discrete convolution operation is defined as
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|    .. math:: (a * v)[n] = \\sum_{m = -\\infty}^{\\infty} a[m] v[n - m]
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|    It can be shown that a convolution :math:`x(t) * y(t)` in time/space
   804|         0|            0|            0|  0.00%|    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
   805|         0|            0|            0|  0.00%|    domain, after appropriate padding (padding is necessary to prevent
   806|         0|            0|            0|  0.00%|    circular convolution).  Since multiplication is more efficient (faster)
   807|         0|            0|            0|  0.00%|    than convolution, the function `scipy.signal.fftconvolve` exploits the
   808|         0|            0|            0|  0.00%|    FFT to calculate the convolution of large data-sets.
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|    References
   811|         0|            0|            0|  0.00%|    ----------
   812|         0|            0|            0|  0.00%|    .. [1] Wikipedia, "Convolution",
   813|         0|            0|            0|  0.00%|        https://en.wikipedia.org/wiki/Convolution
   814|         0|            0|            0|  0.00%|
   815|         0|            0|            0|  0.00%|    Examples
   816|         0|            0|            0|  0.00%|    --------
   817|         0|            0|            0|  0.00%|    Note how the convolution operator flips the second array
   818|         0|            0|            0|  0.00%|    before "sliding" the two across one another:
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|    >>> np.convolve([1, 2, 3], [0, 1, 0.5])
   821|         0|            0|            0|  0.00%|    array([0. , 1. , 2.5, 4. , 1.5])
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|    Only return the middle values of the convolution.
   824|         0|            0|            0|  0.00%|    Contains boundary effects, where zeros are taken
   825|         0|            0|            0|  0.00%|    into account:
   826|         0|            0|            0|  0.00%|
   827|         0|            0|            0|  0.00%|    >>> np.convolve([1,2,3],[0,1,0.5], 'same')
   828|         0|            0|            0|  0.00%|    array([1. ,  2.5,  4. ])
   829|         0|            0|            0|  0.00%|
   830|         0|            0|            0|  0.00%|    The two arrays are of the same length, so there
   831|         0|            0|            0|  0.00%|    is only one position where they completely overlap:
   832|         0|            0|            0|  0.00%|
   833|         0|            0|            0|  0.00%|    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')
   834|         0|            0|            0|  0.00%|    array([2.5])
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|    """
   837|         0|            0|            0|  0.00%|    a, v = array(a, copy=False, ndmin=1), array(v, copy=False, ndmin=1)
   838|         0|            0|            0|  0.00%|    if (len(v) > len(a)):
   839|         0|            0|            0|  0.00%|        a, v = v, a
   840|         0|            0|            0|  0.00%|    if len(a) == 0:
   841|         0|            0|            0|  0.00%|        raise ValueError('a cannot be empty')
   842|         0|            0|            0|  0.00%|    if len(v) == 0:
   843|         0|            0|            0|  0.00%|        raise ValueError('v cannot be empty')
   844|         0|            0|            0|  0.00%|    return multiarray.correlate(a, v[::-1], mode)
   845|         0|            0|            0|  0.00%|
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|def _outer_dispatcher(a, b, out=None):
   848|         0|            0|            0|  0.00%|    return (a, b, out)
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|@array_function_dispatch(_outer_dispatcher)
   852|         0|            0|            0|  0.00%|def outer(a, b, out=None):
   853|         0|            0|            0|  0.00%|    """
   854|         0|            0|            0|  0.00%|    Compute the outer product of two vectors.
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|    Given two vectors, ``a = [a0, a1, ..., aM]`` and
   857|         0|            0|            0|  0.00%|    ``b = [b0, b1, ..., bN]``,
   858|         0|            0|            0|  0.00%|    the outer product [1]_ is::
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|      [[a0*b0  a0*b1 ... a0*bN ]
   861|         0|            0|            0|  0.00%|       [a1*b0    .
   862|         0|            0|            0|  0.00%|       [ ...          .
   863|         0|            0|            0|  0.00%|       [aM*b0            aM*bN ]]
   864|         0|            0|            0|  0.00%|
   865|         0|            0|            0|  0.00%|    Parameters
   866|         0|            0|            0|  0.00%|    ----------
   867|         0|            0|            0|  0.00%|    a : (M,) array_like
   868|         0|            0|            0|  0.00%|        First input vector.  Input is flattened if
   869|         0|            0|            0|  0.00%|        not already 1-dimensional.
   870|         0|            0|            0|  0.00%|    b : (N,) array_like
   871|         0|            0|            0|  0.00%|        Second input vector.  Input is flattened if
   872|         0|            0|            0|  0.00%|        not already 1-dimensional.
   873|         0|            0|            0|  0.00%|    out : (M, N) ndarray, optional
   874|         0|            0|            0|  0.00%|        A location where the result is stored
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|    Returns
   879|         0|            0|            0|  0.00%|    -------
   880|         0|            0|            0|  0.00%|    out : (M, N) ndarray
   881|         0|            0|            0|  0.00%|        ``out[i, j] = a[i] * b[j]``
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|    See also
   884|         0|            0|            0|  0.00%|    --------
   885|         0|            0|            0|  0.00%|    inner
   886|         0|            0|            0|  0.00%|    einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
   887|         0|            0|            0|  0.00%|    ufunc.outer : A generalization to dimensions other than 1D and other
   888|         0|            0|            0|  0.00%|                  operations. ``np.multiply.outer(a.ravel(), b.ravel())``
   889|         0|            0|            0|  0.00%|                  is the equivalent.
   890|         0|            0|            0|  0.00%|    tensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``
   891|         0|            0|            0|  0.00%|                is the equivalent.
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|    References
   894|         0|            0|            0|  0.00%|    ----------
   895|         0|            0|            0|  0.00%|    .. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
   896|         0|            0|            0|  0.00%|             ed., Baltimore, MD, Johns Hopkins University Press, 1996,
   897|         0|            0|            0|  0.00%|             pg. 8.
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|    Examples
   900|         0|            0|            0|  0.00%|    --------
   901|         0|            0|            0|  0.00%|    Make a (*very* coarse) grid for computing a Mandelbrot set:
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
   904|         0|            0|            0|  0.00%|    >>> rl
   905|         0|            0|            0|  0.00%|    array([[-2., -1.,  0.,  1.,  2.],
   906|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.],
   907|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.],
   908|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.],
   909|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.]])
   910|         0|            0|            0|  0.00%|    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
   911|         0|            0|            0|  0.00%|    >>> im
   912|         0|            0|            0|  0.00%|    array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
   913|         0|            0|            0|  0.00%|           [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
   914|         0|            0|            0|  0.00%|           [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
   915|         0|            0|            0|  0.00%|           [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
   916|         0|            0|            0|  0.00%|           [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
   917|         0|            0|            0|  0.00%|    >>> grid = rl + im
   918|         0|            0|            0|  0.00%|    >>> grid
   919|         0|            0|            0|  0.00%|    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
   920|         0|            0|            0|  0.00%|           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
   921|         0|            0|            0|  0.00%|           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
   922|         0|            0|            0|  0.00%|           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
   923|         0|            0|            0|  0.00%|           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
   924|         0|            0|            0|  0.00%|
   925|         0|            0|            0|  0.00%|    An example using a "vector" of letters:
   926|         0|            0|            0|  0.00%|
   927|         0|            0|            0|  0.00%|    >>> x = np.array(['a', 'b', 'c'], dtype=object)
   928|         0|            0|            0|  0.00%|    >>> np.outer(x, [1, 2, 3])
   929|         0|            0|            0|  0.00%|    array([['a', 'aa', 'aaa'],
   930|         0|            0|            0|  0.00%|           ['b', 'bb', 'bbb'],
   931|         0|            0|            0|  0.00%|           ['c', 'cc', 'ccc']], dtype=object)
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|    """
   934|         0|            0|            0|  0.00%|    a = asarray(a)
   935|         0|            0|            0|  0.00%|    b = asarray(b)
   936|         0|            0|            0|  0.00%|    return multiply(a.ravel()[:, newaxis], b.ravel()[newaxis, :], out)
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|
   939|     15020|    0.0163124|  1.08604e-06|  0.05%|def _tensordot_dispatcher(a, b, axes=None):
   940|     15020|    0.0402954|  2.68278e-06|  0.11%|    return (a, b)
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|
   943|     15020|    0.0613165|  4.08232e-06|  0.17%|@array_function_dispatch(_tensordot_dispatcher)
   944|         0|            0|            0|  0.00%|def tensordot(a, b, axes=2):
   945|         0|            0|            0|  0.00%|    """
   946|         0|            0|            0|  0.00%|    Compute tensor dot product along specified axes.
   947|         0|            0|            0|  0.00%|
   948|         0|            0|            0|  0.00%|    Given two tensors, `a` and `b`, and an array_like object containing
   949|         0|            0|            0|  0.00%|    two array_like objects, ``(a_axes, b_axes)``, sum the products of
   950|         0|            0|            0|  0.00%|    `a`'s and `b`'s elements (components) over the axes specified by
   951|         0|            0|            0|  0.00%|    ``a_axes`` and ``b_axes``. The third argument can be a single non-negative
   952|         0|            0|            0|  0.00%|    integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions
   953|         0|            0|            0|  0.00%|    of `a` and the first ``N`` dimensions of `b` are summed over.
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|    Parameters
   956|         0|            0|            0|  0.00%|    ----------
   957|         0|            0|            0|  0.00%|    a, b : array_like
   958|         0|            0|            0|  0.00%|        Tensors to "dot".
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|    axes : int or (2,) array_like
   961|         0|            0|            0|  0.00%|        * integer_like
   962|         0|            0|            0|  0.00%|          If an int N, sum over the last N axes of `a` and the first N axes
   963|         0|            0|            0|  0.00%|          of `b` in order. The sizes of the corresponding axes must match.
   964|         0|            0|            0|  0.00%|        * (2,) array_like
   965|         0|            0|            0|  0.00%|          Or, a list of axes to be summed over, first sequence applying to `a`,
   966|         0|            0|            0|  0.00%|          second to `b`. Both elements array_like must be of the same length.
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|    Returns
   969|         0|            0|            0|  0.00%|    -------
   970|         0|            0|            0|  0.00%|    output : ndarray
   971|         0|            0|            0|  0.00%|        The tensor dot product of the input.
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|    See Also
   974|         0|            0|            0|  0.00%|    --------
   975|         0|            0|            0|  0.00%|    dot, einsum
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|    Notes
   978|         0|            0|            0|  0.00%|    -----
   979|         0|            0|            0|  0.00%|    Three common use cases are:
   980|         0|            0|            0|  0.00%|        * ``axes = 0`` : tensor product :math:`a\\otimes b`
   981|         0|            0|            0|  0.00%|        * ``axes = 1`` : tensor dot product :math:`a\\cdot b`
   982|         0|            0|            0|  0.00%|        * ``axes = 2`` : (default) tensor double contraction :math:`a:b`
   983|         0|            0|            0|  0.00%|
   984|         0|            0|            0|  0.00%|    When `axes` is integer_like, the sequence for evaluation will be: first
   985|         0|            0|            0|  0.00%|    the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and
   986|         0|            0|            0|  0.00%|    Nth axis in `b` last.
   987|         0|            0|            0|  0.00%|
   988|         0|            0|            0|  0.00%|    When there is more than one axis to sum over - and they are not the last
   989|         0|            0|            0|  0.00%|    (first) axes of `a` (`b`) - the argument `axes` should consist of
   990|         0|            0|            0|  0.00%|    two sequences of the same length, with the first axis to sum over given
   991|         0|            0|            0|  0.00%|    first in both sequences, the second axis second, and so forth.
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    The shape of the result consists of the non-contracted axes of the
   994|         0|            0|            0|  0.00%|    first tensor, followed by the non-contracted axes of the second.
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|    Examples
   997|         0|            0|            0|  0.00%|    --------
   998|         0|            0|            0|  0.00%|    A "traditional" example:
   999|         0|            0|            0|  0.00%|
  1000|         0|            0|            0|  0.00%|    >>> a = np.arange(60.).reshape(3,4,5)
  1001|         0|            0|            0|  0.00%|    >>> b = np.arange(24.).reshape(4,3,2)
  1002|         0|            0|            0|  0.00%|    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
  1003|         0|            0|            0|  0.00%|    >>> c.shape
  1004|         0|            0|            0|  0.00%|    (5, 2)
  1005|         0|            0|            0|  0.00%|    >>> c
  1006|         0|            0|            0|  0.00%|    array([[4400., 4730.],
  1007|         0|            0|            0|  0.00%|           [4532., 4874.],
  1008|         0|            0|            0|  0.00%|           [4664., 5018.],
  1009|         0|            0|            0|  0.00%|           [4796., 5162.],
  1010|         0|            0|            0|  0.00%|           [4928., 5306.]])
  1011|         0|            0|            0|  0.00%|    >>> # A slower but equivalent way of computing the same...
  1012|         0|            0|            0|  0.00%|    >>> d = np.zeros((5,2))
  1013|         0|            0|            0|  0.00%|    >>> for i in range(5):
  1014|         0|            0|            0|  0.00%|    ...   for j in range(2):
  1015|         0|            0|            0|  0.00%|    ...     for k in range(3):
  1016|         0|            0|            0|  0.00%|    ...       for n in range(4):
  1017|         0|            0|            0|  0.00%|    ...         d[i,j] += a[k,n,i] * b[n,k,j]
  1018|         0|            0|            0|  0.00%|    >>> c == d
  1019|         0|            0|            0|  0.00%|    array([[ True,  True],
  1020|         0|            0|            0|  0.00%|           [ True,  True],
  1021|         0|            0|            0|  0.00%|           [ True,  True],
  1022|         0|            0|            0|  0.00%|           [ True,  True],
  1023|         0|            0|            0|  0.00%|           [ True,  True]])
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|    An extended example taking advantage of the overloading of + and \\*:
  1026|         0|            0|            0|  0.00%|
  1027|         0|            0|            0|  0.00%|    >>> a = np.array(range(1, 9))
  1028|         0|            0|            0|  0.00%|    >>> a.shape = (2, 2, 2)
  1029|         0|            0|            0|  0.00%|    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
  1030|         0|            0|            0|  0.00%|    >>> A.shape = (2, 2)
  1031|         0|            0|            0|  0.00%|    >>> a; A
  1032|         0|            0|            0|  0.00%|    array([[[1, 2],
  1033|         0|            0|            0|  0.00%|            [3, 4]],
  1034|         0|            0|            0|  0.00%|           [[5, 6],
  1035|         0|            0|            0|  0.00%|            [7, 8]]])
  1036|         0|            0|            0|  0.00%|    array([['a', 'b'],
  1037|         0|            0|            0|  0.00%|           ['c', 'd']], dtype=object)
  1038|         0|            0|            0|  0.00%|
  1039|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A) # third argument default is 2 for double-contraction
  1040|         0|            0|            0|  0.00%|    array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)
  1041|         0|            0|            0|  0.00%|
  1042|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, 1)
  1043|         0|            0|            0|  0.00%|    array([[['acc', 'bdd'],
  1044|         0|            0|            0|  0.00%|            ['aaacccc', 'bbbdddd']],
  1045|         0|            0|            0|  0.00%|           [['aaaaacccccc', 'bbbbbdddddd'],
  1046|         0|            0|            0|  0.00%|            ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)
  1047|         0|            0|            0|  0.00%|
  1048|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
  1049|         0|            0|            0|  0.00%|    array([[[[['a', 'b'],
  1050|         0|            0|            0|  0.00%|              ['c', 'd']],
  1051|         0|            0|            0|  0.00%|              ...
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, (0, 1))
  1054|         0|            0|            0|  0.00%|    array([[['abbbbb', 'cddddd'],
  1055|         0|            0|            0|  0.00%|            ['aabbbbbb', 'ccdddddd']],
  1056|         0|            0|            0|  0.00%|           [['aaabbbbbbb', 'cccddddddd'],
  1057|         0|            0|            0|  0.00%|            ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, (2, 1))
  1060|         0|            0|            0|  0.00%|    array([[['abb', 'cdd'],
  1061|         0|            0|            0|  0.00%|            ['aaabbbb', 'cccdddd']],
  1062|         0|            0|            0|  0.00%|           [['aaaaabbbbbb', 'cccccdddddd'],
  1063|         0|            0|            0|  0.00%|            ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)
  1064|         0|            0|            0|  0.00%|
  1065|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, ((0, 1), (0, 1)))
  1066|         0|            0|            0|  0.00%|    array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)
  1067|         0|            0|            0|  0.00%|
  1068|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, ((2, 1), (1, 0)))
  1069|         0|            0|            0|  0.00%|    array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    """
  1072|     15020|     0.069876|  4.65219e-06|  0.20%|    try:
  1073|     15020|     0.140197|  9.33401e-06|  0.40%|        iter(axes)
  1074|     15020|       0.1114|   7.4168e-06|  0.32%|    except Exception:
  1075|     15020|     0.113265|  7.54092e-06|  0.32%|        axes_a = list(range(-axes, 0))
  1076|     15020|     0.105132|  6.99949e-06|  0.30%|        axes_b = list(range(0, axes))
  1077|         0|            0|            0|  0.00%|    else:
  1078|         0|            0|            0|  0.00%|        axes_a, axes_b = axes
  1079|     15020|    0.0765734|  5.09809e-06|  0.22%|    try:
  1080|     15020|    0.0734274|  4.88864e-06|  0.21%|        na = len(axes_a)
  1081|     15020|    0.0753443|  5.01627e-06|  0.21%|        axes_a = list(axes_a)
  1082|         0|            0|            0|  0.00%|    except TypeError:
  1083|         0|            0|            0|  0.00%|        axes_a = [axes_a]
  1084|         0|            0|            0|  0.00%|        na = 1
  1085|     15020|    0.0671248|  4.46903e-06|  0.19%|    try:
  1086|     15020|    0.0541255|  3.60357e-06|  0.15%|        nb = len(axes_b)
  1087|     15020|    0.0698328|  4.64932e-06|  0.20%|        axes_b = list(axes_b)
  1088|         0|            0|            0|  0.00%|    except TypeError:
  1089|         0|            0|            0|  0.00%|        axes_b = [axes_b]
  1090|         0|            0|            0|  0.00%|        nb = 1
  1091|         0|            0|            0|  0.00%|
  1092|     15020|     0.078465|  5.22403e-06|  0.22%|    a, b = asarray(a), asarray(b)
  1093|     15020|    0.0752368|  5.00911e-06|  0.21%|    as_ = a.shape
  1094|     15020|    0.0726573|  4.83737e-06|  0.21%|    nda = a.ndim
  1095|     15020|    0.0746448|  4.96969e-06|  0.21%|    bs = b.shape
  1096|     15020|    0.0695026|  4.62734e-06|  0.20%|    ndb = b.ndim
  1097|     15020|    0.0574014|  3.82167e-06|  0.16%|    equal = True
  1098|     15020|    0.0607221|  4.04275e-06|  0.17%|    if na != nb:
  1099|         0|            0|            0|  0.00%|        equal = False
  1100|         0|            0|            0|  0.00%|    else:
  1101|     40050|     0.153313|  3.82803e-06|  0.44%|        for k in range(na):
  1102|     25030|     0.109515|  4.37537e-06|  0.31%|            if as_[axes_a[k]] != bs[axes_b[k]]:
  1103|         0|            0|            0|  0.00%|                equal = False
  1104|         0|            0|            0|  0.00%|                break
  1105|     25030|     0.105093|  4.19868e-06|  0.30%|            if axes_a[k] < 0:
  1106|     25030|    0.0987933|  3.94699e-06|  0.28%|                axes_a[k] += nda
  1107|     25030|    0.0983071|  3.92757e-06|  0.28%|            if axes_b[k] < 0:
  1108|         0|            0|            0|  0.00%|                axes_b[k] += ndb
  1109|     15020|    0.0707519|  4.71051e-06|  0.20%|    if not equal:
  1110|         0|            0|            0|  0.00%|        raise ValueError("shape-mismatch for sum")
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|    # Move the axes to sum over to the end of "a"
  1113|         0|            0|            0|  0.00%|    # and to the front of "b"
  1114|     80100|     0.285054|  3.55873e-06|  0.81%|    notin = [k for k in range(nda) if k not in axes_a]
(call)|     15020|     0.144386|  9.61292e-06|  0.41%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1114 <listcomp>
  1115|     15020|    0.0614102|  4.08856e-06|  0.17%|    newaxes_a = notin + axes_a
  1116|     15020|    0.0685828|   4.5661e-06|  0.20%|    N2 = 1
  1117|     40050|     0.155956|  3.89403e-06|  0.44%|    for axis in axes_a:
  1118|     25030|    0.0947928|  3.78717e-06|  0.27%|        N2 *= as_[axis]
  1119|     55070|     0.298928|  5.42814e-06|  0.85%|    newshape_a = (int(multiply.reduce([as_[ax] for ax in notin])), N2)
(call)|     15020|    0.0667772|  4.44589e-06|  0.19%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1119 <listcomp>
  1120|     55070|     0.221101|  4.01491e-06|  0.63%|    olda = [as_[axis] for axis in notin]
(call)|     15020|    0.0800185|  5.32746e-06|  0.23%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1120 <listcomp>
  1121|         0|            0|            0|  0.00%|
  1122|     80110|     0.262984|  3.28279e-06|  0.75%|    notin = [k for k in range(ndb) if k not in axes_b]
(call)|     15020|     0.129834|   8.6441e-06|  0.37%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1122 <listcomp>
  1123|     15020|     0.053354|   3.5522e-06|  0.15%|    newaxes_b = axes_b + notin
  1124|     15020|    0.0620718|  4.13261e-06|  0.18%|    N2 = 1
  1125|     40050|     0.130733|  3.26423e-06|  0.37%|    for axis in axes_b:
  1126|     25030|    0.0935545|  3.73769e-06|  0.27%|        N2 *= bs[axis]
  1127|     55080|     0.242574|  4.40403e-06|  0.69%|    newshape_b = (N2, int(multiply.reduce([bs[ax] for ax in notin])))
(call)|     15020|    0.0599644|   3.9923e-06|  0.17%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1127 <listcomp>
  1128|     55080|     0.228023|  4.13986e-06|  0.65%|    oldb = [bs[axis] for axis in notin]
(call)|     15020|      0.08447|  5.62384e-06|  0.24%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1128 <listcomp>
  1129|         0|            0|            0|  0.00%|
  1130|     15020|    0.0985279|  6.55978e-06|  0.28%|    at = a.transpose(newaxes_a).reshape(newshape_a)
  1131|     15020|    0.0697176|  4.64165e-06|  0.20%|    bt = b.transpose(newaxes_b).reshape(newshape_b)
  1132|     15020|     0.139138|  9.26355e-06|  0.40%|    res = dot(at, bt)
(call)|     15020|     0.347493|  2.31354e-05|  0.99%|# <__array_function__ internals>:177 dot
  1133|     15020|    0.0708759|  4.71877e-06|  0.20%|    return res.reshape(olda + oldb)
  1134|         0|            0|            0|  0.00%|
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|def _roll_dispatcher(a, shift, axis=None):
  1137|         0|            0|            0|  0.00%|    return (a,)
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|@array_function_dispatch(_roll_dispatcher)
  1141|         0|            0|            0|  0.00%|def roll(a, shift, axis=None):
  1142|         0|            0|            0|  0.00%|    """
  1143|         0|            0|            0|  0.00%|    Roll array elements along a given axis.
  1144|         0|            0|            0|  0.00%|
  1145|         0|            0|            0|  0.00%|    Elements that roll beyond the last position are re-introduced at
  1146|         0|            0|            0|  0.00%|    the first.
  1147|         0|            0|            0|  0.00%|
  1148|         0|            0|            0|  0.00%|    Parameters
  1149|         0|            0|            0|  0.00%|    ----------
  1150|         0|            0|            0|  0.00%|    a : array_like
  1151|         0|            0|            0|  0.00%|        Input array.
  1152|         0|            0|            0|  0.00%|    shift : int or tuple of ints
  1153|         0|            0|            0|  0.00%|        The number of places by which elements are shifted.  If a tuple,
  1154|         0|            0|            0|  0.00%|        then `axis` must be a tuple of the same size, and each of the
  1155|         0|            0|            0|  0.00%|        given axes is shifted by the corresponding number.  If an int
  1156|         0|            0|            0|  0.00%|        while `axis` is a tuple of ints, then the same value is used for
  1157|         0|            0|            0|  0.00%|        all given axes.
  1158|         0|            0|            0|  0.00%|    axis : int or tuple of ints, optional
  1159|         0|            0|            0|  0.00%|        Axis or axes along which elements are shifted.  By default, the
  1160|         0|            0|            0|  0.00%|        array is flattened before shifting, after which the original
  1161|         0|            0|            0|  0.00%|        shape is restored.
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|    Returns
  1164|         0|            0|            0|  0.00%|    -------
  1165|         0|            0|            0|  0.00%|    res : ndarray
  1166|         0|            0|            0|  0.00%|        Output array, with the same shape as `a`.
  1167|         0|            0|            0|  0.00%|
  1168|         0|            0|            0|  0.00%|    See Also
  1169|         0|            0|            0|  0.00%|    --------
  1170|         0|            0|            0|  0.00%|    rollaxis : Roll the specified axis backwards, until it lies in a
  1171|         0|            0|            0|  0.00%|               given position.
  1172|         0|            0|            0|  0.00%|
  1173|         0|            0|            0|  0.00%|    Notes
  1174|         0|            0|            0|  0.00%|    -----
  1175|         0|            0|            0|  0.00%|    .. versionadded:: 1.12.0
  1176|         0|            0|            0|  0.00%|
  1177|         0|            0|            0|  0.00%|    Supports rolling over multiple dimensions simultaneously.
  1178|         0|            0|            0|  0.00%|
  1179|         0|            0|            0|  0.00%|    Examples
  1180|         0|            0|            0|  0.00%|    --------
  1181|         0|            0|            0|  0.00%|    >>> x = np.arange(10)
  1182|         0|            0|            0|  0.00%|    >>> np.roll(x, 2)
  1183|         0|            0|            0|  0.00%|    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
  1184|         0|            0|            0|  0.00%|    >>> np.roll(x, -2)
  1185|         0|            0|            0|  0.00%|    array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])
  1186|         0|            0|            0|  0.00%|
  1187|         0|            0|            0|  0.00%|    >>> x2 = np.reshape(x, (2, 5))
  1188|         0|            0|            0|  0.00%|    >>> x2
  1189|         0|            0|            0|  0.00%|    array([[0, 1, 2, 3, 4],
  1190|         0|            0|            0|  0.00%|           [5, 6, 7, 8, 9]])
  1191|         0|            0|            0|  0.00%|    >>> np.roll(x2, 1)
  1192|         0|            0|            0|  0.00%|    array([[9, 0, 1, 2, 3],
  1193|         0|            0|            0|  0.00%|           [4, 5, 6, 7, 8]])
  1194|         0|            0|            0|  0.00%|    >>> np.roll(x2, -1)
  1195|         0|            0|            0|  0.00%|    array([[1, 2, 3, 4, 5],
  1196|         0|            0|            0|  0.00%|           [6, 7, 8, 9, 0]])
  1197|         0|            0|            0|  0.00%|    >>> np.roll(x2, 1, axis=0)
  1198|         0|            0|            0|  0.00%|    array([[5, 6, 7, 8, 9],
  1199|         0|            0|            0|  0.00%|           [0, 1, 2, 3, 4]])
  1200|         0|            0|            0|  0.00%|    >>> np.roll(x2, -1, axis=0)
  1201|         0|            0|            0|  0.00%|    array([[5, 6, 7, 8, 9],
  1202|         0|            0|            0|  0.00%|           [0, 1, 2, 3, 4]])
  1203|         0|            0|            0|  0.00%|    >>> np.roll(x2, 1, axis=1)
  1204|         0|            0|            0|  0.00%|    array([[4, 0, 1, 2, 3],
  1205|         0|            0|            0|  0.00%|           [9, 5, 6, 7, 8]])
  1206|         0|            0|            0|  0.00%|    >>> np.roll(x2, -1, axis=1)
  1207|         0|            0|            0|  0.00%|    array([[1, 2, 3, 4, 0],
  1208|         0|            0|            0|  0.00%|           [6, 7, 8, 9, 5]])
  1209|         0|            0|            0|  0.00%|    >>> np.roll(x2, (1, 1), axis=(1, 0))
  1210|         0|            0|            0|  0.00%|    array([[9, 5, 6, 7, 8],
  1211|         0|            0|            0|  0.00%|           [4, 0, 1, 2, 3]])
  1212|         0|            0|            0|  0.00%|    >>> np.roll(x2, (2, 1), axis=(1, 0))
  1213|         0|            0|            0|  0.00%|    array([[8, 9, 5, 6, 7],
  1214|         0|            0|            0|  0.00%|           [3, 4, 0, 1, 2]])
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|    """
  1217|         0|            0|            0|  0.00%|    a = asanyarray(a)
  1218|         0|            0|            0|  0.00%|    if axis is None:
  1219|         0|            0|            0|  0.00%|        return roll(a.ravel(), shift, 0).reshape(a.shape)
  1220|         0|            0|            0|  0.00%|
  1221|         0|            0|            0|  0.00%|    else:
  1222|         0|            0|            0|  0.00%|        axis = normalize_axis_tuple(axis, a.ndim, allow_duplicate=True)
  1223|         0|            0|            0|  0.00%|        broadcasted = broadcast(shift, axis)
  1224|         0|            0|            0|  0.00%|        if broadcasted.ndim > 1:
  1225|         0|            0|            0|  0.00%|            raise ValueError(
  1226|         0|            0|            0|  0.00%|                "'shift' and 'axis' should be scalars or 1D sequences")
  1227|         0|            0|            0|  0.00%|        shifts = {ax: 0 for ax in range(a.ndim)}
  1228|         0|            0|            0|  0.00%|        for sh, ax in broadcasted:
  1229|         0|            0|            0|  0.00%|            shifts[ax] += sh
  1230|         0|            0|            0|  0.00%|
  1231|         0|            0|            0|  0.00%|        rolls = [((slice(None), slice(None)),)] * a.ndim
  1232|         0|            0|            0|  0.00%|        for ax, offset in shifts.items():
  1233|         0|            0|            0|  0.00%|            offset %= a.shape[ax] or 1  # If `a` is empty, nothing matters.
  1234|         0|            0|            0|  0.00%|            if offset:
  1235|         0|            0|            0|  0.00%|                # (original, result), (original, result)
  1236|         0|            0|            0|  0.00%|                rolls[ax] = ((slice(None, -offset), slice(offset, None)),
  1237|         0|            0|            0|  0.00%|                             (slice(-offset, None), slice(None, offset)))
  1238|         0|            0|            0|  0.00%|
  1239|         0|            0|            0|  0.00%|        result = empty_like(a)
  1240|         0|            0|            0|  0.00%|        for indices in itertools.product(*rolls):
  1241|         0|            0|            0|  0.00%|            arr_index, res_index = zip(*indices)
  1242|         0|            0|            0|  0.00%|            result[res_index] = a[arr_index]
  1243|         0|            0|            0|  0.00%|
  1244|         0|            0|            0|  0.00%|        return result
  1245|         0|            0|            0|  0.00%|
  1246|         0|            0|            0|  0.00%|
  1247|         0|            0|            0|  0.00%|def _rollaxis_dispatcher(a, axis, start=None):
  1248|         0|            0|            0|  0.00%|    return (a,)
  1249|         0|            0|            0|  0.00%|
  1250|         0|            0|            0|  0.00%|
  1251|         0|            0|            0|  0.00%|@array_function_dispatch(_rollaxis_dispatcher)
  1252|         0|            0|            0|  0.00%|def rollaxis(a, axis, start=0):
  1253|         0|            0|            0|  0.00%|    """
  1254|         0|            0|            0|  0.00%|    Roll the specified axis backwards, until it lies in a given position.
  1255|         0|            0|            0|  0.00%|
  1256|         0|            0|            0|  0.00%|    This function continues to be supported for backward compatibility, but you
  1257|         0|            0|            0|  0.00%|    should prefer `moveaxis`. The `moveaxis` function was added in NumPy
  1258|         0|            0|            0|  0.00%|    1.11.
  1259|         0|            0|            0|  0.00%|
  1260|         0|            0|            0|  0.00%|    Parameters
  1261|         0|            0|            0|  0.00%|    ----------
  1262|         0|            0|            0|  0.00%|    a : ndarray
  1263|         0|            0|            0|  0.00%|        Input array.
  1264|         0|            0|            0|  0.00%|    axis : int
  1265|         0|            0|            0|  0.00%|        The axis to be rolled. The positions of the other axes do not
  1266|         0|            0|            0|  0.00%|        change relative to one another.
  1267|         0|            0|            0|  0.00%|    start : int, optional
  1268|         0|            0|            0|  0.00%|        When ``start <= axis``, the axis is rolled back until it lies in
  1269|         0|            0|            0|  0.00%|        this position. When ``start > axis``, the axis is rolled until it
  1270|         0|            0|            0|  0.00%|        lies before this position. The default, 0, results in a "complete"
  1271|         0|            0|            0|  0.00%|        roll. The following table describes how negative values of ``start``
  1272|         0|            0|            0|  0.00%|        are interpreted:
  1273|         0|            0|            0|  0.00%|
  1274|         0|            0|            0|  0.00%|        .. table::
  1275|         0|            0|            0|  0.00%|           :align: left
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1278|         0|            0|            0|  0.00%|           |     ``start``     | Normalized ``start`` |
  1279|         0|            0|            0|  0.00%|           +===================+======================+
  1280|         0|            0|            0|  0.00%|           | ``-(arr.ndim+1)`` | raise ``AxisError``  |
  1281|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1282|         0|            0|            0|  0.00%|           | ``-arr.ndim``     | 0                    |
  1283|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1284|         0|            0|            0|  0.00%|           | |vdots|           | |vdots|              |
  1285|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1286|         0|            0|            0|  0.00%|           | ``-1``            | ``arr.ndim-1``       |
  1287|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1288|         0|            0|            0|  0.00%|           | ``0``             | ``0``                |
  1289|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1290|         0|            0|            0|  0.00%|           | |vdots|           | |vdots|              |
  1291|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1292|         0|            0|            0|  0.00%|           | ``arr.ndim``      | ``arr.ndim``         |
  1293|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1294|         0|            0|            0|  0.00%|           | ``arr.ndim + 1``  | raise ``AxisError``  |
  1295|         0|            0|            0|  0.00%|           +-------------------+----------------------+
  1296|         0|            0|            0|  0.00%|
  1297|         0|            0|            0|  0.00%|        .. |vdots|   unicode:: U+22EE .. Vertical Ellipsis
  1298|         0|            0|            0|  0.00%|
  1299|         0|            0|            0|  0.00%|    Returns
  1300|         0|            0|            0|  0.00%|    -------
  1301|         0|            0|            0|  0.00%|    res : ndarray
  1302|         0|            0|            0|  0.00%|        For NumPy >= 1.10.0 a view of `a` is always returned. For earlier
  1303|         0|            0|            0|  0.00%|        NumPy versions a view of `a` is returned only if the order of the
  1304|         0|            0|            0|  0.00%|        axes is changed, otherwise the input array is returned.
  1305|         0|            0|            0|  0.00%|
  1306|         0|            0|            0|  0.00%|    See Also
  1307|         0|            0|            0|  0.00%|    --------
  1308|         0|            0|            0|  0.00%|    moveaxis : Move array axes to new positions.
  1309|         0|            0|            0|  0.00%|    roll : Roll the elements of an array by a number of positions along a
  1310|         0|            0|            0|  0.00%|        given axis.
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|    Examples
  1313|         0|            0|            0|  0.00%|    --------
  1314|         0|            0|            0|  0.00%|    >>> a = np.ones((3,4,5,6))
  1315|         0|            0|            0|  0.00%|    >>> np.rollaxis(a, 3, 1).shape
  1316|         0|            0|            0|  0.00%|    (3, 6, 4, 5)
  1317|         0|            0|            0|  0.00%|    >>> np.rollaxis(a, 2).shape
  1318|         0|            0|            0|  0.00%|    (5, 3, 4, 6)
  1319|         0|            0|            0|  0.00%|    >>> np.rollaxis(a, 1, 4).shape
  1320|         0|            0|            0|  0.00%|    (3, 5, 6, 4)
  1321|         0|            0|            0|  0.00%|
  1322|         0|            0|            0|  0.00%|    """
  1323|         0|            0|            0|  0.00%|    n = a.ndim
  1324|         0|            0|            0|  0.00%|    axis = normalize_axis_index(axis, n)
  1325|         0|            0|            0|  0.00%|    if start < 0:
  1326|         0|            0|            0|  0.00%|        start += n
  1327|         0|            0|            0|  0.00%|    msg = "'%s' arg requires %d <= %s < %d, but %d was passed in"
  1328|         0|            0|            0|  0.00%|    if not (0 <= start < n + 1):
  1329|         0|            0|            0|  0.00%|        raise AxisError(msg % ('start', -n, 'start', n + 1, start))
  1330|         0|            0|            0|  0.00%|    if axis < start:
  1331|         0|            0|            0|  0.00%|        # it's been removed
  1332|         0|            0|            0|  0.00%|        start -= 1
  1333|         0|            0|            0|  0.00%|    if axis == start:
  1334|         0|            0|            0|  0.00%|        return a[...]
  1335|         0|            0|            0|  0.00%|    axes = list(range(0, n))
  1336|         0|            0|            0|  0.00%|    axes.remove(axis)
  1337|         0|            0|            0|  0.00%|    axes.insert(start, axis)
  1338|         0|            0|            0|  0.00%|    return a.transpose(axes)
  1339|         0|            0|            0|  0.00%|
  1340|         0|            0|            0|  0.00%|
  1341|         0|            0|            0|  0.00%|def normalize_axis_tuple(axis, ndim, argname=None, allow_duplicate=False):
  1342|         0|            0|            0|  0.00%|    """
  1343|         0|            0|            0|  0.00%|    Normalizes an axis argument into a tuple of non-negative integer axes.
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|    This handles shorthands such as ``1`` and converts them to ``(1,)``,
  1346|         0|            0|            0|  0.00%|    as well as performing the handling of negative indices covered by
  1347|         0|            0|            0|  0.00%|    `normalize_axis_index`.
  1348|         0|            0|            0|  0.00%|
  1349|         0|            0|            0|  0.00%|    By default, this forbids axes from being specified multiple times.
  1350|         0|            0|            0|  0.00%|
  1351|         0|            0|            0|  0.00%|    Used internally by multi-axis-checking logic.
  1352|         0|            0|            0|  0.00%|
  1353|         0|            0|            0|  0.00%|    .. versionadded:: 1.13.0
  1354|         0|            0|            0|  0.00%|
  1355|         0|            0|            0|  0.00%|    Parameters
  1356|         0|            0|            0|  0.00%|    ----------
  1357|         0|            0|            0|  0.00%|    axis : int, iterable of int
  1358|         0|            0|            0|  0.00%|        The un-normalized index or indices of the axis.
  1359|         0|            0|            0|  0.00%|    ndim : int
  1360|         0|            0|            0|  0.00%|        The number of dimensions of the array that `axis` should be normalized
  1361|         0|            0|            0|  0.00%|        against.
  1362|         0|            0|            0|  0.00%|    argname : str, optional
  1363|         0|            0|            0|  0.00%|        A prefix to put before the error message, typically the name of the
  1364|         0|            0|            0|  0.00%|        argument.
  1365|         0|            0|            0|  0.00%|    allow_duplicate : bool, optional
  1366|         0|            0|            0|  0.00%|        If False, the default, disallow an axis from being specified twice.
  1367|         0|            0|            0|  0.00%|
  1368|         0|            0|            0|  0.00%|    Returns
  1369|         0|            0|            0|  0.00%|    -------
  1370|         0|            0|            0|  0.00%|    normalized_axes : tuple of int
  1371|         0|            0|            0|  0.00%|        The normalized axis index, such that `0 <= normalized_axis < ndim`
  1372|         0|            0|            0|  0.00%|
  1373|         0|            0|            0|  0.00%|    Raises
  1374|         0|            0|            0|  0.00%|    ------
  1375|         0|            0|            0|  0.00%|    AxisError
  1376|         0|            0|            0|  0.00%|        If any axis provided is out of range
  1377|         0|            0|            0|  0.00%|    ValueError
  1378|         0|            0|            0|  0.00%|        If an axis is repeated
  1379|         0|            0|            0|  0.00%|
  1380|         0|            0|            0|  0.00%|    See also
  1381|         0|            0|            0|  0.00%|    --------
  1382|         0|            0|            0|  0.00%|    normalize_axis_index : normalizing a single scalar axis
  1383|         0|            0|            0|  0.00%|    """
  1384|         0|            0|            0|  0.00%|    # Optimization to speed-up the most common cases.
  1385|         0|            0|            0|  0.00%|    if type(axis) not in (tuple, list):
  1386|         0|            0|            0|  0.00%|        try:
  1387|         0|            0|            0|  0.00%|            axis = [operator.index(axis)]
  1388|         0|            0|            0|  0.00%|        except TypeError:
  1389|         0|            0|            0|  0.00%|            pass
  1390|         0|            0|            0|  0.00%|    # Going via an iterator directly is slower than via list comprehension.
  1391|         0|            0|            0|  0.00%|    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])
  1392|         0|            0|            0|  0.00%|    if not allow_duplicate and len(set(axis)) != len(axis):
  1393|         0|            0|            0|  0.00%|        if argname:
  1394|         0|            0|            0|  0.00%|            raise ValueError('repeated axis in `{}` argument'.format(argname))
  1395|         0|            0|            0|  0.00%|        else:
  1396|         0|            0|            0|  0.00%|            raise ValueError('repeated axis')
  1397|         0|            0|            0|  0.00%|    return axis
  1398|         0|            0|            0|  0.00%|
  1399|         0|            0|            0|  0.00%|
  1400|         0|            0|            0|  0.00%|def _moveaxis_dispatcher(a, source, destination):
  1401|         0|            0|            0|  0.00%|    return (a,)
  1402|         0|            0|            0|  0.00%|
  1403|         0|            0|            0|  0.00%|
  1404|         0|            0|            0|  0.00%|@array_function_dispatch(_moveaxis_dispatcher)
  1405|         0|            0|            0|  0.00%|def moveaxis(a, source, destination):
  1406|         0|            0|            0|  0.00%|    """
  1407|         0|            0|            0|  0.00%|    Move axes of an array to new positions.
  1408|         0|            0|            0|  0.00%|
  1409|         0|            0|            0|  0.00%|    Other axes remain in their original order.
  1410|         0|            0|            0|  0.00%|
  1411|         0|            0|            0|  0.00%|    .. versionadded:: 1.11.0
  1412|         0|            0|            0|  0.00%|
  1413|         0|            0|            0|  0.00%|    Parameters
  1414|         0|            0|            0|  0.00%|    ----------
  1415|         0|            0|            0|  0.00%|    a : np.ndarray
  1416|         0|            0|            0|  0.00%|        The array whose axes should be reordered.
  1417|         0|            0|            0|  0.00%|    source : int or sequence of int
  1418|         0|            0|            0|  0.00%|        Original positions of the axes to move. These must be unique.
  1419|         0|            0|            0|  0.00%|    destination : int or sequence of int
  1420|         0|            0|            0|  0.00%|        Destination positions for each of the original axes. These must also be
  1421|         0|            0|            0|  0.00%|        unique.
  1422|         0|            0|            0|  0.00%|
  1423|         0|            0|            0|  0.00%|    Returns
  1424|         0|            0|            0|  0.00%|    -------
  1425|         0|            0|            0|  0.00%|    result : np.ndarray
  1426|         0|            0|            0|  0.00%|        Array with moved axes. This array is a view of the input array.
  1427|         0|            0|            0|  0.00%|
  1428|         0|            0|            0|  0.00%|    See Also
  1429|         0|            0|            0|  0.00%|    --------
  1430|         0|            0|            0|  0.00%|    transpose : Permute the dimensions of an array.
  1431|         0|            0|            0|  0.00%|    swapaxes : Interchange two axes of an array.
  1432|         0|            0|            0|  0.00%|
  1433|         0|            0|            0|  0.00%|    Examples
  1434|         0|            0|            0|  0.00%|    --------
  1435|         0|            0|            0|  0.00%|    >>> x = np.zeros((3, 4, 5))
  1436|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, 0, -1).shape
  1437|         0|            0|            0|  0.00%|    (4, 5, 3)
  1438|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, -1, 0).shape
  1439|         0|            0|            0|  0.00%|    (5, 3, 4)
  1440|         0|            0|            0|  0.00%|
  1441|         0|            0|            0|  0.00%|    These all achieve the same result:
  1442|         0|            0|            0|  0.00%|
  1443|         0|            0|            0|  0.00%|    >>> np.transpose(x).shape
  1444|         0|            0|            0|  0.00%|    (5, 4, 3)
  1445|         0|            0|            0|  0.00%|    >>> np.swapaxes(x, 0, -1).shape
  1446|         0|            0|            0|  0.00%|    (5, 4, 3)
  1447|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, [0, 1], [-1, -2]).shape
  1448|         0|            0|            0|  0.00%|    (5, 4, 3)
  1449|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
  1450|         0|            0|            0|  0.00%|    (5, 4, 3)
  1451|         0|            0|            0|  0.00%|
  1452|         0|            0|            0|  0.00%|    """
  1453|         0|            0|            0|  0.00%|    try:
  1454|         0|            0|            0|  0.00%|        # allow duck-array types if they define transpose
  1455|         0|            0|            0|  0.00%|        transpose = a.transpose
  1456|         0|            0|            0|  0.00%|    except AttributeError:
  1457|         0|            0|            0|  0.00%|        a = asarray(a)
  1458|         0|            0|            0|  0.00%|        transpose = a.transpose
  1459|         0|            0|            0|  0.00%|
  1460|         0|            0|            0|  0.00%|    source = normalize_axis_tuple(source, a.ndim, 'source')
  1461|         0|            0|            0|  0.00%|    destination = normalize_axis_tuple(destination, a.ndim, 'destination')
  1462|         0|            0|            0|  0.00%|    if len(source) != len(destination):
  1463|         0|            0|            0|  0.00%|        raise ValueError('`source` and `destination` arguments must have '
  1464|         0|            0|            0|  0.00%|                         'the same number of elements')
  1465|         0|            0|            0|  0.00%|
  1466|         0|            0|            0|  0.00%|    order = [n for n in range(a.ndim) if n not in source]
  1467|         0|            0|            0|  0.00%|
  1468|         0|            0|            0|  0.00%|    for dest, src in sorted(zip(destination, source)):
  1469|         0|            0|            0|  0.00%|        order.insert(dest, src)
  1470|         0|            0|            0|  0.00%|
  1471|         0|            0|            0|  0.00%|    result = transpose(order)
  1472|         0|            0|            0|  0.00%|    return result
  1473|         0|            0|            0|  0.00%|
  1474|         0|            0|            0|  0.00%|
  1475|         0|            0|            0|  0.00%|def _cross_dispatcher(a, b, axisa=None, axisb=None, axisc=None, axis=None):
  1476|         0|            0|            0|  0.00%|    return (a, b)
  1477|         0|            0|            0|  0.00%|
  1478|         0|            0|            0|  0.00%|
  1479|         0|            0|            0|  0.00%|@array_function_dispatch(_cross_dispatcher)
  1480|         0|            0|            0|  0.00%|def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):
  1481|         0|            0|            0|  0.00%|    """
  1482|         0|            0|            0|  0.00%|    Return the cross product of two (arrays of) vectors.
  1483|         0|            0|            0|  0.00%|
  1484|         0|            0|            0|  0.00%|    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
  1485|         0|            0|            0|  0.00%|    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
  1486|         0|            0|            0|  0.00%|    are defined by the last axis of `a` and `b` by default, and these axes
  1487|         0|            0|            0|  0.00%|    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
  1488|         0|            0|            0|  0.00%|    2, the third component of the input vector is assumed to be zero and the
  1489|         0|            0|            0|  0.00%|    cross product calculated accordingly.  In cases where both input vectors
  1490|         0|            0|            0|  0.00%|    have dimension 2, the z-component of the cross product is returned.
  1491|         0|            0|            0|  0.00%|
  1492|         0|            0|            0|  0.00%|    Parameters
  1493|         0|            0|            0|  0.00%|    ----------
  1494|         0|            0|            0|  0.00%|    a : array_like
  1495|         0|            0|            0|  0.00%|        Components of the first vector(s).
  1496|         0|            0|            0|  0.00%|    b : array_like
  1497|         0|            0|            0|  0.00%|        Components of the second vector(s).
  1498|         0|            0|            0|  0.00%|    axisa : int, optional
  1499|         0|            0|            0|  0.00%|        Axis of `a` that defines the vector(s).  By default, the last axis.
  1500|         0|            0|            0|  0.00%|    axisb : int, optional
  1501|         0|            0|            0|  0.00%|        Axis of `b` that defines the vector(s).  By default, the last axis.
  1502|         0|            0|            0|  0.00%|    axisc : int, optional
  1503|         0|            0|            0|  0.00%|        Axis of `c` containing the cross product vector(s).  Ignored if
  1504|         0|            0|            0|  0.00%|        both input vectors have dimension 2, as the return is scalar.
  1505|         0|            0|            0|  0.00%|        By default, the last axis.
  1506|         0|            0|            0|  0.00%|    axis : int, optional
  1507|         0|            0|            0|  0.00%|        If defined, the axis of `a`, `b` and `c` that defines the vector(s)
  1508|         0|            0|            0|  0.00%|        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.
  1509|         0|            0|            0|  0.00%|
  1510|         0|            0|            0|  0.00%|    Returns
  1511|         0|            0|            0|  0.00%|    -------
  1512|         0|            0|            0|  0.00%|    c : ndarray
  1513|         0|            0|            0|  0.00%|        Vector cross product(s).
  1514|         0|            0|            0|  0.00%|
  1515|         0|            0|            0|  0.00%|    Raises
  1516|         0|            0|            0|  0.00%|    ------
  1517|         0|            0|            0|  0.00%|    ValueError
  1518|         0|            0|            0|  0.00%|        When the dimension of the vector(s) in `a` and/or `b` does not
  1519|         0|            0|            0|  0.00%|        equal 2 or 3.
  1520|         0|            0|            0|  0.00%|
  1521|         0|            0|            0|  0.00%|    See Also
  1522|         0|            0|            0|  0.00%|    --------
  1523|         0|            0|            0|  0.00%|    inner : Inner product
  1524|         0|            0|            0|  0.00%|    outer : Outer product.
  1525|         0|            0|            0|  0.00%|    ix_ : Construct index arrays.
  1526|         0|            0|            0|  0.00%|
  1527|         0|            0|            0|  0.00%|    Notes
  1528|         0|            0|            0|  0.00%|    -----
  1529|         0|            0|            0|  0.00%|    .. versionadded:: 1.9.0
  1530|         0|            0|            0|  0.00%|
  1531|         0|            0|            0|  0.00%|    Supports full broadcasting of the inputs.
  1532|         0|            0|            0|  0.00%|
  1533|         0|            0|            0|  0.00%|    Examples
  1534|         0|            0|            0|  0.00%|    --------
  1535|         0|            0|            0|  0.00%|    Vector cross-product.
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|    >>> x = [1, 2, 3]
  1538|         0|            0|            0|  0.00%|    >>> y = [4, 5, 6]
  1539|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1540|         0|            0|            0|  0.00%|    array([-3,  6, -3])
  1541|         0|            0|            0|  0.00%|
  1542|         0|            0|            0|  0.00%|    One vector with dimension 2.
  1543|         0|            0|            0|  0.00%|
  1544|         0|            0|            0|  0.00%|    >>> x = [1, 2]
  1545|         0|            0|            0|  0.00%|    >>> y = [4, 5, 6]
  1546|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1547|         0|            0|            0|  0.00%|    array([12, -6, -3])
  1548|         0|            0|            0|  0.00%|
  1549|         0|            0|            0|  0.00%|    Equivalently:
  1550|         0|            0|            0|  0.00%|
  1551|         0|            0|            0|  0.00%|    >>> x = [1, 2, 0]
  1552|         0|            0|            0|  0.00%|    >>> y = [4, 5, 6]
  1553|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1554|         0|            0|            0|  0.00%|    array([12, -6, -3])
  1555|         0|            0|            0|  0.00%|
  1556|         0|            0|            0|  0.00%|    Both vectors with dimension 2.
  1557|         0|            0|            0|  0.00%|
  1558|         0|            0|            0|  0.00%|    >>> x = [1,2]
  1559|         0|            0|            0|  0.00%|    >>> y = [4,5]
  1560|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1561|         0|            0|            0|  0.00%|    array(-3)
  1562|         0|            0|            0|  0.00%|
  1563|         0|            0|            0|  0.00%|    Multiple vector cross-products. Note that the direction of the cross
  1564|         0|            0|            0|  0.00%|    product vector is defined by the `right-hand rule`.
  1565|         0|            0|            0|  0.00%|
  1566|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2,3], [4,5,6]])
  1567|         0|            0|            0|  0.00%|    >>> y = np.array([[4,5,6], [1,2,3]])
  1568|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1569|         0|            0|            0|  0.00%|    array([[-3,  6, -3],
  1570|         0|            0|            0|  0.00%|           [ 3, -6,  3]])
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|    The orientation of `c` can be changed using the `axisc` keyword.
  1573|         0|            0|            0|  0.00%|
  1574|         0|            0|            0|  0.00%|    >>> np.cross(x, y, axisc=0)
  1575|         0|            0|            0|  0.00%|    array([[-3,  3],
  1576|         0|            0|            0|  0.00%|           [ 6, -6],
  1577|         0|            0|            0|  0.00%|           [-3,  3]])
  1578|         0|            0|            0|  0.00%|
  1579|         0|            0|            0|  0.00%|    Change the vector definition of `x` and `y` using `axisa` and `axisb`.
  1580|         0|            0|            0|  0.00%|
  1581|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
  1582|         0|            0|            0|  0.00%|    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
  1583|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1584|         0|            0|            0|  0.00%|    array([[ -6,  12,  -6],
  1585|         0|            0|            0|  0.00%|           [  0,   0,   0],
  1586|         0|            0|            0|  0.00%|           [  6, -12,   6]])
  1587|         0|            0|            0|  0.00%|    >>> np.cross(x, y, axisa=0, axisb=0)
  1588|         0|            0|            0|  0.00%|    array([[-24,  48, -24],
  1589|         0|            0|            0|  0.00%|           [-30,  60, -30],
  1590|         0|            0|            0|  0.00%|           [-36,  72, -36]])
  1591|         0|            0|            0|  0.00%|
  1592|         0|            0|            0|  0.00%|    """
  1593|         0|            0|            0|  0.00%|    if axis is not None:
  1594|         0|            0|            0|  0.00%|        axisa, axisb, axisc = (axis,) * 3
  1595|         0|            0|            0|  0.00%|    a = asarray(a)
  1596|         0|            0|            0|  0.00%|    b = asarray(b)
  1597|         0|            0|            0|  0.00%|    # Check axisa and axisb are within bounds
  1598|         0|            0|            0|  0.00%|    axisa = normalize_axis_index(axisa, a.ndim, msg_prefix='axisa')
  1599|         0|            0|            0|  0.00%|    axisb = normalize_axis_index(axisb, b.ndim, msg_prefix='axisb')
  1600|         0|            0|            0|  0.00%|
  1601|         0|            0|            0|  0.00%|    # Move working axis to the end of the shape
  1602|         0|            0|            0|  0.00%|    a = moveaxis(a, axisa, -1)
  1603|         0|            0|            0|  0.00%|    b = moveaxis(b, axisb, -1)
  1604|         0|            0|            0|  0.00%|    msg = ("incompatible dimensions for cross product\n"
  1605|         0|            0|            0|  0.00%|           "(dimension must be 2 or 3)")
  1606|         0|            0|            0|  0.00%|    if a.shape[-1] not in (2, 3) or b.shape[-1] not in (2, 3):
  1607|         0|            0|            0|  0.00%|        raise ValueError(msg)
  1608|         0|            0|            0|  0.00%|
  1609|         0|            0|            0|  0.00%|    # Create the output array
  1610|         0|            0|            0|  0.00%|    shape = broadcast(a[..., 0], b[..., 0]).shape
  1611|         0|            0|            0|  0.00%|    if a.shape[-1] == 3 or b.shape[-1] == 3:
  1612|         0|            0|            0|  0.00%|        shape += (3,)
  1613|         0|            0|            0|  0.00%|        # Check axisc is within bounds
  1614|         0|            0|            0|  0.00%|        axisc = normalize_axis_index(axisc, len(shape), msg_prefix='axisc')
  1615|         0|            0|            0|  0.00%|    dtype = promote_types(a.dtype, b.dtype)
  1616|         0|            0|            0|  0.00%|    cp = empty(shape, dtype)
  1617|         0|            0|            0|  0.00%|
  1618|         0|            0|            0|  0.00%|    # create local aliases for readability
  1619|         0|            0|            0|  0.00%|    a0 = a[..., 0]
  1620|         0|            0|            0|  0.00%|    a1 = a[..., 1]
  1621|         0|            0|            0|  0.00%|    if a.shape[-1] == 3:
  1622|         0|            0|            0|  0.00%|        a2 = a[..., 2]
  1623|         0|            0|            0|  0.00%|    b0 = b[..., 0]
  1624|         0|            0|            0|  0.00%|    b1 = b[..., 1]
  1625|         0|            0|            0|  0.00%|    if b.shape[-1] == 3:
  1626|         0|            0|            0|  0.00%|        b2 = b[..., 2]
  1627|         0|            0|            0|  0.00%|    if cp.ndim != 0 and cp.shape[-1] == 3:
  1628|         0|            0|            0|  0.00%|        cp0 = cp[..., 0]
  1629|         0|            0|            0|  0.00%|        cp1 = cp[..., 1]
  1630|         0|            0|            0|  0.00%|        cp2 = cp[..., 2]
  1631|         0|            0|            0|  0.00%|
  1632|         0|            0|            0|  0.00%|    if a.shape[-1] == 2:
  1633|         0|            0|            0|  0.00%|        if b.shape[-1] == 2:
  1634|         0|            0|            0|  0.00%|            # a0 * b1 - a1 * b0
  1635|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp)
  1636|         0|            0|            0|  0.00%|            cp -= a1 * b0
  1637|         0|            0|            0|  0.00%|            return cp
  1638|         0|            0|            0|  0.00%|        else:
  1639|         0|            0|            0|  0.00%|            assert b.shape[-1] == 3
  1640|         0|            0|            0|  0.00%|            # cp0 = a1 * b2 - 0  (a2 = 0)
  1641|         0|            0|            0|  0.00%|            # cp1 = 0 - a0 * b2  (a2 = 0)
  1642|         0|            0|            0|  0.00%|            # cp2 = a0 * b1 - a1 * b0
  1643|         0|            0|            0|  0.00%|            multiply(a1, b2, out=cp0)
  1644|         0|            0|            0|  0.00%|            multiply(a0, b2, out=cp1)
  1645|         0|            0|            0|  0.00%|            negative(cp1, out=cp1)
  1646|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp2)
  1647|         0|            0|            0|  0.00%|            cp2 -= a1 * b0
  1648|         0|            0|            0|  0.00%|    else:
  1649|         0|            0|            0|  0.00%|        assert a.shape[-1] == 3
  1650|         0|            0|            0|  0.00%|        if b.shape[-1] == 3:
  1651|         0|            0|            0|  0.00%|            # cp0 = a1 * b2 - a2 * b1
  1652|         0|            0|            0|  0.00%|            # cp1 = a2 * b0 - a0 * b2
  1653|         0|            0|            0|  0.00%|            # cp2 = a0 * b1 - a1 * b0
  1654|         0|            0|            0|  0.00%|            multiply(a1, b2, out=cp0)
  1655|         0|            0|            0|  0.00%|            tmp = array(a2 * b1)
  1656|         0|            0|            0|  0.00%|            cp0 -= tmp
  1657|         0|            0|            0|  0.00%|            multiply(a2, b0, out=cp1)
  1658|         0|            0|            0|  0.00%|            multiply(a0, b2, out=tmp)
  1659|         0|            0|            0|  0.00%|            cp1 -= tmp
  1660|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp2)
  1661|         0|            0|            0|  0.00%|            multiply(a1, b0, out=tmp)
  1662|         0|            0|            0|  0.00%|            cp2 -= tmp
  1663|         0|            0|            0|  0.00%|        else:
  1664|         0|            0|            0|  0.00%|            assert b.shape[-1] == 2
  1665|         0|            0|            0|  0.00%|            # cp0 = 0 - a2 * b1  (b2 = 0)
  1666|         0|            0|            0|  0.00%|            # cp1 = a2 * b0 - 0  (b2 = 0)
  1667|         0|            0|            0|  0.00%|            # cp2 = a0 * b1 - a1 * b0
  1668|         0|            0|            0|  0.00%|            multiply(a2, b1, out=cp0)
  1669|         0|            0|            0|  0.00%|            negative(cp0, out=cp0)
  1670|         0|            0|            0|  0.00%|            multiply(a2, b0, out=cp1)
  1671|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp2)
  1672|         0|            0|            0|  0.00%|            cp2 -= a1 * b0
  1673|         0|            0|            0|  0.00%|
  1674|         0|            0|            0|  0.00%|    return moveaxis(cp, -1, axisc)
  1675|         0|            0|            0|  0.00%|
  1676|         0|            0|            0|  0.00%|
  1677|         0|            0|            0|  0.00%|little_endian = (sys.byteorder == 'little')
  1678|         0|            0|            0|  0.00%|
  1679|         0|            0|            0|  0.00%|
  1680|         0|            0|            0|  0.00%|@set_module('numpy')
  1681|         0|            0|            0|  0.00%|def indices(dimensions, dtype=int, sparse=False):
  1682|         0|            0|            0|  0.00%|    """
  1683|         0|            0|            0|  0.00%|    Return an array representing the indices of a grid.
  1684|         0|            0|            0|  0.00%|
  1685|         0|            0|            0|  0.00%|    Compute an array where the subarrays contain index values 0, 1, ...
  1686|         0|            0|            0|  0.00%|    varying only along the corresponding axis.
  1687|         0|            0|            0|  0.00%|
  1688|         0|            0|            0|  0.00%|    Parameters
  1689|         0|            0|            0|  0.00%|    ----------
  1690|         0|            0|            0|  0.00%|    dimensions : sequence of ints
  1691|         0|            0|            0|  0.00%|        The shape of the grid.
  1692|         0|            0|            0|  0.00%|    dtype : dtype, optional
  1693|         0|            0|            0|  0.00%|        Data type of the result.
  1694|         0|            0|            0|  0.00%|    sparse : boolean, optional
  1695|         0|            0|            0|  0.00%|        Return a sparse representation of the grid instead of a dense
  1696|         0|            0|            0|  0.00%|        representation. Default is False.
  1697|         0|            0|            0|  0.00%|
  1698|         0|            0|            0|  0.00%|        .. versionadded:: 1.17
  1699|         0|            0|            0|  0.00%|
  1700|         0|            0|            0|  0.00%|    Returns
  1701|         0|            0|            0|  0.00%|    -------
  1702|         0|            0|            0|  0.00%|    grid : one ndarray or tuple of ndarrays
  1703|         0|            0|            0|  0.00%|        If sparse is False:
  1704|         0|            0|            0|  0.00%|            Returns one array of grid indices,
  1705|         0|            0|            0|  0.00%|            ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
  1706|         0|            0|            0|  0.00%|        If sparse is True:
  1707|         0|            0|            0|  0.00%|            Returns a tuple of arrays, with
  1708|         0|            0|            0|  0.00%|            ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
  1709|         0|            0|            0|  0.00%|            dimensions[i] in the ith place
  1710|         0|            0|            0|  0.00%|
  1711|         0|            0|            0|  0.00%|    See Also
  1712|         0|            0|            0|  0.00%|    --------
  1713|         0|            0|            0|  0.00%|    mgrid, ogrid, meshgrid
  1714|         0|            0|            0|  0.00%|
  1715|         0|            0|            0|  0.00%|    Notes
  1716|         0|            0|            0|  0.00%|    -----
  1717|         0|            0|            0|  0.00%|    The output shape in the dense case is obtained by prepending the number
  1718|         0|            0|            0|  0.00%|    of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
  1719|         0|            0|            0|  0.00%|    is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
  1720|         0|            0|            0|  0.00%|    ``(N, r0, ..., rN-1)``.
  1721|         0|            0|            0|  0.00%|
  1722|         0|            0|            0|  0.00%|    The subarrays ``grid[k]`` contains the N-D array of indices along the
  1723|         0|            0|            0|  0.00%|    ``k-th`` axis. Explicitly::
  1724|         0|            0|            0|  0.00%|
  1725|         0|            0|            0|  0.00%|        grid[k, i0, i1, ..., iN-1] = ik
  1726|         0|            0|            0|  0.00%|
  1727|         0|            0|            0|  0.00%|    Examples
  1728|         0|            0|            0|  0.00%|    --------
  1729|         0|            0|            0|  0.00%|    >>> grid = np.indices((2, 3))
  1730|         0|            0|            0|  0.00%|    >>> grid.shape
  1731|         0|            0|            0|  0.00%|    (2, 2, 3)
  1732|         0|            0|            0|  0.00%|    >>> grid[0]        # row indices
  1733|         0|            0|            0|  0.00%|    array([[0, 0, 0],
  1734|         0|            0|            0|  0.00%|           [1, 1, 1]])
  1735|         0|            0|            0|  0.00%|    >>> grid[1]        # column indices
  1736|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1737|         0|            0|            0|  0.00%|           [0, 1, 2]])
  1738|         0|            0|            0|  0.00%|
  1739|         0|            0|            0|  0.00%|    The indices can be used as an index into an array.
  1740|         0|            0|            0|  0.00%|
  1741|         0|            0|            0|  0.00%|    >>> x = np.arange(20).reshape(5, 4)
  1742|         0|            0|            0|  0.00%|    >>> row, col = np.indices((2, 3))
  1743|         0|            0|            0|  0.00%|    >>> x[row, col]
  1744|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1745|         0|            0|            0|  0.00%|           [4, 5, 6]])
  1746|         0|            0|            0|  0.00%|
  1747|         0|            0|            0|  0.00%|    Note that it would be more straightforward in the above example to
  1748|         0|            0|            0|  0.00%|    extract the required elements directly with ``x[:2, :3]``.
  1749|         0|            0|            0|  0.00%|
  1750|         0|            0|            0|  0.00%|    If sparse is set to true, the grid will be returned in a sparse
  1751|         0|            0|            0|  0.00%|    representation.
  1752|         0|            0|            0|  0.00%|
  1753|         0|            0|            0|  0.00%|    >>> i, j = np.indices((2, 3), sparse=True)
  1754|         0|            0|            0|  0.00%|    >>> i.shape
  1755|         0|            0|            0|  0.00%|    (2, 1)
  1756|         0|            0|            0|  0.00%|    >>> j.shape
  1757|         0|            0|            0|  0.00%|    (1, 3)
  1758|         0|            0|            0|  0.00%|    >>> i        # row indices
  1759|         0|            0|            0|  0.00%|    array([[0],
  1760|         0|            0|            0|  0.00%|           [1]])
  1761|         0|            0|            0|  0.00%|    >>> j        # column indices
  1762|         0|            0|            0|  0.00%|    array([[0, 1, 2]])
  1763|         0|            0|            0|  0.00%|
  1764|         0|            0|            0|  0.00%|    """
  1765|         0|            0|            0|  0.00%|    dimensions = tuple(dimensions)
  1766|         0|            0|            0|  0.00%|    N = len(dimensions)
  1767|         0|            0|            0|  0.00%|    shape = (1,)*N
  1768|         0|            0|            0|  0.00%|    if sparse:
  1769|         0|            0|            0|  0.00%|        res = tuple()
  1770|         0|            0|            0|  0.00%|    else:
  1771|         0|            0|            0|  0.00%|        res = empty((N,)+dimensions, dtype=dtype)
  1772|         0|            0|            0|  0.00%|    for i, dim in enumerate(dimensions):
  1773|         0|            0|            0|  0.00%|        idx = arange(dim, dtype=dtype).reshape(
  1774|         0|            0|            0|  0.00%|            shape[:i] + (dim,) + shape[i+1:]
  1775|         0|            0|            0|  0.00%|        )
  1776|         0|            0|            0|  0.00%|        if sparse:
  1777|         0|            0|            0|  0.00%|            res = res + (idx,)
  1778|         0|            0|            0|  0.00%|        else:
  1779|         0|            0|            0|  0.00%|            res[i] = idx
  1780|         0|            0|            0|  0.00%|    return res
  1781|         0|            0|            0|  0.00%|
  1782|         0|            0|            0|  0.00%|
  1783|         0|            0|            0|  0.00%|def _fromfunction_dispatcher(function, shape, *, dtype=None, like=None, **kwargs):
  1784|         0|            0|            0|  0.00%|    return (like,)
  1785|         0|            0|            0|  0.00%|
  1786|         0|            0|            0|  0.00%|
  1787|         0|            0|            0|  0.00%|@set_array_function_like_doc
  1788|         0|            0|            0|  0.00%|@set_module('numpy')
  1789|         0|            0|            0|  0.00%|def fromfunction(function, shape, *, dtype=float, like=None, **kwargs):
  1790|         0|            0|            0|  0.00%|    """
  1791|         0|            0|            0|  0.00%|    Construct an array by executing a function over each coordinate.
  1792|         0|            0|            0|  0.00%|
  1793|         0|            0|            0|  0.00%|    The resulting array therefore has a value ``fn(x, y, z)`` at
  1794|         0|            0|            0|  0.00%|    coordinate ``(x, y, z)``.
  1795|         0|            0|            0|  0.00%|
  1796|         0|            0|            0|  0.00%|    Parameters
  1797|         0|            0|            0|  0.00%|    ----------
  1798|         0|            0|            0|  0.00%|    function : callable
  1799|         0|            0|            0|  0.00%|        The function is called with N parameters, where N is the rank of
  1800|         0|            0|            0|  0.00%|        `shape`.  Each parameter represents the coordinates of the array
  1801|         0|            0|            0|  0.00%|        varying along a specific axis.  For example, if `shape`
  1802|         0|            0|            0|  0.00%|        were ``(2, 2)``, then the parameters would be
  1803|         0|            0|            0|  0.00%|        ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
  1804|         0|            0|            0|  0.00%|    shape : (N,) tuple of ints
  1805|         0|            0|            0|  0.00%|        Shape of the output array, which also determines the shape of
  1806|         0|            0|            0|  0.00%|        the coordinate arrays passed to `function`.
  1807|         0|            0|            0|  0.00%|    dtype : data-type, optional
  1808|         0|            0|            0|  0.00%|        Data-type of the coordinate arrays passed to `function`.
  1809|         0|            0|            0|  0.00%|        By default, `dtype` is float.
  1810|         0|            0|            0|  0.00%|    ${ARRAY_FUNCTION_LIKE}
  1811|         0|            0|            0|  0.00%|
  1812|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
  1813|         0|            0|            0|  0.00%|
  1814|         0|            0|            0|  0.00%|    Returns
  1815|         0|            0|            0|  0.00%|    -------
  1816|         0|            0|            0|  0.00%|    fromfunction : any
  1817|         0|            0|            0|  0.00%|        The result of the call to `function` is passed back directly.
  1818|         0|            0|            0|  0.00%|        Therefore the shape of `fromfunction` is completely determined by
  1819|         0|            0|            0|  0.00%|        `function`.  If `function` returns a scalar value, the shape of
  1820|         0|            0|            0|  0.00%|        `fromfunction` would not match the `shape` parameter.
  1821|         0|            0|            0|  0.00%|
  1822|         0|            0|            0|  0.00%|    See Also
  1823|         0|            0|            0|  0.00%|    --------
  1824|         0|            0|            0|  0.00%|    indices, meshgrid
  1825|         0|            0|            0|  0.00%|
  1826|         0|            0|            0|  0.00%|    Notes
  1827|         0|            0|            0|  0.00%|    -----
  1828|         0|            0|            0|  0.00%|    Keywords other than `dtype` are passed to `function`.
  1829|         0|            0|            0|  0.00%|
  1830|         0|            0|            0|  0.00%|    Examples
  1831|         0|            0|            0|  0.00%|    --------
  1832|         0|            0|            0|  0.00%|    >>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
  1833|         0|            0|            0|  0.00%|    array([[ True, False, False],
  1834|         0|            0|            0|  0.00%|           [False,  True, False],
  1835|         0|            0|            0|  0.00%|           [False, False,  True]])
  1836|         0|            0|            0|  0.00%|
  1837|         0|            0|            0|  0.00%|    >>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
  1838|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1839|         0|            0|            0|  0.00%|           [1, 2, 3],
  1840|         0|            0|            0|  0.00%|           [2, 3, 4]])
  1841|         0|            0|            0|  0.00%|
  1842|         0|            0|            0|  0.00%|    """
  1843|         0|            0|            0|  0.00%|    if like is not None:
  1844|         0|            0|            0|  0.00%|        return _fromfunction_with_like(function, shape, dtype=dtype, like=like, **kwargs)
  1845|         0|            0|            0|  0.00%|
  1846|         0|            0|            0|  0.00%|    args = indices(shape, dtype=dtype)
  1847|         0|            0|            0|  0.00%|    return function(*args, **kwargs)
  1848|         0|            0|            0|  0.00%|
  1849|         0|            0|            0|  0.00%|
  1850|         0|            0|            0|  0.00%|_fromfunction_with_like = array_function_dispatch(
  1851|         0|            0|            0|  0.00%|    _fromfunction_dispatcher
  1852|         0|            0|            0|  0.00%|)(fromfunction)
  1853|         0|            0|            0|  0.00%|
  1854|         0|            0|            0|  0.00%|
  1855|         0|            0|            0|  0.00%|def _frombuffer(buf, dtype, shape, order):
  1856|         0|            0|            0|  0.00%|    return frombuffer(buf, dtype=dtype).reshape(shape, order=order)
  1857|         0|            0|            0|  0.00%|
  1858|         0|            0|            0|  0.00%|
  1859|        16|            0|            0|  0.00%|@set_module('numpy')
  1860|         0|            0|            0|  0.00%|def isscalar(element):
  1861|         0|            0|            0|  0.00%|    """
  1862|         0|            0|            0|  0.00%|    Returns True if the type of `element` is a scalar type.
  1863|         0|            0|            0|  0.00%|
  1864|         0|            0|            0|  0.00%|    Parameters
  1865|         0|            0|            0|  0.00%|    ----------
  1866|         0|            0|            0|  0.00%|    element : any
  1867|         0|            0|            0|  0.00%|        Input argument, can be of any type and shape.
  1868|         0|            0|            0|  0.00%|
  1869|         0|            0|            0|  0.00%|    Returns
  1870|         0|            0|            0|  0.00%|    -------
  1871|         0|            0|            0|  0.00%|    val : bool
  1872|         0|            0|            0|  0.00%|        True if `element` is a scalar type, False if it is not.
  1873|         0|            0|            0|  0.00%|
  1874|         0|            0|            0|  0.00%|    See Also
  1875|         0|            0|            0|  0.00%|    --------
  1876|         0|            0|            0|  0.00%|    ndim : Get the number of dimensions of an array
  1877|         0|            0|            0|  0.00%|
  1878|         0|            0|            0|  0.00%|    Notes
  1879|         0|            0|            0|  0.00%|    -----
  1880|         0|            0|            0|  0.00%|    If you need a stricter way to identify a *numerical* scalar, use
  1881|         0|            0|            0|  0.00%|    ``isinstance(x, numbers.Number)``, as that returns ``False`` for most
  1882|         0|            0|            0|  0.00%|    non-numerical elements such as strings.
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|    In most cases ``np.ndim(x) == 0`` should be used instead of this function,
  1885|         0|            0|            0|  0.00%|    as that will also return true for 0d arrays. This is how numpy overloads
  1886|         0|            0|            0|  0.00%|    functions in the style of the ``dx`` arguments to `gradient` and the ``bins``
  1887|         0|            0|            0|  0.00%|    argument to `histogram`. Some key differences:
  1888|         0|            0|            0|  0.00%|
  1889|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1890|         0|            0|            0|  0.00%|    | x                                    |``isscalar(x)``|``np.ndim(x) == 0``|
  1891|         0|            0|            0|  0.00%|    +======================================+===============+===================+
  1892|         0|            0|            0|  0.00%|    | PEP 3141 numeric objects (including  | ``True``      | ``True``          |
  1893|         0|            0|            0|  0.00%|    | builtins)                            |               |                   |
  1894|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1895|         0|            0|            0|  0.00%|    | builtin string and buffer objects    | ``True``      | ``True``          |
  1896|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1897|         0|            0|            0|  0.00%|    | other builtin objects, like          | ``False``     | ``True``          |
  1898|         0|            0|            0|  0.00%|    | `pathlib.Path`, `Exception`,         |               |                   |
  1899|         0|            0|            0|  0.00%|    | the result of `re.compile`           |               |                   |
  1900|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1901|         0|            0|            0|  0.00%|    | third-party objects like             | ``False``     | ``True``          |
  1902|         0|            0|            0|  0.00%|    | `matplotlib.figure.Figure`           |               |                   |
  1903|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1904|         0|            0|            0|  0.00%|    | zero-dimensional numpy arrays        | ``False``     | ``True``          |
  1905|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1906|         0|            0|            0|  0.00%|    | other numpy arrays                   | ``False``     | ``False``         |
  1907|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1908|         0|            0|            0|  0.00%|    | `list`, `tuple`, and other sequence  | ``False``     | ``False``         |
  1909|         0|            0|            0|  0.00%|    | objects                              |               |                   |
  1910|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1911|         0|            0|            0|  0.00%|
  1912|         0|            0|            0|  0.00%|    Examples
  1913|         0|            0|            0|  0.00%|    --------
  1914|         0|            0|            0|  0.00%|    >>> np.isscalar(3.1)
  1915|         0|            0|            0|  0.00%|    True
  1916|         0|            0|            0|  0.00%|    >>> np.isscalar(np.array(3.1))
  1917|         0|            0|            0|  0.00%|    False
  1918|         0|            0|            0|  0.00%|    >>> np.isscalar([3.1])
  1919|         0|            0|            0|  0.00%|    False
  1920|         0|            0|            0|  0.00%|    >>> np.isscalar(False)
  1921|         0|            0|            0|  0.00%|    True
  1922|         0|            0|            0|  0.00%|    >>> np.isscalar('numpy')
  1923|         0|            0|            0|  0.00%|    True
  1924|         0|            0|            0|  0.00%|
  1925|         0|            0|            0|  0.00%|    NumPy supports PEP 3141 numbers:
  1926|         0|            0|            0|  0.00%|
  1927|         0|            0|            0|  0.00%|    >>> from fractions import Fraction
  1928|         0|            0|            0|  0.00%|    >>> np.isscalar(Fraction(5, 17))
  1929|         0|            0|            0|  0.00%|    True
  1930|         0|            0|            0|  0.00%|    >>> from numbers import Number
  1931|         0|            0|            0|  0.00%|    >>> np.isscalar(Number())
  1932|         0|            0|            0|  0.00%|    True
  1933|         0|            0|            0|  0.00%|
  1934|         0|            0|            0|  0.00%|    """
  1935|        48|            0|            0|  0.00%|    return (isinstance(element, generic)
  1936|        16|            0|            0|  0.00%|            or type(element) in ScalarType
  1937|        16|            0|            0|  0.00%|            or isinstance(element, numbers.Number))
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\abc.py:96 __instancecheck__
  1938|         0|            0|            0|  0.00%|
  1939|         0|            0|            0|  0.00%|
  1940|         0|            0|            0|  0.00%|@set_module('numpy')
  1941|         0|            0|            0|  0.00%|def binary_repr(num, width=None):
  1942|         0|            0|            0|  0.00%|    """
  1943|         0|            0|            0|  0.00%|    Return the binary representation of the input number as a string.
  1944|         0|            0|            0|  0.00%|
  1945|         0|            0|            0|  0.00%|    For negative numbers, if width is not given, a minus sign is added to the
  1946|         0|            0|            0|  0.00%|    front. If width is given, the two's complement of the number is
  1947|         0|            0|            0|  0.00%|    returned, with respect to that width.
  1948|         0|            0|            0|  0.00%|
  1949|         0|            0|            0|  0.00%|    In a two's-complement system negative numbers are represented by the two's
  1950|         0|            0|            0|  0.00%|    complement of the absolute value. This is the most common method of
  1951|         0|            0|            0|  0.00%|    representing signed integers on computers [1]_. A N-bit two's-complement
  1952|         0|            0|            0|  0.00%|    system can represent every integer in the range
  1953|         0|            0|            0|  0.00%|    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.
  1954|         0|            0|            0|  0.00%|
  1955|         0|            0|            0|  0.00%|    Parameters
  1956|         0|            0|            0|  0.00%|    ----------
  1957|         0|            0|            0|  0.00%|    num : int
  1958|         0|            0|            0|  0.00%|        Only an integer decimal number can be used.
  1959|         0|            0|            0|  0.00%|    width : int, optional
  1960|         0|            0|            0|  0.00%|        The length of the returned string if `num` is positive, or the length
  1961|         0|            0|            0|  0.00%|        of the two's complement if `num` is negative, provided that `width` is
  1962|         0|            0|            0|  0.00%|        at least a sufficient number of bits for `num` to be represented in the
  1963|         0|            0|            0|  0.00%|        designated form.
  1964|         0|            0|            0|  0.00%|
  1965|         0|            0|            0|  0.00%|        If the `width` value is insufficient, it will be ignored, and `num` will
  1966|         0|            0|            0|  0.00%|        be returned in binary (`num` > 0) or two's complement (`num` < 0) form
  1967|         0|            0|            0|  0.00%|        with its width equal to the minimum number of bits needed to represent
  1968|         0|            0|            0|  0.00%|        the number in the designated form. This behavior is deprecated and will
  1969|         0|            0|            0|  0.00%|        later raise an error.
  1970|         0|            0|            0|  0.00%|
  1971|         0|            0|            0|  0.00%|        .. deprecated:: 1.12.0
  1972|         0|            0|            0|  0.00%|
  1973|         0|            0|            0|  0.00%|    Returns
  1974|         0|            0|            0|  0.00%|    -------
  1975|         0|            0|            0|  0.00%|    bin : str
  1976|         0|            0|            0|  0.00%|        Binary representation of `num` or two's complement of `num`.
  1977|         0|            0|            0|  0.00%|
  1978|         0|            0|            0|  0.00%|    See Also
  1979|         0|            0|            0|  0.00%|    --------
  1980|         0|            0|            0|  0.00%|    base_repr: Return a string representation of a number in the given base
  1981|         0|            0|            0|  0.00%|               system.
  1982|         0|            0|            0|  0.00%|    bin: Python's built-in binary representation generator of an integer.
  1983|         0|            0|            0|  0.00%|
  1984|         0|            0|            0|  0.00%|    Notes
  1985|         0|            0|            0|  0.00%|    -----
  1986|         0|            0|            0|  0.00%|    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
  1987|         0|            0|            0|  0.00%|    faster.
  1988|         0|            0|            0|  0.00%|
  1989|         0|            0|            0|  0.00%|    References
  1990|         0|            0|            0|  0.00%|    ----------
  1991|         0|            0|            0|  0.00%|    .. [1] Wikipedia, "Two's complement",
  1992|         0|            0|            0|  0.00%|        https://en.wikipedia.org/wiki/Two's_complement
  1993|         0|            0|            0|  0.00%|
  1994|         0|            0|            0|  0.00%|    Examples
  1995|         0|            0|            0|  0.00%|    --------
  1996|         0|            0|            0|  0.00%|    >>> np.binary_repr(3)
  1997|         0|            0|            0|  0.00%|    '11'
  1998|         0|            0|            0|  0.00%|    >>> np.binary_repr(-3)
  1999|         0|            0|            0|  0.00%|    '-11'
  2000|         0|            0|            0|  0.00%|    >>> np.binary_repr(3, width=4)
  2001|         0|            0|            0|  0.00%|    '0011'
  2002|         0|            0|            0|  0.00%|
  2003|         0|            0|            0|  0.00%|    The two's complement is returned when the input number is negative and
  2004|         0|            0|            0|  0.00%|    width is specified:
  2005|         0|            0|            0|  0.00%|
  2006|         0|            0|            0|  0.00%|    >>> np.binary_repr(-3, width=3)
  2007|         0|            0|            0|  0.00%|    '101'
  2008|         0|            0|            0|  0.00%|    >>> np.binary_repr(-3, width=5)
  2009|         0|            0|            0|  0.00%|    '11101'
  2010|         0|            0|            0|  0.00%|
  2011|         0|            0|            0|  0.00%|    """
  2012|         0|            0|            0|  0.00%|    def warn_if_insufficient(width, binwidth):
  2013|         0|            0|            0|  0.00%|        if width is not None and width < binwidth:
  2014|         0|            0|            0|  0.00%|            warnings.warn(
  2015|         0|            0|            0|  0.00%|                "Insufficient bit width provided. This behavior "
  2016|         0|            0|            0|  0.00%|                "will raise an error in the future.", DeprecationWarning,
  2017|         0|            0|            0|  0.00%|                stacklevel=3)
  2018|         0|            0|            0|  0.00%|
  2019|         0|            0|            0|  0.00%|    # Ensure that num is a Python integer to avoid overflow or unwanted
  2020|         0|            0|            0|  0.00%|    # casts to floating point.
  2021|         0|            0|            0|  0.00%|    num = operator.index(num)
  2022|         0|            0|            0|  0.00%|
  2023|         0|            0|            0|  0.00%|    if num == 0:
  2024|         0|            0|            0|  0.00%|        return '0' * (width or 1)
  2025|         0|            0|            0|  0.00%|
  2026|         0|            0|            0|  0.00%|    elif num > 0:
  2027|         0|            0|            0|  0.00%|        binary = bin(num)[2:]
  2028|         0|            0|            0|  0.00%|        binwidth = len(binary)
  2029|         0|            0|            0|  0.00%|        outwidth = (binwidth if width is None
  2030|         0|            0|            0|  0.00%|                    else max(binwidth, width))
  2031|         0|            0|            0|  0.00%|        warn_if_insufficient(width, binwidth)
  2032|         0|            0|            0|  0.00%|        return binary.zfill(outwidth)
  2033|         0|            0|            0|  0.00%|
  2034|         0|            0|            0|  0.00%|    else:
  2035|         0|            0|            0|  0.00%|        if width is None:
  2036|         0|            0|            0|  0.00%|            return '-' + bin(-num)[2:]
  2037|         0|            0|            0|  0.00%|
  2038|         0|            0|            0|  0.00%|        else:
  2039|         0|            0|            0|  0.00%|            poswidth = len(bin(-num)[2:])
  2040|         0|            0|            0|  0.00%|
  2041|         0|            0|            0|  0.00%|            # See gh-8679: remove extra digit
  2042|         0|            0|            0|  0.00%|            # for numbers at boundaries.
  2043|         0|            0|            0|  0.00%|            if 2**(poswidth - 1) == -num:
  2044|         0|            0|            0|  0.00%|                poswidth -= 1
  2045|         0|            0|            0|  0.00%|
  2046|         0|            0|            0|  0.00%|            twocomp = 2**(poswidth + 1) + num
  2047|         0|            0|            0|  0.00%|            binary = bin(twocomp)[2:]
  2048|         0|            0|            0|  0.00%|            binwidth = len(binary)
  2049|         0|            0|            0|  0.00%|
  2050|         0|            0|            0|  0.00%|            outwidth = max(binwidth, width)
  2051|         0|            0|            0|  0.00%|            warn_if_insufficient(width, binwidth)
  2052|         0|            0|            0|  0.00%|            return '1' * (outwidth - binwidth) + binary
  2053|         0|            0|            0|  0.00%|
  2054|         0|            0|            0|  0.00%|
  2055|         0|            0|            0|  0.00%|@set_module('numpy')
  2056|         0|            0|            0|  0.00%|def base_repr(number, base=2, padding=0):
  2057|         0|            0|            0|  0.00%|    """
  2058|         0|            0|            0|  0.00%|    Return a string representation of a number in the given base system.
  2059|         0|            0|            0|  0.00%|
  2060|         0|            0|            0|  0.00%|    Parameters
  2061|         0|            0|            0|  0.00%|    ----------
  2062|         0|            0|            0|  0.00%|    number : int
  2063|         0|            0|            0|  0.00%|        The value to convert. Positive and negative values are handled.
  2064|         0|            0|            0|  0.00%|    base : int, optional
  2065|         0|            0|            0|  0.00%|        Convert `number` to the `base` number system. The valid range is 2-36,
  2066|         0|            0|            0|  0.00%|        the default value is 2.
  2067|         0|            0|            0|  0.00%|    padding : int, optional
  2068|         0|            0|            0|  0.00%|        Number of zeros padded on the left. Default is 0 (no padding).
  2069|         0|            0|            0|  0.00%|
  2070|         0|            0|            0|  0.00%|    Returns
  2071|         0|            0|            0|  0.00%|    -------
  2072|         0|            0|            0|  0.00%|    out : str
  2073|         0|            0|            0|  0.00%|        String representation of `number` in `base` system.
  2074|         0|            0|            0|  0.00%|
  2075|         0|            0|            0|  0.00%|    See Also
  2076|         0|            0|            0|  0.00%|    --------
  2077|         0|            0|            0|  0.00%|    binary_repr : Faster version of `base_repr` for base 2.
  2078|         0|            0|            0|  0.00%|
  2079|         0|            0|            0|  0.00%|    Examples
  2080|         0|            0|            0|  0.00%|    --------
  2081|         0|            0|            0|  0.00%|    >>> np.base_repr(5)
  2082|         0|            0|            0|  0.00%|    '101'
  2083|         0|            0|            0|  0.00%|    >>> np.base_repr(6, 5)
  2084|         0|            0|            0|  0.00%|    '11'
  2085|         0|            0|            0|  0.00%|    >>> np.base_repr(7, base=5, padding=3)
  2086|         0|            0|            0|  0.00%|    '00012'
  2087|         0|            0|            0|  0.00%|
  2088|         0|            0|            0|  0.00%|    >>> np.base_repr(10, base=16)
  2089|         0|            0|            0|  0.00%|    'A'
  2090|         0|            0|            0|  0.00%|    >>> np.base_repr(32, base=16)
  2091|         0|            0|            0|  0.00%|    '20'
  2092|         0|            0|            0|  0.00%|
  2093|         0|            0|            0|  0.00%|    """
  2094|         0|            0|            0|  0.00%|    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  2095|         0|            0|            0|  0.00%|    if base > len(digits):
  2096|         0|            0|            0|  0.00%|        raise ValueError("Bases greater than 36 not handled in base_repr.")
  2097|         0|            0|            0|  0.00%|    elif base < 2:
  2098|         0|            0|            0|  0.00%|        raise ValueError("Bases less than 2 not handled in base_repr.")
  2099|         0|            0|            0|  0.00%|
  2100|         0|            0|            0|  0.00%|    num = abs(number)
  2101|         0|            0|            0|  0.00%|    res = []
  2102|         0|            0|            0|  0.00%|    while num:
  2103|         0|            0|            0|  0.00%|        res.append(digits[num % base])
  2104|         0|            0|            0|  0.00%|        num //= base
  2105|         0|            0|            0|  0.00%|    if padding:
  2106|         0|            0|            0|  0.00%|        res.append('0' * padding)
  2107|         0|            0|            0|  0.00%|    if number < 0:
  2108|         0|            0|            0|  0.00%|        res.append('-')
  2109|         0|            0|            0|  0.00%|    return ''.join(reversed(res or '0'))
  2110|         0|            0|            0|  0.00%|
  2111|         0|            0|            0|  0.00%|
  2112|         0|            0|            0|  0.00%|# These are all essentially abbreviations
  2113|         0|            0|            0|  0.00%|# These might wind up in a special abbreviations module
  2114|         0|            0|            0|  0.00%|
  2115|         0|            0|            0|  0.00%|
  2116|         0|            0|            0|  0.00%|def _maketup(descr, val):
  2117|         0|            0|            0|  0.00%|    dt = dtype(descr)
  2118|         0|            0|            0|  0.00%|    # Place val in all scalar tuples:
  2119|         0|            0|            0|  0.00%|    fields = dt.fields
  2120|         0|            0|            0|  0.00%|    if fields is None:
  2121|         0|            0|            0|  0.00%|        return val
  2122|         0|            0|            0|  0.00%|    else:
  2123|         0|            0|            0|  0.00%|        res = [_maketup(fields[name][0], val) for name in dt.names]
  2124|         0|            0|            0|  0.00%|        return tuple(res)
  2125|         0|            0|            0|  0.00%|
  2126|         0|            0|            0|  0.00%|
  2127|         0|            0|            0|  0.00%|def _identity_dispatcher(n, dtype=None, *, like=None):
  2128|         0|            0|            0|  0.00%|    return (like,)
  2129|         0|            0|            0|  0.00%|
  2130|         0|            0|            0|  0.00%|
  2131|         0|            0|            0|  0.00%|@set_array_function_like_doc
  2132|         0|            0|            0|  0.00%|@set_module('numpy')
  2133|         0|            0|            0|  0.00%|def identity(n, dtype=None, *, like=None):
  2134|         0|            0|            0|  0.00%|    """
  2135|         0|            0|            0|  0.00%|    Return the identity array.
  2136|         0|            0|            0|  0.00%|
  2137|         0|            0|            0|  0.00%|    The identity array is a square array with ones on
  2138|         0|            0|            0|  0.00%|    the main diagonal.
  2139|         0|            0|            0|  0.00%|
  2140|         0|            0|            0|  0.00%|    Parameters
  2141|         0|            0|            0|  0.00%|    ----------
  2142|         0|            0|            0|  0.00%|    n : int
  2143|         0|            0|            0|  0.00%|        Number of rows (and columns) in `n` x `n` output.
  2144|         0|            0|            0|  0.00%|    dtype : data-type, optional
  2145|         0|            0|            0|  0.00%|        Data-type of the output.  Defaults to ``float``.
  2146|         0|            0|            0|  0.00%|    ${ARRAY_FUNCTION_LIKE}
  2147|         0|            0|            0|  0.00%|
  2148|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
  2149|         0|            0|            0|  0.00%|
  2150|         0|            0|            0|  0.00%|    Returns
  2151|         0|            0|            0|  0.00%|    -------
  2152|         0|            0|            0|  0.00%|    out : ndarray
  2153|         0|            0|            0|  0.00%|        `n` x `n` array with its main diagonal set to one,
  2154|         0|            0|            0|  0.00%|        and all other elements 0.
  2155|         0|            0|            0|  0.00%|
  2156|         0|            0|            0|  0.00%|    Examples
  2157|         0|            0|            0|  0.00%|    --------
  2158|         0|            0|            0|  0.00%|    >>> np.identity(3)
  2159|         0|            0|            0|  0.00%|    array([[1.,  0.,  0.],
  2160|         0|            0|            0|  0.00%|           [0.,  1.,  0.],
  2161|         0|            0|            0|  0.00%|           [0.,  0.,  1.]])
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|    """
  2164|         0|            0|            0|  0.00%|    if like is not None:
  2165|         0|            0|            0|  0.00%|        return _identity_with_like(n, dtype=dtype, like=like)
  2166|         0|            0|            0|  0.00%|
  2167|         0|            0|            0|  0.00%|    from numpy import eye
  2168|         0|            0|            0|  0.00%|    return eye(n, dtype=dtype, like=like)
  2169|         0|            0|            0|  0.00%|
  2170|         0|            0|            0|  0.00%|
  2171|         0|            0|            0|  0.00%|_identity_with_like = array_function_dispatch(
  2172|         0|            0|            0|  0.00%|    _identity_dispatcher
  2173|         0|            0|            0|  0.00%|)(identity)
  2174|         0|            0|            0|  0.00%|
  2175|         0|            0|            0|  0.00%|
  2176|         0|            0|            0|  0.00%|def _allclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):
  2177|         0|            0|            0|  0.00%|    return (a, b)
  2178|         0|            0|            0|  0.00%|
  2179|         0|            0|            0|  0.00%|
  2180|         0|            0|            0|  0.00%|@array_function_dispatch(_allclose_dispatcher)
  2181|         0|            0|            0|  0.00%|def allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
  2182|         0|            0|            0|  0.00%|    """
  2183|         0|            0|            0|  0.00%|    Returns True if two arrays are element-wise equal within a tolerance.
  2184|         0|            0|            0|  0.00%|
  2185|         0|            0|            0|  0.00%|    The tolerance values are positive, typically very small numbers.  The
  2186|         0|            0|            0|  0.00%|    relative difference (`rtol` * abs(`b`)) and the absolute difference
  2187|         0|            0|            0|  0.00%|    `atol` are added together to compare against the absolute difference
  2188|         0|            0|            0|  0.00%|    between `a` and `b`.
  2189|         0|            0|            0|  0.00%|
  2190|         0|            0|            0|  0.00%|    NaNs are treated as equal if they are in the same place and if
  2191|         0|            0|            0|  0.00%|    ``equal_nan=True``.  Infs are treated as equal if they are in the same
  2192|         0|            0|            0|  0.00%|    place and of the same sign in both arrays.
  2193|         0|            0|            0|  0.00%|
  2194|         0|            0|            0|  0.00%|    Parameters
  2195|         0|            0|            0|  0.00%|    ----------
  2196|         0|            0|            0|  0.00%|    a, b : array_like
  2197|         0|            0|            0|  0.00%|        Input arrays to compare.
  2198|         0|            0|            0|  0.00%|    rtol : float
  2199|         0|            0|            0|  0.00%|        The relative tolerance parameter (see Notes).
  2200|         0|            0|            0|  0.00%|    atol : float
  2201|         0|            0|            0|  0.00%|        The absolute tolerance parameter (see Notes).
  2202|         0|            0|            0|  0.00%|    equal_nan : bool
  2203|         0|            0|            0|  0.00%|        Whether to compare NaN's as equal.  If True, NaN's in `a` will be
  2204|         0|            0|            0|  0.00%|        considered equal to NaN's in `b` in the output array.
  2205|         0|            0|            0|  0.00%|
  2206|         0|            0|            0|  0.00%|        .. versionadded:: 1.10.0
  2207|         0|            0|            0|  0.00%|
  2208|         0|            0|            0|  0.00%|    Returns
  2209|         0|            0|            0|  0.00%|    -------
  2210|         0|            0|            0|  0.00%|    allclose : bool
  2211|         0|            0|            0|  0.00%|        Returns True if the two arrays are equal within the given
  2212|         0|            0|            0|  0.00%|        tolerance; False otherwise.
  2213|         0|            0|            0|  0.00%|
  2214|         0|            0|            0|  0.00%|    See Also
  2215|         0|            0|            0|  0.00%|    --------
  2216|         0|            0|            0|  0.00%|    isclose, all, any, equal
  2217|         0|            0|            0|  0.00%|
  2218|         0|            0|            0|  0.00%|    Notes
  2219|         0|            0|            0|  0.00%|    -----
  2220|         0|            0|            0|  0.00%|    If the following equation is element-wise True, then allclose returns
  2221|         0|            0|            0|  0.00%|    True.
  2222|         0|            0|            0|  0.00%|
  2223|         0|            0|            0|  0.00%|     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
  2224|         0|            0|            0|  0.00%|
  2225|         0|            0|            0|  0.00%|    The above equation is not symmetric in `a` and `b`, so that
  2226|         0|            0|            0|  0.00%|    ``allclose(a, b)`` might be different from ``allclose(b, a)`` in
  2227|         0|            0|            0|  0.00%|    some rare cases.
  2228|         0|            0|            0|  0.00%|
  2229|         0|            0|            0|  0.00%|    The comparison of `a` and `b` uses standard broadcasting, which
  2230|         0|            0|            0|  0.00%|    means that `a` and `b` need not have the same shape in order for
  2231|         0|            0|            0|  0.00%|    ``allclose(a, b)`` to evaluate to True.  The same is true for
  2232|         0|            0|            0|  0.00%|    `equal` but not `array_equal`.
  2233|         0|            0|            0|  0.00%|
  2234|         0|            0|            0|  0.00%|    `allclose` is not defined for non-numeric data types.
  2235|         0|            0|            0|  0.00%|    `bool` is considered a numeric data-type for this purpose.
  2236|         0|            0|            0|  0.00%|
  2237|         0|            0|            0|  0.00%|    Examples
  2238|         0|            0|            0|  0.00%|    --------
  2239|         0|            0|            0|  0.00%|    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
  2240|         0|            0|            0|  0.00%|    False
  2241|         0|            0|            0|  0.00%|    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
  2242|         0|            0|            0|  0.00%|    True
  2243|         0|            0|            0|  0.00%|    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
  2244|         0|            0|            0|  0.00%|    False
  2245|         0|            0|            0|  0.00%|    >>> np.allclose([1.0, np.nan], [1.0, np.nan])
  2246|         0|            0|            0|  0.00%|    False
  2247|         0|            0|            0|  0.00%|    >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
  2248|         0|            0|            0|  0.00%|    True
  2249|         0|            0|            0|  0.00%|
  2250|         0|            0|            0|  0.00%|    """
  2251|         0|            0|            0|  0.00%|    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
  2252|         0|            0|            0|  0.00%|    return bool(res)
  2253|         0|            0|            0|  0.00%|
  2254|         0|            0|            0|  0.00%|
  2255|         0|            0|            0|  0.00%|def _isclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):
  2256|         0|            0|            0|  0.00%|    return (a, b)
  2257|         0|            0|            0|  0.00%|
  2258|         0|            0|            0|  0.00%|
  2259|         0|            0|            0|  0.00%|@array_function_dispatch(_isclose_dispatcher)
  2260|         0|            0|            0|  0.00%|def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
  2261|         0|            0|            0|  0.00%|    """
  2262|         0|            0|            0|  0.00%|    Returns a boolean array where two arrays are element-wise equal within a
  2263|         0|            0|            0|  0.00%|    tolerance.
  2264|         0|            0|            0|  0.00%|
  2265|         0|            0|            0|  0.00%|    The tolerance values are positive, typically very small numbers.  The
  2266|         0|            0|            0|  0.00%|    relative difference (`rtol` * abs(`b`)) and the absolute difference
  2267|         0|            0|            0|  0.00%|    `atol` are added together to compare against the absolute difference
  2268|         0|            0|            0|  0.00%|    between `a` and `b`.
  2269|         0|            0|            0|  0.00%|
  2270|         0|            0|            0|  0.00%|    .. warning:: The default `atol` is not appropriate for comparing numbers
  2271|         0|            0|            0|  0.00%|                 that are much smaller than one (see Notes).
  2272|         0|            0|            0|  0.00%|
  2273|         0|            0|            0|  0.00%|    Parameters
  2274|         0|            0|            0|  0.00%|    ----------
  2275|         0|            0|            0|  0.00%|    a, b : array_like
  2276|         0|            0|            0|  0.00%|        Input arrays to compare.
  2277|         0|            0|            0|  0.00%|    rtol : float
  2278|         0|            0|            0|  0.00%|        The relative tolerance parameter (see Notes).
  2279|         0|            0|            0|  0.00%|    atol : float
  2280|         0|            0|            0|  0.00%|        The absolute tolerance parameter (see Notes).
  2281|         0|            0|            0|  0.00%|    equal_nan : bool
  2282|         0|            0|            0|  0.00%|        Whether to compare NaN's as equal.  If True, NaN's in `a` will be
  2283|         0|            0|            0|  0.00%|        considered equal to NaN's in `b` in the output array.
  2284|         0|            0|            0|  0.00%|
  2285|         0|            0|            0|  0.00%|    Returns
  2286|         0|            0|            0|  0.00%|    -------
  2287|         0|            0|            0|  0.00%|    y : array_like
  2288|         0|            0|            0|  0.00%|        Returns a boolean array of where `a` and `b` are equal within the
  2289|         0|            0|            0|  0.00%|        given tolerance. If both `a` and `b` are scalars, returns a single
  2290|         0|            0|            0|  0.00%|        boolean value.
  2291|         0|            0|            0|  0.00%|
  2292|         0|            0|            0|  0.00%|    See Also
  2293|         0|            0|            0|  0.00%|    --------
  2294|         0|            0|            0|  0.00%|    allclose
  2295|         0|            0|            0|  0.00%|    math.isclose
  2296|         0|            0|            0|  0.00%|
  2297|         0|            0|            0|  0.00%|    Notes
  2298|         0|            0|            0|  0.00%|    -----
  2299|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  2300|         0|            0|            0|  0.00%|
  2301|         0|            0|            0|  0.00%|    For finite values, isclose uses the following equation to test whether
  2302|         0|            0|            0|  0.00%|    two floating point values are equivalent.
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
  2305|         0|            0|            0|  0.00%|
  2306|         0|            0|            0|  0.00%|    Unlike the built-in `math.isclose`, the above equation is not symmetric
  2307|         0|            0|            0|  0.00%|    in `a` and `b` -- it assumes `b` is the reference value -- so that
  2308|         0|            0|            0|  0.00%|    `isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,
  2309|         0|            0|            0|  0.00%|    the default value of atol is not zero, and is used to determine what
  2310|         0|            0|            0|  0.00%|    small values should be considered close to zero. The default value is
  2311|         0|            0|            0|  0.00%|    appropriate for expected values of order unity: if the expected values
  2312|         0|            0|            0|  0.00%|    are significantly smaller than one, it can result in false positives.
  2313|         0|            0|            0|  0.00%|    `atol` should be carefully selected for the use case at hand. A zero value
  2314|         0|            0|            0|  0.00%|    for `atol` will result in `False` if either `a` or `b` is zero.
  2315|         0|            0|            0|  0.00%|
  2316|         0|            0|            0|  0.00%|    `isclose` is not defined for non-numeric data types.
  2317|         0|            0|            0|  0.00%|    `bool` is considered a numeric data-type for this purpose.
  2318|         0|            0|            0|  0.00%|
  2319|         0|            0|            0|  0.00%|    Examples
  2320|         0|            0|            0|  0.00%|    --------
  2321|         0|            0|            0|  0.00%|    >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
  2322|         0|            0|            0|  0.00%|    array([ True, False])
  2323|         0|            0|            0|  0.00%|    >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
  2324|         0|            0|            0|  0.00%|    array([ True, True])
  2325|         0|            0|            0|  0.00%|    >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
  2326|         0|            0|            0|  0.00%|    array([False,  True])
  2327|         0|            0|            0|  0.00%|    >>> np.isclose([1.0, np.nan], [1.0, np.nan])
  2328|         0|            0|            0|  0.00%|    array([ True, False])
  2329|         0|            0|            0|  0.00%|    >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
  2330|         0|            0|            0|  0.00%|    array([ True, True])
  2331|         0|            0|            0|  0.00%|    >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
  2332|         0|            0|            0|  0.00%|    array([ True, False])
  2333|         0|            0|            0|  0.00%|    >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
  2334|         0|            0|            0|  0.00%|    array([False, False])
  2335|         0|            0|            0|  0.00%|    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
  2336|         0|            0|            0|  0.00%|    array([ True,  True])
  2337|         0|            0|            0|  0.00%|    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
  2338|         0|            0|            0|  0.00%|    array([False,  True])
  2339|         0|            0|            0|  0.00%|    """
  2340|         0|            0|            0|  0.00%|    def within_tol(x, y, atol, rtol):
  2341|         0|            0|            0|  0.00%|        with errstate(invalid='ignore'):
  2342|         0|            0|            0|  0.00%|            return less_equal(abs(x-y), atol + rtol * abs(y))
  2343|         0|            0|            0|  0.00%|
  2344|         0|            0|            0|  0.00%|    x = asanyarray(a)
  2345|         0|            0|            0|  0.00%|    y = asanyarray(b)
  2346|         0|            0|            0|  0.00%|
  2347|         0|            0|            0|  0.00%|    # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
  2348|         0|            0|            0|  0.00%|    # This will cause casting of x later. Also, make sure to allow subclasses
  2349|         0|            0|            0|  0.00%|    # (e.g., for numpy.ma).
  2350|         0|            0|            0|  0.00%|    # NOTE: We explicitly allow timedelta, which used to work. This could
  2351|         0|            0|            0|  0.00%|    #       possibly be deprecated. See also gh-18286.
  2352|         0|            0|            0|  0.00%|    #       timedelta works if `atol` is an integer or also a timedelta.
  2353|         0|            0|            0|  0.00%|    #       Although, the default tolerances are unlikely to be useful
  2354|         0|            0|            0|  0.00%|    if y.dtype.kind != "m":
  2355|         0|            0|            0|  0.00%|        dt = multiarray.result_type(y, 1.)
  2356|         0|            0|            0|  0.00%|        y = asanyarray(y, dtype=dt)
  2357|         0|            0|            0|  0.00%|
  2358|         0|            0|            0|  0.00%|    xfin = isfinite(x)
  2359|         0|            0|            0|  0.00%|    yfin = isfinite(y)
  2360|         0|            0|            0|  0.00%|    if all(xfin) and all(yfin):
  2361|         0|            0|            0|  0.00%|        return within_tol(x, y, atol, rtol)
  2362|         0|            0|            0|  0.00%|    else:
  2363|         0|            0|            0|  0.00%|        finite = xfin & yfin
  2364|         0|            0|            0|  0.00%|        cond = zeros_like(finite, subok=True)
  2365|         0|            0|            0|  0.00%|        # Because we're using boolean indexing, x & y must be the same shape.
  2366|         0|            0|            0|  0.00%|        # Ideally, we'd just do x, y = broadcast_arrays(x, y). It's in
  2367|         0|            0|            0|  0.00%|        # lib.stride_tricks, though, so we can't import it here.
  2368|         0|            0|            0|  0.00%|        x = x * ones_like(cond)
  2369|         0|            0|            0|  0.00%|        y = y * ones_like(cond)
  2370|         0|            0|            0|  0.00%|        # Avoid subtraction with infinite/nan values...
  2371|         0|            0|            0|  0.00%|        cond[finite] = within_tol(x[finite], y[finite], atol, rtol)
  2372|         0|            0|            0|  0.00%|        # Check for equality of infinite values...
  2373|         0|            0|            0|  0.00%|        cond[~finite] = (x[~finite] == y[~finite])
  2374|         0|            0|            0|  0.00%|        if equal_nan:
  2375|         0|            0|            0|  0.00%|            # Make NaN == NaN
  2376|         0|            0|            0|  0.00%|            both_nan = isnan(x) & isnan(y)
  2377|         0|            0|            0|  0.00%|
  2378|         0|            0|            0|  0.00%|            # Needed to treat masked arrays correctly. = True would not work.
  2379|         0|            0|            0|  0.00%|            cond[both_nan] = both_nan[both_nan]
  2380|         0|            0|            0|  0.00%|
  2381|         0|            0|            0|  0.00%|        return cond[()]  # Flatten 0d arrays to scalars
  2382|         0|            0|            0|  0.00%|
  2383|         0|            0|            0|  0.00%|
  2384|         0|            0|            0|  0.00%|def _array_equal_dispatcher(a1, a2, equal_nan=None):
  2385|         0|            0|            0|  0.00%|    return (a1, a2)
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|
  2388|         0|            0|            0|  0.00%|@array_function_dispatch(_array_equal_dispatcher)
  2389|         0|            0|            0|  0.00%|def array_equal(a1, a2, equal_nan=False):
  2390|         0|            0|            0|  0.00%|    """
  2391|         0|            0|            0|  0.00%|    True if two arrays have the same shape and elements, False otherwise.
  2392|         0|            0|            0|  0.00%|
  2393|         0|            0|            0|  0.00%|    Parameters
  2394|         0|            0|            0|  0.00%|    ----------
  2395|         0|            0|            0|  0.00%|    a1, a2 : array_like
  2396|         0|            0|            0|  0.00%|        Input arrays.
  2397|         0|            0|            0|  0.00%|    equal_nan : bool
  2398|         0|            0|            0|  0.00%|        Whether to compare NaN's as equal. If the dtype of a1 and a2 is
  2399|         0|            0|            0|  0.00%|        complex, values will be considered equal if either the real or the
  2400|         0|            0|            0|  0.00%|        imaginary component of a given value is ``nan``.
  2401|         0|            0|            0|  0.00%|
  2402|         0|            0|            0|  0.00%|        .. versionadded:: 1.19.0
  2403|         0|            0|            0|  0.00%|
  2404|         0|            0|            0|  0.00%|    Returns
  2405|         0|            0|            0|  0.00%|    -------
  2406|         0|            0|            0|  0.00%|    b : bool
  2407|         0|            0|            0|  0.00%|        Returns True if the arrays are equal.
  2408|         0|            0|            0|  0.00%|
  2409|         0|            0|            0|  0.00%|    See Also
  2410|         0|            0|            0|  0.00%|    --------
  2411|         0|            0|            0|  0.00%|    allclose: Returns True if two arrays are element-wise equal within a
  2412|         0|            0|            0|  0.00%|              tolerance.
  2413|         0|            0|            0|  0.00%|    array_equiv: Returns True if input arrays are shape consistent and all
  2414|         0|            0|            0|  0.00%|                 elements equal.
  2415|         0|            0|            0|  0.00%|
  2416|         0|            0|            0|  0.00%|    Examples
  2417|         0|            0|            0|  0.00%|    --------
  2418|         0|            0|            0|  0.00%|    >>> np.array_equal([1, 2], [1, 2])
  2419|         0|            0|            0|  0.00%|    True
  2420|         0|            0|            0|  0.00%|    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
  2421|         0|            0|            0|  0.00%|    True
  2422|         0|            0|            0|  0.00%|    >>> np.array_equal([1, 2], [1, 2, 3])
  2423|         0|            0|            0|  0.00%|    False
  2424|         0|            0|            0|  0.00%|    >>> np.array_equal([1, 2], [1, 4])
  2425|         0|            0|            0|  0.00%|    False
  2426|         0|            0|            0|  0.00%|    >>> a = np.array([1, np.nan])
  2427|         0|            0|            0|  0.00%|    >>> np.array_equal(a, a)
  2428|         0|            0|            0|  0.00%|    False
  2429|         0|            0|            0|  0.00%|    >>> np.array_equal(a, a, equal_nan=True)
  2430|         0|            0|            0|  0.00%|    True
  2431|         0|            0|            0|  0.00%|
  2432|         0|            0|            0|  0.00%|    When ``equal_nan`` is True, complex values with nan components are
  2433|         0|            0|            0|  0.00%|    considered equal if either the real *or* the imaginary components are nan.
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|    >>> a = np.array([1 + 1j])
  2436|         0|            0|            0|  0.00%|    >>> b = a.copy()
  2437|         0|            0|            0|  0.00%|    >>> a.real = np.nan
  2438|         0|            0|            0|  0.00%|    >>> b.imag = np.nan
  2439|         0|            0|            0|  0.00%|    >>> np.array_equal(a, b, equal_nan=True)
  2440|         0|            0|            0|  0.00%|    True
  2441|         0|            0|            0|  0.00%|    """
  2442|         0|            0|            0|  0.00%|    try:
  2443|         0|            0|            0|  0.00%|        a1, a2 = asarray(a1), asarray(a2)
  2444|         0|            0|            0|  0.00%|    except Exception:
  2445|         0|            0|            0|  0.00%|        return False
  2446|         0|            0|            0|  0.00%|    if a1.shape != a2.shape:
  2447|         0|            0|            0|  0.00%|        return False
  2448|         0|            0|            0|  0.00%|    if not equal_nan:
  2449|         0|            0|            0|  0.00%|        return bool(asarray(a1 == a2).all())
  2450|         0|            0|            0|  0.00%|    # Handling NaN values if equal_nan is True
  2451|         0|            0|            0|  0.00%|    a1nan, a2nan = isnan(a1), isnan(a2)
  2452|         0|            0|            0|  0.00%|    # NaN's occur at different locations
  2453|         0|            0|            0|  0.00%|    if not (a1nan == a2nan).all():
  2454|         0|            0|            0|  0.00%|        return False
  2455|         0|            0|            0|  0.00%|    # Shapes of a1, a2 and masks are guaranteed to be consistent by this point
  2456|         0|            0|            0|  0.00%|    return bool(asarray(a1[~a1nan] == a2[~a1nan]).all())
  2457|         0|            0|            0|  0.00%|
  2458|         0|            0|            0|  0.00%|
  2459|         0|            0|            0|  0.00%|def _array_equiv_dispatcher(a1, a2):
  2460|         0|            0|            0|  0.00%|    return (a1, a2)
  2461|         0|            0|            0|  0.00%|
  2462|         0|            0|            0|  0.00%|
  2463|         0|            0|            0|  0.00%|@array_function_dispatch(_array_equiv_dispatcher)
  2464|         0|            0|            0|  0.00%|def array_equiv(a1, a2):
  2465|         0|            0|            0|  0.00%|    """
  2466|         0|            0|            0|  0.00%|    Returns True if input arrays are shape consistent and all elements equal.
  2467|         0|            0|            0|  0.00%|
  2468|         0|            0|            0|  0.00%|    Shape consistent means they are either the same shape, or one input array
  2469|         0|            0|            0|  0.00%|    can be broadcasted to create the same shape as the other one.
  2470|         0|            0|            0|  0.00%|
  2471|         0|            0|            0|  0.00%|    Parameters
  2472|         0|            0|            0|  0.00%|    ----------
  2473|         0|            0|            0|  0.00%|    a1, a2 : array_like
  2474|         0|            0|            0|  0.00%|        Input arrays.
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|    Returns
  2477|         0|            0|            0|  0.00%|    -------
  2478|         0|            0|            0|  0.00%|    out : bool
  2479|         0|            0|            0|  0.00%|        True if equivalent, False otherwise.
  2480|         0|            0|            0|  0.00%|
  2481|         0|            0|            0|  0.00%|    Examples
  2482|         0|            0|            0|  0.00%|    --------
  2483|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [1, 2])
  2484|         0|            0|            0|  0.00%|    True
  2485|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [1, 3])
  2486|         0|            0|            0|  0.00%|    False
  2487|         0|            0|            0|  0.00%|
  2488|         0|            0|            0|  0.00%|    Showing the shape equivalence:
  2489|         0|            0|            0|  0.00%|
  2490|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
  2491|         0|            0|            0|  0.00%|    True
  2492|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
  2493|         0|            0|            0|  0.00%|    False
  2494|         0|            0|            0|  0.00%|
  2495|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
  2496|         0|            0|            0|  0.00%|    False
  2497|         0|            0|            0|  0.00%|
  2498|         0|            0|            0|  0.00%|    """
  2499|         0|            0|            0|  0.00%|    try:
  2500|         0|            0|            0|  0.00%|        a1, a2 = asarray(a1), asarray(a2)
  2501|         0|            0|            0|  0.00%|    except Exception:
  2502|         0|            0|            0|  0.00%|        return False
  2503|         0|            0|            0|  0.00%|    try:
  2504|         0|            0|            0|  0.00%|        multiarray.broadcast(a1, a2)
  2505|         0|            0|            0|  0.00%|    except Exception:
  2506|         0|            0|            0|  0.00%|        return False
  2507|         0|            0|            0|  0.00%|
  2508|         0|            0|            0|  0.00%|    return bool(asarray(a1 == a2).all())
  2509|         0|            0|            0|  0.00%|
  2510|         0|            0|            0|  0.00%|
  2511|         0|            0|            0|  0.00%|Inf = inf = infty = Infinity = PINF
  2512|         0|            0|            0|  0.00%|nan = NaN = NAN
  2513|         0|            0|            0|  0.00%|False_ = bool_(False)
  2514|         0|            0|            0|  0.00%|True_ = bool_(True)
  2515|         0|            0|            0|  0.00%|
  2516|         0|            0|            0|  0.00%|
  2517|         0|            0|            0|  0.00%|def extend_all(module):
  2518|         0|            0|            0|  0.00%|    existing = set(__all__)
  2519|         0|            0|            0|  0.00%|    mall = getattr(module, '__all__')
  2520|         0|            0|            0|  0.00%|    for a in mall:
  2521|         0|            0|            0|  0.00%|        if a not in existing:
  2522|         0|            0|            0|  0.00%|            __all__.append(a)
  2523|         0|            0|            0|  0.00%|
  2524|         0|            0|            0|  0.00%|
  2525|         0|            0|            0|  0.00%|from .umath import *
  2526|         0|            0|            0|  0.00%|from .numerictypes import *
  2527|         0|            0|            0|  0.00%|from . import fromnumeric
  2528|         0|            0|            0|  0.00%|from .fromnumeric import *
  2529|         0|            0|            0|  0.00%|from . import arrayprint
  2530|         0|            0|            0|  0.00%|from .arrayprint import *
  2531|         0|            0|            0|  0.00%|from . import _asarray
  2532|         0|            0|            0|  0.00%|from ._asarray import *
  2533|         0|            0|            0|  0.00%|from . import _ufunc_config
  2534|         0|            0|            0|  0.00%|from ._ufunc_config import *
  2535|         0|            0|            0|  0.00%|extend_all(fromnumeric)
  2536|         0|            0|            0|  0.00%|extend_all(umath)
  2537|         0|            0|            0|  0.00%|extend_all(numerictypes)
  2538|         0|            0|            0|  0.00%|extend_all(arrayprint)
  2539|         0|            0|            0|  0.00%|extend_all(_asarray)
  2540|         0|            0|            0|  0.00%|extend_all(_ufunc_config)
File: <__array_function__ internals>
File duration: 3.75124s (10.69%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|    191231|     0.352839|  1.84509e-06|  1.01%|
   178|         0|            0|            0|  0.00%|
   179|    191231|      1.21885|  6.37371e-06|  3.47%|
(call)|      2108|    0.0119741|  5.68031e-06|  0.03%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2155 _sum_dispatcher
(call)|       106|   0.00102472|   9.6672e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:842 _copy_dispatcher
(call)|     15020|    0.0566077|  3.76882e-06|  0.16%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:939 _tensordot_dispatcher
(call)|     15020|    0.0623133|  4.14869e-06|  0.18%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:736 dot
(call)|    136310|     0.427301|  3.13477e-06|  1.22%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:883 bincount
(call)|      1094|   0.00407004|  3.72033e-06|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:341 where
(call)|      5878|    0.0373404|  6.35257e-06|  0.11%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:148 concatenate
(call)|      5005|    0.0884912|  1.76806e-05|  0.25%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\shape_base.py:218 _vhstack_dispatcher
(call)|      5005|    0.0152366|  3.04428e-06|  0.04%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\shape_base.py:77 _atleast_2d_dispatcher
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3253 _around_dispatcher
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3253 _around_dispatcher
(call)|        36|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\arraysetops.py:133 _unique_dispatcher
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2491 _cumsum_dispatcher
(call)|      5012|    0.0222249|  4.43434e-06|  0.06%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:1071 copyto
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3160 _ndim_dispatcher
(call)|       100|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:498 can_cast
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:80 empty_like
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py:416 lexsort
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:5333 _append_dispatcher
(call)|        24|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:1751 _ravel_dispatcher
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:1862 _nonzero_dispatcher
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:1291 _diff_dispatcher
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:621 _flatnonzero_dispatcher
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2079 _clip_dispatcher
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3351 _mean_dispatcher
(call)|       337|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:4954 _delete_dispatcher
(call)|        88|  0.000997543|  1.13357e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2399 _all_dispatcher
   180|    382462|      1.80463|  4.71846e-06|  5.14%|
(call)|      2108|     0.106475|    5.051e-05|  0.30%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2160 sum
(call)|       106|   0.00099802|  9.41528e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:846 copy
(call)|     15020|      5.12689|  0.000341338| 14.61%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:943 tensordot
(call)|      5005|     0.177483|  3.54611e-05|  0.51%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\shape_base.py:81 atleast_2d
(call)|      5005|     0.510271|  0.000101952|  1.45%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\shape_base.py:222 vstack
(call)|         8|  0.000998497|  0.000124812|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3257 around
(call)|         8|  0.000998497|  0.000124812|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3764 round_
(call)|        36|   0.00549316|  0.000152588|  0.02%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\arraysetops.py:138 unique
(call)|        16|  0.000995398|  6.22123e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2495 cumsum
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3164 ndim
(call)|        24|  9.98974e-05|  4.16239e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:1755 ravel
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:5337 append
(call)|         8|  7.55787e-05|  9.44734e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:1866 nonzero
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:1295 diff
(call)|         4|  0.000175476|   4.3869e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:625 flatnonzero
(call)|         4|   0.00148654|  0.000371635|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2083 clip
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:3356 mean
(call)|       337|    0.0273204|  8.10694e-05|  0.08%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py:4958 delete
(call)|        88|   0.00212049|  2.40965e-05|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:2404 all
   181|    191231|     0.374917|  1.96055e-06|  1.07%|
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\multiarray.py
File duration: 0.55325s (1.58%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Create the numpy.core.multiarray namespace for backward compatibility. In v1.16
     3|         0|            0|            0|  0.00%|the multiarray and umath c-extension modules were merged into a single
     4|         0|            0|            0|  0.00%|_multiarray_umath extension module. So we replicate the old namespace
     5|         0|            0|            0|  0.00%|by importing from the extension module.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|"""
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|import functools
    10|         0|            0|            0|  0.00%|from . import overrides
    11|         0|            0|            0|  0.00%|from . import _multiarray_umath
    12|         0|            0|            0|  0.00%|from ._multiarray_umath import *  # noqa: F403
    13|         0|            0|            0|  0.00%|# These imports are needed for backward compatibility,
    14|         0|            0|            0|  0.00%|# do not change them. issue gh-15518
    15|         0|            0|            0|  0.00%|# _get_ndarray_c_version is semi-public, on purpose not added to __all__
    16|         0|            0|            0|  0.00%|from ._multiarray_umath import (
    17|         0|            0|            0|  0.00%|    _fastCopyAndTranspose, _flagdict, _from_dlpack, _insert, _reconstruct,
    18|         0|            0|            0|  0.00%|    _vec_string, _ARRAY_API, _monotonicity, _get_ndarray_c_version,
    19|         0|            0|            0|  0.00%|    _set_madvise_hugepage,
    20|         0|            0|            0|  0.00%|    )
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|__all__ = [
    23|         0|            0|            0|  0.00%|    '_ARRAY_API', 'ALLOW_THREADS', 'BUFSIZE', 'CLIP', 'DATETIMEUNITS',
    24|         0|            0|            0|  0.00%|    'ITEM_HASOBJECT', 'ITEM_IS_POINTER', 'LIST_PICKLE', 'MAXDIMS',
    25|         0|            0|            0|  0.00%|    'MAY_SHARE_BOUNDS', 'MAY_SHARE_EXACT', 'NEEDS_INIT', 'NEEDS_PYAPI',
    26|         0|            0|            0|  0.00%|    'RAISE', 'USE_GETITEM', 'USE_SETITEM', 'WRAP', '_fastCopyAndTranspose',
    27|         0|            0|            0|  0.00%|    '_flagdict', '_from_dlpack', '_insert', '_reconstruct', '_vec_string',
    28|         0|            0|            0|  0.00%|    '_monotonicity', 'add_docstring', 'arange', 'array', 'asarray',
    29|         0|            0|            0|  0.00%|    'asanyarray', 'ascontiguousarray', 'asfortranarray', 'bincount',
    30|         0|            0|            0|  0.00%|    'broadcast', 'busday_count', 'busday_offset', 'busdaycalendar', 'can_cast',
    31|         0|            0|            0|  0.00%|    'compare_chararrays', 'concatenate', 'copyto', 'correlate', 'correlate2',
    32|         0|            0|            0|  0.00%|    'count_nonzero', 'c_einsum', 'datetime_as_string', 'datetime_data',
    33|         0|            0|            0|  0.00%|    'dot', 'dragon4_positional', 'dragon4_scientific', 'dtype',
    34|         0|            0|            0|  0.00%|    'empty', 'empty_like', 'error', 'flagsobj', 'flatiter', 'format_longfloat',
    35|         0|            0|            0|  0.00%|    'frombuffer', 'fromfile', 'fromiter', 'fromstring',
    36|         0|            0|            0|  0.00%|    'get_handler_name', 'get_handler_version', 'inner', 'interp',
    37|         0|            0|            0|  0.00%|    'interp_complex', 'is_busday', 'lexsort', 'matmul', 'may_share_memory',
    38|         0|            0|            0|  0.00%|    'min_scalar_type', 'ndarray', 'nditer', 'nested_iters',
    39|         0|            0|            0|  0.00%|    'normalize_axis_index', 'packbits', 'promote_types', 'putmask',
    40|         0|            0|            0|  0.00%|    'ravel_multi_index', 'result_type', 'scalar', 'set_datetimeparse_function',
    41|         0|            0|            0|  0.00%|    'set_legacy_print_mode', 'set_numeric_ops', 'set_string_function',
    42|         0|            0|            0|  0.00%|    'set_typeDict', 'shares_memory', 'tracemalloc_domain', 'typeinfo',
    43|         0|            0|            0|  0.00%|    'unpackbits', 'unravel_index', 'vdot', 'where', 'zeros']
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|# For backward compatibility, make sure pickle imports these functions from here
    46|         0|            0|            0|  0.00%|_reconstruct.__module__ = 'numpy.core.multiarray'
    47|         0|            0|            0|  0.00%|scalar.__module__ = 'numpy.core.multiarray'
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|_from_dlpack.__module__ = 'numpy'
    51|         0|            0|            0|  0.00%|arange.__module__ = 'numpy'
    52|         0|            0|            0|  0.00%|array.__module__ = 'numpy'
    53|         0|            0|            0|  0.00%|asarray.__module__ = 'numpy'
    54|         0|            0|            0|  0.00%|asanyarray.__module__ = 'numpy'
    55|         0|            0|            0|  0.00%|ascontiguousarray.__module__ = 'numpy'
    56|         0|            0|            0|  0.00%|asfortranarray.__module__ = 'numpy'
    57|         0|            0|            0|  0.00%|datetime_data.__module__ = 'numpy'
    58|         0|            0|            0|  0.00%|empty.__module__ = 'numpy'
    59|         0|            0|            0|  0.00%|frombuffer.__module__ = 'numpy'
    60|         0|            0|            0|  0.00%|fromfile.__module__ = 'numpy'
    61|         0|            0|            0|  0.00%|fromiter.__module__ = 'numpy'
    62|         0|            0|            0|  0.00%|frompyfunc.__module__ = 'numpy'
    63|         0|            0|            0|  0.00%|fromstring.__module__ = 'numpy'
    64|         0|            0|            0|  0.00%|geterrobj.__module__ = 'numpy'
    65|         0|            0|            0|  0.00%|may_share_memory.__module__ = 'numpy'
    66|         0|            0|            0|  0.00%|nested_iters.__module__ = 'numpy'
    67|         0|            0|            0|  0.00%|promote_types.__module__ = 'numpy'
    68|         0|            0|            0|  0.00%|set_numeric_ops.__module__ = 'numpy'
    69|         0|            0|            0|  0.00%|seterrobj.__module__ = 'numpy'
    70|         0|            0|            0|  0.00%|zeros.__module__ = 'numpy'
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|# We can't verify dispatcher signatures because NumPy's C functions don't
    74|         0|            0|            0|  0.00%|# support introspection.
    75|         0|            0|            0|  0.00%|array_function_from_c_func_and_dispatcher = functools.partial(
    76|         0|            0|            0|  0.00%|    overrides.array_function_from_dispatcher,
    77|         0|            0|            0|  0.00%|    module='numpy', docs_from_dispatcher=True, verify=False)
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|
    80|         8|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.empty_like)
    81|         0|            0|            0|  0.00%|def empty_like(prototype, dtype=None, order=None, subok=None, shape=None):
    82|         0|            0|            0|  0.00%|    """
    83|         0|            0|            0|  0.00%|    empty_like(prototype, dtype=None, order='K', subok=True, shape=None)
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|    Return a new array with the same shape and type as a given array.
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|    Parameters
    88|         0|            0|            0|  0.00%|    ----------
    89|         0|            0|            0|  0.00%|    prototype : array_like
    90|         0|            0|            0|  0.00%|        The shape and data-type of `prototype` define these same attributes
    91|         0|            0|            0|  0.00%|        of the returned array.
    92|         0|            0|            0|  0.00%|    dtype : data-type, optional
    93|         0|            0|            0|  0.00%|        Overrides the data type of the result.
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
    96|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
    97|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
    98|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `prototype` is Fortran
    99|         0|            0|            0|  0.00%|        contiguous, 'C' otherwise. 'K' means match the layout of `prototype`
   100|         0|            0|            0|  0.00%|        as closely as possible.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   103|         0|            0|            0|  0.00%|    subok : bool, optional.
   104|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
   105|         0|            0|            0|  0.00%|        type of `prototype`, otherwise it will be a base-class array. Defaults
   106|         0|            0|            0|  0.00%|        to True.
   107|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   108|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   109|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   110|         0|            0|            0|  0.00%|        order='C' is implied.
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|    Returns
   115|         0|            0|            0|  0.00%|    -------
   116|         0|            0|            0|  0.00%|    out : ndarray
   117|         0|            0|            0|  0.00%|        Array of uninitialized (arbitrary) data with the same
   118|         0|            0|            0|  0.00%|        shape and type as `prototype`.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    See Also
   121|         0|            0|            0|  0.00%|    --------
   122|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   123|         0|            0|            0|  0.00%|    zeros_like : Return an array of zeros with shape and type of input.
   124|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   125|         0|            0|            0|  0.00%|    empty : Return a new uninitialized array.
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|    Notes
   128|         0|            0|            0|  0.00%|    -----
   129|         0|            0|            0|  0.00%|    This function does *not* initialize the returned array; to do that use
   130|         0|            0|            0|  0.00%|    `zeros_like` or `ones_like` instead.  It may be marginally faster than
   131|         0|            0|            0|  0.00%|    the functions that do set the array values.
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    Examples
   134|         0|            0|            0|  0.00%|    --------
   135|         0|            0|            0|  0.00%|    >>> a = ([1,2,3], [4,5,6])                         # a is array-like
   136|         0|            0|            0|  0.00%|    >>> np.empty_like(a)
   137|         0|            0|            0|  0.00%|    array([[-1073741821, -1073741821,           3],    # uninitialized
   138|         0|            0|            0|  0.00%|           [          0,           0, -1073741821]])
   139|         0|            0|            0|  0.00%|    >>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
   140|         0|            0|            0|  0.00%|    >>> np.empty_like(a)
   141|         0|            0|            0|  0.00%|    array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
   142|         0|            0|            0|  0.00%|           [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    """
   145|         8|            0|            0|  0.00%|    return (prototype,)
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|
   148|      5878|    0.0130117|  2.21363e-06|  0.04%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.concatenate)
   149|         0|            0|            0|  0.00%|def concatenate(arrays, axis=None, out=None, *, dtype=None, casting=None):
   150|         0|            0|            0|  0.00%|    """
   151|         0|            0|            0|  0.00%|    concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    Join a sequence of arrays along an existing axis.
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    Parameters
   156|         0|            0|            0|  0.00%|    ----------
   157|         0|            0|            0|  0.00%|    a1, a2, ... : sequence of array_like
   158|         0|            0|            0|  0.00%|        The arrays must have the same shape, except in the dimension
   159|         0|            0|            0|  0.00%|        corresponding to `axis` (the first, by default).
   160|         0|            0|            0|  0.00%|    axis : int, optional
   161|         0|            0|            0|  0.00%|        The axis along which the arrays will be joined.  If axis is None,
   162|         0|            0|            0|  0.00%|        arrays are flattened before use.  Default is 0.
   163|         0|            0|            0|  0.00%|    out : ndarray, optional
   164|         0|            0|            0|  0.00%|        If provided, the destination to place the result. The shape must be
   165|         0|            0|            0|  0.00%|        correct, matching that of what concatenate would have returned if no
   166|         0|            0|            0|  0.00%|        out argument were specified.
   167|         0|            0|            0|  0.00%|    dtype : str or dtype
   168|         0|            0|            0|  0.00%|        If provided, the destination array will have this dtype. Cannot be
   169|         0|            0|            0|  0.00%|        provided together with `out`.
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
   174|         0|            0|            0|  0.00%|        Controls what kind of data casting may occur. Defaults to 'same_kind'.
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    Returns
   179|         0|            0|            0|  0.00%|    -------
   180|         0|            0|            0|  0.00%|    res : ndarray
   181|         0|            0|            0|  0.00%|        The concatenated array.
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    See Also
   184|         0|            0|            0|  0.00%|    --------
   185|         0|            0|            0|  0.00%|    ma.concatenate : Concatenate function that preserves input masks.
   186|         0|            0|            0|  0.00%|    array_split : Split an array into multiple sub-arrays of equal or
   187|         0|            0|            0|  0.00%|                  near-equal size.
   188|         0|            0|            0|  0.00%|    split : Split array into a list of multiple sub-arrays of equal size.
   189|         0|            0|            0|  0.00%|    hsplit : Split array into multiple sub-arrays horizontally (column wise).
   190|         0|            0|            0|  0.00%|    vsplit : Split array into multiple sub-arrays vertically (row wise).
   191|         0|            0|            0|  0.00%|    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
   192|         0|            0|            0|  0.00%|    stack : Stack a sequence of arrays along a new axis.
   193|         0|            0|            0|  0.00%|    block : Assemble arrays from blocks.
   194|         0|            0|            0|  0.00%|    hstack : Stack arrays in sequence horizontally (column wise).
   195|         0|            0|            0|  0.00%|    vstack : Stack arrays in sequence vertically (row wise).
   196|         0|            0|            0|  0.00%|    dstack : Stack arrays in sequence depth wise (along third dimension).
   197|         0|            0|            0|  0.00%|    column_stack : Stack 1-D arrays as columns into a 2-D array.
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    Notes
   200|         0|            0|            0|  0.00%|    -----
   201|         0|            0|            0|  0.00%|    When one or more of the arrays to be concatenated is a MaskedArray,
   202|         0|            0|            0|  0.00%|    this function will return a MaskedArray object instead of an ndarray,
   203|         0|            0|            0|  0.00%|    but the input masks are *not* preserved. In cases where a MaskedArray
   204|         0|            0|            0|  0.00%|    is expected as input, use the ma.concatenate function from the masked
   205|         0|            0|            0|  0.00%|    array module instead.
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|    Examples
   208|         0|            0|            0|  0.00%|    --------
   209|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
   210|         0|            0|            0|  0.00%|    >>> b = np.array([[5, 6]])
   211|         0|            0|            0|  0.00%|    >>> np.concatenate((a, b), axis=0)
   212|         0|            0|            0|  0.00%|    array([[1, 2],
   213|         0|            0|            0|  0.00%|           [3, 4],
   214|         0|            0|            0|  0.00%|           [5, 6]])
   215|         0|            0|            0|  0.00%|    >>> np.concatenate((a, b.T), axis=1)
   216|         0|            0|            0|  0.00%|    array([[1, 2, 5],
   217|         0|            0|            0|  0.00%|           [3, 4, 6]])
   218|         0|            0|            0|  0.00%|    >>> np.concatenate((a, b), axis=None)
   219|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|    This function will not preserve masking of MaskedArray inputs.
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    >>> a = np.ma.arange(3)
   224|         0|            0|            0|  0.00%|    >>> a[1] = np.ma.masked
   225|         0|            0|            0|  0.00%|    >>> b = np.arange(2, 5)
   226|         0|            0|            0|  0.00%|    >>> a
   227|         0|            0|            0|  0.00%|    masked_array(data=[0, --, 2],
   228|         0|            0|            0|  0.00%|                 mask=[False,  True, False],
   229|         0|            0|            0|  0.00%|           fill_value=999999)
   230|         0|            0|            0|  0.00%|    >>> b
   231|         0|            0|            0|  0.00%|    array([2, 3, 4])
   232|         0|            0|            0|  0.00%|    >>> np.concatenate([a, b])
   233|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, 2, 2, 3, 4],
   234|         0|            0|            0|  0.00%|                 mask=False,
   235|         0|            0|            0|  0.00%|           fill_value=999999)
   236|         0|            0|            0|  0.00%|    >>> np.ma.concatenate([a, b])
   237|         0|            0|            0|  0.00%|    masked_array(data=[0, --, 2, 2, 3, 4],
   238|         0|            0|            0|  0.00%|                 mask=[False,  True, False, False, False, False],
   239|         0|            0|            0|  0.00%|           fill_value=999999)
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    """
   242|      5878|    0.0121355|  2.06456e-06|  0.03%|    if out is not None:
   243|         0|            0|            0|  0.00%|        # optimize for the typical case where only arrays is provided
   244|         0|            0|            0|  0.00%|        arrays = list(arrays)
   245|         0|            0|            0|  0.00%|        arrays.append(out)
   246|      5878|    0.0121932|  2.07438e-06|  0.03%|    return arrays
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.inner)
   250|         0|            0|            0|  0.00%|def inner(a, b):
   251|         0|            0|            0|  0.00%|    """
   252|         0|            0|            0|  0.00%|    inner(a, b, /)
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    Inner product of two arrays.
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|    Ordinary inner product of vectors for 1-D arrays (without complex
   257|         0|            0|            0|  0.00%|    conjugation), in higher dimensions a sum product over the last axes.
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|    Parameters
   260|         0|            0|            0|  0.00%|    ----------
   261|         0|            0|            0|  0.00%|    a, b : array_like
   262|         0|            0|            0|  0.00%|        If `a` and `b` are nonscalar, their last dimensions must match.
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|    Returns
   265|         0|            0|            0|  0.00%|    -------
   266|         0|            0|            0|  0.00%|    out : ndarray
   267|         0|            0|            0|  0.00%|        If `a` and `b` are both
   268|         0|            0|            0|  0.00%|        scalars or both 1-D arrays then a scalar is returned; otherwise
   269|         0|            0|            0|  0.00%|        an array is returned.
   270|         0|            0|            0|  0.00%|        ``out.shape = (*a.shape[:-1], *b.shape[:-1])``
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|    Raises
   273|         0|            0|            0|  0.00%|    ------
   274|         0|            0|            0|  0.00%|    ValueError
   275|         0|            0|            0|  0.00%|        If both `a` and `b` are nonscalar and their last dimensions have
   276|         0|            0|            0|  0.00%|        different sizes.
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|    See Also
   279|         0|            0|            0|  0.00%|    --------
   280|         0|            0|            0|  0.00%|    tensordot : Sum products over arbitrary axes.
   281|         0|            0|            0|  0.00%|    dot : Generalised matrix product, using second last dimension of `b`.
   282|         0|            0|            0|  0.00%|    einsum : Einstein summation convention.
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    Notes
   285|         0|            0|            0|  0.00%|    -----
   286|         0|            0|            0|  0.00%|    For vectors (1-D arrays) it computes the ordinary inner-product::
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|        np.inner(a, b) = sum(a[:]*b[:])
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|    More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|    or explicitly::
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|        np.inner(a, b)[i0,...,ir-2,j0,...,js-2]
   297|         0|            0|            0|  0.00%|             = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|    In addition `a` or `b` may be scalars, in which case::
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|       np.inner(a,b) = a*b
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|    Examples
   304|         0|            0|            0|  0.00%|    --------
   305|         0|            0|            0|  0.00%|    Ordinary inner product for vectors:
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    >>> a = np.array([1,2,3])
   308|         0|            0|            0|  0.00%|    >>> b = np.array([0,1,0])
   309|         0|            0|            0|  0.00%|    >>> np.inner(a, b)
   310|         0|            0|            0|  0.00%|    2
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    Some multidimensional examples:
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|    >>> a = np.arange(24).reshape((2,3,4))
   315|         0|            0|            0|  0.00%|    >>> b = np.arange(4)
   316|         0|            0|            0|  0.00%|    >>> c = np.inner(a, b)
   317|         0|            0|            0|  0.00%|    >>> c.shape
   318|         0|            0|            0|  0.00%|    (2, 3)
   319|         0|            0|            0|  0.00%|    >>> c
   320|         0|            0|            0|  0.00%|    array([[ 14,  38,  62],
   321|         0|            0|            0|  0.00%|           [ 86, 110, 134]])
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    >>> a = np.arange(2).reshape((1,1,2))
   324|         0|            0|            0|  0.00%|    >>> b = np.arange(6).reshape((3,2))
   325|         0|            0|            0|  0.00%|    >>> c = np.inner(a, b)
   326|         0|            0|            0|  0.00%|    >>> c.shape
   327|         0|            0|            0|  0.00%|    (1, 1, 3)
   328|         0|            0|            0|  0.00%|    >>> c
   329|         0|            0|            0|  0.00%|    array([[[1, 3, 5]]])
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    An example where `b` is a scalar:
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    >>> np.inner(np.eye(2), 7)
   334|         0|            0|            0|  0.00%|    array([[7., 0.],
   335|         0|            0|            0|  0.00%|           [0., 7.]])
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|    """
   338|         0|            0|            0|  0.00%|    return (a, b)
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|
   341|      1094|    0.0020709|  1.89297e-06|  0.01%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.where)
   342|         0|            0|            0|  0.00%|def where(condition, x=None, y=None):
   343|         0|            0|            0|  0.00%|    """
   344|         0|            0|            0|  0.00%|    where(condition, [x, y], /)
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    Return elements chosen from `x` or `y` depending on `condition`.
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    .. note::
   349|         0|            0|            0|  0.00%|        When only `condition` is provided, this function is a shorthand for
   350|         0|            0|            0|  0.00%|        ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be
   351|         0|            0|            0|  0.00%|        preferred, as it behaves correctly for subclasses. The rest of this
   352|         0|            0|            0|  0.00%|        documentation covers only the case where all three arguments are
   353|         0|            0|            0|  0.00%|        provided.
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|    Parameters
   356|         0|            0|            0|  0.00%|    ----------
   357|         0|            0|            0|  0.00%|    condition : array_like, bool
   358|         0|            0|            0|  0.00%|        Where True, yield `x`, otherwise yield `y`.
   359|         0|            0|            0|  0.00%|    x, y : array_like
   360|         0|            0|            0|  0.00%|        Values from which to choose. `x`, `y` and `condition` need to be
   361|         0|            0|            0|  0.00%|        broadcastable to some shape.
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    Returns
   364|         0|            0|            0|  0.00%|    -------
   365|         0|            0|            0|  0.00%|    out : ndarray
   366|         0|            0|            0|  0.00%|        An array with elements from `x` where `condition` is True, and elements
   367|         0|            0|            0|  0.00%|        from `y` elsewhere.
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|    See Also
   370|         0|            0|            0|  0.00%|    --------
   371|         0|            0|            0|  0.00%|    choose
   372|         0|            0|            0|  0.00%|    nonzero : The function that is called when x and y are omitted
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    Notes
   375|         0|            0|            0|  0.00%|    -----
   376|         0|            0|            0|  0.00%|    If all the arrays are 1-D, `where` is equivalent to::
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|        [xv if c else yv
   379|         0|            0|            0|  0.00%|         for c, xv, yv in zip(condition, x, y)]
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    Examples
   382|         0|            0|            0|  0.00%|    --------
   383|         0|            0|            0|  0.00%|    >>> a = np.arange(10)
   384|         0|            0|            0|  0.00%|    >>> a
   385|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
   386|         0|            0|            0|  0.00%|    >>> np.where(a < 5, a, 10*a)
   387|         0|            0|            0|  0.00%|    array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    This can be used on multidimensional arrays too:
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    >>> np.where([[True, False], [True, True]],
   392|         0|            0|            0|  0.00%|    ...          [[1, 2], [3, 4]],
   393|         0|            0|            0|  0.00%|    ...          [[9, 8], [7, 6]])
   394|         0|            0|            0|  0.00%|    array([[1, 8],
   395|         0|            0|            0|  0.00%|           [3, 4]])
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|    The shapes of x, y, and the condition are broadcast together:
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    >>> x, y = np.ogrid[:3, :4]
   400|         0|            0|            0|  0.00%|    >>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
   401|         0|            0|            0|  0.00%|    array([[10,  0,  0,  0],
   402|         0|            0|            0|  0.00%|           [10, 11,  1,  1],
   403|         0|            0|            0|  0.00%|           [10, 11, 12,  2]])
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    >>> a = np.array([[0, 1, 2],
   406|         0|            0|            0|  0.00%|    ...               [0, 2, 4],
   407|         0|            0|            0|  0.00%|    ...               [0, 3, 6]])
   408|         0|            0|            0|  0.00%|    >>> np.where(a < 4, a, -1)  # -1 is broadcast
   409|         0|            0|            0|  0.00%|    array([[ 0,  1,  2],
   410|         0|            0|            0|  0.00%|           [ 0,  2, -1],
   411|         0|            0|            0|  0.00%|           [ 0,  3, -1]])
   412|         0|            0|            0|  0.00%|    """
   413|      1094|   0.00199914|  1.82737e-06|  0.01%|    return (condition, x, y)
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|
   416|         4|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.lexsort)
   417|         0|            0|            0|  0.00%|def lexsort(keys, axis=None):
   418|         0|            0|            0|  0.00%|    """
   419|         0|            0|            0|  0.00%|    lexsort(keys, axis=-1)
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|    Perform an indirect stable sort using a sequence of keys.
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    Given multiple sorting keys, which can be interpreted as columns in a
   424|         0|            0|            0|  0.00%|    spreadsheet, lexsort returns an array of integer indices that describes
   425|         0|            0|            0|  0.00%|    the sort order by multiple columns. The last key in the sequence is used
   426|         0|            0|            0|  0.00%|    for the primary sort order, the second-to-last key for the secondary sort
   427|         0|            0|            0|  0.00%|    order, and so on. The keys argument must be a sequence of objects that
   428|         0|            0|            0|  0.00%|    can be converted to arrays of the same shape. If a 2D array is provided
   429|         0|            0|            0|  0.00%|    for the keys argument, its rows are interpreted as the sorting keys and
   430|         0|            0|            0|  0.00%|    sorting is according to the last row, second last row etc.
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    Parameters
   433|         0|            0|            0|  0.00%|    ----------
   434|         0|            0|            0|  0.00%|    keys : (k, N) array or tuple containing k (N,)-shaped sequences
   435|         0|            0|            0|  0.00%|        The `k` different "columns" to be sorted.  The last column (or row if
   436|         0|            0|            0|  0.00%|        `keys` is a 2D array) is the primary sort key.
   437|         0|            0|            0|  0.00%|    axis : int, optional
   438|         0|            0|            0|  0.00%|        Axis to be indirectly sorted.  By default, sort over the last axis.
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|    Returns
   441|         0|            0|            0|  0.00%|    -------
   442|         0|            0|            0|  0.00%|    indices : (N,) ndarray of ints
   443|         0|            0|            0|  0.00%|        Array of indices that sort the keys along the specified axis.
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    See Also
   446|         0|            0|            0|  0.00%|    --------
   447|         0|            0|            0|  0.00%|    argsort : Indirect sort.
   448|         0|            0|            0|  0.00%|    ndarray.sort : In-place sort.
   449|         0|            0|            0|  0.00%|    sort : Return a sorted copy of an array.
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|    Examples
   452|         0|            0|            0|  0.00%|    --------
   453|         0|            0|            0|  0.00%|    Sort names: first by surname, then by name.
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')
   456|         0|            0|            0|  0.00%|    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')
   457|         0|            0|            0|  0.00%|    >>> ind = np.lexsort((first_names, surnames))
   458|         0|            0|            0|  0.00%|    >>> ind
   459|         0|            0|            0|  0.00%|    array([1, 2, 0])
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    >>> [surnames[i] + ", " + first_names[i] for i in ind]
   462|         0|            0|            0|  0.00%|    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|    Sort two columns of numbers:
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|    >>> a = [1,5,1,4,3,4,4] # First column
   467|         0|            0|            0|  0.00%|    >>> b = [9,4,0,4,0,2,1] # Second column
   468|         0|            0|            0|  0.00%|    >>> ind = np.lexsort((b,a)) # Sort by a, then by b
   469|         0|            0|            0|  0.00%|    >>> ind
   470|         0|            0|            0|  0.00%|    array([2, 0, 4, 6, 5, 3, 1])
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|    >>> [(a[i],b[i]) for i in ind]
   473|         0|            0|            0|  0.00%|    [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|    Note that sorting is first according to the elements of ``a``.
   476|         0|            0|            0|  0.00%|    Secondary sorting is according to the elements of ``b``.
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|    A normal ``argsort`` would have yielded:
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|    >>> [(a[i],b[i]) for i in np.argsort(a)]
   481|         0|            0|            0|  0.00%|    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|    Structured arrays are sorted lexically by ``argsort``:
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|    >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
   486|         0|            0|            0|  0.00%|    ...              dtype=np.dtype([('x', int), ('y', int)]))
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|    >>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))
   489|         0|            0|            0|  0.00%|    array([2, 0, 4, 6, 5, 3, 1])
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    """
   492|         4|            0|            0|  0.00%|    if isinstance(keys, tuple):
   493|         4|            0|            0|  0.00%|        return keys
   494|         0|            0|            0|  0.00%|    else:
   495|         0|            0|            0|  0.00%|        return (keys,)
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|
   498|       100|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.can_cast)
   499|         0|            0|            0|  0.00%|def can_cast(from_, to, casting=None):
   500|         0|            0|            0|  0.00%|    """
   501|         0|            0|            0|  0.00%|    can_cast(from_, to, casting='safe')
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|    Returns True if cast between data types can occur according to the
   504|         0|            0|            0|  0.00%|    casting rule.  If from is a scalar or array scalar, also returns
   505|         0|            0|            0|  0.00%|    True if the scalar value can be cast without overflow or truncation
   506|         0|            0|            0|  0.00%|    to an integer.
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|    Parameters
   509|         0|            0|            0|  0.00%|    ----------
   510|         0|            0|            0|  0.00%|    from_ : dtype, dtype specifier, scalar, or array
   511|         0|            0|            0|  0.00%|        Data type, scalar, or array to cast from.
   512|         0|            0|            0|  0.00%|    to : dtype or dtype specifier
   513|         0|            0|            0|  0.00%|        Data type to cast to.
   514|         0|            0|            0|  0.00%|    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
   515|         0|            0|            0|  0.00%|        Controls what kind of data casting may occur.
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|          * 'no' means the data types should not be cast at all.
   518|         0|            0|            0|  0.00%|          * 'equiv' means only byte-order changes are allowed.
   519|         0|            0|            0|  0.00%|          * 'safe' means only casts which can preserve values are allowed.
   520|         0|            0|            0|  0.00%|          * 'same_kind' means only safe casts or casts within a kind,
   521|         0|            0|            0|  0.00%|            like float64 to float32, are allowed.
   522|         0|            0|            0|  0.00%|          * 'unsafe' means any data conversions may be done.
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|    Returns
   525|         0|            0|            0|  0.00%|    -------
   526|         0|            0|            0|  0.00%|    out : bool
   527|         0|            0|            0|  0.00%|        True if cast can occur according to the casting rule.
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|    Notes
   530|         0|            0|            0|  0.00%|    -----
   531|         0|            0|            0|  0.00%|    .. versionchanged:: 1.17.0
   532|         0|            0|            0|  0.00%|       Casting between a simple data type and a structured one is possible only
   533|         0|            0|            0|  0.00%|       for "unsafe" casting.  Casting to multiple fields is allowed, but
   534|         0|            0|            0|  0.00%|       casting from multiple fields is not.
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|    .. versionchanged:: 1.9.0
   537|         0|            0|            0|  0.00%|       Casting from numeric to string types in 'safe' casting mode requires
   538|         0|            0|            0|  0.00%|       that the string dtype length is long enough to store the maximum
   539|         0|            0|            0|  0.00%|       integer/float value converted.
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|    See also
   542|         0|            0|            0|  0.00%|    --------
   543|         0|            0|            0|  0.00%|    dtype, result_type
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|    Examples
   546|         0|            0|            0|  0.00%|    --------
   547|         0|            0|            0|  0.00%|    Basic examples
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|    >>> np.can_cast(np.int32, np.int64)
   550|         0|            0|            0|  0.00%|    True
   551|         0|            0|            0|  0.00%|    >>> np.can_cast(np.float64, complex)
   552|         0|            0|            0|  0.00%|    True
   553|         0|            0|            0|  0.00%|    >>> np.can_cast(complex, float)
   554|         0|            0|            0|  0.00%|    False
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    >>> np.can_cast('i8', 'f8')
   557|         0|            0|            0|  0.00%|    True
   558|         0|            0|            0|  0.00%|    >>> np.can_cast('i8', 'f4')
   559|         0|            0|            0|  0.00%|    False
   560|         0|            0|            0|  0.00%|    >>> np.can_cast('i4', 'S4')
   561|         0|            0|            0|  0.00%|    False
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|    Casting scalars
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|    >>> np.can_cast(100, 'i1')
   566|         0|            0|            0|  0.00%|    True
   567|         0|            0|            0|  0.00%|    >>> np.can_cast(150, 'i1')
   568|         0|            0|            0|  0.00%|    False
   569|         0|            0|            0|  0.00%|    >>> np.can_cast(150, 'u1')
   570|         0|            0|            0|  0.00%|    True
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    >>> np.can_cast(3.5e100, np.float32)
   573|         0|            0|            0|  0.00%|    False
   574|         0|            0|            0|  0.00%|    >>> np.can_cast(1000.0, np.float32)
   575|         0|            0|            0|  0.00%|    True
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|    Array scalar checks the value, array does not
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    >>> np.can_cast(np.array(1000.0), np.float32)
   580|         0|            0|            0|  0.00%|    True
   581|         0|            0|            0|  0.00%|    >>> np.can_cast(np.array([1000.0]), np.float32)
   582|         0|            0|            0|  0.00%|    False
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|    Using the casting rules
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|    >>> np.can_cast('i8', 'i8', 'no')
   587|         0|            0|            0|  0.00%|    True
   588|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i8', 'no')
   589|         0|            0|            0|  0.00%|    False
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i8', 'equiv')
   592|         0|            0|            0|  0.00%|    True
   593|         0|            0|            0|  0.00%|    >>> np.can_cast('<i4', '>i8', 'equiv')
   594|         0|            0|            0|  0.00%|    False
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|    >>> np.can_cast('<i4', '>i8', 'safe')
   597|         0|            0|            0|  0.00%|    True
   598|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i4', 'safe')
   599|         0|            0|            0|  0.00%|    False
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i4', 'same_kind')
   602|         0|            0|            0|  0.00%|    True
   603|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>u4', 'same_kind')
   604|         0|            0|            0|  0.00%|    False
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>u4', 'unsafe')
   607|         0|            0|            0|  0.00%|    True
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|    """
   610|       100|            0|            0|  0.00%|    return (from_,)
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.min_scalar_type)
   614|         0|            0|            0|  0.00%|def min_scalar_type(a):
   615|         0|            0|            0|  0.00%|    """
   616|         0|            0|            0|  0.00%|    min_scalar_type(a, /)
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|    For scalar ``a``, returns the data type with the smallest size
   619|         0|            0|            0|  0.00%|    and smallest scalar kind which can hold its value.  For non-scalar
   620|         0|            0|            0|  0.00%|    array ``a``, returns the vector's dtype unmodified.
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|    Floating point values are not demoted to integers,
   623|         0|            0|            0|  0.00%|    and complex values are not demoted to floats.
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|    Parameters
   626|         0|            0|            0|  0.00%|    ----------
   627|         0|            0|            0|  0.00%|    a : scalar or array_like
   628|         0|            0|            0|  0.00%|        The value whose minimal data type is to be found.
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|    Returns
   631|         0|            0|            0|  0.00%|    -------
   632|         0|            0|            0|  0.00%|    out : dtype
   633|         0|            0|            0|  0.00%|        The minimal data type.
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|    Notes
   636|         0|            0|            0|  0.00%|    -----
   637|         0|            0|            0|  0.00%|    .. versionadded:: 1.6.0
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|    See Also
   640|         0|            0|            0|  0.00%|    --------
   641|         0|            0|            0|  0.00%|    result_type, promote_types, dtype, can_cast
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    Examples
   644|         0|            0|            0|  0.00%|    --------
   645|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(10)
   646|         0|            0|            0|  0.00%|    dtype('uint8')
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(-260)
   649|         0|            0|            0|  0.00%|    dtype('int16')
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(3.1)
   652|         0|            0|            0|  0.00%|    dtype('float16')
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(1e50)
   655|         0|            0|            0|  0.00%|    dtype('float64')
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(np.arange(4,dtype='f8'))
   658|         0|            0|            0|  0.00%|    dtype('float64')
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    """
   661|         0|            0|            0|  0.00%|    return (a,)
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.result_type)
   665|         0|            0|            0|  0.00%|def result_type(*arrays_and_dtypes):
   666|         0|            0|            0|  0.00%|    """
   667|         0|            0|            0|  0.00%|    result_type(*arrays_and_dtypes)
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|    Returns the type that results from applying the NumPy
   670|         0|            0|            0|  0.00%|    type promotion rules to the arguments.
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    Type promotion in NumPy works similarly to the rules in languages
   673|         0|            0|            0|  0.00%|    like C++, with some slight differences.  When both scalars and
   674|         0|            0|            0|  0.00%|    arrays are used, the array's type takes precedence and the actual value
   675|         0|            0|            0|  0.00%|    of the scalar is taken into account.
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|    For example, calculating 3*a, where a is an array of 32-bit floats,
   678|         0|            0|            0|  0.00%|    intuitively should result in a 32-bit float output.  If the 3 is a
   679|         0|            0|            0|  0.00%|    32-bit integer, the NumPy rules indicate it can't convert losslessly
   680|         0|            0|            0|  0.00%|    into a 32-bit float, so a 64-bit float should be the result type.
   681|         0|            0|            0|  0.00%|    By examining the value of the constant, '3', we see that it fits in
   682|         0|            0|            0|  0.00%|    an 8-bit integer, which can be cast losslessly into the 32-bit float.
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|    Parameters
   685|         0|            0|            0|  0.00%|    ----------
   686|         0|            0|            0|  0.00%|    arrays_and_dtypes : list of arrays and dtypes
   687|         0|            0|            0|  0.00%|        The operands of some operation whose result type is needed.
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    Returns
   690|         0|            0|            0|  0.00%|    -------
   691|         0|            0|            0|  0.00%|    out : dtype
   692|         0|            0|            0|  0.00%|        The result type.
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|    See also
   695|         0|            0|            0|  0.00%|    --------
   696|         0|            0|            0|  0.00%|    dtype, promote_types, min_scalar_type, can_cast
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    Notes
   699|         0|            0|            0|  0.00%|    -----
   700|         0|            0|            0|  0.00%|    .. versionadded:: 1.6.0
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|    The specific algorithm used is as follows.
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|    Categories are determined by first checking which of boolean,
   705|         0|            0|            0|  0.00%|    integer (int/uint), or floating point (float/complex) the maximum
   706|         0|            0|            0|  0.00%|    kind of all the arrays and the scalars are.
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|    If there are only scalars or the maximum category of the scalars
   709|         0|            0|            0|  0.00%|    is higher than the maximum category of the arrays,
   710|         0|            0|            0|  0.00%|    the data types are combined with :func:`promote_types`
   711|         0|            0|            0|  0.00%|    to produce the return value.
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|    Otherwise, `min_scalar_type` is called on each array, and
   714|         0|            0|            0|  0.00%|    the resulting data types are all combined with :func:`promote_types`
   715|         0|            0|            0|  0.00%|    to produce the return value.
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|    The set of int values is not a subset of the uint values for types
   718|         0|            0|            0|  0.00%|    with the same number of bits, something not reflected in
   719|         0|            0|            0|  0.00%|    :func:`min_scalar_type`, but handled as a special case in `result_type`.
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|    Examples
   722|         0|            0|            0|  0.00%|    --------
   723|         0|            0|            0|  0.00%|    >>> np.result_type(3, np.arange(7, dtype='i1'))
   724|         0|            0|            0|  0.00%|    dtype('int8')
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|    >>> np.result_type('i4', 'c8')
   727|         0|            0|            0|  0.00%|    dtype('complex128')
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|    >>> np.result_type(3.0, -2)
   730|         0|            0|            0|  0.00%|    dtype('float64')
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|    """
   733|         0|            0|            0|  0.00%|    return arrays_and_dtypes
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|
   736|     15020|    0.0223911|  1.49075e-06|  0.06%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.dot)
   737|         0|            0|            0|  0.00%|def dot(a, b, out=None):
   738|         0|            0|            0|  0.00%|    """
   739|         0|            0|            0|  0.00%|    dot(a, b, out=None)
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|    Dot product of two arrays. Specifically,
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|    - If both `a` and `b` are 1-D arrays, it is inner product of vectors
   744|         0|            0|            0|  0.00%|      (without complex conjugation).
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|    - If both `a` and `b` are 2-D arrays, it is matrix multiplication,
   747|         0|            0|            0|  0.00%|      but using :func:`matmul` or ``a @ b`` is preferred.
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|    - If either `a` or `b` is 0-D (scalar), it is equivalent to :func:`multiply`
   750|         0|            0|            0|  0.00%|      and using ``numpy.multiply(a, b)`` or ``a * b`` is preferred.
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|    - If `a` is an N-D array and `b` is a 1-D array, it is a sum product over
   753|         0|            0|            0|  0.00%|      the last axis of `a` and `b`.
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|    - If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a
   756|         0|            0|            0|  0.00%|      sum product over the last axis of `a` and the second-to-last axis of `b`::
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|        dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|    Parameters
   761|         0|            0|            0|  0.00%|    ----------
   762|         0|            0|            0|  0.00%|    a : array_like
   763|         0|            0|            0|  0.00%|        First argument.
   764|         0|            0|            0|  0.00%|    b : array_like
   765|         0|            0|            0|  0.00%|        Second argument.
   766|         0|            0|            0|  0.00%|    out : ndarray, optional
   767|         0|            0|            0|  0.00%|        Output argument. This must have the exact kind that would be returned
   768|         0|            0|            0|  0.00%|        if it was not used. In particular, it must have the right type, must be
   769|         0|            0|            0|  0.00%|        C-contiguous, and its dtype must be the dtype that would be returned
   770|         0|            0|            0|  0.00%|        for `dot(a,b)`. This is a performance feature. Therefore, if these
   771|         0|            0|            0|  0.00%|        conditions are not met, an exception is raised, instead of attempting
   772|         0|            0|            0|  0.00%|        to be flexible.
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    Returns
   775|         0|            0|            0|  0.00%|    -------
   776|         0|            0|            0|  0.00%|    output : ndarray
   777|         0|            0|            0|  0.00%|        Returns the dot product of `a` and `b`.  If `a` and `b` are both
   778|         0|            0|            0|  0.00%|        scalars or both 1-D arrays then a scalar is returned; otherwise
   779|         0|            0|            0|  0.00%|        an array is returned.
   780|         0|            0|            0|  0.00%|        If `out` is given, then it is returned.
   781|         0|            0|            0|  0.00%|
   782|         0|            0|            0|  0.00%|    Raises
   783|         0|            0|            0|  0.00%|    ------
   784|         0|            0|            0|  0.00%|    ValueError
   785|         0|            0|            0|  0.00%|        If the last dimension of `a` is not the same size as
   786|         0|            0|            0|  0.00%|        the second-to-last dimension of `b`.
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|    See Also
   789|         0|            0|            0|  0.00%|    --------
   790|         0|            0|            0|  0.00%|    vdot : Complex-conjugating dot product.
   791|         0|            0|            0|  0.00%|    tensordot : Sum products over arbitrary axes.
   792|         0|            0|            0|  0.00%|    einsum : Einstein summation convention.
   793|         0|            0|            0|  0.00%|    matmul : '@' operator as method with out parameter.
   794|         0|            0|            0|  0.00%|    linalg.multi_dot : Chained dot product.
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|    Examples
   797|         0|            0|            0|  0.00%|    --------
   798|         0|            0|            0|  0.00%|    >>> np.dot(3, 4)
   799|         0|            0|            0|  0.00%|    12
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|    Neither argument is complex-conjugated:
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|    >>> np.dot([2j, 3j], [2j, 3j])
   804|         0|            0|            0|  0.00%|    (-13+0j)
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    For 2-D arrays it is the matrix product:
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|    >>> a = [[1, 0], [0, 1]]
   809|         0|            0|            0|  0.00%|    >>> b = [[4, 1], [2, 2]]
   810|         0|            0|            0|  0.00%|    >>> np.dot(a, b)
   811|         0|            0|            0|  0.00%|    array([[4, 1],
   812|         0|            0|            0|  0.00%|           [2, 2]])
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|    >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
   815|         0|            0|            0|  0.00%|    >>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
   816|         0|            0|            0|  0.00%|    >>> np.dot(a, b)[2,3,2,1,2,2]
   817|         0|            0|            0|  0.00%|    499128
   818|         0|            0|            0|  0.00%|    >>> sum(a[2,3,2,:] * b[1,2,:,2])
   819|         0|            0|            0|  0.00%|    499128
   820|         0|            0|            0|  0.00%|
   821|         0|            0|            0|  0.00%|    """
   822|     15020|    0.0399222|  2.65794e-06|  0.11%|    return (a, b, out)
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|
   825|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.vdot)
   826|         0|            0|            0|  0.00%|def vdot(a, b):
   827|         0|            0|            0|  0.00%|    """
   828|         0|            0|            0|  0.00%|    vdot(a, b, /)
   829|         0|            0|            0|  0.00%|
   830|         0|            0|            0|  0.00%|    Return the dot product of two vectors.
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    The vdot(`a`, `b`) function handles complex numbers differently than
   833|         0|            0|            0|  0.00%|    dot(`a`, `b`).  If the first argument is complex the complex conjugate
   834|         0|            0|            0|  0.00%|    of the first argument is used for the calculation of the dot product.
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|    Note that `vdot` handles multidimensional arrays differently than `dot`:
   837|         0|            0|            0|  0.00%|    it does *not* perform a matrix product, but flattens input arguments
   838|         0|            0|            0|  0.00%|    to 1-D vectors first. Consequently, it should only be used for vectors.
   839|         0|            0|            0|  0.00%|
   840|         0|            0|            0|  0.00%|    Parameters
   841|         0|            0|            0|  0.00%|    ----------
   842|         0|            0|            0|  0.00%|    a : array_like
   843|         0|            0|            0|  0.00%|        If `a` is complex the complex conjugate is taken before calculation
   844|         0|            0|            0|  0.00%|        of the dot product.
   845|         0|            0|            0|  0.00%|    b : array_like
   846|         0|            0|            0|  0.00%|        Second argument to the dot product.
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|    Returns
   849|         0|            0|            0|  0.00%|    -------
   850|         0|            0|            0|  0.00%|    output : ndarray
   851|         0|            0|            0|  0.00%|        Dot product of `a` and `b`.  Can be an int, float, or
   852|         0|            0|            0|  0.00%|        complex depending on the types of `a` and `b`.
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|    See Also
   855|         0|            0|            0|  0.00%|    --------
   856|         0|            0|            0|  0.00%|    dot : Return the dot product without using the complex conjugate of the
   857|         0|            0|            0|  0.00%|          first argument.
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|    Examples
   860|         0|            0|            0|  0.00%|    --------
   861|         0|            0|            0|  0.00%|    >>> a = np.array([1+2j,3+4j])
   862|         0|            0|            0|  0.00%|    >>> b = np.array([5+6j,7+8j])
   863|         0|            0|            0|  0.00%|    >>> np.vdot(a, b)
   864|         0|            0|            0|  0.00%|    (70-8j)
   865|         0|            0|            0|  0.00%|    >>> np.vdot(b, a)
   866|         0|            0|            0|  0.00%|    (70+8j)
   867|         0|            0|            0|  0.00%|
   868|         0|            0|            0|  0.00%|    Note that higher-dimensional arrays are flattened!
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 4], [5, 6]])
   871|         0|            0|            0|  0.00%|    >>> b = np.array([[4, 1], [2, 2]])
   872|         0|            0|            0|  0.00%|    >>> np.vdot(a, b)
   873|         0|            0|            0|  0.00%|    30
   874|         0|            0|            0|  0.00%|    >>> np.vdot(b, a)
   875|         0|            0|            0|  0.00%|    30
   876|         0|            0|            0|  0.00%|    >>> 1*4 + 4*1 + 5*2 + 6*2
   877|         0|            0|            0|  0.00%|    30
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|    """
   880|         0|            0|            0|  0.00%|    return (a, b)
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|
   883|    136310|     0.176661|  1.29603e-06|  0.50%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.bincount)
   884|         0|            0|            0|  0.00%|def bincount(x, weights=None, minlength=None):
   885|         0|            0|            0|  0.00%|    """
   886|         0|            0|            0|  0.00%|    bincount(x, /, weights=None, minlength=0)
   887|         0|            0|            0|  0.00%|
   888|         0|            0|            0|  0.00%|    Count number of occurrences of each value in array of non-negative ints.
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|    The number of bins (of size 1) is one larger than the largest value in
   891|         0|            0|            0|  0.00%|    `x`. If `minlength` is specified, there will be at least this number
   892|         0|            0|            0|  0.00%|    of bins in the output array (though it will be longer if necessary,
   893|         0|            0|            0|  0.00%|    depending on the contents of `x`).
   894|         0|            0|            0|  0.00%|    Each bin gives the number of occurrences of its index value in `x`.
   895|         0|            0|            0|  0.00%|    If `weights` is specified the input array is weighted by it, i.e. if a
   896|         0|            0|            0|  0.00%|    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead
   897|         0|            0|            0|  0.00%|    of ``out[n] += 1``.
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|    Parameters
   900|         0|            0|            0|  0.00%|    ----------
   901|         0|            0|            0|  0.00%|    x : array_like, 1 dimension, nonnegative ints
   902|         0|            0|            0|  0.00%|        Input array.
   903|         0|            0|            0|  0.00%|    weights : array_like, optional
   904|         0|            0|            0|  0.00%|        Weights, array of the same shape as `x`.
   905|         0|            0|            0|  0.00%|    minlength : int, optional
   906|         0|            0|            0|  0.00%|        A minimum number of bins for the output array.
   907|         0|            0|            0|  0.00%|
   908|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   909|         0|            0|            0|  0.00%|
   910|         0|            0|            0|  0.00%|    Returns
   911|         0|            0|            0|  0.00%|    -------
   912|         0|            0|            0|  0.00%|    out : ndarray of ints
   913|         0|            0|            0|  0.00%|        The result of binning the input array.
   914|         0|            0|            0|  0.00%|        The length of `out` is equal to ``np.amax(x)+1``.
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|    Raises
   917|         0|            0|            0|  0.00%|    ------
   918|         0|            0|            0|  0.00%|    ValueError
   919|         0|            0|            0|  0.00%|        If the input is not 1-dimensional, or contains elements with negative
   920|         0|            0|            0|  0.00%|        values, or if `minlength` is negative.
   921|         0|            0|            0|  0.00%|    TypeError
   922|         0|            0|            0|  0.00%|        If the type of the input is float or complex.
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|    See Also
   925|         0|            0|            0|  0.00%|    --------
   926|         0|            0|            0|  0.00%|    histogram, digitize, unique
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|    Examples
   929|         0|            0|            0|  0.00%|    --------
   930|         0|            0|            0|  0.00%|    >>> np.bincount(np.arange(5))
   931|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1])
   932|         0|            0|            0|  0.00%|    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
   933|         0|            0|            0|  0.00%|    array([1, 3, 1, 1, 0, 0, 0, 1])
   934|         0|            0|            0|  0.00%|
   935|         0|            0|            0|  0.00%|    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
   936|         0|            0|            0|  0.00%|    >>> np.bincount(x).size == np.amax(x)+1
   937|         0|            0|            0|  0.00%|    True
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|    The input array needs to be of integer dtype, otherwise a
   940|         0|            0|            0|  0.00%|    TypeError is raised:
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|    >>> np.bincount(np.arange(5, dtype=float))
   943|         0|            0|            0|  0.00%|    Traceback (most recent call last):
   944|         0|            0|            0|  0.00%|      ...
   945|         0|            0|            0|  0.00%|    TypeError: Cannot cast array data from dtype('float64') to dtype('int64')
   946|         0|            0|            0|  0.00%|    according to the rule 'safe'
   947|         0|            0|            0|  0.00%|
   948|         0|            0|            0|  0.00%|    A possible use of ``bincount`` is to perform sums over
   949|         0|            0|            0|  0.00%|    variable-size chunks of an array, using the ``weights`` keyword.
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
   952|         0|            0|            0|  0.00%|    >>> x = np.array([0, 1, 1, 2, 2, 2])
   953|         0|            0|            0|  0.00%|    >>> np.bincount(x,  weights=w)
   954|         0|            0|            0|  0.00%|    array([ 0.3,  0.7,  1.1])
   955|         0|            0|            0|  0.00%|
   956|         0|            0|            0|  0.00%|    """
   957|    136310|      0.25064|  1.83875e-06|  0.71%|    return (x, weights)
   958|         0|            0|            0|  0.00%|
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.ravel_multi_index)
   961|         0|            0|            0|  0.00%|def ravel_multi_index(multi_index, dims, mode=None, order=None):
   962|         0|            0|            0|  0.00%|    """
   963|         0|            0|            0|  0.00%|    ravel_multi_index(multi_index, dims, mode='raise', order='C')
   964|         0|            0|            0|  0.00%|
   965|         0|            0|            0|  0.00%|    Converts a tuple of index arrays into an array of flat
   966|         0|            0|            0|  0.00%|    indices, applying boundary modes to the multi-index.
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|    Parameters
   969|         0|            0|            0|  0.00%|    ----------
   970|         0|            0|            0|  0.00%|    multi_index : tuple of array_like
   971|         0|            0|            0|  0.00%|        A tuple of integer arrays, one array for each dimension.
   972|         0|            0|            0|  0.00%|    dims : tuple of ints
   973|         0|            0|            0|  0.00%|        The shape of array into which the indices from ``multi_index`` apply.
   974|         0|            0|            0|  0.00%|    mode : {'raise', 'wrap', 'clip'}, optional
   975|         0|            0|            0|  0.00%|        Specifies how out-of-bounds indices are handled.  Can specify
   976|         0|            0|            0|  0.00%|        either one mode or a tuple of modes, one mode per index.
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|        * 'raise' -- raise an error (default)
   979|         0|            0|            0|  0.00%|        * 'wrap' -- wrap around
   980|         0|            0|            0|  0.00%|        * 'clip' -- clip to the range
   981|         0|            0|            0|  0.00%|
   982|         0|            0|            0|  0.00%|        In 'clip' mode, a negative index which would normally
   983|         0|            0|            0|  0.00%|        wrap will clip to 0 instead.
   984|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
   985|         0|            0|            0|  0.00%|        Determines whether the multi-index should be viewed as
   986|         0|            0|            0|  0.00%|        indexing in row-major (C-style) or column-major
   987|         0|            0|            0|  0.00%|        (Fortran-style) order.
   988|         0|            0|            0|  0.00%|
   989|         0|            0|            0|  0.00%|    Returns
   990|         0|            0|            0|  0.00%|    -------
   991|         0|            0|            0|  0.00%|    raveled_indices : ndarray
   992|         0|            0|            0|  0.00%|        An array of indices into the flattened version of an array
   993|         0|            0|            0|  0.00%|        of dimensions ``dims``.
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|    See Also
   996|         0|            0|            0|  0.00%|    --------
   997|         0|            0|            0|  0.00%|    unravel_index
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|    Notes
  1000|         0|            0|            0|  0.00%|    -----
  1001|         0|            0|            0|  0.00%|    .. versionadded:: 1.6.0
  1002|         0|            0|            0|  0.00%|
  1003|         0|            0|            0|  0.00%|    Examples
  1004|         0|            0|            0|  0.00%|    --------
  1005|         0|            0|            0|  0.00%|    >>> arr = np.array([[3,6,6],[4,5,1]])
  1006|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (7,6))
  1007|         0|            0|            0|  0.00%|    array([22, 41, 37])
  1008|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (7,6), order='F')
  1009|         0|            0|            0|  0.00%|    array([31, 41, 13])
  1010|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (4,6), mode='clip')
  1011|         0|            0|            0|  0.00%|    array([22, 23, 19])
  1012|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
  1013|         0|            0|            0|  0.00%|    array([12, 13, 13])
  1014|         0|            0|            0|  0.00%|
  1015|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))
  1016|         0|            0|            0|  0.00%|    1621
  1017|         0|            0|            0|  0.00%|    """
  1018|         0|            0|            0|  0.00%|    return multi_index
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.unravel_index)
  1022|         0|            0|            0|  0.00%|def unravel_index(indices, shape=None, order=None):
  1023|         0|            0|            0|  0.00%|    """
  1024|         0|            0|            0|  0.00%|    unravel_index(indices, shape, order='C')
  1025|         0|            0|            0|  0.00%|
  1026|         0|            0|            0|  0.00%|    Converts a flat index or array of flat indices into a tuple
  1027|         0|            0|            0|  0.00%|    of coordinate arrays.
  1028|         0|            0|            0|  0.00%|
  1029|         0|            0|            0|  0.00%|    Parameters
  1030|         0|            0|            0|  0.00%|    ----------
  1031|         0|            0|            0|  0.00%|    indices : array_like
  1032|         0|            0|            0|  0.00%|        An integer array whose elements are indices into the flattened
  1033|         0|            0|            0|  0.00%|        version of an array of dimensions ``shape``. Before version 1.6.0,
  1034|         0|            0|            0|  0.00%|        this function accepted just one index value.
  1035|         0|            0|            0|  0.00%|    shape : tuple of ints
  1036|         0|            0|            0|  0.00%|        The shape of the array to use for unraveling ``indices``.
  1037|         0|            0|            0|  0.00%|
  1038|         0|            0|            0|  0.00%|        .. versionchanged:: 1.16.0
  1039|         0|            0|            0|  0.00%|            Renamed from ``dims`` to ``shape``.
  1040|         0|            0|            0|  0.00%|
  1041|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
  1042|         0|            0|            0|  0.00%|        Determines whether the indices should be viewed as indexing in
  1043|         0|            0|            0|  0.00%|        row-major (C-style) or column-major (Fortran-style) order.
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|    Returns
  1048|         0|            0|            0|  0.00%|    -------
  1049|         0|            0|            0|  0.00%|    unraveled_coords : tuple of ndarray
  1050|         0|            0|            0|  0.00%|        Each array in the tuple has the same shape as the ``indices``
  1051|         0|            0|            0|  0.00%|        array.
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|    See Also
  1054|         0|            0|            0|  0.00%|    --------
  1055|         0|            0|            0|  0.00%|    ravel_multi_index
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|    Examples
  1058|         0|            0|            0|  0.00%|    --------
  1059|         0|            0|            0|  0.00%|    >>> np.unravel_index([22, 41, 37], (7,6))
  1060|         0|            0|            0|  0.00%|    (array([3, 6, 6]), array([4, 5, 1]))
  1061|         0|            0|            0|  0.00%|    >>> np.unravel_index([31, 41, 13], (7,6), order='F')
  1062|         0|            0|            0|  0.00%|    (array([3, 6, 6]), array([4, 5, 1]))
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|    >>> np.unravel_index(1621, (6,7,8,9))
  1065|         0|            0|            0|  0.00%|    (3, 1, 4, 1)
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|    """
  1068|         0|            0|            0|  0.00%|    return (indices,)
  1069|         0|            0|            0|  0.00%|
  1070|         0|            0|            0|  0.00%|
  1071|      5012|    0.0100675|  2.00867e-06|  0.03%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.copyto)
  1072|         0|            0|            0|  0.00%|def copyto(dst, src, casting=None, where=None):
  1073|         0|            0|            0|  0.00%|    """
  1074|         0|            0|            0|  0.00%|    copyto(dst, src, casting='same_kind', where=True)
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|    Copies values from one array to another, broadcasting as necessary.
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|    Raises a TypeError if the `casting` rule is violated, and if
  1079|         0|            0|            0|  0.00%|    `where` is provided, it selects which elements to copy.
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|    Parameters
  1084|         0|            0|            0|  0.00%|    ----------
  1085|         0|            0|            0|  0.00%|    dst : ndarray
  1086|         0|            0|            0|  0.00%|        The array into which values are copied.
  1087|         0|            0|            0|  0.00%|    src : array_like
  1088|         0|            0|            0|  0.00%|        The array from which values are copied.
  1089|         0|            0|            0|  0.00%|    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
  1090|         0|            0|            0|  0.00%|        Controls what kind of data casting may occur when copying.
  1091|         0|            0|            0|  0.00%|
  1092|         0|            0|            0|  0.00%|          * 'no' means the data types should not be cast at all.
  1093|         0|            0|            0|  0.00%|          * 'equiv' means only byte-order changes are allowed.
  1094|         0|            0|            0|  0.00%|          * 'safe' means only casts which can preserve values are allowed.
  1095|         0|            0|            0|  0.00%|          * 'same_kind' means only safe casts or casts within a kind,
  1096|         0|            0|            0|  0.00%|            like float64 to float32, are allowed.
  1097|         0|            0|            0|  0.00%|          * 'unsafe' means any data conversions may be done.
  1098|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  1099|         0|            0|            0|  0.00%|        A boolean array which is broadcasted to match the dimensions
  1100|         0|            0|            0|  0.00%|        of `dst`, and selects elements to copy from `src` to `dst`
  1101|         0|            0|            0|  0.00%|        wherever it contains the value True.
  1102|         0|            0|            0|  0.00%|    """
  1103|      5012|    0.0121574|  2.42567e-06|  0.03%|    return (dst, src, where)
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.putmask)
  1107|         0|            0|            0|  0.00%|def putmask(a, mask, values):
  1108|         0|            0|            0|  0.00%|    """
  1109|         0|            0|            0|  0.00%|    putmask(a, mask, values)
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|    Changes elements of an array based on conditional and input values.
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.
  1114|         0|            0|            0|  0.00%|
  1115|         0|            0|            0|  0.00%|    If `values` is not the same size as `a` and `mask` then it will repeat.
  1116|         0|            0|            0|  0.00%|    This gives behavior different from ``a[mask] = values``.
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|    Parameters
  1119|         0|            0|            0|  0.00%|    ----------
  1120|         0|            0|            0|  0.00%|    a : ndarray
  1121|         0|            0|            0|  0.00%|        Target array.
  1122|         0|            0|            0|  0.00%|    mask : array_like
  1123|         0|            0|            0|  0.00%|        Boolean mask array. It has to be the same shape as `a`.
  1124|         0|            0|            0|  0.00%|    values : array_like
  1125|         0|            0|            0|  0.00%|        Values to put into `a` where `mask` is True. If `values` is smaller
  1126|         0|            0|            0|  0.00%|        than `a` it will be repeated.
  1127|         0|            0|            0|  0.00%|
  1128|         0|            0|            0|  0.00%|    See Also
  1129|         0|            0|            0|  0.00%|    --------
  1130|         0|            0|            0|  0.00%|    place, put, take, copyto
  1131|         0|            0|            0|  0.00%|
  1132|         0|            0|            0|  0.00%|    Examples
  1133|         0|            0|            0|  0.00%|    --------
  1134|         0|            0|            0|  0.00%|    >>> x = np.arange(6).reshape(2, 3)
  1135|         0|            0|            0|  0.00%|    >>> np.putmask(x, x>2, x**2)
  1136|         0|            0|            0|  0.00%|    >>> x
  1137|         0|            0|            0|  0.00%|    array([[ 0,  1,  2],
  1138|         0|            0|            0|  0.00%|           [ 9, 16, 25]])
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|    If `values` is smaller than `a` it is repeated:
  1141|         0|            0|            0|  0.00%|
  1142|         0|            0|            0|  0.00%|    >>> x = np.arange(5)
  1143|         0|            0|            0|  0.00%|    >>> np.putmask(x, x>1, [-33, -44])
  1144|         0|            0|            0|  0.00%|    >>> x
  1145|         0|            0|            0|  0.00%|    array([  0,   1, -33, -44, -33])
  1146|         0|            0|            0|  0.00%|
  1147|         0|            0|            0|  0.00%|    """
  1148|         0|            0|            0|  0.00%|    return (a, mask, values)
  1149|         0|            0|            0|  0.00%|
  1150|         0|            0|            0|  0.00%|
  1151|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.packbits)
  1152|         0|            0|            0|  0.00%|def packbits(a, axis=None, bitorder='big'):
  1153|         0|            0|            0|  0.00%|    """
  1154|         0|            0|            0|  0.00%|    packbits(a, /, axis=None, bitorder='big')
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|    Packs the elements of a binary-valued array into bits in a uint8 array.
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|    The result is padded to full bytes by inserting zero bits at the end.
  1159|         0|            0|            0|  0.00%|
  1160|         0|            0|            0|  0.00%|    Parameters
  1161|         0|            0|            0|  0.00%|    ----------
  1162|         0|            0|            0|  0.00%|    a : array_like
  1163|         0|            0|            0|  0.00%|        An array of integers or booleans whose elements should be packed to
  1164|         0|            0|            0|  0.00%|        bits.
  1165|         0|            0|            0|  0.00%|    axis : int, optional
  1166|         0|            0|            0|  0.00%|        The dimension over which bit-packing is done.
  1167|         0|            0|            0|  0.00%|        ``None`` implies packing the flattened array.
  1168|         0|            0|            0|  0.00%|    bitorder : {'big', 'little'}, optional
  1169|         0|            0|            0|  0.00%|        The order of the input bits. 'big' will mimic bin(val),
  1170|         0|            0|            0|  0.00%|        ``[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011``, 'little' will
  1171|         0|            0|            0|  0.00%|        reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] => 3``.
  1172|         0|            0|            0|  0.00%|        Defaults to 'big'.
  1173|         0|            0|            0|  0.00%|
  1174|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|    Returns
  1177|         0|            0|            0|  0.00%|    -------
  1178|         0|            0|            0|  0.00%|    packed : ndarray
  1179|         0|            0|            0|  0.00%|        Array of type uint8 whose elements represent bits corresponding to the
  1180|         0|            0|            0|  0.00%|        logical (0 or nonzero) value of the input elements. The shape of
  1181|         0|            0|            0|  0.00%|        `packed` has the same number of dimensions as the input (unless `axis`
  1182|         0|            0|            0|  0.00%|        is None, in which case the output is 1-D).
  1183|         0|            0|            0|  0.00%|
  1184|         0|            0|            0|  0.00%|    See Also
  1185|         0|            0|            0|  0.00%|    --------
  1186|         0|            0|            0|  0.00%|    unpackbits: Unpacks elements of a uint8 array into a binary-valued output
  1187|         0|            0|            0|  0.00%|                array.
  1188|         0|            0|            0|  0.00%|
  1189|         0|            0|            0|  0.00%|    Examples
  1190|         0|            0|            0|  0.00%|    --------
  1191|         0|            0|            0|  0.00%|    >>> a = np.array([[[1,0,1],
  1192|         0|            0|            0|  0.00%|    ...                [0,1,0]],
  1193|         0|            0|            0|  0.00%|    ...               [[1,1,0],
  1194|         0|            0|            0|  0.00%|    ...                [0,0,1]]])
  1195|         0|            0|            0|  0.00%|    >>> b = np.packbits(a, axis=-1)
  1196|         0|            0|            0|  0.00%|    >>> b
  1197|         0|            0|            0|  0.00%|    array([[[160],
  1198|         0|            0|            0|  0.00%|            [ 64]],
  1199|         0|            0|            0|  0.00%|           [[192],
  1200|         0|            0|            0|  0.00%|            [ 32]]], dtype=uint8)
  1201|         0|            0|            0|  0.00%|
  1202|         0|            0|            0|  0.00%|    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
  1203|         0|            0|            0|  0.00%|    and 32 = 0010 0000.
  1204|         0|            0|            0|  0.00%|
  1205|         0|            0|            0|  0.00%|    """
  1206|         0|            0|            0|  0.00%|    return (a,)
  1207|         0|            0|            0|  0.00%|
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.unpackbits)
  1210|         0|            0|            0|  0.00%|def unpackbits(a, axis=None, count=None, bitorder='big'):
  1211|         0|            0|            0|  0.00%|    """
  1212|         0|            0|            0|  0.00%|    unpackbits(a, /, axis=None, count=None, bitorder='big')
  1213|         0|            0|            0|  0.00%|
  1214|         0|            0|            0|  0.00%|    Unpacks elements of a uint8 array into a binary-valued output array.
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|    Each element of `a` represents a bit-field that should be unpacked
  1217|         0|            0|            0|  0.00%|    into a binary-valued output array. The shape of the output array is
  1218|         0|            0|            0|  0.00%|    either 1-D (if `axis` is ``None``) or the same shape as the input
  1219|         0|            0|            0|  0.00%|    array with unpacking done along the axis specified.
  1220|         0|            0|            0|  0.00%|
  1221|         0|            0|            0|  0.00%|    Parameters
  1222|         0|            0|            0|  0.00%|    ----------
  1223|         0|            0|            0|  0.00%|    a : ndarray, uint8 type
  1224|         0|            0|            0|  0.00%|       Input array.
  1225|         0|            0|            0|  0.00%|    axis : int, optional
  1226|         0|            0|            0|  0.00%|        The dimension over which bit-unpacking is done.
  1227|         0|            0|            0|  0.00%|        ``None`` implies unpacking the flattened array.
  1228|         0|            0|            0|  0.00%|    count : int or None, optional
  1229|         0|            0|            0|  0.00%|        The number of elements to unpack along `axis`, provided as a way
  1230|         0|            0|            0|  0.00%|        of undoing the effect of packing a size that is not a multiple
  1231|         0|            0|            0|  0.00%|        of eight. A non-negative number means to only unpack `count`
  1232|         0|            0|            0|  0.00%|        bits. A negative number means to trim off that many bits from
  1233|         0|            0|            0|  0.00%|        the end. ``None`` means to unpack the entire array (the
  1234|         0|            0|            0|  0.00%|        default). Counts larger than the available number of bits will
  1235|         0|            0|            0|  0.00%|        add zero padding to the output. Negative counts must not
  1236|         0|            0|            0|  0.00%|        exceed the available number of bits.
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1239|         0|            0|            0|  0.00%|
  1240|         0|            0|            0|  0.00%|    bitorder : {'big', 'little'}, optional
  1241|         0|            0|            0|  0.00%|        The order of the returned bits. 'big' will mimic bin(val),
  1242|         0|            0|            0|  0.00%|        ``3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse
  1243|         0|            0|            0|  0.00%|        the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.
  1244|         0|            0|            0|  0.00%|        Defaults to 'big'.
  1245|         0|            0|            0|  0.00%|
  1246|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1247|         0|            0|            0|  0.00%|
  1248|         0|            0|            0|  0.00%|    Returns
  1249|         0|            0|            0|  0.00%|    -------
  1250|         0|            0|            0|  0.00%|    unpacked : ndarray, uint8 type
  1251|         0|            0|            0|  0.00%|       The elements are binary-valued (0 or 1).
  1252|         0|            0|            0|  0.00%|
  1253|         0|            0|            0|  0.00%|    See Also
  1254|         0|            0|            0|  0.00%|    --------
  1255|         0|            0|            0|  0.00%|    packbits : Packs the elements of a binary-valued array into bits in
  1256|         0|            0|            0|  0.00%|               a uint8 array.
  1257|         0|            0|            0|  0.00%|
  1258|         0|            0|            0|  0.00%|    Examples
  1259|         0|            0|            0|  0.00%|    --------
  1260|         0|            0|            0|  0.00%|    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)
  1261|         0|            0|            0|  0.00%|    >>> a
  1262|         0|            0|            0|  0.00%|    array([[ 2],
  1263|         0|            0|            0|  0.00%|           [ 7],
  1264|         0|            0|            0|  0.00%|           [23]], dtype=uint8)
  1265|         0|            0|            0|  0.00%|    >>> b = np.unpackbits(a, axis=1)
  1266|         0|            0|            0|  0.00%|    >>> b
  1267|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0, 0, 0, 1, 0],
  1268|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 1, 1, 1],
  1269|         0|            0|            0|  0.00%|           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
  1270|         0|            0|            0|  0.00%|    >>> c = np.unpackbits(a, axis=1, count=-3)
  1271|         0|            0|            0|  0.00%|    >>> c
  1272|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0, 0],
  1273|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0],
  1274|         0|            0|            0|  0.00%|           [0, 0, 0, 1, 0]], dtype=uint8)
  1275|         0|            0|            0|  0.00%|
  1276|         0|            0|            0|  0.00%|    >>> p = np.packbits(b, axis=0)
  1277|         0|            0|            0|  0.00%|    >>> np.unpackbits(p, axis=0)
  1278|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0, 0, 0, 1, 0],
  1279|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 1, 1, 1],
  1280|         0|            0|            0|  0.00%|           [0, 0, 0, 1, 0, 1, 1, 1],
  1281|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1282|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1283|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1284|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1285|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
  1286|         0|            0|            0|  0.00%|    >>> np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))
  1287|         0|            0|            0|  0.00%|    True
  1288|         0|            0|            0|  0.00%|
  1289|         0|            0|            0|  0.00%|    """
  1290|         0|            0|            0|  0.00%|    return (a,)
  1291|         0|            0|            0|  0.00%|
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.shares_memory)
  1294|         0|            0|            0|  0.00%|def shares_memory(a, b, max_work=None):
  1295|         0|            0|            0|  0.00%|    """
  1296|         0|            0|            0|  0.00%|    shares_memory(a, b, /, max_work=None)
  1297|         0|            0|            0|  0.00%|
  1298|         0|            0|            0|  0.00%|    Determine if two arrays share memory.
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|    .. warning::
  1301|         0|            0|            0|  0.00%|
  1302|         0|            0|            0|  0.00%|       This function can be exponentially slow for some inputs, unless
  1303|         0|            0|            0|  0.00%|       `max_work` is set to a finite number or ``MAY_SHARE_BOUNDS``.
  1304|         0|            0|            0|  0.00%|       If in doubt, use `numpy.may_share_memory` instead.
  1305|         0|            0|            0|  0.00%|
  1306|         0|            0|            0|  0.00%|    Parameters
  1307|         0|            0|            0|  0.00%|    ----------
  1308|         0|            0|            0|  0.00%|    a, b : ndarray
  1309|         0|            0|            0|  0.00%|        Input arrays
  1310|         0|            0|            0|  0.00%|    max_work : int, optional
  1311|         0|            0|            0|  0.00%|        Effort to spend on solving the overlap problem (maximum number
  1312|         0|            0|            0|  0.00%|        of candidate solutions to consider). The following special
  1313|         0|            0|            0|  0.00%|        values are recognized:
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|        max_work=MAY_SHARE_EXACT  (default)
  1316|         0|            0|            0|  0.00%|            The problem is solved exactly. In this case, the function returns
  1317|         0|            0|            0|  0.00%|            True only if there is an element shared between the arrays. Finding
  1318|         0|            0|            0|  0.00%|            the exact solution may take extremely long in some cases.
  1319|         0|            0|            0|  0.00%|        max_work=MAY_SHARE_BOUNDS
  1320|         0|            0|            0|  0.00%|            Only the memory bounds of a and b are checked.
  1321|         0|            0|            0|  0.00%|
  1322|         0|            0|            0|  0.00%|    Raises
  1323|         0|            0|            0|  0.00%|    ------
  1324|         0|            0|            0|  0.00%|    numpy.TooHardError
  1325|         0|            0|            0|  0.00%|        Exceeded max_work.
  1326|         0|            0|            0|  0.00%|
  1327|         0|            0|            0|  0.00%|    Returns
  1328|         0|            0|            0|  0.00%|    -------
  1329|         0|            0|            0|  0.00%|    out : bool
  1330|         0|            0|            0|  0.00%|
  1331|         0|            0|            0|  0.00%|    See Also
  1332|         0|            0|            0|  0.00%|    --------
  1333|         0|            0|            0|  0.00%|    may_share_memory
  1334|         0|            0|            0|  0.00%|
  1335|         0|            0|            0|  0.00%|    Examples
  1336|         0|            0|            0|  0.00%|    --------
  1337|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 3, 4])
  1338|         0|            0|            0|  0.00%|    >>> np.shares_memory(x, np.array([5, 6, 7]))
  1339|         0|            0|            0|  0.00%|    False
  1340|         0|            0|            0|  0.00%|    >>> np.shares_memory(x[::2], x)
  1341|         0|            0|            0|  0.00%|    True
  1342|         0|            0|            0|  0.00%|    >>> np.shares_memory(x[::2], x[1::2])
  1343|         0|            0|            0|  0.00%|    False
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|    Checking whether two arrays share memory is NP-complete, and
  1346|         0|            0|            0|  0.00%|    runtime may increase exponentially in the number of
  1347|         0|            0|            0|  0.00%|    dimensions. Hence, `max_work` should generally be set to a finite
  1348|         0|            0|            0|  0.00%|    number, as it is possible to construct examples that take
  1349|         0|            0|            0|  0.00%|    extremely long to run:
  1350|         0|            0|            0|  0.00%|
  1351|         0|            0|            0|  0.00%|    >>> from numpy.lib.stride_tricks import as_strided
  1352|         0|            0|            0|  0.00%|    >>> x = np.zeros([192163377], dtype=np.int8)
  1353|         0|            0|            0|  0.00%|    >>> x1 = as_strided(x, strides=(36674, 61119, 85569), shape=(1049, 1049, 1049))
  1354|         0|            0|            0|  0.00%|    >>> x2 = as_strided(x[64023025:], strides=(12223, 12224, 1), shape=(1049, 1049, 1))
  1355|         0|            0|            0|  0.00%|    >>> np.shares_memory(x1, x2, max_work=1000)
  1356|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1357|         0|            0|            0|  0.00%|    ...
  1358|         0|            0|            0|  0.00%|    numpy.TooHardError: Exceeded max_work
  1359|         0|            0|            0|  0.00%|
  1360|         0|            0|            0|  0.00%|    Running ``np.shares_memory(x1, x2)`` without `max_work` set takes
  1361|         0|            0|            0|  0.00%|    around 1 minute for this case. It is possible to find problems
  1362|         0|            0|            0|  0.00%|    that take still significantly longer.
  1363|         0|            0|            0|  0.00%|
  1364|         0|            0|            0|  0.00%|    """
  1365|         0|            0|            0|  0.00%|    return (a, b)
  1366|         0|            0|            0|  0.00%|
  1367|         0|            0|            0|  0.00%|
  1368|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.may_share_memory)
  1369|         0|            0|            0|  0.00%|def may_share_memory(a, b, max_work=None):
  1370|         0|            0|            0|  0.00%|    """
  1371|         0|            0|            0|  0.00%|    may_share_memory(a, b, /, max_work=None)
  1372|         0|            0|            0|  0.00%|
  1373|         0|            0|            0|  0.00%|    Determine if two arrays might share memory
  1374|         0|            0|            0|  0.00%|
  1375|         0|            0|            0|  0.00%|    A return of True does not necessarily mean that the two arrays
  1376|         0|            0|            0|  0.00%|    share any element.  It just means that they *might*.
  1377|         0|            0|            0|  0.00%|
  1378|         0|            0|            0|  0.00%|    Only the memory bounds of a and b are checked by default.
  1379|         0|            0|            0|  0.00%|
  1380|         0|            0|            0|  0.00%|    Parameters
  1381|         0|            0|            0|  0.00%|    ----------
  1382|         0|            0|            0|  0.00%|    a, b : ndarray
  1383|         0|            0|            0|  0.00%|        Input arrays
  1384|         0|            0|            0|  0.00%|    max_work : int, optional
  1385|         0|            0|            0|  0.00%|        Effort to spend on solving the overlap problem.  See
  1386|         0|            0|            0|  0.00%|        `shares_memory` for details.  Default for ``may_share_memory``
  1387|         0|            0|            0|  0.00%|        is to do a bounds check.
  1388|         0|            0|            0|  0.00%|
  1389|         0|            0|            0|  0.00%|    Returns
  1390|         0|            0|            0|  0.00%|    -------
  1391|         0|            0|            0|  0.00%|    out : bool
  1392|         0|            0|            0|  0.00%|
  1393|         0|            0|            0|  0.00%|    See Also
  1394|         0|            0|            0|  0.00%|    --------
  1395|         0|            0|            0|  0.00%|    shares_memory
  1396|         0|            0|            0|  0.00%|
  1397|         0|            0|            0|  0.00%|    Examples
  1398|         0|            0|            0|  0.00%|    --------
  1399|         0|            0|            0|  0.00%|    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
  1400|         0|            0|            0|  0.00%|    False
  1401|         0|            0|            0|  0.00%|    >>> x = np.zeros([3, 4])
  1402|         0|            0|            0|  0.00%|    >>> np.may_share_memory(x[:,0], x[:,1])
  1403|         0|            0|            0|  0.00%|    True
  1404|         0|            0|            0|  0.00%|
  1405|         0|            0|            0|  0.00%|    """
  1406|         0|            0|            0|  0.00%|    return (a, b)
  1407|         0|            0|            0|  0.00%|
  1408|         0|            0|            0|  0.00%|
  1409|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.is_busday)
  1410|         0|            0|            0|  0.00%|def is_busday(dates, weekmask=None, holidays=None, busdaycal=None, out=None):
  1411|         0|            0|            0|  0.00%|    """
  1412|         0|            0|            0|  0.00%|    is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)
  1413|         0|            0|            0|  0.00%|
  1414|         0|            0|            0|  0.00%|    Calculates which of the given dates are valid days, and which are not.
  1415|         0|            0|            0|  0.00%|
  1416|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1417|         0|            0|            0|  0.00%|
  1418|         0|            0|            0|  0.00%|    Parameters
  1419|         0|            0|            0|  0.00%|    ----------
  1420|         0|            0|            0|  0.00%|    dates : array_like of datetime64[D]
  1421|         0|            0|            0|  0.00%|        The array of dates to process.
  1422|         0|            0|            0|  0.00%|    weekmask : str or array_like of bool, optional
  1423|         0|            0|            0|  0.00%|        A seven-element array indicating which of Monday through Sunday are
  1424|         0|            0|            0|  0.00%|        valid days. May be specified as a length-seven list or array, like
  1425|         0|            0|            0|  0.00%|        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
  1426|         0|            0|            0|  0.00%|        like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
  1427|         0|            0|            0|  0.00%|        weekdays, optionally separated by white space. Valid abbreviations
  1428|         0|            0|            0|  0.00%|        are: Mon Tue Wed Thu Fri Sat Sun
  1429|         0|            0|            0|  0.00%|    holidays : array_like of datetime64[D], optional
  1430|         0|            0|            0|  0.00%|        An array of dates to consider as invalid dates.  They may be
  1431|         0|            0|            0|  0.00%|        specified in any order, and NaT (not-a-time) dates are ignored.
  1432|         0|            0|            0|  0.00%|        This list is saved in a normalized form that is suited for
  1433|         0|            0|            0|  0.00%|        fast calculations of valid days.
  1434|         0|            0|            0|  0.00%|    busdaycal : busdaycalendar, optional
  1435|         0|            0|            0|  0.00%|        A `busdaycalendar` object which specifies the valid days. If this
  1436|         0|            0|            0|  0.00%|        parameter is provided, neither weekmask nor holidays may be
  1437|         0|            0|            0|  0.00%|        provided.
  1438|         0|            0|            0|  0.00%|    out : array of bool, optional
  1439|         0|            0|            0|  0.00%|        If provided, this array is filled with the result.
  1440|         0|            0|            0|  0.00%|
  1441|         0|            0|            0|  0.00%|    Returns
  1442|         0|            0|            0|  0.00%|    -------
  1443|         0|            0|            0|  0.00%|    out : array of bool
  1444|         0|            0|            0|  0.00%|        An array with the same shape as ``dates``, containing True for
  1445|         0|            0|            0|  0.00%|        each valid day, and False for each invalid day.
  1446|         0|            0|            0|  0.00%|
  1447|         0|            0|            0|  0.00%|    See Also
  1448|         0|            0|            0|  0.00%|    --------
  1449|         0|            0|            0|  0.00%|    busdaycalendar : An object that specifies a custom set of valid days.
  1450|         0|            0|            0|  0.00%|    busday_offset : Applies an offset counted in valid days.
  1451|         0|            0|            0|  0.00%|    busday_count : Counts how many valid days are in a half-open date range.
  1452|         0|            0|            0|  0.00%|
  1453|         0|            0|            0|  0.00%|    Examples
  1454|         0|            0|            0|  0.00%|    --------
  1455|         0|            0|            0|  0.00%|    >>> # The weekdays are Friday, Saturday, and Monday
  1456|         0|            0|            0|  0.00%|    ... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
  1457|         0|            0|            0|  0.00%|    ...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
  1458|         0|            0|            0|  0.00%|    array([False, False,  True])
  1459|         0|            0|            0|  0.00%|    """
  1460|         0|            0|            0|  0.00%|    return (dates, weekmask, holidays, out)
  1461|         0|            0|            0|  0.00%|
  1462|         0|            0|            0|  0.00%|
  1463|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_offset)
  1464|         0|            0|            0|  0.00%|def busday_offset(dates, offsets, roll=None, weekmask=None, holidays=None,
  1465|         0|            0|            0|  0.00%|                  busdaycal=None, out=None):
  1466|         0|            0|            0|  0.00%|    """
  1467|         0|            0|            0|  0.00%|    busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)
  1468|         0|            0|            0|  0.00%|
  1469|         0|            0|            0|  0.00%|    First adjusts the date to fall on a valid day according to
  1470|         0|            0|            0|  0.00%|    the ``roll`` rule, then applies offsets to the given dates
  1471|         0|            0|            0|  0.00%|    counted in valid days.
  1472|         0|            0|            0|  0.00%|
  1473|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1474|         0|            0|            0|  0.00%|
  1475|         0|            0|            0|  0.00%|    Parameters
  1476|         0|            0|            0|  0.00%|    ----------
  1477|         0|            0|            0|  0.00%|    dates : array_like of datetime64[D]
  1478|         0|            0|            0|  0.00%|        The array of dates to process.
  1479|         0|            0|            0|  0.00%|    offsets : array_like of int
  1480|         0|            0|            0|  0.00%|        The array of offsets, which is broadcast with ``dates``.
  1481|         0|            0|            0|  0.00%|    roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional
  1482|         0|            0|            0|  0.00%|        How to treat dates that do not fall on a valid day. The default
  1483|         0|            0|            0|  0.00%|        is 'raise'.
  1484|         0|            0|            0|  0.00%|
  1485|         0|            0|            0|  0.00%|          * 'raise' means to raise an exception for an invalid day.
  1486|         0|            0|            0|  0.00%|          * 'nat' means to return a NaT (not-a-time) for an invalid day.
  1487|         0|            0|            0|  0.00%|          * 'forward' and 'following' mean to take the first valid day
  1488|         0|            0|            0|  0.00%|            later in time.
  1489|         0|            0|            0|  0.00%|          * 'backward' and 'preceding' mean to take the first valid day
  1490|         0|            0|            0|  0.00%|            earlier in time.
  1491|         0|            0|            0|  0.00%|          * 'modifiedfollowing' means to take the first valid day
  1492|         0|            0|            0|  0.00%|            later in time unless it is across a Month boundary, in which
  1493|         0|            0|            0|  0.00%|            case to take the first valid day earlier in time.
  1494|         0|            0|            0|  0.00%|          * 'modifiedpreceding' means to take the first valid day
  1495|         0|            0|            0|  0.00%|            earlier in time unless it is across a Month boundary, in which
  1496|         0|            0|            0|  0.00%|            case to take the first valid day later in time.
  1497|         0|            0|            0|  0.00%|    weekmask : str or array_like of bool, optional
  1498|         0|            0|            0|  0.00%|        A seven-element array indicating which of Monday through Sunday are
  1499|         0|            0|            0|  0.00%|        valid days. May be specified as a length-seven list or array, like
  1500|         0|            0|            0|  0.00%|        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
  1501|         0|            0|            0|  0.00%|        like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
  1502|         0|            0|            0|  0.00%|        weekdays, optionally separated by white space. Valid abbreviations
  1503|         0|            0|            0|  0.00%|        are: Mon Tue Wed Thu Fri Sat Sun
  1504|         0|            0|            0|  0.00%|    holidays : array_like of datetime64[D], optional
  1505|         0|            0|            0|  0.00%|        An array of dates to consider as invalid dates.  They may be
  1506|         0|            0|            0|  0.00%|        specified in any order, and NaT (not-a-time) dates are ignored.
  1507|         0|            0|            0|  0.00%|        This list is saved in a normalized form that is suited for
  1508|         0|            0|            0|  0.00%|        fast calculations of valid days.
  1509|         0|            0|            0|  0.00%|    busdaycal : busdaycalendar, optional
  1510|         0|            0|            0|  0.00%|        A `busdaycalendar` object which specifies the valid days. If this
  1511|         0|            0|            0|  0.00%|        parameter is provided, neither weekmask nor holidays may be
  1512|         0|            0|            0|  0.00%|        provided.
  1513|         0|            0|            0|  0.00%|    out : array of datetime64[D], optional
  1514|         0|            0|            0|  0.00%|        If provided, this array is filled with the result.
  1515|         0|            0|            0|  0.00%|
  1516|         0|            0|            0|  0.00%|    Returns
  1517|         0|            0|            0|  0.00%|    -------
  1518|         0|            0|            0|  0.00%|    out : array of datetime64[D]
  1519|         0|            0|            0|  0.00%|        An array with a shape from broadcasting ``dates`` and ``offsets``
  1520|         0|            0|            0|  0.00%|        together, containing the dates with offsets applied.
  1521|         0|            0|            0|  0.00%|
  1522|         0|            0|            0|  0.00%|    See Also
  1523|         0|            0|            0|  0.00%|    --------
  1524|         0|            0|            0|  0.00%|    busdaycalendar : An object that specifies a custom set of valid days.
  1525|         0|            0|            0|  0.00%|    is_busday : Returns a boolean array indicating valid days.
  1526|         0|            0|            0|  0.00%|    busday_count : Counts how many valid days are in a half-open date range.
  1527|         0|            0|            0|  0.00%|
  1528|         0|            0|            0|  0.00%|    Examples
  1529|         0|            0|            0|  0.00%|    --------
  1530|         0|            0|            0|  0.00%|    >>> # First business day in October 2011 (not accounting for holidays)
  1531|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-10', 0, roll='forward')
  1532|         0|            0|            0|  0.00%|    numpy.datetime64('2011-10-03')
  1533|         0|            0|            0|  0.00%|    >>> # Last business day in February 2012 (not accounting for holidays)
  1534|         0|            0|            0|  0.00%|    ... np.busday_offset('2012-03', -1, roll='forward')
  1535|         0|            0|            0|  0.00%|    numpy.datetime64('2012-02-29')
  1536|         0|            0|            0|  0.00%|    >>> # Third Wednesday in January 2011
  1537|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
  1538|         0|            0|            0|  0.00%|    numpy.datetime64('2011-01-19')
  1539|         0|            0|            0|  0.00%|    >>> # 2012 Mother's Day in Canada and the U.S.
  1540|         0|            0|            0|  0.00%|    ... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
  1541|         0|            0|            0|  0.00%|    numpy.datetime64('2012-05-13')
  1542|         0|            0|            0|  0.00%|
  1543|         0|            0|            0|  0.00%|    >>> # First business day on or after a date
  1544|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-03-20', 0, roll='forward')
  1545|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-21')
  1546|         0|            0|            0|  0.00%|    >>> np.busday_offset('2011-03-22', 0, roll='forward')
  1547|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-22')
  1548|         0|            0|            0|  0.00%|    >>> # First business day after a date
  1549|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-03-20', 1, roll='backward')
  1550|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-21')
  1551|         0|            0|            0|  0.00%|    >>> np.busday_offset('2011-03-22', 1, roll='backward')
  1552|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-23')
  1553|         0|            0|            0|  0.00%|    """
  1554|         0|            0|            0|  0.00%|    return (dates, offsets, weekmask, holidays, out)
  1555|         0|            0|            0|  0.00%|
  1556|         0|            0|            0|  0.00%|
  1557|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_count)
  1558|         0|            0|            0|  0.00%|def busday_count(begindates, enddates, weekmask=None, holidays=None,
  1559|         0|            0|            0|  0.00%|                 busdaycal=None, out=None):
  1560|         0|            0|            0|  0.00%|    """
  1561|         0|            0|            0|  0.00%|    busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)
  1562|         0|            0|            0|  0.00%|
  1563|         0|            0|            0|  0.00%|    Counts the number of valid days between `begindates` and
  1564|         0|            0|            0|  0.00%|    `enddates`, not including the day of `enddates`.
  1565|         0|            0|            0|  0.00%|
  1566|         0|            0|            0|  0.00%|    If ``enddates`` specifies a date value that is earlier than the
  1567|         0|            0|            0|  0.00%|    corresponding ``begindates`` date value, the count will be negative.
  1568|         0|            0|            0|  0.00%|
  1569|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1570|         0|            0|            0|  0.00%|
  1571|         0|            0|            0|  0.00%|    Parameters
  1572|         0|            0|            0|  0.00%|    ----------
  1573|         0|            0|            0|  0.00%|    begindates : array_like of datetime64[D]
  1574|         0|            0|            0|  0.00%|        The array of the first dates for counting.
  1575|         0|            0|            0|  0.00%|    enddates : array_like of datetime64[D]
  1576|         0|            0|            0|  0.00%|        The array of the end dates for counting, which are excluded
  1577|         0|            0|            0|  0.00%|        from the count themselves.
  1578|         0|            0|            0|  0.00%|    weekmask : str or array_like of bool, optional
  1579|         0|            0|            0|  0.00%|        A seven-element array indicating which of Monday through Sunday are
  1580|         0|            0|            0|  0.00%|        valid days. May be specified as a length-seven list or array, like
  1581|         0|            0|            0|  0.00%|        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
  1582|         0|            0|            0|  0.00%|        like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
  1583|         0|            0|            0|  0.00%|        weekdays, optionally separated by white space. Valid abbreviations
  1584|         0|            0|            0|  0.00%|        are: Mon Tue Wed Thu Fri Sat Sun
  1585|         0|            0|            0|  0.00%|    holidays : array_like of datetime64[D], optional
  1586|         0|            0|            0|  0.00%|        An array of dates to consider as invalid dates.  They may be
  1587|         0|            0|            0|  0.00%|        specified in any order, and NaT (not-a-time) dates are ignored.
  1588|         0|            0|            0|  0.00%|        This list is saved in a normalized form that is suited for
  1589|         0|            0|            0|  0.00%|        fast calculations of valid days.
  1590|         0|            0|            0|  0.00%|    busdaycal : busdaycalendar, optional
  1591|         0|            0|            0|  0.00%|        A `busdaycalendar` object which specifies the valid days. If this
  1592|         0|            0|            0|  0.00%|        parameter is provided, neither weekmask nor holidays may be
  1593|         0|            0|            0|  0.00%|        provided.
  1594|         0|            0|            0|  0.00%|    out : array of int, optional
  1595|         0|            0|            0|  0.00%|        If provided, this array is filled with the result.
  1596|         0|            0|            0|  0.00%|
  1597|         0|            0|            0|  0.00%|    Returns
  1598|         0|            0|            0|  0.00%|    -------
  1599|         0|            0|            0|  0.00%|    out : array of int
  1600|         0|            0|            0|  0.00%|        An array with a shape from broadcasting ``begindates`` and ``enddates``
  1601|         0|            0|            0|  0.00%|        together, containing the number of valid days between
  1602|         0|            0|            0|  0.00%|        the begin and end dates.
  1603|         0|            0|            0|  0.00%|
  1604|         0|            0|            0|  0.00%|    See Also
  1605|         0|            0|            0|  0.00%|    --------
  1606|         0|            0|            0|  0.00%|    busdaycalendar : An object that specifies a custom set of valid days.
  1607|         0|            0|            0|  0.00%|    is_busday : Returns a boolean array indicating valid days.
  1608|         0|            0|            0|  0.00%|    busday_offset : Applies an offset counted in valid days.
  1609|         0|            0|            0|  0.00%|
  1610|         0|            0|            0|  0.00%|    Examples
  1611|         0|            0|            0|  0.00%|    --------
  1612|         0|            0|            0|  0.00%|    >>> # Number of weekdays in January 2011
  1613|         0|            0|            0|  0.00%|    ... np.busday_count('2011-01', '2011-02')
  1614|         0|            0|            0|  0.00%|    21
  1615|         0|            0|            0|  0.00%|    >>> # Number of weekdays in 2011
  1616|         0|            0|            0|  0.00%|    >>> np.busday_count('2011', '2012')
  1617|         0|            0|            0|  0.00%|    260
  1618|         0|            0|            0|  0.00%|    >>> # Number of Saturdays in 2011
  1619|         0|            0|            0|  0.00%|    ... np.busday_count('2011', '2012', weekmask='Sat')
  1620|         0|            0|            0|  0.00%|    53
  1621|         0|            0|            0|  0.00%|    """
  1622|         0|            0|            0|  0.00%|    return (begindates, enddates, weekmask, holidays, out)
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|
  1625|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(
  1626|         0|            0|            0|  0.00%|    _multiarray_umath.datetime_as_string)
  1627|         0|            0|            0|  0.00%|def datetime_as_string(arr, unit=None, timezone=None, casting=None):
  1628|         0|            0|            0|  0.00%|    """
  1629|         0|            0|            0|  0.00%|    datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')
  1630|         0|            0|            0|  0.00%|
  1631|         0|            0|            0|  0.00%|    Convert an array of datetimes into an array of strings.
  1632|         0|            0|            0|  0.00%|
  1633|         0|            0|            0|  0.00%|    Parameters
  1634|         0|            0|            0|  0.00%|    ----------
  1635|         0|            0|            0|  0.00%|    arr : array_like of datetime64
  1636|         0|            0|            0|  0.00%|        The array of UTC timestamps to format.
  1637|         0|            0|            0|  0.00%|    unit : str
  1638|         0|            0|            0|  0.00%|        One of None, 'auto', or a :ref:`datetime unit <arrays.dtypes.dateunits>`.
  1639|         0|            0|            0|  0.00%|    timezone : {'naive', 'UTC', 'local'} or tzinfo
  1640|         0|            0|            0|  0.00%|        Timezone information to use when displaying the datetime. If 'UTC', end
  1641|         0|            0|            0|  0.00%|        with a Z to indicate UTC time. If 'local', convert to the local timezone
  1642|         0|            0|            0|  0.00%|        first, and suffix with a +-#### timezone offset. If a tzinfo object,
  1643|         0|            0|            0|  0.00%|        then do as with 'local', but use the specified timezone.
  1644|         0|            0|            0|  0.00%|    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}
  1645|         0|            0|            0|  0.00%|        Casting to allow when changing between datetime units.
  1646|         0|            0|            0|  0.00%|
  1647|         0|            0|            0|  0.00%|    Returns
  1648|         0|            0|            0|  0.00%|    -------
  1649|         0|            0|            0|  0.00%|    str_arr : ndarray
  1650|         0|            0|            0|  0.00%|        An array of strings the same shape as `arr`.
  1651|         0|            0|            0|  0.00%|
  1652|         0|            0|            0|  0.00%|    Examples
  1653|         0|            0|            0|  0.00%|    --------
  1654|         0|            0|            0|  0.00%|    >>> import pytz
  1655|         0|            0|            0|  0.00%|    >>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
  1656|         0|            0|            0|  0.00%|    >>> d
  1657|         0|            0|            0|  0.00%|    array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
  1658|         0|            0|            0|  0.00%|           '2002-10-27T07:30'], dtype='datetime64[m]')
  1659|         0|            0|            0|  0.00%|
  1660|         0|            0|            0|  0.00%|    Setting the timezone to UTC shows the same information, but with a Z suffix
  1661|         0|            0|            0|  0.00%|
  1662|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, timezone='UTC')
  1663|         0|            0|            0|  0.00%|    array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
  1664|         0|            0|            0|  0.00%|           '2002-10-27T07:30Z'], dtype='<U35')
  1665|         0|            0|            0|  0.00%|
  1666|         0|            0|            0|  0.00%|    Note that we picked datetimes that cross a DST boundary. Passing in a
  1667|         0|            0|            0|  0.00%|    ``pytz`` timezone object will print the appropriate offset
  1668|         0|            0|            0|  0.00%|
  1669|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
  1670|         0|            0|            0|  0.00%|    array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
  1671|         0|            0|            0|  0.00%|           '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')
  1672|         0|            0|            0|  0.00%|
  1673|         0|            0|            0|  0.00%|    Passing in a unit will change the precision
  1674|         0|            0|            0|  0.00%|
  1675|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, unit='h')
  1676|         0|            0|            0|  0.00%|    array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
  1677|         0|            0|            0|  0.00%|          dtype='<U32')
  1678|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, unit='s')
  1679|         0|            0|            0|  0.00%|    array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
  1680|         0|            0|            0|  0.00%|           '2002-10-27T07:30:00'], dtype='<U38')
  1681|         0|            0|            0|  0.00%|
  1682|         0|            0|            0|  0.00%|    'casting' can be used to specify whether precision can be changed
  1683|         0|            0|            0|  0.00%|
  1684|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, unit='h', casting='safe')
  1685|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1686|         0|            0|            0|  0.00%|        ...
  1687|         0|            0|            0|  0.00%|    TypeError: Cannot create a datetime string as units 'h' from a NumPy
  1688|         0|            0|            0|  0.00%|    datetime with units 'm' according to the rule 'safe'
  1689|         0|            0|            0|  0.00%|    """
  1690|         0|            0|            0|  0.00%|    return (arr,)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\shape_base.py
File duration: 0.381282s (1.09%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|__all__ = ['atleast_1d', 'atleast_2d', 'atleast_3d', 'block', 'hstack',
     2|         0|            0|            0|  0.00%|           'stack', 'vstack']
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|import functools
     5|         0|            0|            0|  0.00%|import itertools
     6|         0|            0|            0|  0.00%|import operator
     7|         0|            0|            0|  0.00%|import warnings
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from . import numeric as _nx
    10|         0|            0|            0|  0.00%|from . import overrides
    11|         0|            0|            0|  0.00%|from .multiarray import array, asanyarray, normalize_axis_index
    12|         0|            0|            0|  0.00%|from . import fromnumeric as _from_nx
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    16|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|def _atleast_1d_dispatcher(*arys):
    20|         0|            0|            0|  0.00%|    return arys
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|@array_function_dispatch(_atleast_1d_dispatcher)
    24|         0|            0|            0|  0.00%|def atleast_1d(*arys):
    25|         0|            0|            0|  0.00%|    """
    26|         0|            0|            0|  0.00%|    Convert inputs to arrays with at least one dimension.
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|    Scalar inputs are converted to 1-dimensional arrays, whilst
    29|         0|            0|            0|  0.00%|    higher-dimensional inputs are preserved.
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|    Parameters
    32|         0|            0|            0|  0.00%|    ----------
    33|         0|            0|            0|  0.00%|    arys1, arys2, ... : array_like
    34|         0|            0|            0|  0.00%|        One or more input arrays.
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    Returns
    37|         0|            0|            0|  0.00%|    -------
    38|         0|            0|            0|  0.00%|    ret : ndarray
    39|         0|            0|            0|  0.00%|        An array, or list of arrays, each with ``a.ndim >= 1``.
    40|         0|            0|            0|  0.00%|        Copies are made only if necessary.
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    See Also
    43|         0|            0|            0|  0.00%|    --------
    44|         0|            0|            0|  0.00%|    atleast_2d, atleast_3d
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    Examples
    47|         0|            0|            0|  0.00%|    --------
    48|         0|            0|            0|  0.00%|    >>> np.atleast_1d(1.0)
    49|         0|            0|            0|  0.00%|    array([1.])
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    >>> x = np.arange(9.0).reshape(3,3)
    52|         0|            0|            0|  0.00%|    >>> np.atleast_1d(x)
    53|         0|            0|            0|  0.00%|    array([[0., 1., 2.],
    54|         0|            0|            0|  0.00%|           [3., 4., 5.],
    55|         0|            0|            0|  0.00%|           [6., 7., 8.]])
    56|         0|            0|            0|  0.00%|    >>> np.atleast_1d(x) is x
    57|         0|            0|            0|  0.00%|    True
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|    >>> np.atleast_1d(1, [3, 4])
    60|         0|            0|            0|  0.00%|    [array([1]), array([3, 4])]
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    """
    63|         0|            0|            0|  0.00%|    res = []
    64|         0|            0|            0|  0.00%|    for ary in arys:
    65|         0|            0|            0|  0.00%|        ary = asanyarray(ary)
    66|         0|            0|            0|  0.00%|        if ary.ndim == 0:
    67|         0|            0|            0|  0.00%|            result = ary.reshape(1)
    68|         0|            0|            0|  0.00%|        else:
    69|         0|            0|            0|  0.00%|            result = ary
    70|         0|            0|            0|  0.00%|        res.append(result)
    71|         0|            0|            0|  0.00%|    if len(res) == 1:
    72|         0|            0|            0|  0.00%|        return res[0]
    73|         0|            0|            0|  0.00%|    else:
    74|         0|            0|            0|  0.00%|        return res
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|      5005|   0.00515628|  1.03023e-06|  0.01%|def _atleast_2d_dispatcher(*arys):
    78|      5005|    0.0100803|  2.01405e-06|  0.03%|    return arys
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|      5005|    0.0102553|  2.04902e-06|  0.03%|@array_function_dispatch(_atleast_2d_dispatcher)
    82|         0|            0|            0|  0.00%|def atleast_2d(*arys):
    83|         0|            0|            0|  0.00%|    """
    84|         0|            0|            0|  0.00%|    View inputs as arrays with at least two dimensions.
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    Parameters
    87|         0|            0|            0|  0.00%|    ----------
    88|         0|            0|            0|  0.00%|    arys1, arys2, ... : array_like
    89|         0|            0|            0|  0.00%|        One or more array-like sequences.  Non-array inputs are converted
    90|         0|            0|            0|  0.00%|        to arrays.  Arrays that already have two or more dimensions are
    91|         0|            0|            0|  0.00%|        preserved.
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    Returns
    94|         0|            0|            0|  0.00%|    -------
    95|         0|            0|            0|  0.00%|    res, res2, ... : ndarray
    96|         0|            0|            0|  0.00%|        An array, or list of arrays, each with ``a.ndim >= 2``.
    97|         0|            0|            0|  0.00%|        Copies are avoided where possible, and views with two or more
    98|         0|            0|            0|  0.00%|        dimensions are returned.
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|    See Also
   101|         0|            0|            0|  0.00%|    --------
   102|         0|            0|            0|  0.00%|    atleast_1d, atleast_3d
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    Examples
   105|         0|            0|            0|  0.00%|    --------
   106|         0|            0|            0|  0.00%|    >>> np.atleast_2d(3.0)
   107|         0|            0|            0|  0.00%|    array([[3.]])
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|    >>> x = np.arange(3.0)
   110|         0|            0|            0|  0.00%|    >>> np.atleast_2d(x)
   111|         0|            0|            0|  0.00%|    array([[0., 1., 2.]])
   112|         0|            0|            0|  0.00%|    >>> np.atleast_2d(x).base is x
   113|         0|            0|            0|  0.00%|    True
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|    >>> np.atleast_2d(1, [1, 2], [[1, 2]])
   116|         0|            0|            0|  0.00%|    [array([[1]]), array([[1, 2]]), array([[1, 2]])]
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    """
   119|      5005|     0.011107|  2.21917e-06|  0.03%|    res = []
   120|     15015|    0.0287123|  1.91224e-06|  0.08%|    for ary in arys:
   121|     10010|    0.0282681|  2.82399e-06|  0.08%|        ary = asanyarray(ary)
   122|     10010|    0.0224512|  2.24287e-06|  0.06%|        if ary.ndim == 0:
   123|         0|            0|            0|  0.00%|            result = ary.reshape(1, 1)
   124|     10010|    0.0152924|  1.52771e-06|  0.04%|        elif ary.ndim == 1:
   125|      5005|     0.014055|  2.80819e-06|  0.04%|            result = ary[_nx.newaxis, :]
   126|         0|            0|            0|  0.00%|        else:
   127|      5005|   0.00813103|  1.62458e-06|  0.02%|            result = ary
   128|     10010|    0.0161104|  1.60943e-06|  0.05%|        res.append(result)
   129|      5005|    0.0100281|  2.00362e-06|  0.03%|    if len(res) == 1:
   130|         0|            0|            0|  0.00%|        return res[0]
   131|         0|            0|            0|  0.00%|    else:
   132|      5005|    0.0130718|  2.61174e-06|  0.04%|        return res
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|def _atleast_3d_dispatcher(*arys):
   136|         0|            0|            0|  0.00%|    return arys
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|@array_function_dispatch(_atleast_3d_dispatcher)
   140|         0|            0|            0|  0.00%|def atleast_3d(*arys):
   141|         0|            0|            0|  0.00%|    """
   142|         0|            0|            0|  0.00%|    View inputs as arrays with at least three dimensions.
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    Parameters
   145|         0|            0|            0|  0.00%|    ----------
   146|         0|            0|            0|  0.00%|    arys1, arys2, ... : array_like
   147|         0|            0|            0|  0.00%|        One or more array-like sequences.  Non-array inputs are converted to
   148|         0|            0|            0|  0.00%|        arrays.  Arrays that already have three or more dimensions are
   149|         0|            0|            0|  0.00%|        preserved.
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|    Returns
   152|         0|            0|            0|  0.00%|    -------
   153|         0|            0|            0|  0.00%|    res1, res2, ... : ndarray
   154|         0|            0|            0|  0.00%|        An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are
   155|         0|            0|            0|  0.00%|        avoided where possible, and views with three or more dimensions are
   156|         0|            0|            0|  0.00%|        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
   157|         0|            0|            0|  0.00%|        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
   158|         0|            0|            0|  0.00%|        view of shape ``(M, N, 1)``.
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|    See Also
   161|         0|            0|            0|  0.00%|    --------
   162|         0|            0|            0|  0.00%|    atleast_1d, atleast_2d
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    Examples
   165|         0|            0|            0|  0.00%|    --------
   166|         0|            0|            0|  0.00%|    >>> np.atleast_3d(3.0)
   167|         0|            0|            0|  0.00%|    array([[[3.]]])
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|    >>> x = np.arange(3.0)
   170|         0|            0|            0|  0.00%|    >>> np.atleast_3d(x).shape
   171|         0|            0|            0|  0.00%|    (1, 3, 1)
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    >>> x = np.arange(12.0).reshape(4,3)
   174|         0|            0|            0|  0.00%|    >>> np.atleast_3d(x).shape
   175|         0|            0|            0|  0.00%|    (4, 3, 1)
   176|         0|            0|            0|  0.00%|    >>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
   177|         0|            0|            0|  0.00%|    True
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
   180|         0|            0|            0|  0.00%|    ...     print(arr, arr.shape) # doctest: +SKIP
   181|         0|            0|            0|  0.00%|    ...
   182|         0|            0|            0|  0.00%|    [[[1]
   183|         0|            0|            0|  0.00%|      [2]]] (1, 2, 1)
   184|         0|            0|            0|  0.00%|    [[[1]
   185|         0|            0|            0|  0.00%|      [2]]] (1, 2, 1)
   186|         0|            0|            0|  0.00%|    [[[1 2]]] (1, 1, 2)
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    """
   189|         0|            0|            0|  0.00%|    res = []
   190|         0|            0|            0|  0.00%|    for ary in arys:
   191|         0|            0|            0|  0.00%|        ary = asanyarray(ary)
   192|         0|            0|            0|  0.00%|        if ary.ndim == 0:
   193|         0|            0|            0|  0.00%|            result = ary.reshape(1, 1, 1)
   194|         0|            0|            0|  0.00%|        elif ary.ndim == 1:
   195|         0|            0|            0|  0.00%|            result = ary[_nx.newaxis, :, _nx.newaxis]
   196|         0|            0|            0|  0.00%|        elif ary.ndim == 2:
   197|         0|            0|            0|  0.00%|            result = ary[:, :, _nx.newaxis]
   198|         0|            0|            0|  0.00%|        else:
   199|         0|            0|            0|  0.00%|            result = ary
   200|         0|            0|            0|  0.00%|        res.append(result)
   201|         0|            0|            0|  0.00%|    if len(res) == 1:
   202|         0|            0|            0|  0.00%|        return res[0]
   203|         0|            0|            0|  0.00%|    else:
   204|         0|            0|            0|  0.00%|        return res
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|      5005|   0.00717545|  1.43366e-06|  0.02%|def _arrays_for_stack_dispatcher(arrays, stacklevel=4):
   208|      5005|    0.0171325|  3.42308e-06|  0.05%|    if not hasattr(arrays, '__getitem__') and hasattr(arrays, '__iter__'):
   209|         0|            0|            0|  0.00%|        warnings.warn('arrays to stack must be passed as a "sequence" type '
   210|         0|            0|            0|  0.00%|                      'such as list or tuple. Support for non-sequence '
   211|         0|            0|            0|  0.00%|                      'iterables such as generators is deprecated as of '
   212|         0|            0|            0|  0.00%|                      'NumPy 1.16 and will raise an error in the future.',
   213|         0|            0|            0|  0.00%|                      FutureWarning, stacklevel=stacklevel)
   214|         0|            0|            0|  0.00%|        return ()
   215|      5005|   0.00905418|  1.80903e-06|  0.03%|    return arrays
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|
   218|      5005|    0.0110261|  2.20303e-06|  0.03%|def _vhstack_dispatcher(tup):
   219|      5005|    0.0441029|  8.81177e-06|  0.13%|    return _arrays_for_stack_dispatcher(tup)
(call)|      5005|    0.0333622|  6.66576e-06|  0.10%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\shape_base.py:207 _arrays_for_stack_dispatcher
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|
   222|      5005|   0.00706053|  1.41069e-06|  0.02%|@array_function_dispatch(_vhstack_dispatcher)
   223|         0|            0|            0|  0.00%|def vstack(tup):
   224|         0|            0|            0|  0.00%|    """
   225|         0|            0|            0|  0.00%|    Stack arrays in sequence vertically (row wise).
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    This is equivalent to concatenation along the first axis after 1-D arrays
   228|         0|            0|            0|  0.00%|    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
   229|         0|            0|            0|  0.00%|    `vsplit`.
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    This function makes most sense for arrays with up to 3 dimensions. For
   232|         0|            0|            0|  0.00%|    instance, for pixel-data with a height (first axis), width (second axis),
   233|         0|            0|            0|  0.00%|    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
   234|         0|            0|            0|  0.00%|    `block` provide more general stacking and concatenation operations.
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    Parameters
   237|         0|            0|            0|  0.00%|    ----------
   238|         0|            0|            0|  0.00%|    tup : sequence of ndarrays
   239|         0|            0|            0|  0.00%|        The arrays must have the same shape along all but the first axis.
   240|         0|            0|            0|  0.00%|        1-D arrays must have the same length.
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|    Returns
   243|         0|            0|            0|  0.00%|    -------
   244|         0|            0|            0|  0.00%|    stacked : ndarray
   245|         0|            0|            0|  0.00%|        The array formed by stacking the given arrays, will be at least 2-D.
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    See Also
   248|         0|            0|            0|  0.00%|    --------
   249|         0|            0|            0|  0.00%|    concatenate : Join a sequence of arrays along an existing axis.
   250|         0|            0|            0|  0.00%|    stack : Join a sequence of arrays along a new axis.
   251|         0|            0|            0|  0.00%|    block : Assemble an nd-array from nested lists of blocks.
   252|         0|            0|            0|  0.00%|    hstack : Stack arrays in sequence horizontally (column wise).
   253|         0|            0|            0|  0.00%|    dstack : Stack arrays in sequence depth wise (along third axis).
   254|         0|            0|            0|  0.00%|    column_stack : Stack 1-D arrays as columns into a 2-D array.
   255|         0|            0|            0|  0.00%|    vsplit : Split an array into multiple sub-arrays vertically (row-wise).
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    Examples
   258|         0|            0|            0|  0.00%|    --------
   259|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3])
   260|         0|            0|            0|  0.00%|    >>> b = np.array([4, 5, 6])
   261|         0|            0|            0|  0.00%|    >>> np.vstack((a,b))
   262|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   263|         0|            0|            0|  0.00%|           [4, 5, 6]])
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|    >>> a = np.array([[1], [2], [3]])
   266|         0|            0|            0|  0.00%|    >>> b = np.array([[4], [5], [6]])
   267|         0|            0|            0|  0.00%|    >>> np.vstack((a,b))
   268|         0|            0|            0|  0.00%|    array([[1],
   269|         0|            0|            0|  0.00%|           [2],
   270|         0|            0|            0|  0.00%|           [3],
   271|         0|            0|            0|  0.00%|           [4],
   272|         0|            0|            0|  0.00%|           [5],
   273|         0|            0|            0|  0.00%|           [6]])
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    """
   276|      5005|    0.0113158|   2.2609e-06|  0.03%|    if not overrides.ARRAY_FUNCTION_ENABLED:
   277|         0|            0|            0|  0.00%|        # raise warning if necessary
   278|         0|            0|            0|  0.00%|        _arrays_for_stack_dispatcher(tup, stacklevel=2)
   279|      5005|    0.0387704|  7.74634e-06|  0.11%|    arrs = atleast_2d(*tup)
(call)|      5005|     0.277712|   5.5487e-05|  0.79%|# <__array_function__ internals>:177 atleast_2d
   280|      5005|   0.00913787|  1.82575e-06|  0.03%|    if not isinstance(arrs, list):
   281|         0|            0|            0|  0.00%|        arrs = [arrs]
   282|      5005|    0.0337873|   6.7507e-06|  0.10%|    return _nx.concatenate(arrs, 0)
(call)|      5005|     0.132487|  2.64709e-05|  0.38%|# <__array_function__ internals>:177 concatenate
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|@array_function_dispatch(_vhstack_dispatcher)
   286|         0|            0|            0|  0.00%|def hstack(tup):
   287|         0|            0|            0|  0.00%|    """
   288|         0|            0|            0|  0.00%|    Stack arrays in sequence horizontally (column wise).
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|    This is equivalent to concatenation along the second axis, except for 1-D
   291|         0|            0|            0|  0.00%|    arrays where it concatenates along the first axis. Rebuilds arrays divided
   292|         0|            0|            0|  0.00%|    by `hsplit`.
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|    This function makes most sense for arrays with up to 3 dimensions. For
   295|         0|            0|            0|  0.00%|    instance, for pixel-data with a height (first axis), width (second axis),
   296|         0|            0|            0|  0.00%|    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
   297|         0|            0|            0|  0.00%|    `block` provide more general stacking and concatenation operations.
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|    Parameters
   300|         0|            0|            0|  0.00%|    ----------
   301|         0|            0|            0|  0.00%|    tup : sequence of ndarrays
   302|         0|            0|            0|  0.00%|        The arrays must have the same shape along all but the second axis,
   303|         0|            0|            0|  0.00%|        except 1-D arrays which can be any length.
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|    Returns
   306|         0|            0|            0|  0.00%|    -------
   307|         0|            0|            0|  0.00%|    stacked : ndarray
   308|         0|            0|            0|  0.00%|        The array formed by stacking the given arrays.
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    See Also
   311|         0|            0|            0|  0.00%|    --------
   312|         0|            0|            0|  0.00%|    concatenate : Join a sequence of arrays along an existing axis.
   313|         0|            0|            0|  0.00%|    stack : Join a sequence of arrays along a new axis.
   314|         0|            0|            0|  0.00%|    block : Assemble an nd-array from nested lists of blocks.
   315|         0|            0|            0|  0.00%|    vstack : Stack arrays in sequence vertically (row wise).
   316|         0|            0|            0|  0.00%|    dstack : Stack arrays in sequence depth wise (along third axis).
   317|         0|            0|            0|  0.00%|    column_stack : Stack 1-D arrays as columns into a 2-D array.
   318|         0|            0|            0|  0.00%|    hsplit : Split an array into multiple sub-arrays horizontally (column-wise).
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    Examples
   321|         0|            0|            0|  0.00%|    --------
   322|         0|            0|            0|  0.00%|    >>> a = np.array((1,2,3))
   323|         0|            0|            0|  0.00%|    >>> b = np.array((4,5,6))
   324|         0|            0|            0|  0.00%|    >>> np.hstack((a,b))
   325|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
   326|         0|            0|            0|  0.00%|    >>> a = np.array([[1],[2],[3]])
   327|         0|            0|            0|  0.00%|    >>> b = np.array([[4],[5],[6]])
   328|         0|            0|            0|  0.00%|    >>> np.hstack((a,b))
   329|         0|            0|            0|  0.00%|    array([[1, 4],
   330|         0|            0|            0|  0.00%|           [2, 5],
   331|         0|            0|            0|  0.00%|           [3, 6]])
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    """
   334|         0|            0|            0|  0.00%|    if not overrides.ARRAY_FUNCTION_ENABLED:
   335|         0|            0|            0|  0.00%|        # raise warning if necessary
   336|         0|            0|            0|  0.00%|        _arrays_for_stack_dispatcher(tup, stacklevel=2)
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    arrs = atleast_1d(*tup)
   339|         0|            0|            0|  0.00%|    if not isinstance(arrs, list):
   340|         0|            0|            0|  0.00%|        arrs = [arrs]
   341|         0|            0|            0|  0.00%|    # As a special case, dimension 0 of 1-dimensional arrays is "horizontal"
   342|         0|            0|            0|  0.00%|    if arrs and arrs[0].ndim == 1:
   343|         0|            0|            0|  0.00%|        return _nx.concatenate(arrs, 0)
   344|         0|            0|            0|  0.00%|    else:
   345|         0|            0|            0|  0.00%|        return _nx.concatenate(arrs, 1)
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|def _stack_dispatcher(arrays, axis=None, out=None):
   349|         0|            0|            0|  0.00%|    arrays = _arrays_for_stack_dispatcher(arrays, stacklevel=6)
   350|         0|            0|            0|  0.00%|    if out is not None:
   351|         0|            0|            0|  0.00%|        # optimize for the typical case where only arrays is provided
   352|         0|            0|            0|  0.00%|        arrays = list(arrays)
   353|         0|            0|            0|  0.00%|        arrays.append(out)
   354|         0|            0|            0|  0.00%|    return arrays
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|@array_function_dispatch(_stack_dispatcher)
   358|         0|            0|            0|  0.00%|def stack(arrays, axis=0, out=None):
   359|         0|            0|            0|  0.00%|    """
   360|         0|            0|            0|  0.00%|    Join a sequence of arrays along a new axis.
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    The ``axis`` parameter specifies the index of the new axis in the
   363|         0|            0|            0|  0.00%|    dimensions of the result. For example, if ``axis=0`` it will be the first
   364|         0|            0|            0|  0.00%|    dimension and if ``axis=-1`` it will be the last dimension.
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|    .. versionadded:: 1.10.0
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|    Parameters
   369|         0|            0|            0|  0.00%|    ----------
   370|         0|            0|            0|  0.00%|    arrays : sequence of array_like
   371|         0|            0|            0|  0.00%|        Each array must have the same shape.
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|    axis : int, optional
   374|         0|            0|            0|  0.00%|        The axis in the result array along which the input arrays are stacked.
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    out : ndarray, optional
   377|         0|            0|            0|  0.00%|        If provided, the destination to place the result. The shape must be
   378|         0|            0|            0|  0.00%|        correct, matching that of what stack would have returned if no
   379|         0|            0|            0|  0.00%|        out argument were specified.
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    Returns
   382|         0|            0|            0|  0.00%|    -------
   383|         0|            0|            0|  0.00%|    stacked : ndarray
   384|         0|            0|            0|  0.00%|        The stacked array has one more dimension than the input arrays.
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|    See Also
   387|         0|            0|            0|  0.00%|    --------
   388|         0|            0|            0|  0.00%|    concatenate : Join a sequence of arrays along an existing axis.
   389|         0|            0|            0|  0.00%|    block : Assemble an nd-array from nested lists of blocks.
   390|         0|            0|            0|  0.00%|    split : Split array into a list of multiple sub-arrays of equal size.
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|    Examples
   393|         0|            0|            0|  0.00%|    --------
   394|         0|            0|            0|  0.00%|    >>> arrays = [np.random.randn(3, 4) for _ in range(10)]
   395|         0|            0|            0|  0.00%|    >>> np.stack(arrays, axis=0).shape
   396|         0|            0|            0|  0.00%|    (10, 3, 4)
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    >>> np.stack(arrays, axis=1).shape
   399|         0|            0|            0|  0.00%|    (3, 10, 4)
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|    >>> np.stack(arrays, axis=2).shape
   402|         0|            0|            0|  0.00%|    (3, 4, 10)
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3])
   405|         0|            0|            0|  0.00%|    >>> b = np.array([4, 5, 6])
   406|         0|            0|            0|  0.00%|    >>> np.stack((a, b))
   407|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   408|         0|            0|            0|  0.00%|           [4, 5, 6]])
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|    >>> np.stack((a, b), axis=-1)
   411|         0|            0|            0|  0.00%|    array([[1, 4],
   412|         0|            0|            0|  0.00%|           [2, 5],
   413|         0|            0|            0|  0.00%|           [3, 6]])
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|    """
   416|         0|            0|            0|  0.00%|    if not overrides.ARRAY_FUNCTION_ENABLED:
   417|         0|            0|            0|  0.00%|        # raise warning if necessary
   418|         0|            0|            0|  0.00%|        _arrays_for_stack_dispatcher(arrays, stacklevel=2)
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    arrays = [asanyarray(arr) for arr in arrays]
   421|         0|            0|            0|  0.00%|    if not arrays:
   422|         0|            0|            0|  0.00%|        raise ValueError('need at least one array to stack')
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|    shapes = {arr.shape for arr in arrays}
   425|         0|            0|            0|  0.00%|    if len(shapes) != 1:
   426|         0|            0|            0|  0.00%|        raise ValueError('all input arrays must have the same shape')
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|    result_ndim = arrays[0].ndim + 1
   429|         0|            0|            0|  0.00%|    axis = normalize_axis_index(axis, result_ndim)
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|    sl = (slice(None),) * axis + (_nx.newaxis,)
   432|         0|            0|            0|  0.00%|    expanded_arrays = [arr[sl] for arr in arrays]
   433|         0|            0|            0|  0.00%|    return _nx.concatenate(expanded_arrays, axis=axis, out=out)
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|# Internal functions to eliminate the overhead of repeated dispatch in one of
   437|         0|            0|            0|  0.00%|# the two possible paths inside np.block.
   438|         0|            0|            0|  0.00%|# Use getattr to protect against __array_function__ being disabled.
   439|         0|            0|            0|  0.00%|_size = getattr(_from_nx.size, '__wrapped__', _from_nx.size)
   440|         0|            0|            0|  0.00%|_ndim = getattr(_from_nx.ndim, '__wrapped__', _from_nx.ndim)
   441|         0|            0|            0|  0.00%|_concatenate = getattr(_from_nx.concatenate, '__wrapped__', _from_nx.concatenate)
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|def _block_format_index(index):
   445|         0|            0|            0|  0.00%|    """
   446|         0|            0|            0|  0.00%|    Convert a list of indices ``[0, 1, 2]`` into ``"arrays[0][1][2]"``.
   447|         0|            0|            0|  0.00%|    """
   448|         0|            0|            0|  0.00%|    idx_str = ''.join('[{}]'.format(i) for i in index if i is not None)
   449|         0|            0|            0|  0.00%|    return 'arrays' + idx_str
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|def _block_check_depths_match(arrays, parent_index=[]):
   453|         0|            0|            0|  0.00%|    """
   454|         0|            0|            0|  0.00%|    Recursive function checking that the depths of nested lists in `arrays`
   455|         0|            0|            0|  0.00%|    all match. Mismatch raises a ValueError as described in the block
   456|         0|            0|            0|  0.00%|    docstring below.
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|    The entire index (rather than just the depth) needs to be calculated
   459|         0|            0|            0|  0.00%|    for each innermost list, in case an error needs to be raised, so that
   460|         0|            0|            0|  0.00%|    the index of the offending list can be printed as part of the error.
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|    Parameters
   463|         0|            0|            0|  0.00%|    ----------
   464|         0|            0|            0|  0.00%|    arrays : nested list of arrays
   465|         0|            0|            0|  0.00%|        The arrays to check
   466|         0|            0|            0|  0.00%|    parent_index : list of int
   467|         0|            0|            0|  0.00%|        The full index of `arrays` within the nested lists passed to
   468|         0|            0|            0|  0.00%|        `_block_check_depths_match` at the top of the recursion.
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|    Returns
   471|         0|            0|            0|  0.00%|    -------
   472|         0|            0|            0|  0.00%|    first_index : list of int
   473|         0|            0|            0|  0.00%|        The full index of an element from the bottom of the nesting in
   474|         0|            0|            0|  0.00%|        `arrays`. If any element at the bottom is an empty list, this will
   475|         0|            0|            0|  0.00%|        refer to it, and the last index along the empty axis will be None.
   476|         0|            0|            0|  0.00%|    max_arr_ndim : int
   477|         0|            0|            0|  0.00%|        The maximum of the ndims of the arrays nested in `arrays`.
   478|         0|            0|            0|  0.00%|    final_size: int
   479|         0|            0|            0|  0.00%|        The number of elements in the final array. This is used the motivate
   480|         0|            0|            0|  0.00%|        the choice of algorithm used using benchmarking wisdom.
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    """
   483|         0|            0|            0|  0.00%|    if type(arrays) is tuple:
   484|         0|            0|            0|  0.00%|        # not strictly necessary, but saves us from:
   485|         0|            0|            0|  0.00%|        #  - more than one way to do things - no point treating tuples like
   486|         0|            0|            0|  0.00%|        #    lists
   487|         0|            0|            0|  0.00%|        #  - horribly confusing behaviour that results when tuples are
   488|         0|            0|            0|  0.00%|        #    treated like ndarray
   489|         0|            0|            0|  0.00%|        raise TypeError(
   490|         0|            0|            0|  0.00%|            '{} is a tuple. '
   491|         0|            0|            0|  0.00%|            'Only lists can be used to arrange blocks, and np.block does '
   492|         0|            0|            0|  0.00%|            'not allow implicit conversion from tuple to ndarray.'.format(
   493|         0|            0|            0|  0.00%|                _block_format_index(parent_index)
   494|         0|            0|            0|  0.00%|            )
   495|         0|            0|            0|  0.00%|        )
   496|         0|            0|            0|  0.00%|    elif type(arrays) is list and len(arrays) > 0:
   497|         0|            0|            0|  0.00%|        idxs_ndims = (_block_check_depths_match(arr, parent_index + [i])
   498|         0|            0|            0|  0.00%|                      for i, arr in enumerate(arrays))
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|        first_index, max_arr_ndim, final_size = next(idxs_ndims)
   501|         0|            0|            0|  0.00%|        for index, ndim, size in idxs_ndims:
   502|         0|            0|            0|  0.00%|            final_size += size
   503|         0|            0|            0|  0.00%|            if ndim > max_arr_ndim:
   504|         0|            0|            0|  0.00%|                max_arr_ndim = ndim
   505|         0|            0|            0|  0.00%|            if len(index) != len(first_index):
   506|         0|            0|            0|  0.00%|                raise ValueError(
   507|         0|            0|            0|  0.00%|                    "List depths are mismatched. First element was at depth "
   508|         0|            0|            0|  0.00%|                    "{}, but there is an element at depth {} ({})".format(
   509|         0|            0|            0|  0.00%|                        len(first_index),
   510|         0|            0|            0|  0.00%|                        len(index),
   511|         0|            0|            0|  0.00%|                        _block_format_index(index)
   512|         0|            0|            0|  0.00%|                    )
   513|         0|            0|            0|  0.00%|                )
   514|         0|            0|            0|  0.00%|            # propagate our flag that indicates an empty list at the bottom
   515|         0|            0|            0|  0.00%|            if index[-1] is None:
   516|         0|            0|            0|  0.00%|                first_index = index
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|        return first_index, max_arr_ndim, final_size
   519|         0|            0|            0|  0.00%|    elif type(arrays) is list and len(arrays) == 0:
   520|         0|            0|            0|  0.00%|        # We've 'bottomed out' on an empty list
   521|         0|            0|            0|  0.00%|        return parent_index + [None], 0, 0
   522|         0|            0|            0|  0.00%|    else:
   523|         0|            0|            0|  0.00%|        # We've 'bottomed out' - arrays is either a scalar or an array
   524|         0|            0|            0|  0.00%|        size = _size(arrays)
   525|         0|            0|            0|  0.00%|        return parent_index, _ndim(arrays), size
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|def _atleast_nd(a, ndim):
   529|         0|            0|            0|  0.00%|    # Ensures `a` has at least `ndim` dimensions by prepending
   530|         0|            0|            0|  0.00%|    # ones to `a.shape` as necessary
   531|         0|            0|            0|  0.00%|    return array(a, ndmin=ndim, copy=False, subok=True)
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|def _accumulate(values):
   535|         0|            0|            0|  0.00%|    return list(itertools.accumulate(values))
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|def _concatenate_shapes(shapes, axis):
   539|         0|            0|            0|  0.00%|    """Given array shapes, return the resulting shape and slices prefixes.
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|    These help in nested concatenation.
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    Returns
   544|         0|            0|            0|  0.00%|    -------
   545|         0|            0|            0|  0.00%|    shape: tuple of int
   546|         0|            0|            0|  0.00%|        This tuple satisfies:
   547|         0|            0|            0|  0.00%|        ```
   548|         0|            0|            0|  0.00%|        shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)
   549|         0|            0|            0|  0.00%|        shape == concatenate(arrs, axis).shape
   550|         0|            0|            0|  0.00%|        ```
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|    slice_prefixes: tuple of (slice(start, end), )
   553|         0|            0|            0|  0.00%|        For a list of arrays being concatenated, this returns the slice
   554|         0|            0|            0|  0.00%|        in the larger array at axis that needs to be sliced into.
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|        For example, the following holds:
   557|         0|            0|            0|  0.00%|        ```
   558|         0|            0|            0|  0.00%|        ret = concatenate([a, b, c], axis)
   559|         0|            0|            0|  0.00%|        _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis)
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|        ret[(slice(None),) * axis + sl_a] == a
   562|         0|            0|            0|  0.00%|        ret[(slice(None),) * axis + sl_b] == b
   563|         0|            0|            0|  0.00%|        ret[(slice(None),) * axis + sl_c] == c
   564|         0|            0|            0|  0.00%|        ```
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|        These are called slice prefixes since they are used in the recursive
   567|         0|            0|            0|  0.00%|        blocking algorithm to compute the left-most slices during the
   568|         0|            0|            0|  0.00%|        recursion. Therefore, they must be prepended to rest of the slice
   569|         0|            0|            0|  0.00%|        that was computed deeper in the recursion.
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|        These are returned as tuples to ensure that they can quickly be added
   572|         0|            0|            0|  0.00%|        to existing slice tuple without creating a new tuple every time.
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|    """
   575|         0|            0|            0|  0.00%|    # Cache a result that will be reused.
   576|         0|            0|            0|  0.00%|    shape_at_axis = [shape[axis] for shape in shapes]
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    # Take a shape, any shape
   579|         0|            0|            0|  0.00%|    first_shape = shapes[0]
   580|         0|            0|            0|  0.00%|    first_shape_pre = first_shape[:axis]
   581|         0|            0|            0|  0.00%|    first_shape_post = first_shape[axis+1:]
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|    if any(shape[:axis] != first_shape_pre or
   584|         0|            0|            0|  0.00%|           shape[axis+1:] != first_shape_post for shape in shapes):
   585|         0|            0|            0|  0.00%|        raise ValueError(
   586|         0|            0|            0|  0.00%|            'Mismatched array shapes in block along axis {}.'.format(axis))
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|    shape = (first_shape_pre + (sum(shape_at_axis),) + first_shape[axis+1:])
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|    offsets_at_axis = _accumulate(shape_at_axis)
   591|         0|            0|            0|  0.00%|    slice_prefixes = [(slice(start, end),)
   592|         0|            0|            0|  0.00%|                      for start, end in zip([0] + offsets_at_axis,
   593|         0|            0|            0|  0.00%|                                            offsets_at_axis)]
   594|         0|            0|            0|  0.00%|    return shape, slice_prefixes
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|def _block_info_recursion(arrays, max_depth, result_ndim, depth=0):
   598|         0|            0|            0|  0.00%|    """
   599|         0|            0|            0|  0.00%|    Returns the shape of the final array, along with a list
   600|         0|            0|            0|  0.00%|    of slices and a list of arrays that can be used for assignment inside the
   601|         0|            0|            0|  0.00%|    new array
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|    Parameters
   604|         0|            0|            0|  0.00%|    ----------
   605|         0|            0|            0|  0.00%|    arrays : nested list of arrays
   606|         0|            0|            0|  0.00%|        The arrays to check
   607|         0|            0|            0|  0.00%|    max_depth : list of int
   608|         0|            0|            0|  0.00%|        The number of nested lists
   609|         0|            0|            0|  0.00%|    result_ndim : int
   610|         0|            0|            0|  0.00%|        The number of dimensions in thefinal array.
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|    Returns
   613|         0|            0|            0|  0.00%|    -------
   614|         0|            0|            0|  0.00%|    shape : tuple of int
   615|         0|            0|            0|  0.00%|        The shape that the final array will take on.
   616|         0|            0|            0|  0.00%|    slices: list of tuple of slices
   617|         0|            0|            0|  0.00%|        The slices into the full array required for assignment. These are
   618|         0|            0|            0|  0.00%|        required to be prepended with ``(Ellipsis, )`` to obtain to correct
   619|         0|            0|            0|  0.00%|        final index.
   620|         0|            0|            0|  0.00%|    arrays: list of ndarray
   621|         0|            0|            0|  0.00%|        The data to assign to each slice of the full array
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    """
   624|         0|            0|            0|  0.00%|    if depth < max_depth:
   625|         0|            0|            0|  0.00%|        shapes, slices, arrays = zip(
   626|         0|            0|            0|  0.00%|            *[_block_info_recursion(arr, max_depth, result_ndim, depth+1)
   627|         0|            0|            0|  0.00%|              for arr in arrays])
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|        axis = result_ndim - max_depth + depth
   630|         0|            0|            0|  0.00%|        shape, slice_prefixes = _concatenate_shapes(shapes, axis)
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|        # Prepend the slice prefix and flatten the slices
   633|         0|            0|            0|  0.00%|        slices = [slice_prefix + the_slice
   634|         0|            0|            0|  0.00%|                  for slice_prefix, inner_slices in zip(slice_prefixes, slices)
   635|         0|            0|            0|  0.00%|                  for the_slice in inner_slices]
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|        # Flatten the array list
   638|         0|            0|            0|  0.00%|        arrays = functools.reduce(operator.add, arrays)
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|        return shape, slices, arrays
   641|         0|            0|            0|  0.00%|    else:
   642|         0|            0|            0|  0.00%|        # We've 'bottomed out' - arrays is either a scalar or an array
   643|         0|            0|            0|  0.00%|        # type(arrays) is not list
   644|         0|            0|            0|  0.00%|        # Return the slice and the array inside a list to be consistent with
   645|         0|            0|            0|  0.00%|        # the recursive case.
   646|         0|            0|            0|  0.00%|        arr = _atleast_nd(arrays, result_ndim)
   647|         0|            0|            0|  0.00%|        return arr.shape, [()], [arr]
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|
   650|         0|            0|            0|  0.00%|def _block(arrays, max_depth, result_ndim, depth=0):
   651|         0|            0|            0|  0.00%|    """
   652|         0|            0|            0|  0.00%|    Internal implementation of block based on repeated concatenation.
   653|         0|            0|            0|  0.00%|    `arrays` is the argument passed to
   654|         0|            0|            0|  0.00%|    block. `max_depth` is the depth of nested lists within `arrays` and
   655|         0|            0|            0|  0.00%|    `result_ndim` is the greatest of the dimensions of the arrays in
   656|         0|            0|            0|  0.00%|    `arrays` and the depth of the lists in `arrays` (see block docstring
   657|         0|            0|            0|  0.00%|    for details).
   658|         0|            0|            0|  0.00%|    """
   659|         0|            0|            0|  0.00%|    if depth < max_depth:
   660|         0|            0|            0|  0.00%|        arrs = [_block(arr, max_depth, result_ndim, depth+1)
   661|         0|            0|            0|  0.00%|                for arr in arrays]
   662|         0|            0|            0|  0.00%|        return _concatenate(arrs, axis=-(max_depth-depth))
   663|         0|            0|            0|  0.00%|    else:
   664|         0|            0|            0|  0.00%|        # We've 'bottomed out' - arrays is either a scalar or an array
   665|         0|            0|            0|  0.00%|        # type(arrays) is not list
   666|         0|            0|            0|  0.00%|        return _atleast_nd(arrays, result_ndim)
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|def _block_dispatcher(arrays):
   670|         0|            0|            0|  0.00%|    # Use type(...) is list to match the behavior of np.block(), which special
   671|         0|            0|            0|  0.00%|    # cases list specifically rather than allowing for generic iterables or
   672|         0|            0|            0|  0.00%|    # tuple. Also, we know that list.__array_function__ will never exist.
   673|         0|            0|            0|  0.00%|    if type(arrays) is list:
   674|         0|            0|            0|  0.00%|        for subarrays in arrays:
   675|         0|            0|            0|  0.00%|            yield from _block_dispatcher(subarrays)
   676|         0|            0|            0|  0.00%|    else:
   677|         0|            0|            0|  0.00%|        yield arrays
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|@array_function_dispatch(_block_dispatcher)
   681|         0|            0|            0|  0.00%|def block(arrays):
   682|         0|            0|            0|  0.00%|    """
   683|         0|            0|            0|  0.00%|    Assemble an nd-array from nested lists of blocks.
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|    Blocks in the innermost lists are concatenated (see `concatenate`) along
   686|         0|            0|            0|  0.00%|    the last dimension (-1), then these are concatenated along the
   687|         0|            0|            0|  0.00%|    second-last dimension (-2), and so on until the outermost list is reached.
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    Blocks can be of any dimension, but will not be broadcasted using the normal
   690|         0|            0|            0|  0.00%|    rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``
   691|         0|            0|            0|  0.00%|    the same for all blocks. This is primarily useful for working with scalars,
   692|         0|            0|            0|  0.00%|    and means that code like ``np.block([v, 1])`` is valid, where
   693|         0|            0|            0|  0.00%|    ``v.ndim == 1``.
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|    When the nested list is two levels deep, this allows block matrices to be
   696|         0|            0|            0|  0.00%|    constructed from their components.
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    .. versionadded:: 1.13.0
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|    Parameters
   701|         0|            0|            0|  0.00%|    ----------
   702|         0|            0|            0|  0.00%|    arrays : nested list of array_like or scalars (but not tuples)
   703|         0|            0|            0|  0.00%|        If passed a single ndarray or scalar (a nested list of depth 0), this
   704|         0|            0|            0|  0.00%|        is returned unmodified (and not copied).
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|        Elements shapes must match along the appropriate axes (without
   707|         0|            0|            0|  0.00%|        broadcasting), but leading 1s will be prepended to the shape as
   708|         0|            0|            0|  0.00%|        necessary to make the dimensions match.
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|    Returns
   711|         0|            0|            0|  0.00%|    -------
   712|         0|            0|            0|  0.00%|    block_array : ndarray
   713|         0|            0|            0|  0.00%|        The array assembled from the given blocks.
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|        The dimensionality of the output is equal to the greatest of:
   716|         0|            0|            0|  0.00%|        * the dimensionality of all the inputs
   717|         0|            0|            0|  0.00%|        * the depth to which the input list is nested
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    Raises
   720|         0|            0|            0|  0.00%|    ------
   721|         0|            0|            0|  0.00%|    ValueError
   722|         0|            0|            0|  0.00%|        * If list depths are mismatched - for instance, ``[[a, b], c]`` is
   723|         0|            0|            0|  0.00%|          illegal, and should be spelt ``[[a, b], [c]]``
   724|         0|            0|            0|  0.00%|        * If lists are empty - for instance, ``[[a, b], []]``
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|    See Also
   727|         0|            0|            0|  0.00%|    --------
   728|         0|            0|            0|  0.00%|    concatenate : Join a sequence of arrays along an existing axis.
   729|         0|            0|            0|  0.00%|    stack : Join a sequence of arrays along a new axis.
   730|         0|            0|            0|  0.00%|    vstack : Stack arrays in sequence vertically (row wise).
   731|         0|            0|            0|  0.00%|    hstack : Stack arrays in sequence horizontally (column wise).
   732|         0|            0|            0|  0.00%|    dstack : Stack arrays in sequence depth wise (along third axis).
   733|         0|            0|            0|  0.00%|    column_stack : Stack 1-D arrays as columns into a 2-D array.
   734|         0|            0|            0|  0.00%|    vsplit : Split an array into multiple sub-arrays vertically (row-wise).
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|    Notes
   737|         0|            0|            0|  0.00%|    -----
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|    When called with only scalars, ``np.block`` is equivalent to an ndarray
   740|         0|            0|            0|  0.00%|    call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to
   741|         0|            0|            0|  0.00%|    ``np.array([[1, 2], [3, 4]])``.
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|    This function does not enforce that the blocks lie on a fixed grid.
   744|         0|            0|            0|  0.00%|    ``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|        AAAbb
   747|         0|            0|            0|  0.00%|        AAAbb
   748|         0|            0|            0|  0.00%|        cccDD
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|    But is also allowed to produce, for some ``a, b, c, d``::
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|        AAAbb
   753|         0|            0|            0|  0.00%|        AAAbb
   754|         0|            0|            0|  0.00%|        cDDDD
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|    Since concatenation happens along the last axis first, `block` is _not_
   757|         0|            0|            0|  0.00%|    capable of producing the following directly::
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|        AAAbb
   760|         0|            0|            0|  0.00%|        cccbb
   761|         0|            0|            0|  0.00%|        cccDD
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|    Matlab's "square bracket stacking", ``[A, B, ...; p, q, ...]``, is
   764|         0|            0|            0|  0.00%|    equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    Examples
   767|         0|            0|            0|  0.00%|    --------
   768|         0|            0|            0|  0.00%|    The most common use of this function is to build a block matrix
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|    >>> A = np.eye(2) * 2
   771|         0|            0|            0|  0.00%|    >>> B = np.eye(3) * 3
   772|         0|            0|            0|  0.00%|    >>> np.block([
   773|         0|            0|            0|  0.00%|    ...     [A,               np.zeros((2, 3))],
   774|         0|            0|            0|  0.00%|    ...     [np.ones((3, 2)), B               ]
   775|         0|            0|            0|  0.00%|    ... ])
   776|         0|            0|            0|  0.00%|    array([[2., 0., 0., 0., 0.],
   777|         0|            0|            0|  0.00%|           [0., 2., 0., 0., 0.],
   778|         0|            0|            0|  0.00%|           [1., 1., 3., 0., 0.],
   779|         0|            0|            0|  0.00%|           [1., 1., 0., 3., 0.],
   780|         0|            0|            0|  0.00%|           [1., 1., 0., 0., 3.]])
   781|         0|            0|            0|  0.00%|
   782|         0|            0|            0|  0.00%|    With a list of depth 1, `block` can be used as `hstack`
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|    >>> np.block([1, 2, 3])              # hstack([1, 2, 3])
   785|         0|            0|            0|  0.00%|    array([1, 2, 3])
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3])
   788|         0|            0|            0|  0.00%|    >>> b = np.array([4, 5, 6])
   789|         0|            0|            0|  0.00%|    >>> np.block([a, b, 10])             # hstack([a, b, 10])
   790|         0|            0|            0|  0.00%|    array([ 1,  2,  3,  4,  5,  6, 10])
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|    >>> A = np.ones((2, 2), int)
   793|         0|            0|            0|  0.00%|    >>> B = 2 * A
   794|         0|            0|            0|  0.00%|    >>> np.block([A, B])                 # hstack([A, B])
   795|         0|            0|            0|  0.00%|    array([[1, 1, 2, 2],
   796|         0|            0|            0|  0.00%|           [1, 1, 2, 2]])
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|    With a list of depth 2, `block` can be used in place of `vstack`:
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3])
   801|         0|            0|            0|  0.00%|    >>> b = np.array([4, 5, 6])
   802|         0|            0|            0|  0.00%|    >>> np.block([[a], [b]])             # vstack([a, b])
   803|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   804|         0|            0|            0|  0.00%|           [4, 5, 6]])
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    >>> A = np.ones((2, 2), int)
   807|         0|            0|            0|  0.00%|    >>> B = 2 * A
   808|         0|            0|            0|  0.00%|    >>> np.block([[A], [B]])             # vstack([A, B])
   809|         0|            0|            0|  0.00%|    array([[1, 1],
   810|         0|            0|            0|  0.00%|           [1, 1],
   811|         0|            0|            0|  0.00%|           [2, 2],
   812|         0|            0|            0|  0.00%|           [2, 2]])
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|    It can also be used in places of `atleast_1d` and `atleast_2d`
   815|         0|            0|            0|  0.00%|
   816|         0|            0|            0|  0.00%|    >>> a = np.array(0)
   817|         0|            0|            0|  0.00%|    >>> b = np.array([1])
   818|         0|            0|            0|  0.00%|    >>> np.block([a])                    # atleast_1d(a)
   819|         0|            0|            0|  0.00%|    array([0])
   820|         0|            0|            0|  0.00%|    >>> np.block([b])                    # atleast_1d(b)
   821|         0|            0|            0|  0.00%|    array([1])
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|    >>> np.block([[a]])                  # atleast_2d(a)
   824|         0|            0|            0|  0.00%|    array([[0]])
   825|         0|            0|            0|  0.00%|    >>> np.block([[b]])                  # atleast_2d(b)
   826|         0|            0|            0|  0.00%|    array([[1]])
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|    """
   830|         0|            0|            0|  0.00%|    arrays, list_ndim, result_ndim, final_size = _block_setup(arrays)
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    # It was found through benchmarking that making an array of final size
   833|         0|            0|            0|  0.00%|    # around 256x256 was faster by straight concatenation on a
   834|         0|            0|            0|  0.00%|    # i7-7700HQ processor and dual channel ram 2400MHz.
   835|         0|            0|            0|  0.00%|    # It didn't seem to matter heavily on the dtype used.
   836|         0|            0|            0|  0.00%|    #
   837|         0|            0|            0|  0.00%|    # A 2D array using repeated concatenation requires 2 copies of the array.
   838|         0|            0|            0|  0.00%|    #
   839|         0|            0|            0|  0.00%|    # The fastest algorithm will depend on the ratio of CPU power to memory
   840|         0|            0|            0|  0.00%|    # speed.
   841|         0|            0|            0|  0.00%|    # One can monitor the results of the benchmark
   842|         0|            0|            0|  0.00%|    # https://pv.github.io/numpy-bench/#bench_shape_base.Block2D.time_block2d
   843|         0|            0|            0|  0.00%|    # to tune this parameter until a C version of the `_block_info_recursion`
   844|         0|            0|            0|  0.00%|    # algorithm is implemented which would likely be faster than the python
   845|         0|            0|            0|  0.00%|    # version.
   846|         0|            0|            0|  0.00%|    if list_ndim * final_size > (2 * 512 * 512):
   847|         0|            0|            0|  0.00%|        return _block_slicing(arrays, list_ndim, result_ndim)
   848|         0|            0|            0|  0.00%|    else:
   849|         0|            0|            0|  0.00%|        return _block_concatenate(arrays, list_ndim, result_ndim)
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|# These helper functions are mostly used for testing.
   853|         0|            0|            0|  0.00%|# They allow us to write tests that directly call `_block_slicing`
   854|         0|            0|            0|  0.00%|# or `_block_concatenate` without blocking large arrays to force the wisdom
   855|         0|            0|            0|  0.00%|# to trigger the desired path.
   856|         0|            0|            0|  0.00%|def _block_setup(arrays):
   857|         0|            0|            0|  0.00%|    """
   858|         0|            0|            0|  0.00%|    Returns
   859|         0|            0|            0|  0.00%|    (`arrays`, list_ndim, result_ndim, final_size)
   860|         0|            0|            0|  0.00%|    """
   861|         0|            0|            0|  0.00%|    bottom_index, arr_ndim, final_size = _block_check_depths_match(arrays)
   862|         0|            0|            0|  0.00%|    list_ndim = len(bottom_index)
   863|         0|            0|            0|  0.00%|    if bottom_index and bottom_index[-1] is None:
   864|         0|            0|            0|  0.00%|        raise ValueError(
   865|         0|            0|            0|  0.00%|            'List at {} cannot be empty'.format(
   866|         0|            0|            0|  0.00%|                _block_format_index(bottom_index)
   867|         0|            0|            0|  0.00%|            )
   868|         0|            0|            0|  0.00%|        )
   869|         0|            0|            0|  0.00%|    result_ndim = max(arr_ndim, list_ndim)
   870|         0|            0|            0|  0.00%|    return arrays, list_ndim, result_ndim, final_size
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|def _block_slicing(arrays, list_ndim, result_ndim):
   874|         0|            0|            0|  0.00%|    shape, slices, arrays = _block_info_recursion(
   875|         0|            0|            0|  0.00%|        arrays, list_ndim, result_ndim)
   876|         0|            0|            0|  0.00%|    dtype = _nx.result_type(*[arr.dtype for arr in arrays])
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|    # Test preferring F only in the case that all input arrays are F
   879|         0|            0|            0|  0.00%|    F_order = all(arr.flags['F_CONTIGUOUS'] for arr in arrays)
   880|         0|            0|            0|  0.00%|    C_order = all(arr.flags['C_CONTIGUOUS'] for arr in arrays)
   881|         0|            0|            0|  0.00%|    order = 'F' if F_order and not C_order else 'C'
   882|         0|            0|            0|  0.00%|    result = _nx.empty(shape=shape, dtype=dtype, order=order)
   883|         0|            0|            0|  0.00%|    # Note: In a c implementation, the function
   884|         0|            0|            0|  0.00%|    # PyArray_CreateMultiSortedStridePerm could be used for more advanced
   885|         0|            0|            0|  0.00%|    # guessing of the desired order.
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|    for the_slice, arr in zip(slices, arrays):
   888|         0|            0|            0|  0.00%|        result[(Ellipsis,) + the_slice] = arr
   889|         0|            0|            0|  0.00%|    return result
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|
   892|         0|            0|            0|  0.00%|def _block_concatenate(arrays, list_ndim, result_ndim):
   893|         0|            0|            0|  0.00%|    result = _block(arrays, list_ndim, result_ndim)
   894|         0|            0|            0|  0.00%|    if list_ndim == 0:
   895|         0|            0|            0|  0.00%|        # Catch an edge case where _block returns a view because
   896|         0|            0|            0|  0.00%|        # `arrays` is a single numpy array and not a list of numpy arrays.
   897|         0|            0|            0|  0.00%|        # This might copy scalars or lists twice, but this isn't a likely
   898|         0|            0|            0|  0.00%|        # usecase for those interested in performance
   899|         0|            0|            0|  0.00%|        result = result.copy()
   900|         0|            0|            0|  0.00%|    return result
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py
File duration: 0.252174s (0.72%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Machine limits for Float32 and Float64 and (long double) if available...
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|"""
     4|         0|            0|            0|  0.00%|__all__ = ['finfo', 'iinfo']
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|import warnings
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|from ._machar import MachAr
     9|         0|            0|            0|  0.00%|from .overrides import set_module
    10|         0|            0|            0|  0.00%|from . import numeric
    11|         0|            0|            0|  0.00%|from . import numerictypes as ntypes
    12|         0|            0|            0|  0.00%|from .numeric import array, inf, NaN
    13|         0|            0|            0|  0.00%|from .umath import log10, exp2, nextafter, isnan
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|def _fr0(a):
    17|         0|            0|            0|  0.00%|    """fix rank-0 --> rank-1"""
    18|         0|            0|            0|  0.00%|    if a.ndim == 0:
    19|         0|            0|            0|  0.00%|        a = a.copy()
    20|         0|            0|            0|  0.00%|        a.shape = (1,)
    21|         0|            0|            0|  0.00%|    return a
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|def _fr1(a):
    25|         0|            0|            0|  0.00%|    """fix rank > 0 --> rank-0"""
    26|         0|            0|            0|  0.00%|    if a.size == 1:
    27|         0|            0|            0|  0.00%|        a = a.copy()
    28|         0|            0|            0|  0.00%|        a.shape = ()
    29|         0|            0|            0|  0.00%|    return a
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|class MachArLike:
    33|         0|            0|            0|  0.00%|    """ Object to simulate MachAr instance """
    34|         0|            0|            0|  0.00%|    def __init__(self, ftype, *, eps, epsneg, huge, tiny,
    35|         0|            0|            0|  0.00%|                 ibeta, smallest_subnormal=None, **kwargs):
    36|         0|            0|            0|  0.00%|        self.params = _MACHAR_PARAMS[ftype]
    37|         0|            0|            0|  0.00%|        self.ftype = ftype
    38|         0|            0|            0|  0.00%|        self.title = self.params['title']
    39|         0|            0|            0|  0.00%|        # Parameter types same as for discovered MachAr object.
    40|         0|            0|            0|  0.00%|        if not smallest_subnormal:
    41|         0|            0|            0|  0.00%|            self._smallest_subnormal = nextafter(
    42|         0|            0|            0|  0.00%|                self.ftype(0), self.ftype(1), dtype=self.ftype)
    43|         0|            0|            0|  0.00%|        else:
    44|         0|            0|            0|  0.00%|            self._smallest_subnormal = smallest_subnormal
    45|         0|            0|            0|  0.00%|        self.epsilon = self.eps = self._float_to_float(eps)
    46|         0|            0|            0|  0.00%|        self.epsneg = self._float_to_float(epsneg)
    47|         0|            0|            0|  0.00%|        self.xmax = self.huge = self._float_to_float(huge)
    48|         0|            0|            0|  0.00%|        self.xmin = self._float_to_float(tiny)
    49|         0|            0|            0|  0.00%|        self.smallest_normal = self.tiny = self._float_to_float(tiny)
    50|         0|            0|            0|  0.00%|        self.ibeta = self.params['itype'](ibeta)
    51|         0|            0|            0|  0.00%|        self.__dict__.update(kwargs)
    52|         0|            0|            0|  0.00%|        self.precision = int(-log10(self.eps))
    53|         0|            0|            0|  0.00%|        self.resolution = self._float_to_float(
    54|         0|            0|            0|  0.00%|            self._float_conv(10) ** (-self.precision))
    55|         0|            0|            0|  0.00%|        self._str_eps = self._float_to_str(self.eps)
    56|         0|            0|            0|  0.00%|        self._str_epsneg = self._float_to_str(self.epsneg)
    57|         0|            0|            0|  0.00%|        self._str_xmin = self._float_to_str(self.xmin)
    58|         0|            0|            0|  0.00%|        self._str_xmax = self._float_to_str(self.xmax)
    59|         0|            0|            0|  0.00%|        self._str_resolution = self._float_to_str(self.resolution)
    60|         0|            0|            0|  0.00%|        self._str_smallest_normal = self._float_to_str(self.xmin)
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    @property
    63|         0|            0|            0|  0.00%|    def smallest_subnormal(self):
    64|         0|            0|            0|  0.00%|        """Return the value for the smallest subnormal.
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|        Returns
    67|         0|            0|            0|  0.00%|        -------
    68|         0|            0|            0|  0.00%|        smallest_subnormal : float
    69|         0|            0|            0|  0.00%|            value for the smallest subnormal.
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|        Warns
    72|         0|            0|            0|  0.00%|        -----
    73|         0|            0|            0|  0.00%|        UserWarning
    74|         0|            0|            0|  0.00%|            If the calculated value for the smallest subnormal is zero.
    75|         0|            0|            0|  0.00%|        """
    76|         0|            0|            0|  0.00%|        # Check that the calculated value is not zero, in case it raises a
    77|         0|            0|            0|  0.00%|        # warning.
    78|         0|            0|            0|  0.00%|        value = self._smallest_subnormal
    79|         0|            0|            0|  0.00%|        if self.ftype(0) == value:
    80|         0|            0|            0|  0.00%|            warnings.warn(
    81|         0|            0|            0|  0.00%|                'The value of the smallest subnormal for {} type '
    82|         0|            0|            0|  0.00%|                'is zero.'.format(self.ftype), UserWarning, stacklevel=2)
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|        return self._float_to_float(value)
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    @property
    87|         0|            0|            0|  0.00%|    def _str_smallest_subnormal(self):
    88|         0|            0|            0|  0.00%|        """Return the string representation of the smallest subnormal."""
    89|         0|            0|            0|  0.00%|        return self._float_to_str(self.smallest_subnormal)
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|    def _float_to_float(self, value):
    92|         0|            0|            0|  0.00%|        """Converts float to float.
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|        Parameters
    95|         0|            0|            0|  0.00%|        ----------
    96|         0|            0|            0|  0.00%|        value : float
    97|         0|            0|            0|  0.00%|            value to be converted.
    98|         0|            0|            0|  0.00%|        """
    99|         0|            0|            0|  0.00%|        return _fr1(self._float_conv(value))
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    def _float_conv(self, value):
   102|         0|            0|            0|  0.00%|        """Converts float to conv.
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|        Parameters
   105|         0|            0|            0|  0.00%|        ----------
   106|         0|            0|            0|  0.00%|        value : float
   107|         0|            0|            0|  0.00%|            value to be converted.
   108|         0|            0|            0|  0.00%|        """
   109|         0|            0|            0|  0.00%|        return array([value], self.ftype)
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    def _float_to_str(self, value):
   112|         0|            0|            0|  0.00%|        """Converts float to str.
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|        Parameters
   115|         0|            0|            0|  0.00%|        ----------
   116|         0|            0|            0|  0.00%|        value : float
   117|         0|            0|            0|  0.00%|            value to be converted.
   118|         0|            0|            0|  0.00%|        """
   119|         0|            0|            0|  0.00%|        return self.params['fmt'] % array(_fr0(value)[0], self.ftype)
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|_convert_to_float = {
   123|         0|            0|            0|  0.00%|    ntypes.csingle: ntypes.single,
   124|         0|            0|            0|  0.00%|    ntypes.complex_: ntypes.float_,
   125|         0|            0|            0|  0.00%|    ntypes.clongfloat: ntypes.longfloat
   126|         0|            0|            0|  0.00%|    }
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|# Parameters for creating MachAr / MachAr-like objects
   129|         0|            0|            0|  0.00%|_title_fmt = 'numpy {} precision floating point number'
   130|         0|            0|            0|  0.00%|_MACHAR_PARAMS = {
   131|         0|            0|            0|  0.00%|    ntypes.double: dict(
   132|         0|            0|            0|  0.00%|        itype = ntypes.int64,
   133|         0|            0|            0|  0.00%|        fmt = '%24.16e',
   134|         0|            0|            0|  0.00%|        title = _title_fmt.format('double')),
   135|         0|            0|            0|  0.00%|    ntypes.single: dict(
   136|         0|            0|            0|  0.00%|        itype = ntypes.int32,
   137|         0|            0|            0|  0.00%|        fmt = '%15.7e',
   138|         0|            0|            0|  0.00%|        title = _title_fmt.format('single')),
   139|         0|            0|            0|  0.00%|    ntypes.longdouble: dict(
   140|         0|            0|            0|  0.00%|        itype = ntypes.longlong,
   141|         0|            0|            0|  0.00%|        fmt = '%s',
   142|         0|            0|            0|  0.00%|        title = _title_fmt.format('long double')),
   143|         0|            0|            0|  0.00%|    ntypes.half: dict(
   144|         0|            0|            0|  0.00%|        itype = ntypes.int16,
   145|         0|            0|            0|  0.00%|        fmt = '%12.5e',
   146|         0|            0|            0|  0.00%|        title = _title_fmt.format('half'))}
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|# Key to identify the floating point type.  Key is result of
   149|         0|            0|            0|  0.00%|# ftype('-0.1').newbyteorder('<').tobytes()
   150|         0|            0|            0|  0.00%|# See:
   151|         0|            0|            0|  0.00%|# https://perl5.git.perl.org/perl.git/blob/3118d7d684b56cbeb702af874f4326683c45f045:/Configure
   152|         0|            0|            0|  0.00%|_KNOWN_TYPES = {}
   153|         0|            0|            0|  0.00%|def _register_type(machar, bytepat):
   154|         0|            0|            0|  0.00%|    _KNOWN_TYPES[bytepat] = machar
   155|         0|            0|            0|  0.00%|_float_ma = {}
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|def _register_known_types():
   159|         0|            0|            0|  0.00%|    # Known parameters for float16
   160|         0|            0|            0|  0.00%|    # See docstring of MachAr class for description of parameters.
   161|         0|            0|            0|  0.00%|    f16 = ntypes.float16
   162|         0|            0|            0|  0.00%|    float16_ma = MachArLike(f16,
   163|         0|            0|            0|  0.00%|                            machep=-10,
   164|         0|            0|            0|  0.00%|                            negep=-11,
   165|         0|            0|            0|  0.00%|                            minexp=-14,
   166|         0|            0|            0|  0.00%|                            maxexp=16,
   167|         0|            0|            0|  0.00%|                            it=10,
   168|         0|            0|            0|  0.00%|                            iexp=5,
   169|         0|            0|            0|  0.00%|                            ibeta=2,
   170|         0|            0|            0|  0.00%|                            irnd=5,
   171|         0|            0|            0|  0.00%|                            ngrd=0,
   172|         0|            0|            0|  0.00%|                            eps=exp2(f16(-10)),
   173|         0|            0|            0|  0.00%|                            epsneg=exp2(f16(-11)),
   174|         0|            0|            0|  0.00%|                            huge=f16(65504),
   175|         0|            0|            0|  0.00%|                            tiny=f16(2 ** -14))
   176|         0|            0|            0|  0.00%|    _register_type(float16_ma, b'f\xae')
   177|         0|            0|            0|  0.00%|    _float_ma[16] = float16_ma
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|    # Known parameters for float32
   180|         0|            0|            0|  0.00%|    f32 = ntypes.float32
   181|         0|            0|            0|  0.00%|    float32_ma = MachArLike(f32,
   182|         0|            0|            0|  0.00%|                            machep=-23,
   183|         0|            0|            0|  0.00%|                            negep=-24,
   184|         0|            0|            0|  0.00%|                            minexp=-126,
   185|         0|            0|            0|  0.00%|                            maxexp=128,
   186|         0|            0|            0|  0.00%|                            it=23,
   187|         0|            0|            0|  0.00%|                            iexp=8,
   188|         0|            0|            0|  0.00%|                            ibeta=2,
   189|         0|            0|            0|  0.00%|                            irnd=5,
   190|         0|            0|            0|  0.00%|                            ngrd=0,
   191|         0|            0|            0|  0.00%|                            eps=exp2(f32(-23)),
   192|         0|            0|            0|  0.00%|                            epsneg=exp2(f32(-24)),
   193|         0|            0|            0|  0.00%|                            huge=f32((1 - 2 ** -24) * 2**128),
   194|         0|            0|            0|  0.00%|                            tiny=exp2(f32(-126)))
   195|         0|            0|            0|  0.00%|    _register_type(float32_ma, b'\xcd\xcc\xcc\xbd')
   196|         0|            0|            0|  0.00%|    _float_ma[32] = float32_ma
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    # Known parameters for float64
   199|         0|            0|            0|  0.00%|    f64 = ntypes.float64
   200|         0|            0|            0|  0.00%|    epsneg_f64 = 2.0 ** -53.0
   201|         0|            0|            0|  0.00%|    tiny_f64 = 2.0 ** -1022.0
   202|         0|            0|            0|  0.00%|    float64_ma = MachArLike(f64,
   203|         0|            0|            0|  0.00%|                            machep=-52,
   204|         0|            0|            0|  0.00%|                            negep=-53,
   205|         0|            0|            0|  0.00%|                            minexp=-1022,
   206|         0|            0|            0|  0.00%|                            maxexp=1024,
   207|         0|            0|            0|  0.00%|                            it=52,
   208|         0|            0|            0|  0.00%|                            iexp=11,
   209|         0|            0|            0|  0.00%|                            ibeta=2,
   210|         0|            0|            0|  0.00%|                            irnd=5,
   211|         0|            0|            0|  0.00%|                            ngrd=0,
   212|         0|            0|            0|  0.00%|                            eps=2.0 ** -52.0,
   213|         0|            0|            0|  0.00%|                            epsneg=epsneg_f64,
   214|         0|            0|            0|  0.00%|                            huge=(1.0 - epsneg_f64) / tiny_f64 * f64(4),
   215|         0|            0|            0|  0.00%|                            tiny=tiny_f64)
   216|         0|            0|            0|  0.00%|    _register_type(float64_ma, b'\x9a\x99\x99\x99\x99\x99\xb9\xbf')
   217|         0|            0|            0|  0.00%|    _float_ma[64] = float64_ma
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|    # Known parameters for IEEE 754 128-bit binary float
   220|         0|            0|            0|  0.00%|    ld = ntypes.longdouble
   221|         0|            0|            0|  0.00%|    epsneg_f128 = exp2(ld(-113))
   222|         0|            0|            0|  0.00%|    tiny_f128 = exp2(ld(-16382))
   223|         0|            0|            0|  0.00%|    # Ignore runtime error when this is not f128
   224|         0|            0|            0|  0.00%|    with numeric.errstate(all='ignore'):
   225|         0|            0|            0|  0.00%|        huge_f128 = (ld(1) - epsneg_f128) / tiny_f128 * ld(4)
   226|         0|            0|            0|  0.00%|    float128_ma = MachArLike(ld,
   227|         0|            0|            0|  0.00%|                             machep=-112,
   228|         0|            0|            0|  0.00%|                             negep=-113,
   229|         0|            0|            0|  0.00%|                             minexp=-16382,
   230|         0|            0|            0|  0.00%|                             maxexp=16384,
   231|         0|            0|            0|  0.00%|                             it=112,
   232|         0|            0|            0|  0.00%|                             iexp=15,
   233|         0|            0|            0|  0.00%|                             ibeta=2,
   234|         0|            0|            0|  0.00%|                             irnd=5,
   235|         0|            0|            0|  0.00%|                             ngrd=0,
   236|         0|            0|            0|  0.00%|                             eps=exp2(ld(-112)),
   237|         0|            0|            0|  0.00%|                             epsneg=epsneg_f128,
   238|         0|            0|            0|  0.00%|                             huge=huge_f128,
   239|         0|            0|            0|  0.00%|                             tiny=tiny_f128)
   240|         0|            0|            0|  0.00%|    # IEEE 754 128-bit binary float
   241|         0|            0|            0|  0.00%|    _register_type(float128_ma,
   242|         0|            0|            0|  0.00%|        b'\x9a\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\xfb\xbf')
   243|         0|            0|            0|  0.00%|    _register_type(float128_ma,
   244|         0|            0|            0|  0.00%|        b'\x9a\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\xfb\xbf')
   245|         0|            0|            0|  0.00%|    _float_ma[128] = float128_ma
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    # Known parameters for float80 (Intel 80-bit extended precision)
   248|         0|            0|            0|  0.00%|    epsneg_f80 = exp2(ld(-64))
   249|         0|            0|            0|  0.00%|    tiny_f80 = exp2(ld(-16382))
   250|         0|            0|            0|  0.00%|    # Ignore runtime error when this is not f80
   251|         0|            0|            0|  0.00%|    with numeric.errstate(all='ignore'):
   252|         0|            0|            0|  0.00%|        huge_f80 = (ld(1) - epsneg_f80) / tiny_f80 * ld(4)
   253|         0|            0|            0|  0.00%|    float80_ma = MachArLike(ld,
   254|         0|            0|            0|  0.00%|                            machep=-63,
   255|         0|            0|            0|  0.00%|                            negep=-64,
   256|         0|            0|            0|  0.00%|                            minexp=-16382,
   257|         0|            0|            0|  0.00%|                            maxexp=16384,
   258|         0|            0|            0|  0.00%|                            it=63,
   259|         0|            0|            0|  0.00%|                            iexp=15,
   260|         0|            0|            0|  0.00%|                            ibeta=2,
   261|         0|            0|            0|  0.00%|                            irnd=5,
   262|         0|            0|            0|  0.00%|                            ngrd=0,
   263|         0|            0|            0|  0.00%|                            eps=exp2(ld(-63)),
   264|         0|            0|            0|  0.00%|                            epsneg=epsneg_f80,
   265|         0|            0|            0|  0.00%|                            huge=huge_f80,
   266|         0|            0|            0|  0.00%|                            tiny=tiny_f80)
   267|         0|            0|            0|  0.00%|    # float80, first 10 bytes containing actual storage
   268|         0|            0|            0|  0.00%|    _register_type(float80_ma, b'\xcd\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xfb\xbf')
   269|         0|            0|            0|  0.00%|    _float_ma[80] = float80_ma
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    # Guessed / known parameters for double double; see:
   272|         0|            0|            0|  0.00%|    # https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic
   273|         0|            0|            0|  0.00%|    # These numbers have the same exponent range as float64, but extended number of
   274|         0|            0|            0|  0.00%|    # digits in the significand.
   275|         0|            0|            0|  0.00%|    huge_dd = nextafter(ld(inf), ld(0), dtype=ld)
   276|         0|            0|            0|  0.00%|    # As the smallest_normal in double double is so hard to calculate we set
   277|         0|            0|            0|  0.00%|    # it to NaN.
   278|         0|            0|            0|  0.00%|    smallest_normal_dd = NaN
   279|         0|            0|            0|  0.00%|    # Leave the same value for the smallest subnormal as double
   280|         0|            0|            0|  0.00%|    smallest_subnormal_dd = ld(nextafter(0., 1.))
   281|         0|            0|            0|  0.00%|    float_dd_ma = MachArLike(ld,
   282|         0|            0|            0|  0.00%|                             machep=-105,
   283|         0|            0|            0|  0.00%|                             negep=-106,
   284|         0|            0|            0|  0.00%|                             minexp=-1022,
   285|         0|            0|            0|  0.00%|                             maxexp=1024,
   286|         0|            0|            0|  0.00%|                             it=105,
   287|         0|            0|            0|  0.00%|                             iexp=11,
   288|         0|            0|            0|  0.00%|                             ibeta=2,
   289|         0|            0|            0|  0.00%|                             irnd=5,
   290|         0|            0|            0|  0.00%|                             ngrd=0,
   291|         0|            0|            0|  0.00%|                             eps=exp2(ld(-105)),
   292|         0|            0|            0|  0.00%|                             epsneg=exp2(ld(-106)),
   293|         0|            0|            0|  0.00%|                             huge=huge_dd,
   294|         0|            0|            0|  0.00%|                             tiny=smallest_normal_dd,
   295|         0|            0|            0|  0.00%|                             smallest_subnormal=smallest_subnormal_dd)
   296|         0|            0|            0|  0.00%|    # double double; low, high order (e.g. PPC 64)
   297|         0|            0|            0|  0.00%|    _register_type(float_dd_ma,
   298|         0|            0|            0|  0.00%|        b'\x9a\x99\x99\x99\x99\x99Y<\x9a\x99\x99\x99\x99\x99\xb9\xbf')
   299|         0|            0|            0|  0.00%|    # double double; high, low order (e.g. PPC 64 le)
   300|         0|            0|            0|  0.00%|    _register_type(float_dd_ma,
   301|         0|            0|            0|  0.00%|        b'\x9a\x99\x99\x99\x99\x99\xb9\xbf\x9a\x99\x99\x99\x99\x99Y<')
   302|         0|            0|            0|  0.00%|    _float_ma['dd'] = float_dd_ma
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|def _get_machar(ftype):
   306|         0|            0|            0|  0.00%|    """ Get MachAr instance or MachAr-like instance
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    Get parameters for floating point type, by first trying signatures of
   309|         0|            0|            0|  0.00%|    various known floating point types, then, if none match, attempting to
   310|         0|            0|            0|  0.00%|    identify parameters by analysis.
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    Parameters
   313|         0|            0|            0|  0.00%|    ----------
   314|         0|            0|            0|  0.00%|    ftype : class
   315|         0|            0|            0|  0.00%|        Numpy floating point type class (e.g. ``np.float64``)
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    Returns
   318|         0|            0|            0|  0.00%|    -------
   319|         0|            0|            0|  0.00%|    ma_like : instance of :class:`MachAr` or :class:`MachArLike`
   320|         0|            0|            0|  0.00%|        Object giving floating point parameters for `ftype`.
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    Warns
   323|         0|            0|            0|  0.00%|    -----
   324|         0|            0|            0|  0.00%|    UserWarning
   325|         0|            0|            0|  0.00%|        If the binary signature of the float type is not in the dictionary of
   326|         0|            0|            0|  0.00%|        known float types.
   327|         0|            0|            0|  0.00%|    """
   328|         0|            0|            0|  0.00%|    params = _MACHAR_PARAMS.get(ftype)
   329|         0|            0|            0|  0.00%|    if params is None:
   330|         0|            0|            0|  0.00%|        raise ValueError(repr(ftype))
   331|         0|            0|            0|  0.00%|    # Detect known / suspected types
   332|         0|            0|            0|  0.00%|    key = ftype('-0.1').newbyteorder('<').tobytes()
   333|         0|            0|            0|  0.00%|    ma_like = None
   334|         0|            0|            0|  0.00%|    if ftype == ntypes.longdouble:
   335|         0|            0|            0|  0.00%|        # Could be 80 bit == 10 byte extended precision, where last bytes can
   336|         0|            0|            0|  0.00%|        # be random garbage.
   337|         0|            0|            0|  0.00%|        # Comparing first 10 bytes to pattern first to avoid branching on the
   338|         0|            0|            0|  0.00%|        # random garbage.
   339|         0|            0|            0|  0.00%|        ma_like = _KNOWN_TYPES.get(key[:10])
   340|         0|            0|            0|  0.00%|    if ma_like is None:
   341|         0|            0|            0|  0.00%|        ma_like = _KNOWN_TYPES.get(key)
   342|         0|            0|            0|  0.00%|    if ma_like is not None:
   343|         0|            0|            0|  0.00%|        return ma_like
   344|         0|            0|            0|  0.00%|    # Fall back to parameter discovery
   345|         0|            0|            0|  0.00%|    warnings.warn(
   346|         0|            0|            0|  0.00%|        'Signature {} for {} does not match any known type: '
   347|         0|            0|            0|  0.00%|        'falling back to type probe function'.format(key, ftype),
   348|         0|            0|            0|  0.00%|        UserWarning, stacklevel=2)
   349|         0|            0|            0|  0.00%|    return _discovered_machar(ftype)
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|def _discovered_machar(ftype):
   353|         0|            0|            0|  0.00%|    """ Create MachAr instance with found information on float types
   354|         0|            0|            0|  0.00%|    """
   355|         0|            0|            0|  0.00%|    params = _MACHAR_PARAMS[ftype]
   356|         0|            0|            0|  0.00%|    return MachAr(lambda v: array([v], ftype),
   357|         0|            0|            0|  0.00%|                  lambda v:_fr0(v.astype(params['itype']))[0],
   358|         0|            0|            0|  0.00%|                  lambda v:array(_fr0(v)[0], ftype),
   359|         0|            0|            0|  0.00%|                  lambda v: params['fmt'] % array(_fr0(v)[0], ftype),
   360|         0|            0|            0|  0.00%|                  params['title'])
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|@set_module('numpy')
   364|         0|            0|            0|  0.00%|class finfo:
   365|         0|            0|            0|  0.00%|    """
   366|         0|            0|            0|  0.00%|    finfo(dtype)
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|    Machine limits for floating point types.
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    Attributes
   371|         0|            0|            0|  0.00%|    ----------
   372|         0|            0|            0|  0.00%|    bits : int
   373|         0|            0|            0|  0.00%|        The number of bits occupied by the type.
   374|         0|            0|            0|  0.00%|    eps : float
   375|         0|            0|            0|  0.00%|        The difference between 1.0 and the next smallest representable float
   376|         0|            0|            0|  0.00%|        larger than 1.0. For example, for 64-bit binary floats in the IEEE-754
   377|         0|            0|            0|  0.00%|        standard, ``eps = 2**-52``, approximately 2.22e-16.
   378|         0|            0|            0|  0.00%|    epsneg : float
   379|         0|            0|            0|  0.00%|        The difference between 1.0 and the next smallest representable float
   380|         0|            0|            0|  0.00%|        less than 1.0. For example, for 64-bit binary floats in the IEEE-754
   381|         0|            0|            0|  0.00%|        standard, ``epsneg = 2**-53``, approximately 1.11e-16.
   382|         0|            0|            0|  0.00%|    iexp : int
   383|         0|            0|            0|  0.00%|        The number of bits in the exponent portion of the floating point
   384|         0|            0|            0|  0.00%|        representation.
   385|         0|            0|            0|  0.00%|    machar : MachAr
   386|         0|            0|            0|  0.00%|        The object which calculated these parameters and holds more
   387|         0|            0|            0|  0.00%|        detailed information.
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|        .. deprecated:: 1.22
   390|         0|            0|            0|  0.00%|    machep : int
   391|         0|            0|            0|  0.00%|        The exponent that yields `eps`.
   392|         0|            0|            0|  0.00%|    max : floating point number of the appropriate type
   393|         0|            0|            0|  0.00%|        The largest representable number.
   394|         0|            0|            0|  0.00%|    maxexp : int
   395|         0|            0|            0|  0.00%|        The smallest positive power of the base (2) that causes overflow.
   396|         0|            0|            0|  0.00%|    min : floating point number of the appropriate type
   397|         0|            0|            0|  0.00%|        The smallest representable number, typically ``-max``.
   398|         0|            0|            0|  0.00%|    minexp : int
   399|         0|            0|            0|  0.00%|        The most negative power of the base (2) consistent with there
   400|         0|            0|            0|  0.00%|        being no leading 0's in the mantissa.
   401|         0|            0|            0|  0.00%|    negep : int
   402|         0|            0|            0|  0.00%|        The exponent that yields `epsneg`.
   403|         0|            0|            0|  0.00%|    nexp : int
   404|         0|            0|            0|  0.00%|        The number of bits in the exponent including its sign and bias.
   405|         0|            0|            0|  0.00%|    nmant : int
   406|         0|            0|            0|  0.00%|        The number of bits in the mantissa.
   407|         0|            0|            0|  0.00%|    precision : int
   408|         0|            0|            0|  0.00%|        The approximate number of decimal digits to which this kind of
   409|         0|            0|            0|  0.00%|        float is precise.
   410|         0|            0|            0|  0.00%|    resolution : floating point number of the appropriate type
   411|         0|            0|            0|  0.00%|        The approximate decimal resolution of this type, i.e.,
   412|         0|            0|            0|  0.00%|        ``10**-precision``.
   413|         0|            0|            0|  0.00%|    tiny : float
   414|         0|            0|            0|  0.00%|        An alias for `smallest_normal`, kept for backwards compatibility.
   415|         0|            0|            0|  0.00%|    smallest_normal : float
   416|         0|            0|            0|  0.00%|        The smallest positive floating point number with 1 as leading bit in
   417|         0|            0|            0|  0.00%|        the mantissa following IEEE-754 (see Notes).
   418|         0|            0|            0|  0.00%|    smallest_subnormal : float
   419|         0|            0|            0|  0.00%|        The smallest positive floating point number with 0 as leading bit in
   420|         0|            0|            0|  0.00%|        the mantissa following IEEE-754.
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    Parameters
   423|         0|            0|            0|  0.00%|    ----------
   424|         0|            0|            0|  0.00%|    dtype : float, dtype, or instance
   425|         0|            0|            0|  0.00%|        Kind of floating point data-type about which to get information.
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|    See Also
   428|         0|            0|            0|  0.00%|    --------
   429|         0|            0|            0|  0.00%|    MachAr : The implementation of the tests that produce this information.
   430|         0|            0|            0|  0.00%|    iinfo : The equivalent for integer data types.
   431|         0|            0|            0|  0.00%|    spacing : The distance between a value and the nearest adjacent number
   432|         0|            0|            0|  0.00%|    nextafter : The next floating point value after x1 towards x2
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|    Notes
   435|         0|            0|            0|  0.00%|    -----
   436|         0|            0|            0|  0.00%|    For developers of NumPy: do not instantiate this at the module level.
   437|         0|            0|            0|  0.00%|    The initial calculation of these parameters is expensive and negatively
   438|         0|            0|            0|  0.00%|    impacts import times.  These objects are cached, so calling ``finfo()``
   439|         0|            0|            0|  0.00%|    repeatedly inside your functions is not a problem.
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|    Note that ``smallest_normal`` is not actually the smallest positive
   442|         0|            0|            0|  0.00%|    representable value in a NumPy floating point type. As in the IEEE-754
   443|         0|            0|            0|  0.00%|    standard [1]_, NumPy floating point types make use of subnormal numbers to
   444|         0|            0|            0|  0.00%|    fill the gap between 0 and ``smallest_normal``. However, subnormal numbers
   445|         0|            0|            0|  0.00%|    may have significantly reduced precision [2]_.
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    References
   448|         0|            0|            0|  0.00%|    ----------
   449|         0|            0|            0|  0.00%|    .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,
   450|         0|            0|            0|  0.00%|           pp.1-70, 2008, http://www.doi.org/10.1109/IEEESTD.2008.4610935
   451|         0|            0|            0|  0.00%|    .. [2] Wikipedia, "Denormal Numbers",
   452|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Denormal_number
   453|         0|            0|            0|  0.00%|    """
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    _finfo_cache = {}
   456|         0|            0|            0|  0.00%|
   457|     14816|    0.0434501|  2.93265e-06|  0.12%|    def __new__(cls, dtype):
   458|     14816|    0.0433841|  2.92819e-06|  0.12%|        try:
   459|     14816|    0.0468357|  3.16115e-06|  0.13%|            dtype = numeric.dtype(dtype)
   460|         0|            0|            0|  0.00%|        except TypeError:
   461|         0|            0|            0|  0.00%|            # In case a float instance was given
   462|         0|            0|            0|  0.00%|            dtype = numeric.dtype(type(dtype))
   463|         0|            0|            0|  0.00%|
   464|     14816|    0.0414777|  2.79952e-06|  0.12%|        obj = cls._finfo_cache.get(dtype, None)
   465|     14816|    0.0393708|  2.65731e-06|  0.11%|        if obj is not None:
   466|     14816|    0.0356624|  2.40702e-06|  0.10%|            return obj
   467|         0|            0|            0|  0.00%|        dtypes = [dtype]
   468|         0|            0|            0|  0.00%|        newdtype = numeric.obj2sctype(dtype)
   469|         0|            0|            0|  0.00%|        if newdtype is not dtype:
   470|         0|            0|            0|  0.00%|            dtypes.append(newdtype)
   471|         0|            0|            0|  0.00%|            dtype = newdtype
   472|         0|            0|            0|  0.00%|        if not issubclass(dtype, numeric.inexact):
   473|         0|            0|            0|  0.00%|            raise ValueError("data type %r not inexact" % (dtype))
   474|         0|            0|            0|  0.00%|        obj = cls._finfo_cache.get(dtype, None)
   475|         0|            0|            0|  0.00%|        if obj is not None:
   476|         0|            0|            0|  0.00%|            return obj
   477|         0|            0|            0|  0.00%|        if not issubclass(dtype, numeric.floating):
   478|         0|            0|            0|  0.00%|            newdtype = _convert_to_float[dtype]
   479|         0|            0|            0|  0.00%|            if newdtype is not dtype:
   480|         0|            0|            0|  0.00%|                dtypes.append(newdtype)
   481|         0|            0|            0|  0.00%|                dtype = newdtype
   482|         0|            0|            0|  0.00%|        obj = cls._finfo_cache.get(dtype, None)
   483|         0|            0|            0|  0.00%|        if obj is not None:
   484|         0|            0|            0|  0.00%|            return obj
   485|         0|            0|            0|  0.00%|        obj = object.__new__(cls)._init(dtype)
   486|         0|            0|            0|  0.00%|        for dt in dtypes:
   487|         0|            0|            0|  0.00%|            cls._finfo_cache[dt] = obj
   488|         0|            0|            0|  0.00%|        return obj
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|    def _init(self, dtype):
   491|         0|            0|            0|  0.00%|        self.dtype = numeric.dtype(dtype)
   492|         0|            0|            0|  0.00%|        machar = _get_machar(dtype)
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|        for word in ['precision', 'iexp',
   495|         0|            0|            0|  0.00%|                     'maxexp', 'minexp', 'negep',
   496|         0|            0|            0|  0.00%|                     'machep']:
   497|         0|            0|            0|  0.00%|            setattr(self, word, getattr(machar, word))
   498|         0|            0|            0|  0.00%|        for word in ['resolution', 'epsneg', 'smallest_subnormal']:
   499|         0|            0|            0|  0.00%|            setattr(self, word, getattr(machar, word).flat[0])
   500|         0|            0|            0|  0.00%|        self.bits = self.dtype.itemsize * 8
   501|         0|            0|            0|  0.00%|        self.max = machar.huge.flat[0]
   502|         0|            0|            0|  0.00%|        self.min = -self.max
   503|         0|            0|            0|  0.00%|        self.eps = machar.eps.flat[0]
   504|         0|            0|            0|  0.00%|        self.nexp = machar.iexp
   505|         0|            0|            0|  0.00%|        self.nmant = machar.it
   506|         0|            0|            0|  0.00%|        self._machar = machar
   507|         0|            0|            0|  0.00%|        self._str_tiny = machar._str_xmin.strip()
   508|         0|            0|            0|  0.00%|        self._str_max = machar._str_xmax.strip()
   509|         0|            0|            0|  0.00%|        self._str_epsneg = machar._str_epsneg.strip()
   510|         0|            0|            0|  0.00%|        self._str_eps = machar._str_eps.strip()
   511|         0|            0|            0|  0.00%|        self._str_resolution = machar._str_resolution.strip()
   512|         0|            0|            0|  0.00%|        self._str_smallest_normal = machar._str_smallest_normal.strip()
   513|         0|            0|            0|  0.00%|        self._str_smallest_subnormal = machar._str_smallest_subnormal.strip()
   514|         0|            0|            0|  0.00%|        return self
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    def __str__(self):
   517|         0|            0|            0|  0.00%|        fmt = (
   518|         0|            0|            0|  0.00%|            'Machine parameters for %(dtype)s\n'
   519|         0|            0|            0|  0.00%|            '---------------------------------------------------------------\n'
   520|         0|            0|            0|  0.00%|            'precision = %(precision)3s   resolution = %(_str_resolution)s\n'
   521|         0|            0|            0|  0.00%|            'machep = %(machep)6s   eps =        %(_str_eps)s\n'
   522|         0|            0|            0|  0.00%|            'negep =  %(negep)6s   epsneg =     %(_str_epsneg)s\n'
   523|         0|            0|            0|  0.00%|            'minexp = %(minexp)6s   tiny =       %(_str_tiny)s\n'
   524|         0|            0|            0|  0.00%|            'maxexp = %(maxexp)6s   max =        %(_str_max)s\n'
   525|         0|            0|            0|  0.00%|            'nexp =   %(nexp)6s   min =        -max\n'
   526|         0|            0|            0|  0.00%|            'smallest_normal = %(_str_smallest_normal)s   '
   527|         0|            0|            0|  0.00%|            'smallest_subnormal = %(_str_smallest_subnormal)s\n'
   528|         0|            0|            0|  0.00%|            '---------------------------------------------------------------\n'
   529|         0|            0|            0|  0.00%|            )
   530|         0|            0|            0|  0.00%|        return fmt % self.__dict__
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|    def __repr__(self):
   533|         0|            0|            0|  0.00%|        c = self.__class__.__name__
   534|         0|            0|            0|  0.00%|        d = self.__dict__.copy()
   535|         0|            0|            0|  0.00%|        d['klass'] = c
   536|         0|            0|            0|  0.00%|        return (("%(klass)s(resolution=%(resolution)s, min=-%(_str_max)s,"
   537|         0|            0|            0|  0.00%|                 " max=%(_str_max)s, dtype=%(dtype)s)") % d)
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|    @property
   540|         0|            0|            0|  0.00%|    def smallest_normal(self):
   541|         0|            0|            0|  0.00%|        """Return the value for the smallest normal.
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|        Returns
   544|         0|            0|            0|  0.00%|        -------
   545|         0|            0|            0|  0.00%|        smallest_normal : float
   546|         0|            0|            0|  0.00%|            Value for the smallest normal.
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|        Warns
   549|         0|            0|            0|  0.00%|        -----
   550|         0|            0|            0|  0.00%|        UserWarning
   551|         0|            0|            0|  0.00%|            If the calculated value for the smallest normal is requested for
   552|         0|            0|            0|  0.00%|            double-double.
   553|         0|            0|            0|  0.00%|        """
   554|         0|            0|            0|  0.00%|        # This check is necessary because the value for smallest_normal is
   555|         0|            0|            0|  0.00%|        # platform dependent for longdouble types.
   556|         0|            0|            0|  0.00%|        if isnan(self._machar.smallest_normal.flat[0]):
   557|         0|            0|            0|  0.00%|            warnings.warn(
   558|         0|            0|            0|  0.00%|                'The value of smallest normal is undefined for double double',
   559|         0|            0|            0|  0.00%|                UserWarning, stacklevel=2)
   560|         0|            0|            0|  0.00%|        return self._machar.smallest_normal.flat[0]
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    @property
   563|         0|            0|            0|  0.00%|    def tiny(self):
   564|         0|            0|            0|  0.00%|        """Return the value for tiny, alias of smallest_normal.
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|        Returns
   567|         0|            0|            0|  0.00%|        -------
   568|         0|            0|            0|  0.00%|        tiny : float
   569|         0|            0|            0|  0.00%|            Value for the smallest normal, alias of smallest_normal.
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|        Warns
   572|         0|            0|            0|  0.00%|        -----
   573|         0|            0|            0|  0.00%|        UserWarning
   574|         0|            0|            0|  0.00%|            If the calculated value for the smallest normal is requested for
   575|         0|            0|            0|  0.00%|            double-double.
   576|         0|            0|            0|  0.00%|        """
   577|         0|            0|            0|  0.00%|        return self.smallest_normal
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    @property
   580|         0|            0|            0|  0.00%|    def machar(self):
   581|         0|            0|            0|  0.00%|        """The object which calculated these parameters and holds more
   582|         0|            0|            0|  0.00%|        detailed information.
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|        .. deprecated:: 1.22
   585|         0|            0|            0|  0.00%|        """
   586|         0|            0|            0|  0.00%|        # Deprecated 2021-10-27, NumPy 1.22
   587|         0|            0|            0|  0.00%|        warnings.warn(
   588|         0|            0|            0|  0.00%|            "`finfo.machar` is deprecated (NumPy 1.22)",
   589|         0|            0|            0|  0.00%|            DeprecationWarning, stacklevel=2,
   590|         0|            0|            0|  0.00%|        )
   591|         0|            0|            0|  0.00%|        return self._machar
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|@set_module('numpy')
   595|         0|            0|            0|  0.00%|class iinfo:
   596|         0|            0|            0|  0.00%|    """
   597|         0|            0|            0|  0.00%|    iinfo(type)
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|    Machine limits for integer types.
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|    Attributes
   602|         0|            0|            0|  0.00%|    ----------
   603|         0|            0|            0|  0.00%|    bits : int
   604|         0|            0|            0|  0.00%|        The number of bits occupied by the type.
   605|         0|            0|            0|  0.00%|    min : int
   606|         0|            0|            0|  0.00%|        The smallest integer expressible by the type.
   607|         0|            0|            0|  0.00%|    max : int
   608|         0|            0|            0|  0.00%|        The largest integer expressible by the type.
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|    Parameters
   611|         0|            0|            0|  0.00%|    ----------
   612|         0|            0|            0|  0.00%|    int_type : integer type, dtype, or instance
   613|         0|            0|            0|  0.00%|        The kind of integer data type to get information about.
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    See Also
   616|         0|            0|            0|  0.00%|    --------
   617|         0|            0|            0|  0.00%|    finfo : The equivalent for floating point data types.
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    Examples
   620|         0|            0|            0|  0.00%|    --------
   621|         0|            0|            0|  0.00%|    With types:
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    >>> ii16 = np.iinfo(np.int16)
   624|         0|            0|            0|  0.00%|    >>> ii16.min
   625|         0|            0|            0|  0.00%|    -32768
   626|         0|            0|            0|  0.00%|    >>> ii16.max
   627|         0|            0|            0|  0.00%|    32767
   628|         0|            0|            0|  0.00%|    >>> ii32 = np.iinfo(np.int32)
   629|         0|            0|            0|  0.00%|    >>> ii32.min
   630|         0|            0|            0|  0.00%|    -2147483648
   631|         0|            0|            0|  0.00%|    >>> ii32.max
   632|         0|            0|            0|  0.00%|    2147483647
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|    With instances:
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|    >>> ii32 = np.iinfo(np.int32(10))
   637|         0|            0|            0|  0.00%|    >>> ii32.min
   638|         0|            0|            0|  0.00%|    -2147483648
   639|         0|            0|            0|  0.00%|    >>> ii32.max
   640|         0|            0|            0|  0.00%|    2147483647
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    """
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|    _min_vals = {}
   645|         0|            0|            0|  0.00%|    _max_vals = {}
   646|         0|            0|            0|  0.00%|
   647|       112|            0|            0|  0.00%|    def __init__(self, int_type):
   648|       112|            0|            0|  0.00%|        try:
   649|       112|            0|            0|  0.00%|            self.dtype = numeric.dtype(int_type)
   650|         0|            0|            0|  0.00%|        except TypeError:
   651|         0|            0|            0|  0.00%|            self.dtype = numeric.dtype(type(int_type))
   652|       112|            0|            0|  0.00%|        self.kind = self.dtype.kind
   653|       112|            0|            0|  0.00%|        self.bits = self.dtype.itemsize * 8
   654|       112|            0|            0|  0.00%|        self.key = "%s%d" % (self.kind, self.bits)
   655|       112|  0.000997066|  8.90238e-06|  0.00%|        if self.kind not in 'iu':
   656|         0|            0|            0|  0.00%|            raise ValueError("Invalid integer data type %r." % (self.kind,))
   657|         0|            0|            0|  0.00%|
   658|        56|            0|            0|  0.00%|    @property
   659|         0|            0|            0|  0.00%|    def min(self):
   660|         0|            0|            0|  0.00%|        """Minimum value of given dtype."""
   661|        56|            0|            0|  0.00%|        if self.kind == 'u':
   662|         0|            0|            0|  0.00%|            return 0
   663|         0|            0|            0|  0.00%|        else:
   664|        56|            0|            0|  0.00%|            try:
   665|        56|  0.000996351|   1.7792e-05|  0.00%|                val = iinfo._min_vals[self.key]
   666|         0|            0|            0|  0.00%|            except KeyError:
   667|         0|            0|            0|  0.00%|                val = int(-(1 << (self.bits-1)))
   668|         0|            0|            0|  0.00%|                iinfo._min_vals[self.key] = val
   669|        56|            0|            0|  0.00%|            return val
   670|         0|            0|            0|  0.00%|
   671|        56|            0|            0|  0.00%|    @property
   672|         0|            0|            0|  0.00%|    def max(self):
   673|         0|            0|            0|  0.00%|        """Maximum value of given dtype."""
   674|        56|            0|            0|  0.00%|        try:
   675|        56|            0|            0|  0.00%|            val = iinfo._max_vals[self.key]
   676|         0|            0|            0|  0.00%|        except KeyError:
   677|         0|            0|            0|  0.00%|            if self.kind == 'u':
   678|         0|            0|            0|  0.00%|                val = int((1 << self.bits) - 1)
   679|         0|            0|            0|  0.00%|            else:
   680|         0|            0|            0|  0.00%|                val = int((1 << (self.bits-1)) - 1)
   681|         0|            0|            0|  0.00%|            iinfo._max_vals[self.key] = val
   682|        56|            0|            0|  0.00%|        return val
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|    def __str__(self):
   685|         0|            0|            0|  0.00%|        """String representation."""
   686|         0|            0|            0|  0.00%|        fmt = (
   687|         0|            0|            0|  0.00%|            'Machine parameters for %(dtype)s\n'
   688|         0|            0|            0|  0.00%|            '---------------------------------------------------------------\n'
   689|         0|            0|            0|  0.00%|            'min = %(min)s\n'
   690|         0|            0|            0|  0.00%|            'max = %(max)s\n'
   691|         0|            0|            0|  0.00%|            '---------------------------------------------------------------\n'
   692|         0|            0|            0|  0.00%|            )
   693|         0|            0|            0|  0.00%|        return fmt % {'dtype': self.dtype, 'min': self.min, 'max': self.max}
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|    def __repr__(self):
   696|         0|            0|            0|  0.00%|        return "%s(min=%s, max=%s, dtype=%s)" % (self.__class__.__name__,
   697|         0|            0|            0|  0.00%|                                    self.min, self.max, self.dtype)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py
File duration: 0.190161s (0.54%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Functions that read and write gzipped files.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|The user of the file doesn't have to worry about the compression,
     4|         0|            0|            0|  0.00%|but random access is not allowed."""
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|# based on Andrew Kuchling's minigzip.py distributed with the zlib module
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import struct, sys, time, os
     9|         0|            0|            0|  0.00%|import zlib
    10|         0|            0|            0|  0.00%|import builtins
    11|         0|            0|            0|  0.00%|import io
    12|         0|            0|            0|  0.00%|import _compression
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|__all__ = ["BadGzipFile", "GzipFile", "open", "compress", "decompress"]
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|FTEXT, FHCRC, FEXTRA, FNAME, FCOMMENT = 1, 2, 4, 8, 16
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|READ, WRITE = 1, 2
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|_COMPRESS_LEVEL_FAST = 1
    21|         0|            0|            0|  0.00%|_COMPRESS_LEVEL_TRADEOFF = 6
    22|         0|            0|            0|  0.00%|_COMPRESS_LEVEL_BEST = 9
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|       120|            0|            0|  0.00%|def open(filename, mode="rb", compresslevel=_COMPRESS_LEVEL_BEST,
    26|         0|            0|            0|  0.00%|         encoding=None, errors=None, newline=None):
    27|         0|            0|            0|  0.00%|    """Open a gzip-compressed file in binary or text mode.
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|    The filename argument can be an actual filename (a str or bytes object), or
    30|         0|            0|            0|  0.00%|    an existing file object to read from or write to.
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|    The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or "ab" for
    33|         0|            0|            0|  0.00%|    binary mode, or "rt", "wt", "xt" or "at" for text mode. The default mode is
    34|         0|            0|            0|  0.00%|    "rb", and the default compresslevel is 9.
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    For binary mode, this function is equivalent to the GzipFile constructor:
    37|         0|            0|            0|  0.00%|    GzipFile(filename, mode, compresslevel). In this case, the encoding, errors
    38|         0|            0|            0|  0.00%|    and newline arguments must not be provided.
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|    For text mode, a GzipFile object is created, and wrapped in an
    41|         0|            0|            0|  0.00%|    io.TextIOWrapper instance with the specified encoding, error handling
    42|         0|            0|            0|  0.00%|    behavior, and line ending(s).
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    """
    45|       120|            0|            0|  0.00%|    if "t" in mode:
    46|         0|            0|            0|  0.00%|        if "b" in mode:
    47|         0|            0|            0|  0.00%|            raise ValueError("Invalid mode: %r" % (mode,))
    48|         0|            0|            0|  0.00%|    else:
    49|       120|            0|            0|  0.00%|        if encoding is not None:
    50|         0|            0|            0|  0.00%|            raise ValueError("Argument 'encoding' not supported in binary mode")
    51|       120|  0.000995398|  8.29498e-06|  0.00%|        if errors is not None:
    52|         0|            0|            0|  0.00%|            raise ValueError("Argument 'errors' not supported in binary mode")
    53|       120|  0.000997305|  8.31087e-06|  0.00%|        if newline is not None:
    54|         0|            0|            0|  0.00%|            raise ValueError("Argument 'newline' not supported in binary mode")
    55|         0|            0|            0|  0.00%|
    56|       120|  0.000997305|  8.31087e-06|  0.00%|    gz_mode = mode.replace("t", "")
    57|       120|   0.00199556|  1.66297e-05|  0.01%|    if isinstance(filename, (str, bytes, os.PathLike)):
    58|       120|  0.000997066|  8.30889e-06|  0.00%|        binary_file = GzipFile(filename, gz_mode, compresslevel)
(call)|       120|     0.153657|   0.00128047|  0.44%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:133 __init__
    59|         0|            0|            0|  0.00%|    elif hasattr(filename, "read") or hasattr(filename, "write"):
    60|         0|            0|            0|  0.00%|        binary_file = GzipFile(None, gz_mode, compresslevel, filename)
    61|         0|            0|            0|  0.00%|    else:
    62|         0|            0|            0|  0.00%|        raise TypeError("filename must be a str or bytes object, or a file")
    63|         0|            0|            0|  0.00%|
    64|       120|            0|            0|  0.00%|    if "t" in mode:
    65|         0|            0|            0|  0.00%|        return io.TextIOWrapper(binary_file, encoding, errors, newline)
    66|         0|            0|            0|  0.00%|    else:
    67|       120|    0.0010469|  8.72413e-06|  0.00%|        return binary_file
    68|         0|            0|            0|  0.00%|
    69|       360|  0.000994205|  2.76168e-06|  0.00%|def write32u(output, value):
    70|         0|            0|            0|  0.00%|    # The L format writes the bit pattern correctly whether signed
    71|         0|            0|            0|  0.00%|    # or unsigned.
    72|       360|   0.00199389|   5.5386e-06|  0.01%|    output.write(struct.pack("<L", value))
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|class _PaddedFile:
    75|         0|            0|            0|  0.00%|    """Minimal read-only file object that prepends a string to the contents
    76|         0|            0|            0|  0.00%|    of an actual file. Shouldn't be used outside of gzip.py, as it lacks
    77|         0|            0|            0|  0.00%|    essential functionality."""
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    def __init__(self, f, prepend=b''):
    80|         0|            0|            0|  0.00%|        self._buffer = prepend
    81|         0|            0|            0|  0.00%|        self._length = len(prepend)
    82|         0|            0|            0|  0.00%|        self.file = f
    83|         0|            0|            0|  0.00%|        self._read = 0
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|    def read(self, size):
    86|         0|            0|            0|  0.00%|        if self._read is None:
    87|         0|            0|            0|  0.00%|            return self.file.read(size)
    88|         0|            0|            0|  0.00%|        if self._read + size <= self._length:
    89|         0|            0|            0|  0.00%|            read = self._read
    90|         0|            0|            0|  0.00%|            self._read += size
    91|         0|            0|            0|  0.00%|            return self._buffer[read:self._read]
    92|         0|            0|            0|  0.00%|        else:
    93|         0|            0|            0|  0.00%|            read = self._read
    94|         0|            0|            0|  0.00%|            self._read = None
    95|         0|            0|            0|  0.00%|            return self._buffer[read:] + \
    96|         0|            0|            0|  0.00%|                   self.file.read(size-self._length+read)
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    def prepend(self, prepend=b''):
    99|         0|            0|            0|  0.00%|        if self._read is None:
   100|         0|            0|            0|  0.00%|            self._buffer = prepend
   101|         0|            0|            0|  0.00%|        else:  # Assume data was read since the last prepend() call
   102|         0|            0|            0|  0.00%|            self._read -= len(prepend)
   103|         0|            0|            0|  0.00%|            return
   104|         0|            0|            0|  0.00%|        self._length = len(self._buffer)
   105|         0|            0|            0|  0.00%|        self._read = 0
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|    def seek(self, off):
   108|         0|            0|            0|  0.00%|        self._read = None
   109|         0|            0|            0|  0.00%|        self._buffer = None
   110|         0|            0|            0|  0.00%|        return self.file.seek(off)
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|    def seekable(self):
   113|         0|            0|            0|  0.00%|        return True  # Allows fast-forwarding even in unseekable streams
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|class BadGzipFile(OSError):
   117|         0|            0|            0|  0.00%|    """Exception raised in some cases for invalid gzip files."""
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|class GzipFile(_compression.BaseStream):
   121|         0|            0|            0|  0.00%|    """The GzipFile class simulates most of the methods of a file object with
   122|         0|            0|            0|  0.00%|    the exception of the truncate() method.
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    This class only supports opening files in binary mode. If you need to open a
   125|         0|            0|            0|  0.00%|    compressed file in text mode, use the gzip.open() function.
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|    """
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    # Overridden with internal file object to be closed, if only a filename
   130|         0|            0|            0|  0.00%|    # is passed in
   131|         0|            0|            0|  0.00%|    myfileobj = None
   132|         0|            0|            0|  0.00%|
   133|       120|            0|            0|  0.00%|    def __init__(self, filename=None, mode=None,
   134|         0|            0|            0|  0.00%|                 compresslevel=_COMPRESS_LEVEL_BEST, fileobj=None, mtime=None):
   135|         0|            0|            0|  0.00%|        """Constructor for the GzipFile class.
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|        At least one of fileobj and filename must be given a
   138|         0|            0|            0|  0.00%|        non-trivial value.
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|        The new class instance is based on fileobj, which can be a regular
   141|         0|            0|            0|  0.00%|        file, an io.BytesIO object, or any other object which simulates a file.
   142|         0|            0|            0|  0.00%|        It defaults to None, in which case filename is opened to provide
   143|         0|            0|            0|  0.00%|        a file object.
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|        When fileobj is not None, the filename argument is only used to be
   146|         0|            0|            0|  0.00%|        included in the gzip file header, which may include the original
   147|         0|            0|            0|  0.00%|        filename of the uncompressed file.  It defaults to the filename of
   148|         0|            0|            0|  0.00%|        fileobj, if discernible; otherwise, it defaults to the empty string,
   149|         0|            0|            0|  0.00%|        and in this case the original filename is not included in the header.
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|        The mode argument can be any of 'r', 'rb', 'a', 'ab', 'w', 'wb', 'x', or
   152|         0|            0|            0|  0.00%|        'xb' depending on whether the file will be read or written.  The default
   153|         0|            0|            0|  0.00%|        is the mode of fileobj if discernible; otherwise, the default is 'rb'.
   154|         0|            0|            0|  0.00%|        A mode of 'r' is equivalent to one of 'rb', and similarly for 'w' and
   155|         0|            0|            0|  0.00%|        'wb', 'a' and 'ab', and 'x' and 'xb'.
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|        The compresslevel argument is an integer from 0 to 9 controlling the
   158|         0|            0|            0|  0.00%|        level of compression; 1 is fastest and produces the least compression,
   159|         0|            0|            0|  0.00%|        and 9 is slowest and produces the most compression. 0 is no compression
   160|         0|            0|            0|  0.00%|        at all. The default is 9.
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|        The mtime argument is an optional numeric timestamp to be written
   163|         0|            0|            0|  0.00%|        to the last modification time field in the stream when compressing.
   164|         0|            0|            0|  0.00%|        If omitted or None, the current time is used.
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|        """
   167|         0|            0|            0|  0.00%|
   168|       120|  0.000996828|   8.3069e-06|  0.00%|        if mode and ('t' in mode or 'U' in mode):
   169|         0|            0|            0|  0.00%|            raise ValueError("Invalid mode: {!r}".format(mode))
   170|       120|   0.00103378|  8.61486e-06|  0.00%|        if mode and 'b' not in mode:
   171|       120|            0|            0|  0.00%|            mode += 'b'
   172|       120|            0|            0|  0.00%|        if fileobj is None:
   173|       120|    0.0188887|  0.000157406|  0.05%|            fileobj = self.myfileobj = builtins.open(filename, mode or 'rb')
   174|       120|            0|            0|  0.00%|        if filename is None:
   175|         0|            0|            0|  0.00%|            filename = getattr(fileobj, 'name', '')
   176|         0|            0|            0|  0.00%|            if not isinstance(filename, (str, bytes)):
   177|         0|            0|            0|  0.00%|                filename = ''
   178|         0|            0|            0|  0.00%|        else:
   179|       120|  8.96454e-05|  7.47045e-07|  0.00%|            filename = os.fspath(filename)
   180|       120|   0.00196981|  1.64151e-05|  0.01%|        if mode is None:
   181|         0|            0|            0|  0.00%|            mode = getattr(fileobj, 'mode', 'rb')
   182|         0|            0|            0|  0.00%|
   183|       120|  8.08239e-05|  6.73532e-07|  0.00%|        if mode.startswith('r'):
   184|         0|            0|            0|  0.00%|            self.mode = READ
   185|         0|            0|            0|  0.00%|            raw = _GzipReader(fileobj)
   186|         0|            0|            0|  0.00%|            self._buffer = io.BufferedReader(raw)
   187|         0|            0|            0|  0.00%|            self.name = filename
   188|         0|            0|            0|  0.00%|
   189|       120|   0.00192356|  1.60297e-05|  0.01%|        elif mode.startswith(('w', 'a', 'x')):
   190|       120|            0|            0|  0.00%|            self.mode = WRITE
   191|       120|   0.00308228|  2.56856e-05|  0.01%|            self._init_write(filename)
(call)|       120|   0.00102949|   8.5791e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:223 _init_write
   192|       240|  0.000997782|  4.15742e-06|  0.00%|            self.compress = zlib.compressobj(compresslevel,
   193|       120|            0|            0|  0.00%|                                             zlib.DEFLATED,
   194|       120|  0.000998259|  8.31882e-06|  0.00%|                                             -zlib.MAX_WBITS,
   195|       120|            0|            0|  0.00%|                                             zlib.DEF_MEM_LEVEL,
   196|       120|            0|            0|  0.00%|                                             0)
   197|       120|            0|            0|  0.00%|            self._write_mtime = mtime
   198|         0|            0|            0|  0.00%|        else:
   199|         0|            0|            0|  0.00%|            raise ValueError("Invalid mode: {!r}".format(mode))
   200|         0|            0|            0|  0.00%|
   201|       120|  0.000951052|  7.92543e-06|  0.00%|        self.fileobj = fileobj
   202|         0|            0|            0|  0.00%|
   203|       120|            0|            0|  0.00%|        if self.mode == WRITE:
   204|       120|  0.000996828|   8.3069e-06|  0.00%|            self._write_gzip_header()
(call)|       120|     0.120618|   0.00100515|  0.34%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:231 _write_gzip_header
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|    @property
   207|         0|            0|            0|  0.00%|    def filename(self):
   208|         0|            0|            0|  0.00%|        import warnings
   209|         0|            0|            0|  0.00%|        warnings.warn("use the name attribute", DeprecationWarning, 2)
   210|         0|            0|            0|  0.00%|        if self.mode == WRITE and self.name[-3:] != ".gz":
   211|         0|            0|            0|  0.00%|            return self.name + ".gz"
   212|         0|            0|            0|  0.00%|        return self.name
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    @property
   215|         0|            0|            0|  0.00%|    def mtime(self):
   216|         0|            0|            0|  0.00%|        """Last modification time read from stream, or None"""
   217|         0|            0|            0|  0.00%|        return self._buffer.raw._last_mtime
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|    def __repr__(self):
   220|         0|            0|            0|  0.00%|        s = repr(self.fileobj)
   221|         0|            0|            0|  0.00%|        return '<gzip ' + s[1:-1] + ' ' + hex(id(self)) + '>'
   222|         0|            0|            0|  0.00%|
   223|       120|            0|            0|  0.00%|    def _init_write(self, filename):
   224|       120|            0|            0|  0.00%|        self.name = filename
   225|       120|  0.000998735|   8.3228e-06|  0.00%|        self.crc = zlib.crc32(b"")
   226|       120|            0|            0|  0.00%|        self.size = 0
   227|       120|            0|            0|  0.00%|        self.writebuf = []
   228|       120|   3.0756e-05|    2.563e-07|  0.00%|        self.bufsize = 0
   229|       120|            0|            0|  0.00%|        self.offset = 0  # Current file offset for seek(), tell(), etc
   230|         0|            0|            0|  0.00%|
   231|       120|            0|            0|  0.00%|    def _write_gzip_header(self):
   232|       120|            0|            0|  0.00%|        self.fileobj.write(b'\037\213')             # magic header
   233|       120|            0|            0|  0.00%|        self.fileobj.write(b'\010')                 # compression method
   234|       120|            0|            0|  0.00%|        try:
   235|         0|            0|            0|  0.00%|            # RFC 1952 requires the FNAME field to be Latin-1. Do not
   236|         0|            0|            0|  0.00%|            # include filenames that cannot be represented that way.
   237|       120|  0.000976324|  8.13603e-06|  0.00%|            fname = os.path.basename(self.name)
(call)|       120|     0.114591|  0.000954924|  0.33%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\ntpath.py:206 basename
   238|       120|            0|            0|  0.00%|            if not isinstance(fname, bytes):
   239|       120|            0|            0|  0.00%|                fname = fname.encode('latin-1')
   240|       120|            0|            0|  0.00%|            if fname.endswith(b'.gz'):
   241|       120|            0|            0|  0.00%|                fname = fname[:-3]
   242|         0|            0|            0|  0.00%|        except UnicodeEncodeError:
   243|         0|            0|            0|  0.00%|            fname = b''
   244|       120|            0|            0|  0.00%|        flags = 0
   245|       120|            0|            0|  0.00%|        if fname:
   246|       120|            0|            0|  0.00%|            flags = FNAME
   247|       120|            0|            0|  0.00%|        self.fileobj.write(chr(flags).encode('latin-1'))
   248|       120|            0|            0|  0.00%|        mtime = self._write_mtime
   249|       120|            0|            0|  0.00%|        if mtime is None:
   250|       120|   0.00103569|  8.63075e-06|  0.00%|            mtime = time.time()
   251|       120|   0.00102496|  8.54135e-06|  0.00%|        write32u(self.fileobj, int(mtime))
(call)|       120|  0.000995874|  8.29895e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:69 write32u
   252|       120|            0|            0|  0.00%|        self.fileobj.write(b'\002')
   253|       120|            0|            0|  0.00%|        self.fileobj.write(b'\377')
   254|       120|            0|            0|  0.00%|        if fname:
   255|       120|   0.00199437|  1.66198e-05|  0.01%|            self.fileobj.write(fname + b'\000')
   256|         0|            0|            0|  0.00%|
   257|       121|            0|            0|  0.00%|    def write(self,data):
   258|       121|  0.000997543|  8.24416e-06|  0.00%|        self._check_not_closed()
(call)|       121|    0.0010438|  8.62642e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\_compression.py:12 _check_not_closed
   259|       121|   0.00203705|  1.68351e-05|  0.01%|        if self.mode != WRITE:
   260|         0|            0|            0|  0.00%|            import errno
   261|         0|            0|            0|  0.00%|            raise OSError(errno.EBADF, "write() on read-only GzipFile object")
   262|         0|            0|            0|  0.00%|
   263|       121|            0|            0|  0.00%|        if self.fileobj is None:
   264|         0|            0|            0|  0.00%|            raise ValueError("write() on closed GzipFile object")
   265|         0|            0|            0|  0.00%|
   266|       121|   0.00103617|  8.56336e-06|  0.00%|        if isinstance(data, bytes):
   267|       121|            0|            0|  0.00%|            length = len(data)
   268|         0|            0|            0|  0.00%|        else:
   269|         0|            0|            0|  0.00%|            # accept any data that supports the buffer protocol
   270|         0|            0|            0|  0.00%|            data = memoryview(data)
   271|         0|            0|            0|  0.00%|            length = data.nbytes
   272|         0|            0|            0|  0.00%|
   273|       121|   0.00104451|  8.63233e-06|  0.00%|        if length > 0:
   274|       121|     0.100533|  0.000830847|  0.29%|            self.fileobj.write(self.compress.compress(data))
   275|       121|            0|            0|  0.00%|            self.size += length
   276|       121|   0.00308847|  2.55246e-05|  0.01%|            self.crc = zlib.crc32(data, self.crc)
   277|       121|            0|            0|  0.00%|            self.offset += length
   278|         0|            0|            0|  0.00%|
   279|       121|            0|            0|  0.00%|        return length
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    def read(self, size=-1):
   282|         0|            0|            0|  0.00%|        self._check_not_closed()
   283|         0|            0|            0|  0.00%|        if self.mode != READ:
   284|         0|            0|            0|  0.00%|            import errno
   285|         0|            0|            0|  0.00%|            raise OSError(errno.EBADF, "read() on write-only GzipFile object")
   286|         0|            0|            0|  0.00%|        return self._buffer.read(size)
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    def read1(self, size=-1):
   289|         0|            0|            0|  0.00%|        """Implements BufferedIOBase.read1()
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        Reads up to a buffer's worth of data if size is negative."""
   292|         0|            0|            0|  0.00%|        self._check_not_closed()
   293|         0|            0|            0|  0.00%|        if self.mode != READ:
   294|         0|            0|            0|  0.00%|            import errno
   295|         0|            0|            0|  0.00%|            raise OSError(errno.EBADF, "read1() on write-only GzipFile object")
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|        if size < 0:
   298|         0|            0|            0|  0.00%|            size = io.DEFAULT_BUFFER_SIZE
   299|         0|            0|            0|  0.00%|        return self._buffer.read1(size)
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    def peek(self, n):
   302|         0|            0|            0|  0.00%|        self._check_not_closed()
   303|         0|            0|            0|  0.00%|        if self.mode != READ:
   304|         0|            0|            0|  0.00%|            import errno
   305|         0|            0|            0|  0.00%|            raise OSError(errno.EBADF, "peek() on write-only GzipFile object")
   306|         0|            0|            0|  0.00%|        return self._buffer.peek(n)
   307|         0|            0|            0|  0.00%|
   308|       361|  0.000961781|  2.66421e-06|  0.00%|    @property
   309|         0|            0|            0|  0.00%|    def closed(self):
   310|       361|            0|            0|  0.00%|        return self.fileobj is None
   311|         0|            0|            0|  0.00%|
   312|       120|            0|            0|  0.00%|    def close(self):
   313|       120|            0|            0|  0.00%|        fileobj = self.fileobj
   314|       120|  0.000961781|  8.01484e-06|  0.00%|        if fileobj is None:
   315|         0|            0|            0|  0.00%|            return
   316|       120|  0.000995159|  8.29299e-06|  0.00%|        self.fileobj = None
   317|       120|  0.000996351|  8.30293e-06|  0.00%|        try:
   318|       120|   0.00101519|  8.45989e-06|  0.00%|            if self.mode == WRITE:
   319|       120|   0.00911069|  7.59224e-05|  0.03%|                fileobj.write(self.compress.flush())
   320|       120|    0.0010078|  8.39829e-06|  0.00%|                write32u(fileobj, self.crc)
(call)|       120|   0.00099802|  8.31683e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:69 write32u
   321|         0|            0|            0|  0.00%|                # self.size may exceed 2 GiB, or even 4 GiB
   322|       120|   7.9155e-05|  6.59625e-07|  0.00%|                write32u(fileobj, self.size & 0xffffffff)
(call)|       120|  0.000994205|  8.28505e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:69 write32u
   323|         0|            0|            0|  0.00%|            elif self.mode == READ:
   324|         0|            0|            0|  0.00%|                self._buffer.close()
   325|         0|            0|            0|  0.00%|        finally:
   326|       120|            0|            0|  0.00%|            myfileobj = self.myfileobj
   327|       120|            0|            0|  0.00%|            if myfileobj:
   328|       120|            0|            0|  0.00%|                self.myfileobj = None
   329|       120|    0.0182085|  0.000151738|  0.05%|                myfileobj.close()
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    def flush(self,zlib_mode=zlib.Z_SYNC_FLUSH):
   332|         0|            0|            0|  0.00%|        self._check_not_closed()
   333|         0|            0|            0|  0.00%|        if self.mode == WRITE:
   334|         0|            0|            0|  0.00%|            # Ensure the compressor's buffer is flushed
   335|         0|            0|            0|  0.00%|            self.fileobj.write(self.compress.flush(zlib_mode))
   336|         0|            0|            0|  0.00%|            self.fileobj.flush()
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    def fileno(self):
   339|         0|            0|            0|  0.00%|        """Invoke the underlying file object's fileno() method.
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|        This will raise AttributeError if the underlying file object
   342|         0|            0|            0|  0.00%|        doesn't support fileno().
   343|         0|            0|            0|  0.00%|        """
   344|         0|            0|            0|  0.00%|        return self.fileobj.fileno()
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    def rewind(self):
   347|         0|            0|            0|  0.00%|        '''Return the uncompressed stream file position indicator to the
   348|         0|            0|            0|  0.00%|        beginning of the file'''
   349|         0|            0|            0|  0.00%|        if self.mode != READ:
   350|         0|            0|            0|  0.00%|            raise OSError("Can't rewind in write mode")
   351|         0|            0|            0|  0.00%|        self._buffer.seek(0)
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|    def readable(self):
   354|         0|            0|            0|  0.00%|        return self.mode == READ
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|    def writable(self):
   357|         0|            0|            0|  0.00%|        return self.mode == WRITE
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|    def seekable(self):
   360|         0|            0|            0|  0.00%|        return True
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    def seek(self, offset, whence=io.SEEK_SET):
   363|         0|            0|            0|  0.00%|        if self.mode == WRITE:
   364|         0|            0|            0|  0.00%|            if whence != io.SEEK_SET:
   365|         0|            0|            0|  0.00%|                if whence == io.SEEK_CUR:
   366|         0|            0|            0|  0.00%|                    offset = self.offset + offset
   367|         0|            0|            0|  0.00%|                else:
   368|         0|            0|            0|  0.00%|                    raise ValueError('Seek from end not supported')
   369|         0|            0|            0|  0.00%|            if offset < self.offset:
   370|         0|            0|            0|  0.00%|                raise OSError('Negative seek in write mode')
   371|         0|            0|            0|  0.00%|            count = offset - self.offset
   372|         0|            0|            0|  0.00%|            chunk = b'\0' * 1024
   373|         0|            0|            0|  0.00%|            for i in range(count // 1024):
   374|         0|            0|            0|  0.00%|                self.write(chunk)
   375|         0|            0|            0|  0.00%|            self.write(b'\0' * (count % 1024))
   376|         0|            0|            0|  0.00%|        elif self.mode == READ:
   377|         0|            0|            0|  0.00%|            self._check_not_closed()
   378|         0|            0|            0|  0.00%|            return self._buffer.seek(offset, whence)
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|        return self.offset
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|    def readline(self, size=-1):
   383|         0|            0|            0|  0.00%|        self._check_not_closed()
   384|         0|            0|            0|  0.00%|        return self._buffer.readline(size)
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|class _GzipReader(_compression.DecompressReader):
   388|         0|            0|            0|  0.00%|    def __init__(self, fp):
   389|         0|            0|            0|  0.00%|        super().__init__(_PaddedFile(fp), zlib.decompressobj,
   390|         0|            0|            0|  0.00%|                         wbits=-zlib.MAX_WBITS)
   391|         0|            0|            0|  0.00%|        # Set flag indicating start of a new member
   392|         0|            0|            0|  0.00%|        self._new_member = True
   393|         0|            0|            0|  0.00%|        self._last_mtime = None
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    def _init_read(self):
   396|         0|            0|            0|  0.00%|        self._crc = zlib.crc32(b"")
   397|         0|            0|            0|  0.00%|        self._stream_size = 0  # Decompressed size of unconcatenated stream
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    def _read_exact(self, n):
   400|         0|            0|            0|  0.00%|        '''Read exactly *n* bytes from `self._fp`
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|        This method is required because self._fp may be unbuffered,
   403|         0|            0|            0|  0.00%|        i.e. return short reads.
   404|         0|            0|            0|  0.00%|        '''
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|        data = self._fp.read(n)
   407|         0|            0|            0|  0.00%|        while len(data) < n:
   408|         0|            0|            0|  0.00%|            b = self._fp.read(n - len(data))
   409|         0|            0|            0|  0.00%|            if not b:
   410|         0|            0|            0|  0.00%|                raise EOFError("Compressed file ended before the "
   411|         0|            0|            0|  0.00%|                               "end-of-stream marker was reached")
   412|         0|            0|            0|  0.00%|            data += b
   413|         0|            0|            0|  0.00%|        return data
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|    def _read_gzip_header(self):
   416|         0|            0|            0|  0.00%|        magic = self._fp.read(2)
   417|         0|            0|            0|  0.00%|        if magic == b'':
   418|         0|            0|            0|  0.00%|            return False
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|        if magic != b'\037\213':
   421|         0|            0|            0|  0.00%|            raise BadGzipFile('Not a gzipped file (%r)' % magic)
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|        (method, flag,
   424|         0|            0|            0|  0.00%|         self._last_mtime) = struct.unpack("<BBIxx", self._read_exact(8))
   425|         0|            0|            0|  0.00%|        if method != 8:
   426|         0|            0|            0|  0.00%|            raise BadGzipFile('Unknown compression method')
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|        if flag & FEXTRA:
   429|         0|            0|            0|  0.00%|            # Read & discard the extra field, if present
   430|         0|            0|            0|  0.00%|            extra_len, = struct.unpack("<H", self._read_exact(2))
   431|         0|            0|            0|  0.00%|            self._read_exact(extra_len)
   432|         0|            0|            0|  0.00%|        if flag & FNAME:
   433|         0|            0|            0|  0.00%|            # Read and discard a null-terminated string containing the filename
   434|         0|            0|            0|  0.00%|            while True:
   435|         0|            0|            0|  0.00%|                s = self._fp.read(1)
   436|         0|            0|            0|  0.00%|                if not s or s==b'\000':
   437|         0|            0|            0|  0.00%|                    break
   438|         0|            0|            0|  0.00%|        if flag & FCOMMENT:
   439|         0|            0|            0|  0.00%|            # Read and discard a null-terminated string containing a comment
   440|         0|            0|            0|  0.00%|            while True:
   441|         0|            0|            0|  0.00%|                s = self._fp.read(1)
   442|         0|            0|            0|  0.00%|                if not s or s==b'\000':
   443|         0|            0|            0|  0.00%|                    break
   444|         0|            0|            0|  0.00%|        if flag & FHCRC:
   445|         0|            0|            0|  0.00%|            self._read_exact(2)     # Read & discard the 16-bit header CRC
   446|         0|            0|            0|  0.00%|        return True
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|    def read(self, size=-1):
   449|         0|            0|            0|  0.00%|        if size < 0:
   450|         0|            0|            0|  0.00%|            return self.readall()
   451|         0|            0|            0|  0.00%|        # size=0 is special because decompress(max_length=0) is not supported
   452|         0|            0|            0|  0.00%|        if not size:
   453|         0|            0|            0|  0.00%|            return b""
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|        # For certain input data, a single
   456|         0|            0|            0|  0.00%|        # call to decompress() may not return
   457|         0|            0|            0|  0.00%|        # any data. In this case, retry until we get some data or reach EOF.
   458|         0|            0|            0|  0.00%|        while True:
   459|         0|            0|            0|  0.00%|            if self._decompressor.eof:
   460|         0|            0|            0|  0.00%|                # Ending case: we've come to the end of a member in the file,
   461|         0|            0|            0|  0.00%|                # so finish up this member, and read a new gzip header.
   462|         0|            0|            0|  0.00%|                # Check the CRC and file size, and set the flag so we read
   463|         0|            0|            0|  0.00%|                # a new member
   464|         0|            0|            0|  0.00%|                self._read_eof()
   465|         0|            0|            0|  0.00%|                self._new_member = True
   466|         0|            0|            0|  0.00%|                self._decompressor = self._decomp_factory(
   467|         0|            0|            0|  0.00%|                    **self._decomp_args)
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|            if self._new_member:
   470|         0|            0|            0|  0.00%|                # If the _new_member flag is set, we have to
   471|         0|            0|            0|  0.00%|                # jump to the next member, if there is one.
   472|         0|            0|            0|  0.00%|                self._init_read()
   473|         0|            0|            0|  0.00%|                if not self._read_gzip_header():
   474|         0|            0|            0|  0.00%|                    self._size = self._pos
   475|         0|            0|            0|  0.00%|                    return b""
   476|         0|            0|            0|  0.00%|                self._new_member = False
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|            # Read a chunk of data from the file
   479|         0|            0|            0|  0.00%|            buf = self._fp.read(io.DEFAULT_BUFFER_SIZE)
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|            uncompress = self._decompressor.decompress(buf, size)
   482|         0|            0|            0|  0.00%|            if self._decompressor.unconsumed_tail != b"":
   483|         0|            0|            0|  0.00%|                self._fp.prepend(self._decompressor.unconsumed_tail)
   484|         0|            0|            0|  0.00%|            elif self._decompressor.unused_data != b"":
   485|         0|            0|            0|  0.00%|                # Prepend the already read bytes to the fileobj so they can
   486|         0|            0|            0|  0.00%|                # be seen by _read_eof() and _read_gzip_header()
   487|         0|            0|            0|  0.00%|                self._fp.prepend(self._decompressor.unused_data)
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|            if uncompress != b"":
   490|         0|            0|            0|  0.00%|                break
   491|         0|            0|            0|  0.00%|            if buf == b"":
   492|         0|            0|            0|  0.00%|                raise EOFError("Compressed file ended before the "
   493|         0|            0|            0|  0.00%|                               "end-of-stream marker was reached")
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|        self._add_read_data( uncompress )
   496|         0|            0|            0|  0.00%|        self._pos += len(uncompress)
   497|         0|            0|            0|  0.00%|        return uncompress
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    def _add_read_data(self, data):
   500|         0|            0|            0|  0.00%|        self._crc = zlib.crc32(data, self._crc)
   501|         0|            0|            0|  0.00%|        self._stream_size = self._stream_size + len(data)
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|    def _read_eof(self):
   504|         0|            0|            0|  0.00%|        # We've read to the end of the file
   505|         0|            0|            0|  0.00%|        # We check the that the computed CRC and size of the
   506|         0|            0|            0|  0.00%|        # uncompressed data matches the stored values.  Note that the size
   507|         0|            0|            0|  0.00%|        # stored is the true file size mod 2**32.
   508|         0|            0|            0|  0.00%|        crc32, isize = struct.unpack("<II", self._read_exact(8))
   509|         0|            0|            0|  0.00%|        if crc32 != self._crc:
   510|         0|            0|            0|  0.00%|            raise BadGzipFile("CRC check failed %s != %s" % (hex(crc32),
   511|         0|            0|            0|  0.00%|                                                             hex(self._crc)))
   512|         0|            0|            0|  0.00%|        elif isize != (self._stream_size & 0xffffffff):
   513|         0|            0|            0|  0.00%|            raise BadGzipFile("Incorrect length of data produced")
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|        # Gzip files can be padded with zeroes and still have archives.
   516|         0|            0|            0|  0.00%|        # Consume all zero bytes and set the file position to the first
   517|         0|            0|            0|  0.00%|        # non-zero byte. See http://www.gzip.org/#faq8
   518|         0|            0|            0|  0.00%|        c = b"\x00"
   519|         0|            0|            0|  0.00%|        while c == b"\x00":
   520|         0|            0|            0|  0.00%|            c = self._fp.read(1)
   521|         0|            0|            0|  0.00%|        if c:
   522|         0|            0|            0|  0.00%|            self._fp.prepend(c)
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|    def _rewind(self):
   525|         0|            0|            0|  0.00%|        super()._rewind()
   526|         0|            0|            0|  0.00%|        self._new_member = True
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|def compress(data, compresslevel=_COMPRESS_LEVEL_BEST, *, mtime=None):
   529|         0|            0|            0|  0.00%|    """Compress data in one shot and return the compressed string.
   530|         0|            0|            0|  0.00%|    Optional argument is the compression level, in range of 0-9.
   531|         0|            0|            0|  0.00%|    """
   532|         0|            0|            0|  0.00%|    buf = io.BytesIO()
   533|         0|            0|            0|  0.00%|    with GzipFile(fileobj=buf, mode='wb', compresslevel=compresslevel, mtime=mtime) as f:
   534|         0|            0|            0|  0.00%|        f.write(data)
   535|         0|            0|            0|  0.00%|    return buf.getvalue()
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|def decompress(data):
   538|         0|            0|            0|  0.00%|    """Decompress a gzip compressed string in one shot.
   539|         0|            0|            0|  0.00%|    Return the decompressed string.
   540|         0|            0|            0|  0.00%|    """
   541|         0|            0|            0|  0.00%|    with GzipFile(fileobj=io.BytesIO(data)) as f:
   542|         0|            0|            0|  0.00%|        return f.read()
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|def main():
   546|         0|            0|            0|  0.00%|    from argparse import ArgumentParser
   547|         0|            0|            0|  0.00%|    parser = ArgumentParser(description=
   548|         0|            0|            0|  0.00%|        "A simple command line interface for the gzip module: act like gzip, "
   549|         0|            0|            0|  0.00%|        "but do not delete the input file.")
   550|         0|            0|            0|  0.00%|    group = parser.add_mutually_exclusive_group()
   551|         0|            0|            0|  0.00%|    group.add_argument('--fast', action='store_true', help='compress faster')
   552|         0|            0|            0|  0.00%|    group.add_argument('--best', action='store_true', help='compress better')
   553|         0|            0|            0|  0.00%|    group.add_argument("-d", "--decompress", action="store_true",
   554|         0|            0|            0|  0.00%|                        help="act like gunzip instead of gzip")
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    parser.add_argument("args", nargs="*", default=["-"], metavar='file')
   557|         0|            0|            0|  0.00%|    args = parser.parse_args()
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|    compresslevel = _COMPRESS_LEVEL_TRADEOFF
   560|         0|            0|            0|  0.00%|    if args.fast:
   561|         0|            0|            0|  0.00%|        compresslevel = _COMPRESS_LEVEL_FAST
   562|         0|            0|            0|  0.00%|    elif args.best:
   563|         0|            0|            0|  0.00%|        compresslevel = _COMPRESS_LEVEL_BEST
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|    for arg in args.args:
   566|         0|            0|            0|  0.00%|        if args.decompress:
   567|         0|            0|            0|  0.00%|            if arg == "-":
   568|         0|            0|            0|  0.00%|                f = GzipFile(filename="", mode="rb", fileobj=sys.stdin.buffer)
   569|         0|            0|            0|  0.00%|                g = sys.stdout.buffer
   570|         0|            0|            0|  0.00%|            else:
   571|         0|            0|            0|  0.00%|                if arg[-3:] != ".gz":
   572|         0|            0|            0|  0.00%|                    print("filename doesn't end in .gz:", repr(arg))
   573|         0|            0|            0|  0.00%|                    continue
   574|         0|            0|            0|  0.00%|                f = open(arg, "rb")
   575|         0|            0|            0|  0.00%|                g = builtins.open(arg[:-3], "wb")
   576|         0|            0|            0|  0.00%|        else:
   577|         0|            0|            0|  0.00%|            if arg == "-":
   578|         0|            0|            0|  0.00%|                f = sys.stdin.buffer
   579|         0|            0|            0|  0.00%|                g = GzipFile(filename="", mode="wb", fileobj=sys.stdout.buffer,
   580|         0|            0|            0|  0.00%|                             compresslevel=compresslevel)
   581|         0|            0|            0|  0.00%|            else:
   582|         0|            0|            0|  0.00%|                f = builtins.open(arg, "rb")
   583|         0|            0|            0|  0.00%|                g = open(arg + ".gz", "wb")
   584|         0|            0|            0|  0.00%|        while True:
   585|         0|            0|            0|  0.00%|            chunk = f.read(1024)
   586|         0|            0|            0|  0.00%|            if not chunk:
   587|         0|            0|            0|  0.00%|                break
   588|         0|            0|            0|  0.00%|            g.write(chunk)
   589|         0|            0|            0|  0.00%|        if g is not sys.stdout.buffer:
   590|         0|            0|            0|  0.00%|            g.close()
   591|         0|            0|            0|  0.00%|        if f is not sys.stdin.buffer:
   592|         0|            0|            0|  0.00%|            f.close()
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|if __name__ == '__main__':
   595|         0|            0|            0|  0.00%|    main()
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py
File duration: 0.168385s (0.48%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|numerictypes: Define the numeric type objects
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|This module is designed so "from numerictypes import \\*" is safe.
     5|         0|            0|            0|  0.00%|Exported symbols include:
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|  Dictionary with all registered number types (including aliases):
     8|         0|            0|            0|  0.00%|    sctypeDict
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|  Type objects (not all will be available, depends on platform):
    11|         0|            0|            0|  0.00%|      see variable sctypes for which ones you have
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|    Bit-width names
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|    int8 int16 int32 int64 int128
    16|         0|            0|            0|  0.00%|    uint8 uint16 uint32 uint64 uint128
    17|         0|            0|            0|  0.00%|    float16 float32 float64 float96 float128 float256
    18|         0|            0|            0|  0.00%|    complex32 complex64 complex128 complex192 complex256 complex512
    19|         0|            0|            0|  0.00%|    datetime64 timedelta64
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|    c-based names
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|    bool_
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|    object_
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    void, str_, unicode_
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|    byte, ubyte,
    30|         0|            0|            0|  0.00%|    short, ushort
    31|         0|            0|            0|  0.00%|    intc, uintc,
    32|         0|            0|            0|  0.00%|    intp, uintp,
    33|         0|            0|            0|  0.00%|    int_, uint,
    34|         0|            0|            0|  0.00%|    longlong, ulonglong,
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    single, csingle,
    37|         0|            0|            0|  0.00%|    float_, complex_,
    38|         0|            0|            0|  0.00%|    longfloat, clongfloat,
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|   As part of the type-hierarchy:    xx -- is bit-width
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|   generic
    43|         0|            0|            0|  0.00%|     +-> bool_                                  (kind=b)
    44|         0|            0|            0|  0.00%|     +-> number
    45|         0|            0|            0|  0.00%|     |   +-> integer
    46|         0|            0|            0|  0.00%|     |   |   +-> signedinteger     (intxx)      (kind=i)
    47|         0|            0|            0|  0.00%|     |   |   |     byte
    48|         0|            0|            0|  0.00%|     |   |   |     short
    49|         0|            0|            0|  0.00%|     |   |   |     intc
    50|         0|            0|            0|  0.00%|     |   |   |     intp            int0
    51|         0|            0|            0|  0.00%|     |   |   |     int_
    52|         0|            0|            0|  0.00%|     |   |   |     longlong
    53|         0|            0|            0|  0.00%|     |   |   \\-> unsignedinteger  (uintxx)     (kind=u)
    54|         0|            0|            0|  0.00%|     |   |         ubyte
    55|         0|            0|            0|  0.00%|     |   |         ushort
    56|         0|            0|            0|  0.00%|     |   |         uintc
    57|         0|            0|            0|  0.00%|     |   |         uintp           uint0
    58|         0|            0|            0|  0.00%|     |   |         uint_
    59|         0|            0|            0|  0.00%|     |   |         ulonglong
    60|         0|            0|            0|  0.00%|     |   +-> inexact
    61|         0|            0|            0|  0.00%|     |       +-> floating          (floatxx)    (kind=f)
    62|         0|            0|            0|  0.00%|     |       |     half
    63|         0|            0|            0|  0.00%|     |       |     single
    64|         0|            0|            0|  0.00%|     |       |     float_          (double)
    65|         0|            0|            0|  0.00%|     |       |     longfloat
    66|         0|            0|            0|  0.00%|     |       \\-> complexfloating  (complexxx)  (kind=c)
    67|         0|            0|            0|  0.00%|     |             csingle         (singlecomplex)
    68|         0|            0|            0|  0.00%|     |             complex_        (cfloat, cdouble)
    69|         0|            0|            0|  0.00%|     |             clongfloat      (longcomplex)
    70|         0|            0|            0|  0.00%|     +-> flexible
    71|         0|            0|            0|  0.00%|     |   +-> character
    72|         0|            0|            0|  0.00%|     |   |     str_     (string_, bytes_)       (kind=S)    [Python 2]
    73|         0|            0|            0|  0.00%|     |   |     unicode_                         (kind=U)    [Python 2]
    74|         0|            0|            0|  0.00%|     |   |
    75|         0|            0|            0|  0.00%|     |   |     bytes_   (string_)               (kind=S)    [Python 3]
    76|         0|            0|            0|  0.00%|     |   |     str_     (unicode_)              (kind=U)    [Python 3]
    77|         0|            0|            0|  0.00%|     |   |
    78|         0|            0|            0|  0.00%|     |   \\-> void                              (kind=V)
    79|         0|            0|            0|  0.00%|     \\-> object_ (not used much)               (kind=O)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|"""
    82|         0|            0|            0|  0.00%|import numbers
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|from numpy.core.multiarray import (
    85|         0|            0|            0|  0.00%|        ndarray, array, dtype, datetime_data, datetime_as_string,
    86|         0|            0|            0|  0.00%|        busday_offset, busday_count, is_busday, busdaycalendar
    87|         0|            0|            0|  0.00%|        )
    88|         0|            0|            0|  0.00%|from numpy.core.overrides import set_module
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|# we add more at the bottom
    91|         0|            0|            0|  0.00%|__all__ = ['sctypeDict', 'sctypes',
    92|         0|            0|            0|  0.00%|           'ScalarType', 'obj2sctype', 'cast', 'nbytes', 'sctype2char',
    93|         0|            0|            0|  0.00%|           'maximum_sctype', 'issctype', 'typecodes', 'find_common_type',
    94|         0|            0|            0|  0.00%|           'issubdtype', 'datetime_data', 'datetime_as_string',
    95|         0|            0|            0|  0.00%|           'busday_offset', 'busday_count', 'is_busday', 'busdaycalendar',
    96|         0|            0|            0|  0.00%|           ]
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|# we don't need all these imports, but we need to keep them for compatibility
    99|         0|            0|            0|  0.00%|# for users using np.core.numerictypes.UPPER_TABLE
   100|         0|            0|            0|  0.00%|from ._string_helpers import (
   101|         0|            0|            0|  0.00%|    english_lower, english_upper, english_capitalize, LOWER_TABLE, UPPER_TABLE
   102|         0|            0|            0|  0.00%|)
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|from ._type_aliases import (
   105|         0|            0|            0|  0.00%|    sctypeDict,
   106|         0|            0|            0|  0.00%|    allTypes,
   107|         0|            0|            0|  0.00%|    bitname,
   108|         0|            0|            0|  0.00%|    sctypes,
   109|         0|            0|            0|  0.00%|    _concrete_types,
   110|         0|            0|            0|  0.00%|    _concrete_typeinfo,
   111|         0|            0|            0|  0.00%|    _bits_of,
   112|         0|            0|            0|  0.00%|)
   113|         0|            0|            0|  0.00%|from ._dtype import _kind_name
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|# we don't export these for import *, but we do want them accessible
   116|         0|            0|            0|  0.00%|# as numerictypes.bool, etc.
   117|         0|            0|            0|  0.00%|from builtins import bool, int, float, complex, object, str, bytes
   118|         0|            0|            0|  0.00%|from numpy.compat import long, unicode
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|# We use this later
   122|         0|            0|            0|  0.00%|generic = allTypes['generic']
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|genericTypeRank = ['bool', 'int8', 'uint8', 'int16', 'uint16',
   125|         0|            0|            0|  0.00%|                   'int32', 'uint32', 'int64', 'uint64', 'int128',
   126|         0|            0|            0|  0.00%|                   'uint128', 'float16',
   127|         0|            0|            0|  0.00%|                   'float32', 'float64', 'float80', 'float96', 'float128',
   128|         0|            0|            0|  0.00%|                   'float256',
   129|         0|            0|            0|  0.00%|                   'complex32', 'complex64', 'complex128', 'complex160',
   130|         0|            0|            0|  0.00%|                   'complex192', 'complex256', 'complex512', 'object']
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|@set_module('numpy')
   133|         0|            0|            0|  0.00%|def maximum_sctype(t):
   134|         0|            0|            0|  0.00%|    """
   135|         0|            0|            0|  0.00%|    Return the scalar type of highest precision of the same kind as the input.
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    Parameters
   138|         0|            0|            0|  0.00%|    ----------
   139|         0|            0|            0|  0.00%|    t : dtype or dtype specifier
   140|         0|            0|            0|  0.00%|        The input data type. This can be a `dtype` object or an object that
   141|         0|            0|            0|  0.00%|        is convertible to a `dtype`.
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|    Returns
   144|         0|            0|            0|  0.00%|    -------
   145|         0|            0|            0|  0.00%|    out : dtype
   146|         0|            0|            0|  0.00%|        The highest precision data type of the same kind (`dtype.kind`) as `t`.
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    See Also
   149|         0|            0|            0|  0.00%|    --------
   150|         0|            0|            0|  0.00%|    obj2sctype, mintypecode, sctype2char
   151|         0|            0|            0|  0.00%|    dtype
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    Examples
   154|         0|            0|            0|  0.00%|    --------
   155|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(int)
   156|         0|            0|            0|  0.00%|    <class 'numpy.int64'>
   157|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(np.uint8)
   158|         0|            0|            0|  0.00%|    <class 'numpy.uint64'>
   159|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(complex)
   160|         0|            0|            0|  0.00%|    <class 'numpy.complex256'> # may vary
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(str)
   163|         0|            0|            0|  0.00%|    <class 'numpy.str_'>
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    >>> np.maximum_sctype('i2')
   166|         0|            0|            0|  0.00%|    <class 'numpy.int64'>
   167|         0|            0|            0|  0.00%|    >>> np.maximum_sctype('f4')
   168|         0|            0|            0|  0.00%|    <class 'numpy.float128'> # may vary
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    """
   171|         0|            0|            0|  0.00%|    g = obj2sctype(t)
   172|         0|            0|            0|  0.00%|    if g is None:
   173|         0|            0|            0|  0.00%|        return t
   174|         0|            0|            0|  0.00%|    t = g
   175|         0|            0|            0|  0.00%|    base = _kind_name(dtype(t))
   176|         0|            0|            0|  0.00%|    if base in sctypes:
   177|         0|            0|            0|  0.00%|        return sctypes[base][-1]
   178|         0|            0|            0|  0.00%|    else:
   179|         0|            0|            0|  0.00%|        return t
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|@set_module('numpy')
   183|         0|            0|            0|  0.00%|def issctype(rep):
   184|         0|            0|            0|  0.00%|    """
   185|         0|            0|            0|  0.00%|    Determines whether the given object represents a scalar data-type.
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    Parameters
   188|         0|            0|            0|  0.00%|    ----------
   189|         0|            0|            0|  0.00%|    rep : any
   190|         0|            0|            0|  0.00%|        If `rep` is an instance of a scalar dtype, True is returned. If not,
   191|         0|            0|            0|  0.00%|        False is returned.
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    Returns
   194|         0|            0|            0|  0.00%|    -------
   195|         0|            0|            0|  0.00%|    out : bool
   196|         0|            0|            0|  0.00%|        Boolean result of check whether `rep` is a scalar dtype.
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    See Also
   199|         0|            0|            0|  0.00%|    --------
   200|         0|            0|            0|  0.00%|    issubsctype, issubdtype, obj2sctype, sctype2char
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    Examples
   203|         0|            0|            0|  0.00%|    --------
   204|         0|            0|            0|  0.00%|    >>> np.issctype(np.int32)
   205|         0|            0|            0|  0.00%|    True
   206|         0|            0|            0|  0.00%|    >>> np.issctype(list)
   207|         0|            0|            0|  0.00%|    False
   208|         0|            0|            0|  0.00%|    >>> np.issctype(1.1)
   209|         0|            0|            0|  0.00%|    False
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|    Strings are also a scalar type:
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    >>> np.issctype(np.dtype('str'))
   214|         0|            0|            0|  0.00%|    True
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    """
   217|         0|            0|            0|  0.00%|    if not isinstance(rep, (type, dtype)):
   218|         0|            0|            0|  0.00%|        return False
   219|         0|            0|            0|  0.00%|    try:
   220|         0|            0|            0|  0.00%|        res = obj2sctype(rep)
   221|         0|            0|            0|  0.00%|        if res and res != object_:
   222|         0|            0|            0|  0.00%|            return True
   223|         0|            0|            0|  0.00%|        return False
   224|         0|            0|            0|  0.00%|    except Exception:
   225|         0|            0|            0|  0.00%|        return False
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|@set_module('numpy')
   229|         0|            0|            0|  0.00%|def obj2sctype(rep, default=None):
   230|         0|            0|            0|  0.00%|    """
   231|         0|            0|            0|  0.00%|    Return the scalar dtype or NumPy equivalent of Python type of an object.
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|    Parameters
   234|         0|            0|            0|  0.00%|    ----------
   235|         0|            0|            0|  0.00%|    rep : any
   236|         0|            0|            0|  0.00%|        The object of which the type is returned.
   237|         0|            0|            0|  0.00%|    default : any, optional
   238|         0|            0|            0|  0.00%|        If given, this is returned for objects whose types can not be
   239|         0|            0|            0|  0.00%|        determined. If not given, None is returned for those objects.
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    Returns
   242|         0|            0|            0|  0.00%|    -------
   243|         0|            0|            0|  0.00%|    dtype : dtype or Python type
   244|         0|            0|            0|  0.00%|        The data type of `rep`.
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|    See Also
   247|         0|            0|            0|  0.00%|    --------
   248|         0|            0|            0|  0.00%|    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|    Examples
   251|         0|            0|            0|  0.00%|    --------
   252|         0|            0|            0|  0.00%|    >>> np.obj2sctype(np.int32)
   253|         0|            0|            0|  0.00%|    <class 'numpy.int32'>
   254|         0|            0|            0|  0.00%|    >>> np.obj2sctype(np.array([1., 2.]))
   255|         0|            0|            0|  0.00%|    <class 'numpy.float64'>
   256|         0|            0|            0|  0.00%|    >>> np.obj2sctype(np.array([1.j]))
   257|         0|            0|            0|  0.00%|    <class 'numpy.complex128'>
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|    >>> np.obj2sctype(dict)
   260|         0|            0|            0|  0.00%|    <class 'numpy.object_'>
   261|         0|            0|            0|  0.00%|    >>> np.obj2sctype('string')
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|    >>> np.obj2sctype(1, default=list)
   264|         0|            0|            0|  0.00%|    <class 'list'>
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|    """
   267|         0|            0|            0|  0.00%|    # prevent abstract classes being upcast
   268|         0|            0|            0|  0.00%|    if isinstance(rep, type) and issubclass(rep, generic):
   269|         0|            0|            0|  0.00%|        return rep
   270|         0|            0|            0|  0.00%|    # extract dtype from arrays
   271|         0|            0|            0|  0.00%|    if isinstance(rep, ndarray):
   272|         0|            0|            0|  0.00%|        return rep.dtype.type
   273|         0|            0|            0|  0.00%|    # fall back on dtype to convert
   274|         0|            0|            0|  0.00%|    try:
   275|         0|            0|            0|  0.00%|        res = dtype(rep)
   276|         0|            0|            0|  0.00%|    except Exception:
   277|         0|            0|            0|  0.00%|        return default
   278|         0|            0|            0|  0.00%|    else:
   279|         0|            0|            0|  0.00%|        return res.type
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|
   282|      9816|    0.0221756|  2.25912e-06|  0.06%|@set_module('numpy')
   283|         0|            0|            0|  0.00%|def issubclass_(arg1, arg2):
   284|         0|            0|            0|  0.00%|    """
   285|         0|            0|            0|  0.00%|    Determine if a class is a subclass of a second class.
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|    `issubclass_` is equivalent to the Python built-in ``issubclass``,
   288|         0|            0|            0|  0.00%|    except that it returns False instead of raising a TypeError if one
   289|         0|            0|            0|  0.00%|    of the arguments is not a class.
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|    Parameters
   292|         0|            0|            0|  0.00%|    ----------
   293|         0|            0|            0|  0.00%|    arg1 : class
   294|         0|            0|            0|  0.00%|        Input class. True is returned if `arg1` is a subclass of `arg2`.
   295|         0|            0|            0|  0.00%|    arg2 : class or tuple of classes.
   296|         0|            0|            0|  0.00%|        Input class. If a tuple of classes, True is returned if `arg1` is a
   297|         0|            0|            0|  0.00%|        subclass of any of the tuple elements.
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|    Returns
   300|         0|            0|            0|  0.00%|    -------
   301|         0|            0|            0|  0.00%|    out : bool
   302|         0|            0|            0|  0.00%|        Whether `arg1` is a subclass of `arg2` or not.
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|    See Also
   305|         0|            0|            0|  0.00%|    --------
   306|         0|            0|            0|  0.00%|    issubsctype, issubdtype, issctype
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    Examples
   309|         0|            0|            0|  0.00%|    --------
   310|         0|            0|            0|  0.00%|    >>> np.issubclass_(np.int32, int)
   311|         0|            0|            0|  0.00%|    False
   312|         0|            0|            0|  0.00%|    >>> np.issubclass_(np.int32, float)
   313|         0|            0|            0|  0.00%|    False
   314|         0|            0|            0|  0.00%|    >>> np.issubclass_(np.float64, float)
   315|         0|            0|            0|  0.00%|    True
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    """
   318|      9816|    0.0130525|  1.32971e-06|  0.04%|    try:
   319|      9816|    0.0231609|  2.35951e-06|  0.07%|        return issubclass(arg1, arg2)
   320|      4908|   0.00624013|  1.27142e-06|  0.02%|    except TypeError:
   321|      4908|     0.011061|  2.25366e-06|  0.03%|        return False
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|@set_module('numpy')
   325|         0|            0|            0|  0.00%|def issubsctype(arg1, arg2):
   326|         0|            0|            0|  0.00%|    """
   327|         0|            0|            0|  0.00%|    Determine if the first argument is a subclass of the second argument.
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|    Parameters
   330|         0|            0|            0|  0.00%|    ----------
   331|         0|            0|            0|  0.00%|    arg1, arg2 : dtype or dtype specifier
   332|         0|            0|            0|  0.00%|        Data-types.
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|    Returns
   335|         0|            0|            0|  0.00%|    -------
   336|         0|            0|            0|  0.00%|    out : bool
   337|         0|            0|            0|  0.00%|        The result.
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|    See Also
   340|         0|            0|            0|  0.00%|    --------
   341|         0|            0|            0|  0.00%|    issctype, issubdtype, obj2sctype
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    Examples
   344|         0|            0|            0|  0.00%|    --------
   345|         0|            0|            0|  0.00%|    >>> np.issubsctype('S8', str)
   346|         0|            0|            0|  0.00%|    False
   347|         0|            0|            0|  0.00%|    >>> np.issubsctype(np.array([1]), int)
   348|         0|            0|            0|  0.00%|    True
   349|         0|            0|            0|  0.00%|    >>> np.issubsctype(np.array([1]), float)
   350|         0|            0|            0|  0.00%|    False
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    """
   353|         0|            0|            0|  0.00%|    return issubclass(obj2sctype(arg1), obj2sctype(arg2))
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|
   356|      4908|    0.0123329|  2.51282e-06|  0.04%|@set_module('numpy')
   357|         0|            0|            0|  0.00%|def issubdtype(arg1, arg2):
   358|         0|            0|            0|  0.00%|    r"""
   359|         0|            0|            0|  0.00%|    Returns True if first argument is a typecode lower/equal in type hierarchy.
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    This is like the builtin :func:`issubclass`, but for `dtype`\ s.
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    Parameters
   364|         0|            0|            0|  0.00%|    ----------
   365|         0|            0|            0|  0.00%|    arg1, arg2 : dtype_like
   366|         0|            0|            0|  0.00%|        `dtype` or object coercible to one
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|    Returns
   369|         0|            0|            0|  0.00%|    -------
   370|         0|            0|            0|  0.00%|    out : bool
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|    See Also
   373|         0|            0|            0|  0.00%|    --------
   374|         0|            0|            0|  0.00%|    :ref:`arrays.scalars` : Overview of the numpy type hierarchy.
   375|         0|            0|            0|  0.00%|    issubsctype, issubclass_
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    Examples
   378|         0|            0|            0|  0.00%|    --------
   379|         0|            0|            0|  0.00%|    `issubdtype` can be used to check the type of arrays:
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    >>> ints = np.array([1, 2, 3], dtype=np.int32)
   382|         0|            0|            0|  0.00%|    >>> np.issubdtype(ints.dtype, np.integer)
   383|         0|            0|            0|  0.00%|    True
   384|         0|            0|            0|  0.00%|    >>> np.issubdtype(ints.dtype, np.floating)
   385|         0|            0|            0|  0.00%|    False
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    >>> floats = np.array([1, 2, 3], dtype=np.float32)
   388|         0|            0|            0|  0.00%|    >>> np.issubdtype(floats.dtype, np.integer)
   389|         0|            0|            0|  0.00%|    False
   390|         0|            0|            0|  0.00%|    >>> np.issubdtype(floats.dtype, np.floating)
   391|         0|            0|            0|  0.00%|    True
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    Similar types of different sizes are not subdtypes of each other:
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    >>> np.issubdtype(np.float64, np.float32)
   396|         0|            0|            0|  0.00%|    False
   397|         0|            0|            0|  0.00%|    >>> np.issubdtype(np.float32, np.float64)
   398|         0|            0|            0|  0.00%|    False
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|    but both are subtypes of `floating`:
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|    >>> np.issubdtype(np.float64, np.floating)
   403|         0|            0|            0|  0.00%|    True
   404|         0|            0|            0|  0.00%|    >>> np.issubdtype(np.float32, np.floating)
   405|         0|            0|            0|  0.00%|    True
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|    For convenience, dtype-like objects are allowed too:
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    >>> np.issubdtype('S1', np.string_)
   410|         0|            0|            0|  0.00%|    True
   411|         0|            0|            0|  0.00%|    >>> np.issubdtype('i4', np.signedinteger)
   412|         0|            0|            0|  0.00%|    True
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    """
   415|      4908|    0.0400939|  8.16909e-06|  0.11%|    if not issubclass_(arg1, generic):
(call)|      4908|      0.05146|  1.04849e-05|  0.15%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:282 issubclass_
   416|      4908|   0.00910234|  1.85459e-06|  0.03%|        arg1 = dtype(arg1).type
   417|      4908|    0.0188808|  3.84695e-06|  0.05%|    if not issubclass_(arg2, generic):
(call)|      4908|      0.02423|  4.93684e-06|  0.07%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:282 issubclass_
   418|         0|            0|            0|  0.00%|        arg2 = dtype(arg2).type
   419|         0|            0|            0|  0.00%|
   420|      4908|    0.0112836|  2.29903e-06|  0.03%|    return issubclass(arg1, arg2)
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|# This dictionary allows look up based on any alias for an array data-type
   424|         0|            0|            0|  0.00%|class _typedict(dict):
   425|         0|            0|            0|  0.00%|    """
   426|         0|            0|            0|  0.00%|    Base object for a dictionary for look-up with any alias for an array dtype.
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|    Instances of `_typedict` can not be used as dictionaries directly,
   429|         0|            0|            0|  0.00%|    first they have to be populated.
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|    """
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|    def __getitem__(self, obj):
   434|         0|            0|            0|  0.00%|        return dict.__getitem__(self, obj2sctype(obj))
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|nbytes = _typedict()
   437|         0|            0|            0|  0.00%|_alignment = _typedict()
   438|         0|            0|            0|  0.00%|_maxvals = _typedict()
   439|         0|            0|            0|  0.00%|_minvals = _typedict()
   440|         0|            0|            0|  0.00%|def _construct_lookups():
   441|         0|            0|            0|  0.00%|    for name, info in _concrete_typeinfo.items():
   442|         0|            0|            0|  0.00%|        obj = info.type
   443|         0|            0|            0|  0.00%|        nbytes[obj] = info.bits // 8
   444|         0|            0|            0|  0.00%|        _alignment[obj] = info.alignment
   445|         0|            0|            0|  0.00%|        if len(info) > 5:
   446|         0|            0|            0|  0.00%|            _maxvals[obj] = info.max
   447|         0|            0|            0|  0.00%|            _minvals[obj] = info.min
   448|         0|            0|            0|  0.00%|        else:
   449|         0|            0|            0|  0.00%|            _maxvals[obj] = None
   450|         0|            0|            0|  0.00%|            _minvals[obj] = None
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|_construct_lookups()
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|@set_module('numpy')
   456|         0|            0|            0|  0.00%|def sctype2char(sctype):
   457|         0|            0|            0|  0.00%|    """
   458|         0|            0|            0|  0.00%|    Return the string representation of a scalar dtype.
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|    Parameters
   461|         0|            0|            0|  0.00%|    ----------
   462|         0|            0|            0|  0.00%|    sctype : scalar dtype or object
   463|         0|            0|            0|  0.00%|        If a scalar dtype, the corresponding string character is
   464|         0|            0|            0|  0.00%|        returned. If an object, `sctype2char` tries to infer its scalar type
   465|         0|            0|            0|  0.00%|        and then return the corresponding string character.
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|    Returns
   468|         0|            0|            0|  0.00%|    -------
   469|         0|            0|            0|  0.00%|    typechar : str
   470|         0|            0|            0|  0.00%|        The string character corresponding to the scalar type.
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|    Raises
   473|         0|            0|            0|  0.00%|    ------
   474|         0|            0|            0|  0.00%|    ValueError
   475|         0|            0|            0|  0.00%|        If `sctype` is an object for which the type can not be inferred.
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|    See Also
   478|         0|            0|            0|  0.00%|    --------
   479|         0|            0|            0|  0.00%|    obj2sctype, issctype, issubsctype, mintypecode
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|    Examples
   482|         0|            0|            0|  0.00%|    --------
   483|         0|            0|            0|  0.00%|    >>> for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:
   484|         0|            0|            0|  0.00%|    ...     print(np.sctype2char(sctype))
   485|         0|            0|            0|  0.00%|    l # may vary
   486|         0|            0|            0|  0.00%|    d
   487|         0|            0|            0|  0.00%|    D
   488|         0|            0|            0|  0.00%|    S
   489|         0|            0|            0|  0.00%|    O
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    >>> x = np.array([1., 2-1.j])
   492|         0|            0|            0|  0.00%|    >>> np.sctype2char(x)
   493|         0|            0|            0|  0.00%|    'D'
   494|         0|            0|            0|  0.00%|    >>> np.sctype2char(list)
   495|         0|            0|            0|  0.00%|    'O'
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    """
   498|         0|            0|            0|  0.00%|    sctype = obj2sctype(sctype)
   499|         0|            0|            0|  0.00%|    if sctype is None:
   500|         0|            0|            0|  0.00%|        raise ValueError("unrecognized type")
   501|         0|            0|            0|  0.00%|    if sctype not in _concrete_types:
   502|         0|            0|            0|  0.00%|        # for compatibility
   503|         0|            0|            0|  0.00%|        raise KeyError(sctype)
   504|         0|            0|            0|  0.00%|    return dtype(sctype).char
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|# Create dictionary of casting functions that wrap sequences
   507|         0|            0|            0|  0.00%|# indexed by type or type character
   508|         0|            0|            0|  0.00%|cast = _typedict()
   509|         0|            0|            0|  0.00%|for key in _concrete_types:
   510|         0|            0|            0|  0.00%|    cast[key] = lambda x, k=key: array(x, copy=False).astype(k)
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|def _scalar_type_key(typ):
   514|         0|            0|            0|  0.00%|    """A ``key`` function for `sorted`."""
   515|         0|            0|            0|  0.00%|    dt = dtype(typ)
   516|         0|            0|            0|  0.00%|    return (dt.kind.lower(), dt.itemsize)
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|ScalarType = [int, float, complex, int, bool, bytes, str, memoryview]
   520|         0|            0|            0|  0.00%|ScalarType += sorted(_concrete_types, key=_scalar_type_key)
   521|         0|            0|            0|  0.00%|ScalarType = tuple(ScalarType)
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|# Now add the types we've determined to this module
   525|         0|            0|            0|  0.00%|for key in allTypes:
   526|         0|            0|            0|  0.00%|    globals()[key] = allTypes[key]
   527|         0|            0|            0|  0.00%|    __all__.append(key)
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|del key
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|typecodes = {'Character':'c',
   532|         0|            0|            0|  0.00%|             'Integer':'bhilqp',
   533|         0|            0|            0|  0.00%|             'UnsignedInteger':'BHILQP',
   534|         0|            0|            0|  0.00%|             'Float':'efdg',
   535|         0|            0|            0|  0.00%|             'Complex':'FDG',
   536|         0|            0|            0|  0.00%|             'AllInteger':'bBhHiIlLqQpP',
   537|         0|            0|            0|  0.00%|             'AllFloat':'efdgFDG',
   538|         0|            0|            0|  0.00%|             'Datetime': 'Mm',
   539|         0|            0|            0|  0.00%|             'All':'?bhilqpBHILQPefdgFDGSUVOMm'}
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|# backwards compatibility --- deprecated name
   542|         0|            0|            0|  0.00%|# Formal deprecation: Numpy 1.20.0, 2020-10-19 (see numpy/__init__.py)
   543|         0|            0|            0|  0.00%|typeDict = sctypeDict
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|# b -> boolean
   546|         0|            0|            0|  0.00%|# u -> unsigned integer
   547|         0|            0|            0|  0.00%|# i -> signed integer
   548|         0|            0|            0|  0.00%|# f -> floating point
   549|         0|            0|            0|  0.00%|# c -> complex
   550|         0|            0|            0|  0.00%|# M -> datetime
   551|         0|            0|            0|  0.00%|# m -> timedelta
   552|         0|            0|            0|  0.00%|# S -> string
   553|         0|            0|            0|  0.00%|# U -> Unicode string
   554|         0|            0|            0|  0.00%|# V -> record
   555|         0|            0|            0|  0.00%|# O -> Python object
   556|         0|            0|            0|  0.00%|_kind_list = ['b', 'u', 'i', 'f', 'c', 'S', 'U', 'V', 'O', 'M', 'm']
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|__test_types = '?'+typecodes['AllInteger'][:-2]+typecodes['AllFloat']+'O'
   559|         0|            0|            0|  0.00%|__len_test_types = len(__test_types)
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|# Keep incrementing until a common type both can be coerced to
   562|         0|            0|            0|  0.00%|#  is found.  Otherwise, return None
   563|         0|            0|            0|  0.00%|def _find_common_coerce(a, b):
   564|         0|            0|            0|  0.00%|    if a > b:
   565|         0|            0|            0|  0.00%|        return a
   566|         0|            0|            0|  0.00%|    try:
   567|         0|            0|            0|  0.00%|        thisind = __test_types.index(a.char)
   568|         0|            0|            0|  0.00%|    except ValueError:
   569|         0|            0|            0|  0.00%|        return None
   570|         0|            0|            0|  0.00%|    return _can_coerce_all([a, b], start=thisind)
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|# Find a data-type that all data-types in a list can be coerced to
   573|         4|            0|            0|  0.00%|def _can_coerce_all(dtypelist, start=0):
   574|         4|            0|            0|  0.00%|    N = len(dtypelist)
   575|         4|            0|            0|  0.00%|    if N == 0:
   576|         2|            0|            0|  0.00%|        return None
   577|         2|            0|            0|  0.00%|    if N == 1:
   578|         1|            0|            0|  0.00%|        return dtypelist[0]
   579|         1|            0|            0|  0.00%|    thisind = start
   580|         6|            0|            0|  0.00%|    while thisind < __len_test_types:
   581|         6|            0|            0|  0.00%|        newdtype = dtype(__test_types[thisind])
   582|        30|            0|            0|  0.00%|        numcoerce = len([x for x in dtypelist if newdtype >= x])
(call)|         6|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:582 <listcomp>
   583|         6|            0|            0|  0.00%|        if numcoerce == N:
   584|         1|            0|            0|  0.00%|            return newdtype
   585|         5|            0|            0|  0.00%|        thisind += 1
   586|         0|            0|            0|  0.00%|    return None
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|def _register_types():
   589|         0|            0|            0|  0.00%|    numbers.Integral.register(integer)
   590|         0|            0|            0|  0.00%|    numbers.Complex.register(inexact)
   591|         0|            0|            0|  0.00%|    numbers.Real.register(floating)
   592|         0|            0|            0|  0.00%|    numbers.Number.register(number)
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|_register_types()
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|
   597|         2|            0|            0|  0.00%|@set_module('numpy')
   598|         0|            0|            0|  0.00%|def find_common_type(array_types, scalar_types):
   599|         0|            0|            0|  0.00%|    """
   600|         0|            0|            0|  0.00%|    Determine common type following standard coercion rules.
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|    Parameters
   603|         0|            0|            0|  0.00%|    ----------
   604|         0|            0|            0|  0.00%|    array_types : sequence
   605|         0|            0|            0|  0.00%|        A list of dtypes or dtype convertible objects representing arrays.
   606|         0|            0|            0|  0.00%|    scalar_types : sequence
   607|         0|            0|            0|  0.00%|        A list of dtypes or dtype convertible objects representing scalars.
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|    Returns
   610|         0|            0|            0|  0.00%|    -------
   611|         0|            0|            0|  0.00%|    datatype : dtype
   612|         0|            0|            0|  0.00%|        The common data type, which is the maximum of `array_types` ignoring
   613|         0|            0|            0|  0.00%|        `scalar_types`, unless the maximum of `scalar_types` is of a
   614|         0|            0|            0|  0.00%|        different kind (`dtype.kind`). If the kind is not understood, then
   615|         0|            0|            0|  0.00%|        None is returned.
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|    See Also
   618|         0|            0|            0|  0.00%|    --------
   619|         0|            0|            0|  0.00%|    dtype, common_type, can_cast, mintypecode
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|    Examples
   622|         0|            0|            0|  0.00%|    --------
   623|         0|            0|            0|  0.00%|    >>> np.find_common_type([], [np.int64, np.float32, complex])
   624|         0|            0|            0|  0.00%|    dtype('complex128')
   625|         0|            0|            0|  0.00%|    >>> np.find_common_type([np.int64, np.float32], [])
   626|         0|            0|            0|  0.00%|    dtype('float64')
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    The standard casting rules ensure that a scalar cannot up-cast an
   629|         0|            0|            0|  0.00%|    array unless the scalar is of a fundamentally different kind of data
   630|         0|            0|            0|  0.00%|    (i.e. under a different hierarchy in the data type hierarchy) then
   631|         0|            0|            0|  0.00%|    the array:
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|    >>> np.find_common_type([np.float32], [np.int64, np.float64])
   634|         0|            0|            0|  0.00%|    dtype('float32')
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|    Complex is of a different type, so it up-casts the float in the
   637|         0|            0|            0|  0.00%|    `array_types` argument:
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|    >>> np.find_common_type([np.float32], [complex])
   640|         0|            0|            0|  0.00%|    dtype('complex128')
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    Type specifier strings are convertible to dtypes and can therefore
   643|         0|            0|            0|  0.00%|    be used instead of dtypes:
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])
   646|         0|            0|            0|  0.00%|    dtype('complex128')
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|    """
   649|         9|            0|            0|  0.00%|    array_types = [dtype(x) for x in array_types]
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:649 <listcomp>
   650|         6|            0|            0|  0.00%|    scalar_types = [dtype(x) for x in scalar_types]
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:650 <listcomp>
   651|         0|            0|            0|  0.00%|
   652|         2|            0|            0|  0.00%|    maxa = _can_coerce_all(array_types)
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:573 _can_coerce_all
   653|         2|            0|            0|  0.00%|    maxsc = _can_coerce_all(scalar_types)
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:573 _can_coerce_all
   654|         0|            0|            0|  0.00%|
   655|         2|            0|            0|  0.00%|    if maxa is None:
   656|         0|            0|            0|  0.00%|        return maxsc
   657|         0|            0|            0|  0.00%|
   658|         2|   0.00100112|   0.00050056|  0.00%|    if maxsc is None:
   659|         2|            0|            0|  0.00%|        return maxa
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|    try:
   662|         0|            0|            0|  0.00%|        index_a = _kind_list.index(maxa.kind)
   663|         0|            0|            0|  0.00%|        index_sc = _kind_list.index(maxsc.kind)
   664|         0|            0|            0|  0.00%|    except ValueError:
   665|         0|            0|            0|  0.00%|        return None
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|    if index_sc > index_a:
   668|         0|            0|            0|  0.00%|        return _find_common_coerce(maxsc, maxa)
   669|         0|            0|            0|  0.00%|    else:
   670|         0|            0|            0|  0.00%|        return maxa
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py
File duration: 0.125223s (0.36%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Module containing non-deprecated functions borrowed from Numeric.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|"""
     4|         0|            0|            0|  0.00%|import functools
     5|         0|            0|            0|  0.00%|import types
     6|         0|            0|            0|  0.00%|import warnings
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import numpy as np
     9|         0|            0|            0|  0.00%|from . import multiarray as mu
    10|         0|            0|            0|  0.00%|from . import overrides
    11|         0|            0|            0|  0.00%|from . import umath as um
    12|         0|            0|            0|  0.00%|from . import numerictypes as nt
    13|         0|            0|            0|  0.00%|from .multiarray import asarray, array, asanyarray, concatenate
    14|         0|            0|            0|  0.00%|from . import _methods
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|_dt_ = nt.sctype2char
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|# functions that are methods
    19|         0|            0|            0|  0.00%|__all__ = [
    20|         0|            0|            0|  0.00%|    'alen', 'all', 'alltrue', 'amax', 'amin', 'any', 'argmax',
    21|         0|            0|            0|  0.00%|    'argmin', 'argpartition', 'argsort', 'around', 'choose', 'clip',
    22|         0|            0|            0|  0.00%|    'compress', 'cumprod', 'cumproduct', 'cumsum', 'diagonal', 'mean',
    23|         0|            0|            0|  0.00%|    'ndim', 'nonzero', 'partition', 'prod', 'product', 'ptp', 'put',
    24|         0|            0|            0|  0.00%|    'ravel', 'repeat', 'reshape', 'resize', 'round_',
    25|         0|            0|            0|  0.00%|    'searchsorted', 'shape', 'size', 'sometrue', 'sort', 'squeeze',
    26|         0|            0|            0|  0.00%|    'std', 'sum', 'swapaxes', 'take', 'trace', 'transpose', 'var',
    27|         0|            0|            0|  0.00%|]
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|_gentype = types.GeneratorType
    30|         0|            0|            0|  0.00%|# save away Python sum
    31|         0|            0|            0|  0.00%|_sum_ = sum
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    34|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|# functions that are now methods
    38|         8|            0|            0|  0.00%|def _wrapit(obj, method, *args, **kwds):
    39|         8|            0|            0|  0.00%|    try:
    40|         8|  0.000998497|  0.000124812|  0.00%|        wrap = obj.__array_wrap__
    41|         8|            0|            0|  0.00%|    except AttributeError:
    42|         8|            0|            0|  0.00%|        wrap = None
    43|         8|            0|            0|  0.00%|    result = getattr(asarray(obj), method)(*args, **kwds)
    44|         8|            0|            0|  0.00%|    if wrap:
    45|         0|            0|            0|  0.00%|        if not isinstance(result, mu.ndarray):
    46|         0|            0|            0|  0.00%|            result = asarray(result)
    47|         0|            0|            0|  0.00%|        result = wrap(result)
    48|         8|            0|            0|  0.00%|    return result
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|        36|  0.000995398|  2.76499e-05|  0.00%|def _wrapfunc(obj, method, *args, **kwds):
    52|        36|            0|            0|  0.00%|    bound = getattr(obj, method, None)
    53|        36|            0|            0|  0.00%|    if bound is None:
    54|         8|            0|            0|  0.00%|        return _wrapit(obj, method, *args, **kwds)
(call)|         8|  0.000998497|  0.000124812|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:38 _wrapit
    55|         0|            0|            0|  0.00%|
    56|        28|            0|            0|  0.00%|    try:
    57|        28|  0.000564098|  2.01464e-05|  0.00%|        return bound(*args, **kwds)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:125 _clip
    58|         0|            0|            0|  0.00%|    except TypeError:
    59|         0|            0|            0|  0.00%|        # A TypeError occurs if the object does have such a method in its
    60|         0|            0|            0|  0.00%|        # class, but its signature is not identical to that of NumPy's. This
    61|         0|            0|            0|  0.00%|        # situation has occurred in the case of a downstream library like
    62|         0|            0|            0|  0.00%|        # 'pandas'.
    63|         0|            0|            0|  0.00%|        #
    64|         0|            0|            0|  0.00%|        # Call _wrapit from within the except clause to ensure a potential
    65|         0|            0|            0|  0.00%|        # exception has a traceback chain.
    66|         0|            0|            0|  0.00%|        return _wrapit(obj, method, *args, **kwds)
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|
    69|      2196|   0.00517869|  2.35824e-06|  0.01%|def _wrapreduction(obj, ufunc, method, axis, dtype, out, **kwargs):
    70|     13088|    0.0284057|  2.17036e-06|  0.08%|    passkwargs = {k: v for k, v in kwargs.items()
(call)|      2196|    0.0212922|  9.69591e-06|  0.06%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:70 <dictcomp>
    71|      6500|   0.00714993|  1.09999e-06|  0.02%|                  if v is not np._NoValue}
    72|         0|            0|            0|  0.00%|
    73|      2196|   0.00406241|  1.84992e-06|  0.01%|    if type(obj) is not mu.ndarray:
    74|         0|            0|            0|  0.00%|        try:
    75|         0|            0|            0|  0.00%|            reduction = getattr(obj, method)
    76|         0|            0|            0|  0.00%|        except AttributeError:
    77|         0|            0|            0|  0.00%|            pass
    78|         0|            0|            0|  0.00%|        else:
    79|         0|            0|            0|  0.00%|            # This branch is needed for reductions like any which don't
    80|         0|            0|            0|  0.00%|            # support a dtype.
    81|         0|            0|            0|  0.00%|            if dtype is not None:
    82|         0|            0|            0|  0.00%|                return reduction(axis=axis, dtype=dtype, out=out, **passkwargs)
    83|         0|            0|            0|  0.00%|            else:
    84|         0|            0|            0|  0.00%|                return reduction(axis=axis, out=out, **passkwargs)
    85|         0|            0|            0|  0.00%|
    86|      2196|    0.0162678|  7.40791e-06|  0.05%|    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|def _take_dispatcher(a, indices, axis=None, out=None, mode=None):
    90|         0|            0|            0|  0.00%|    return (a, out)
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|@array_function_dispatch(_take_dispatcher)
    94|         0|            0|            0|  0.00%|def take(a, indices, axis=None, out=None, mode='raise'):
    95|         0|            0|            0|  0.00%|    """
    96|         0|            0|            0|  0.00%|    Take elements from an array along an axis.
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    When axis is not None, this function does the same thing as "fancy"
    99|         0|            0|            0|  0.00%|    indexing (indexing arrays using arrays); however, it can be easier to use
   100|         0|            0|            0|  0.00%|    if you need elements along a given axis. A call such as
   101|         0|            0|            0|  0.00%|    ``np.take(arr, indices, axis=3)`` is equivalent to
   102|         0|            0|            0|  0.00%|    ``arr[:,:,:,indices,...]``.
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    Explained without fancy indexing, this is equivalent to the following use
   105|         0|            0|            0|  0.00%|    of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of
   106|         0|            0|            0|  0.00%|    indices::
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|        Ni, Nk = a.shape[:axis], a.shape[axis+1:]
   109|         0|            0|            0|  0.00%|        Nj = indices.shape
   110|         0|            0|            0|  0.00%|        for ii in ndindex(Ni):
   111|         0|            0|            0|  0.00%|            for jj in ndindex(Nj):
   112|         0|            0|            0|  0.00%|                for kk in ndindex(Nk):
   113|         0|            0|            0|  0.00%|                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|    Parameters
   116|         0|            0|            0|  0.00%|    ----------
   117|         0|            0|            0|  0.00%|    a : array_like (Ni..., M, Nk...)
   118|         0|            0|            0|  0.00%|        The source array.
   119|         0|            0|            0|  0.00%|    indices : array_like (Nj...)
   120|         0|            0|            0|  0.00%|        The indices of the values to extract.
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|        .. versionadded:: 1.8.0
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|        Also allow scalars for indices.
   125|         0|            0|            0|  0.00%|    axis : int, optional
   126|         0|            0|            0|  0.00%|        The axis over which to select values. By default, the flattened
   127|         0|            0|            0|  0.00%|        input array is used.
   128|         0|            0|            0|  0.00%|    out : ndarray, optional (Ni..., Nj..., Nk...)
   129|         0|            0|            0|  0.00%|        If provided, the result will be placed in this array. It should
   130|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype. Note that `out` is always
   131|         0|            0|            0|  0.00%|        buffered if `mode='raise'`; use other modes for better performance.
   132|         0|            0|            0|  0.00%|    mode : {'raise', 'wrap', 'clip'}, optional
   133|         0|            0|            0|  0.00%|        Specifies how out-of-bounds indices will behave.
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|        * 'raise' -- raise an error (default)
   136|         0|            0|            0|  0.00%|        * 'wrap' -- wrap around
   137|         0|            0|            0|  0.00%|        * 'clip' -- clip to the range
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|        'clip' mode means that all indices that are too large are replaced
   140|         0|            0|            0|  0.00%|        by the index that addresses the last element along that axis. Note
   141|         0|            0|            0|  0.00%|        that this disables indexing with negative numbers.
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|    Returns
   144|         0|            0|            0|  0.00%|    -------
   145|         0|            0|            0|  0.00%|    out : ndarray (Ni..., Nj..., Nk...)
   146|         0|            0|            0|  0.00%|        The returned array has the same type as `a`.
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    See Also
   149|         0|            0|            0|  0.00%|    --------
   150|         0|            0|            0|  0.00%|    compress : Take elements using a boolean mask
   151|         0|            0|            0|  0.00%|    ndarray.take : equivalent method
   152|         0|            0|            0|  0.00%|    take_along_axis : Take elements by matching the array and the index arrays
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|    Notes
   155|         0|            0|            0|  0.00%|    -----
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    By eliminating the inner loop in the description above, and using `s_` to
   158|         0|            0|            0|  0.00%|    build simple slice objects, `take` can be expressed  in terms of applying
   159|         0|            0|            0|  0.00%|    fancy indexing to each 1-d slice::
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|        Ni, Nk = a.shape[:axis], a.shape[axis+1:]
   162|         0|            0|            0|  0.00%|        for ii in ndindex(Ni):
   163|         0|            0|            0|  0.00%|            for kk in ndindex(Nj):
   164|         0|            0|            0|  0.00%|                out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    For this reason, it is equivalent to (but faster than) the following use
   167|         0|            0|            0|  0.00%|    of `apply_along_axis`::
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|        out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    Examples
   172|         0|            0|            0|  0.00%|    --------
   173|         0|            0|            0|  0.00%|    >>> a = [4, 3, 5, 7, 6, 8]
   174|         0|            0|            0|  0.00%|    >>> indices = [0, 1, 4]
   175|         0|            0|            0|  0.00%|    >>> np.take(a, indices)
   176|         0|            0|            0|  0.00%|    array([4, 3, 6])
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    In this example if `a` is an ndarray, "fancy" indexing can be used.
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|    >>> a = np.array(a)
   181|         0|            0|            0|  0.00%|    >>> a[indices]
   182|         0|            0|            0|  0.00%|    array([4, 3, 6])
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|    If `indices` is not one dimensional, the output also has these dimensions.
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    >>> np.take(a, [[0, 1], [2, 3]])
   187|         0|            0|            0|  0.00%|    array([[4, 3],
   188|         0|            0|            0|  0.00%|           [5, 7]])
   189|         0|            0|            0|  0.00%|    """
   190|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'take', indices, axis=axis, out=out, mode=mode)
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|def _reshape_dispatcher(a, newshape, order=None):
   194|         0|            0|            0|  0.00%|    return (a,)
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|# not deprecated --- copy if necessary, view otherwise
   198|         0|            0|            0|  0.00%|@array_function_dispatch(_reshape_dispatcher)
   199|         0|            0|            0|  0.00%|def reshape(a, newshape, order='C'):
   200|         0|            0|            0|  0.00%|    """
   201|         0|            0|            0|  0.00%|    Gives a new shape to an array without changing its data.
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    Parameters
   204|         0|            0|            0|  0.00%|    ----------
   205|         0|            0|            0|  0.00%|    a : array_like
   206|         0|            0|            0|  0.00%|        Array to be reshaped.
   207|         0|            0|            0|  0.00%|    newshape : int or tuple of ints
   208|         0|            0|            0|  0.00%|        The new shape should be compatible with the original shape. If
   209|         0|            0|            0|  0.00%|        an integer, then the result will be a 1-D array of that length.
   210|         0|            0|            0|  0.00%|        One shape dimension can be -1. In this case, the value is
   211|         0|            0|            0|  0.00%|        inferred from the length of the array and remaining dimensions.
   212|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A'}, optional
   213|         0|            0|            0|  0.00%|        Read the elements of `a` using this index order, and place the
   214|         0|            0|            0|  0.00%|        elements into the reshaped array using this index order.  'C'
   215|         0|            0|            0|  0.00%|        means to read / write the elements using C-like index order,
   216|         0|            0|            0|  0.00%|        with the last axis index changing fastest, back to the first
   217|         0|            0|            0|  0.00%|        axis index changing slowest. 'F' means to read / write the
   218|         0|            0|            0|  0.00%|        elements using Fortran-like index order, with the first index
   219|         0|            0|            0|  0.00%|        changing fastest, and the last index changing slowest. Note that
   220|         0|            0|            0|  0.00%|        the 'C' and 'F' options take no account of the memory layout of
   221|         0|            0|            0|  0.00%|        the underlying array, and only refer to the order of indexing.
   222|         0|            0|            0|  0.00%|        'A' means to read / write the elements in Fortran-like index
   223|         0|            0|            0|  0.00%|        order if `a` is Fortran *contiguous* in memory, C-like order
   224|         0|            0|            0|  0.00%|        otherwise.
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|    Returns
   227|         0|            0|            0|  0.00%|    -------
   228|         0|            0|            0|  0.00%|    reshaped_array : ndarray
   229|         0|            0|            0|  0.00%|        This will be a new view object if possible; otherwise, it will
   230|         0|            0|            0|  0.00%|        be a copy.  Note there is no guarantee of the *memory layout* (C- or
   231|         0|            0|            0|  0.00%|        Fortran- contiguous) of the returned array.
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|    See Also
   234|         0|            0|            0|  0.00%|    --------
   235|         0|            0|            0|  0.00%|    ndarray.reshape : Equivalent method.
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    Notes
   238|         0|            0|            0|  0.00%|    -----
   239|         0|            0|            0|  0.00%|    It is not always possible to change the shape of an array without
   240|         0|            0|            0|  0.00%|    copying the data. If you want an error to be raised when the data is copied,
   241|         0|            0|            0|  0.00%|    you should assign the new shape to the shape attribute of the array::
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|     >>> a = np.zeros((10, 2))
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|     # A transpose makes the array non-contiguous
   246|         0|            0|            0|  0.00%|     >>> b = a.T
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|     # Taking a view makes it possible to modify the shape without modifying
   249|         0|            0|            0|  0.00%|     # the initial object.
   250|         0|            0|            0|  0.00%|     >>> c = b.view()
   251|         0|            0|            0|  0.00%|     >>> c.shape = (20)
   252|         0|            0|            0|  0.00%|     Traceback (most recent call last):
   253|         0|            0|            0|  0.00%|        ...
   254|         0|            0|            0|  0.00%|     AttributeError: Incompatible shape for in-place modification. Use
   255|         0|            0|            0|  0.00%|     `.reshape()` to make a copy with the desired shape.
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    The `order` keyword gives the index ordering both for *fetching* the values
   258|         0|            0|            0|  0.00%|    from `a`, and then *placing* the values into the output array.
   259|         0|            0|            0|  0.00%|    For example, let's say you have an array:
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape((3, 2))
   262|         0|            0|            0|  0.00%|    >>> a
   263|         0|            0|            0|  0.00%|    array([[0, 1],
   264|         0|            0|            0|  0.00%|           [2, 3],
   265|         0|            0|            0|  0.00%|           [4, 5]])
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    You can think of reshaping as first raveling the array (using the given
   268|         0|            0|            0|  0.00%|    index order), then inserting the elements from the raveled array into the
   269|         0|            0|            0|  0.00%|    new array using the same kind of index ordering as was used for the
   270|         0|            0|            0|  0.00%|    raveling.
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|    >>> np.reshape(a, (2, 3)) # C-like index ordering
   273|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   274|         0|            0|            0|  0.00%|           [3, 4, 5]])
   275|         0|            0|            0|  0.00%|    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
   276|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   277|         0|            0|            0|  0.00%|           [3, 4, 5]])
   278|         0|            0|            0|  0.00%|    >>> np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
   279|         0|            0|            0|  0.00%|    array([[0, 4, 3],
   280|         0|            0|            0|  0.00%|           [2, 1, 5]])
   281|         0|            0|            0|  0.00%|    >>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
   282|         0|            0|            0|  0.00%|    array([[0, 4, 3],
   283|         0|            0|            0|  0.00%|           [2, 1, 5]])
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    Examples
   286|         0|            0|            0|  0.00%|    --------
   287|         0|            0|            0|  0.00%|    >>> a = np.array([[1,2,3], [4,5,6]])
   288|         0|            0|            0|  0.00%|    >>> np.reshape(a, 6)
   289|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
   290|         0|            0|            0|  0.00%|    >>> np.reshape(a, 6, order='F')
   291|         0|            0|            0|  0.00%|    array([1, 4, 2, 5, 3, 6])
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
   294|         0|            0|            0|  0.00%|    array([[1, 2],
   295|         0|            0|            0|  0.00%|           [3, 4],
   296|         0|            0|            0|  0.00%|           [5, 6]])
   297|         0|            0|            0|  0.00%|    """
   298|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'reshape', newshape, order=order)
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|def _choose_dispatcher(a, choices, out=None, mode=None):
   302|         0|            0|            0|  0.00%|    yield a
   303|         0|            0|            0|  0.00%|    yield from choices
   304|         0|            0|            0|  0.00%|    yield out
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|@array_function_dispatch(_choose_dispatcher)
   308|         0|            0|            0|  0.00%|def choose(a, choices, out=None, mode='raise'):
   309|         0|            0|            0|  0.00%|    """
   310|         0|            0|            0|  0.00%|    Construct an array from an index array and a list of arrays to choose from.
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    First of all, if confused or uncertain, definitely look at the Examples -
   313|         0|            0|            0|  0.00%|    in its full generality, this function is less simple than it might
   314|         0|            0|            0|  0.00%|    seem from the following code description (below ndi =
   315|         0|            0|            0|  0.00%|    `numpy.lib.index_tricks`):
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|    But this omits some subtleties.  Here is a fully general summary:
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|    Given an "index" array (`a`) of integers and a sequence of ``n`` arrays
   322|         0|            0|            0|  0.00%|    (`choices`), `a` and each choice array are first broadcast, as necessary,
   323|         0|            0|            0|  0.00%|    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =
   324|         0|            0|            0|  0.00%|    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``
   325|         0|            0|            0|  0.00%|    for each ``i``.  Then, a new array with shape ``Ba.shape`` is created as
   326|         0|            0|            0|  0.00%|    follows:
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|    * if ``mode='raise'`` (the default), then, first of all, each element of
   329|         0|            0|            0|  0.00%|      ``a`` (and thus ``Ba``) must be in the range ``[0, n-1]``; now, suppose
   330|         0|            0|            0|  0.00%|      that ``i`` (in that range) is the value at the ``(j0, j1, ..., jm)``
   331|         0|            0|            0|  0.00%|      position in ``Ba`` - then the value at the same position in the new array
   332|         0|            0|            0|  0.00%|      is the value in ``Bchoices[i]`` at that same position;
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|    * if ``mode='wrap'``, values in `a` (and thus `Ba`) may be any (signed)
   335|         0|            0|            0|  0.00%|      integer; modular arithmetic is used to map integers outside the range
   336|         0|            0|            0|  0.00%|      `[0, n-1]` back into that range; and then the new array is constructed
   337|         0|            0|            0|  0.00%|      as above;
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|    * if ``mode='clip'``, values in `a` (and thus ``Ba``) may be any (signed)
   340|         0|            0|            0|  0.00%|      integer; negative integers are mapped to 0; values greater than ``n-1``
   341|         0|            0|            0|  0.00%|      are mapped to ``n-1``; and then the new array is constructed as above.
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    Parameters
   344|         0|            0|            0|  0.00%|    ----------
   345|         0|            0|            0|  0.00%|    a : int array
   346|         0|            0|            0|  0.00%|        This array must contain integers in ``[0, n-1]``, where ``n`` is the
   347|         0|            0|            0|  0.00%|        number of choices, unless ``mode=wrap`` or ``mode=clip``, in which
   348|         0|            0|            0|  0.00%|        cases any integers are permissible.
   349|         0|            0|            0|  0.00%|    choices : sequence of arrays
   350|         0|            0|            0|  0.00%|        Choice arrays. `a` and all of the choices must be broadcastable to the
   351|         0|            0|            0|  0.00%|        same shape.  If `choices` is itself an array (not recommended), then
   352|         0|            0|            0|  0.00%|        its outermost dimension (i.e., the one corresponding to
   353|         0|            0|            0|  0.00%|        ``choices.shape[0]``) is taken as defining the "sequence".
   354|         0|            0|            0|  0.00%|    out : array, optional
   355|         0|            0|            0|  0.00%|        If provided, the result will be inserted into this array. It should
   356|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype. Note that `out` is always
   357|         0|            0|            0|  0.00%|        buffered if ``mode='raise'``; use other modes for better performance.
   358|         0|            0|            0|  0.00%|    mode : {'raise' (default), 'wrap', 'clip'}, optional
   359|         0|            0|            0|  0.00%|        Specifies how indices outside ``[0, n-1]`` will be treated:
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|          * 'raise' : an exception is raised
   362|         0|            0|            0|  0.00%|          * 'wrap' : value becomes value mod ``n``
   363|         0|            0|            0|  0.00%|          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|    Returns
   366|         0|            0|            0|  0.00%|    -------
   367|         0|            0|            0|  0.00%|    merged_array : array
   368|         0|            0|            0|  0.00%|        The merged result.
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    Raises
   371|         0|            0|            0|  0.00%|    ------
   372|         0|            0|            0|  0.00%|    ValueError: shape mismatch
   373|         0|            0|            0|  0.00%|        If `a` and each choice array are not all broadcastable to the same
   374|         0|            0|            0|  0.00%|        shape.
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    See Also
   377|         0|            0|            0|  0.00%|    --------
   378|         0|            0|            0|  0.00%|    ndarray.choose : equivalent method
   379|         0|            0|            0|  0.00%|    numpy.take_along_axis : Preferable if `choices` is an array
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    Notes
   382|         0|            0|            0|  0.00%|    -----
   383|         0|            0|            0|  0.00%|    To reduce the chance of misinterpretation, even though the following
   384|         0|            0|            0|  0.00%|    "abuse" is nominally supported, `choices` should neither be, nor be
   385|         0|            0|            0|  0.00%|    thought of as, a single array, i.e., the outermost sequence-like container
   386|         0|            0|            0|  0.00%|    should be either a list or a tuple.
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|    Examples
   389|         0|            0|            0|  0.00%|    --------
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
   392|         0|            0|            0|  0.00%|    ...   [20, 21, 22, 23], [30, 31, 32, 33]]
   393|         0|            0|            0|  0.00%|    >>> np.choose([2, 3, 1, 0], choices
   394|         0|            0|            0|  0.00%|    ... # the first element of the result will be the first element of the
   395|         0|            0|            0|  0.00%|    ... # third (2+1) "array" in choices, namely, 20; the second element
   396|         0|            0|            0|  0.00%|    ... # will be the second element of the fourth (3+1) choice array, i.e.,
   397|         0|            0|            0|  0.00%|    ... # 31, etc.
   398|         0|            0|            0|  0.00%|    ... )
   399|         0|            0|            0|  0.00%|    array([20, 31, 12,  3])
   400|         0|            0|            0|  0.00%|    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
   401|         0|            0|            0|  0.00%|    array([20, 31, 12,  3])
   402|         0|            0|            0|  0.00%|    >>> # because there are 4 choice arrays
   403|         0|            0|            0|  0.00%|    >>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
   404|         0|            0|            0|  0.00%|    array([20,  1, 12,  3])
   405|         0|            0|            0|  0.00%|    >>> # i.e., 0
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|    A couple examples illustrating how choose broadcasts:
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
   410|         0|            0|            0|  0.00%|    >>> choices = [-10, 10]
   411|         0|            0|            0|  0.00%|    >>> np.choose(a, choices)
   412|         0|            0|            0|  0.00%|    array([[ 10, -10,  10],
   413|         0|            0|            0|  0.00%|           [-10,  10, -10],
   414|         0|            0|            0|  0.00%|           [ 10, -10,  10]])
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|    >>> # With thanks to Anne Archibald
   417|         0|            0|            0|  0.00%|    >>> a = np.array([0, 1]).reshape((2,1,1))
   418|         0|            0|            0|  0.00%|    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))
   419|         0|            0|            0|  0.00%|    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
   420|         0|            0|            0|  0.00%|    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
   421|         0|            0|            0|  0.00%|    array([[[ 1,  1,  1,  1,  1],
   422|         0|            0|            0|  0.00%|            [ 2,  2,  2,  2,  2],
   423|         0|            0|            0|  0.00%|            [ 3,  3,  3,  3,  3]],
   424|         0|            0|            0|  0.00%|           [[-1, -2, -3, -4, -5],
   425|         0|            0|            0|  0.00%|            [-1, -2, -3, -4, -5],
   426|         0|            0|            0|  0.00%|            [-1, -2, -3, -4, -5]]])
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|    """
   429|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'choose', choices, out=out, mode=mode)
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|def _repeat_dispatcher(a, repeats, axis=None):
   433|         0|            0|            0|  0.00%|    return (a,)
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|@array_function_dispatch(_repeat_dispatcher)
   437|         0|            0|            0|  0.00%|def repeat(a, repeats, axis=None):
   438|         0|            0|            0|  0.00%|    """
   439|         0|            0|            0|  0.00%|    Repeat elements of an array.
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|    Parameters
   442|         0|            0|            0|  0.00%|    ----------
   443|         0|            0|            0|  0.00%|    a : array_like
   444|         0|            0|            0|  0.00%|        Input array.
   445|         0|            0|            0|  0.00%|    repeats : int or array of ints
   446|         0|            0|            0|  0.00%|        The number of repetitions for each element.  `repeats` is broadcasted
   447|         0|            0|            0|  0.00%|        to fit the shape of the given axis.
   448|         0|            0|            0|  0.00%|    axis : int, optional
   449|         0|            0|            0|  0.00%|        The axis along which to repeat values.  By default, use the
   450|         0|            0|            0|  0.00%|        flattened input array, and return a flat output array.
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|    Returns
   453|         0|            0|            0|  0.00%|    -------
   454|         0|            0|            0|  0.00%|    repeated_array : ndarray
   455|         0|            0|            0|  0.00%|        Output array which has the same shape as `a`, except along
   456|         0|            0|            0|  0.00%|        the given axis.
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|    See Also
   459|         0|            0|            0|  0.00%|    --------
   460|         0|            0|            0|  0.00%|    tile : Tile an array.
   461|         0|            0|            0|  0.00%|    unique : Find the unique elements of an array.
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|    Examples
   464|         0|            0|            0|  0.00%|    --------
   465|         0|            0|            0|  0.00%|    >>> np.repeat(3, 4)
   466|         0|            0|            0|  0.00%|    array([3, 3, 3, 3])
   467|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2],[3,4]])
   468|         0|            0|            0|  0.00%|    >>> np.repeat(x, 2)
   469|         0|            0|            0|  0.00%|    array([1, 1, 2, 2, 3, 3, 4, 4])
   470|         0|            0|            0|  0.00%|    >>> np.repeat(x, 3, axis=1)
   471|         0|            0|            0|  0.00%|    array([[1, 1, 1, 2, 2, 2],
   472|         0|            0|            0|  0.00%|           [3, 3, 3, 4, 4, 4]])
   473|         0|            0|            0|  0.00%|    >>> np.repeat(x, [1, 2], axis=0)
   474|         0|            0|            0|  0.00%|    array([[1, 2],
   475|         0|            0|            0|  0.00%|           [3, 4],
   476|         0|            0|            0|  0.00%|           [3, 4]])
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|    """
   479|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'repeat', repeats, axis=axis)
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|def _put_dispatcher(a, ind, v, mode=None):
   483|         0|            0|            0|  0.00%|    return (a, ind, v)
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|@array_function_dispatch(_put_dispatcher)
   487|         0|            0|            0|  0.00%|def put(a, ind, v, mode='raise'):
   488|         0|            0|            0|  0.00%|    """
   489|         0|            0|            0|  0.00%|    Replaces specified elements of an array with given values.
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    The indexing works on the flattened target array. `put` is roughly
   492|         0|            0|            0|  0.00%|    equivalent to:
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    ::
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|        a.flat[ind] = v
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|    Parameters
   499|         0|            0|            0|  0.00%|    ----------
   500|         0|            0|            0|  0.00%|    a : ndarray
   501|         0|            0|            0|  0.00%|        Target array.
   502|         0|            0|            0|  0.00%|    ind : array_like
   503|         0|            0|            0|  0.00%|        Target indices, interpreted as integers.
   504|         0|            0|            0|  0.00%|    v : array_like
   505|         0|            0|            0|  0.00%|        Values to place in `a` at target indices. If `v` is shorter than
   506|         0|            0|            0|  0.00%|        `ind` it will be repeated as necessary.
   507|         0|            0|            0|  0.00%|    mode : {'raise', 'wrap', 'clip'}, optional
   508|         0|            0|            0|  0.00%|        Specifies how out-of-bounds indices will behave.
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|        * 'raise' -- raise an error (default)
   511|         0|            0|            0|  0.00%|        * 'wrap' -- wrap around
   512|         0|            0|            0|  0.00%|        * 'clip' -- clip to the range
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|        'clip' mode means that all indices that are too large are replaced
   515|         0|            0|            0|  0.00%|        by the index that addresses the last element along that axis. Note
   516|         0|            0|            0|  0.00%|        that this disables indexing with negative numbers. In 'raise' mode,
   517|         0|            0|            0|  0.00%|        if an exception occurs the target array may still be modified.
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|    See Also
   520|         0|            0|            0|  0.00%|    --------
   521|         0|            0|            0|  0.00%|    putmask, place
   522|         0|            0|            0|  0.00%|    put_along_axis : Put elements by matching the array and the index arrays
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|    Examples
   525|         0|            0|            0|  0.00%|    --------
   526|         0|            0|            0|  0.00%|    >>> a = np.arange(5)
   527|         0|            0|            0|  0.00%|    >>> np.put(a, [0, 2], [-44, -55])
   528|         0|            0|            0|  0.00%|    >>> a
   529|         0|            0|            0|  0.00%|    array([-44,   1, -55,   3,   4])
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|    >>> a = np.arange(5)
   532|         0|            0|            0|  0.00%|    >>> np.put(a, 22, -5, mode='clip')
   533|         0|            0|            0|  0.00%|    >>> a
   534|         0|            0|            0|  0.00%|    array([ 0,  1,  2,  3, -5])
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|    """
   537|         0|            0|            0|  0.00%|    try:
   538|         0|            0|            0|  0.00%|        put = a.put
   539|         0|            0|            0|  0.00%|    except AttributeError as e:
   540|         0|            0|            0|  0.00%|        raise TypeError("argument 1 must be numpy.ndarray, "
   541|         0|            0|            0|  0.00%|                        "not {name}".format(name=type(a).__name__)) from e
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    return put(ind, v, mode=mode)
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|def _swapaxes_dispatcher(a, axis1, axis2):
   547|         0|            0|            0|  0.00%|    return (a,)
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|@array_function_dispatch(_swapaxes_dispatcher)
   551|         0|            0|            0|  0.00%|def swapaxes(a, axis1, axis2):
   552|         0|            0|            0|  0.00%|    """
   553|         0|            0|            0|  0.00%|    Interchange two axes of an array.
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|    Parameters
   556|         0|            0|            0|  0.00%|    ----------
   557|         0|            0|            0|  0.00%|    a : array_like
   558|         0|            0|            0|  0.00%|        Input array.
   559|         0|            0|            0|  0.00%|    axis1 : int
   560|         0|            0|            0|  0.00%|        First axis.
   561|         0|            0|            0|  0.00%|    axis2 : int
   562|         0|            0|            0|  0.00%|        Second axis.
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|    Returns
   565|         0|            0|            0|  0.00%|    -------
   566|         0|            0|            0|  0.00%|    a_swapped : ndarray
   567|         0|            0|            0|  0.00%|        For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is
   568|         0|            0|            0|  0.00%|        returned; otherwise a new array is created. For earlier NumPy
   569|         0|            0|            0|  0.00%|        versions a view of `a` is returned only if the order of the
   570|         0|            0|            0|  0.00%|        axes is changed, otherwise the input array is returned.
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    Examples
   573|         0|            0|            0|  0.00%|    --------
   574|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2,3]])
   575|         0|            0|            0|  0.00%|    >>> np.swapaxes(x,0,1)
   576|         0|            0|            0|  0.00%|    array([[1],
   577|         0|            0|            0|  0.00%|           [2],
   578|         0|            0|            0|  0.00%|           [3]])
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
   581|         0|            0|            0|  0.00%|    >>> x
   582|         0|            0|            0|  0.00%|    array([[[0, 1],
   583|         0|            0|            0|  0.00%|            [2, 3]],
   584|         0|            0|            0|  0.00%|           [[4, 5],
   585|         0|            0|            0|  0.00%|            [6, 7]]])
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    >>> np.swapaxes(x,0,2)
   588|         0|            0|            0|  0.00%|    array([[[0, 4],
   589|         0|            0|            0|  0.00%|            [2, 6]],
   590|         0|            0|            0|  0.00%|           [[1, 5],
   591|         0|            0|            0|  0.00%|            [3, 7]]])
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    """
   594|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'swapaxes', axis1, axis2)
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|def _transpose_dispatcher(a, axes=None):
   598|         0|            0|            0|  0.00%|    return (a,)
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|@array_function_dispatch(_transpose_dispatcher)
   602|         0|            0|            0|  0.00%|def transpose(a, axes=None):
   603|         0|            0|            0|  0.00%|    """
   604|         0|            0|            0|  0.00%|    Reverse or permute the axes of an array; returns the modified array.
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|    For an array a with two axes, transpose(a) gives the matrix transpose.
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|    Refer to `numpy.ndarray.transpose` for full documentation.
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|    Parameters
   611|         0|            0|            0|  0.00%|    ----------
   612|         0|            0|            0|  0.00%|    a : array_like
   613|         0|            0|            0|  0.00%|        Input array.
   614|         0|            0|            0|  0.00%|    axes : tuple or list of ints, optional
   615|         0|            0|            0|  0.00%|        If specified, it must be a tuple or list which contains a permutation of
   616|         0|            0|            0|  0.00%|        [0,1,..,N-1] where N is the number of axes of a.  The i'th axis of the
   617|         0|            0|            0|  0.00%|        returned array will correspond to the axis numbered ``axes[i]`` of the
   618|         0|            0|            0|  0.00%|        input.  If not specified, defaults to ``range(a.ndim)[::-1]``, which
   619|         0|            0|            0|  0.00%|        reverses the order of the axes.
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|    Returns
   622|         0|            0|            0|  0.00%|    -------
   623|         0|            0|            0|  0.00%|    p : ndarray
   624|         0|            0|            0|  0.00%|        `a` with its axes permuted.  A view is returned whenever
   625|         0|            0|            0|  0.00%|        possible.
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|    See Also
   628|         0|            0|            0|  0.00%|    --------
   629|         0|            0|            0|  0.00%|    ndarray.transpose : Equivalent method
   630|         0|            0|            0|  0.00%|    moveaxis
   631|         0|            0|            0|  0.00%|    argsort
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|    Notes
   634|         0|            0|            0|  0.00%|    -----
   635|         0|            0|            0|  0.00%|    Use `transpose(a, argsort(axes))` to invert the transposition of tensors
   636|         0|            0|            0|  0.00%|    when using the `axes` keyword argument.
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|    Transposing a 1-D array returns an unchanged view of the original array.
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|    Examples
   641|         0|            0|            0|  0.00%|    --------
   642|         0|            0|            0|  0.00%|    >>> x = np.arange(4).reshape((2,2))
   643|         0|            0|            0|  0.00%|    >>> x
   644|         0|            0|            0|  0.00%|    array([[0, 1],
   645|         0|            0|            0|  0.00%|           [2, 3]])
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    >>> np.transpose(x)
   648|         0|            0|            0|  0.00%|    array([[0, 2],
   649|         0|            0|            0|  0.00%|           [1, 3]])
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|    >>> x = np.ones((1, 2, 3))
   652|         0|            0|            0|  0.00%|    >>> np.transpose(x, (1, 0, 2)).shape
   653|         0|            0|            0|  0.00%|    (2, 1, 3)
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|    >>> x = np.ones((2, 3, 4, 5))
   656|         0|            0|            0|  0.00%|    >>> np.transpose(x).shape
   657|         0|            0|            0|  0.00%|    (5, 4, 3, 2)
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|    """
   660|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'transpose', axes)
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|def _partition_dispatcher(a, kth, axis=None, kind=None, order=None):
   664|         0|            0|            0|  0.00%|    return (a,)
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|@array_function_dispatch(_partition_dispatcher)
   668|         0|            0|            0|  0.00%|def partition(a, kth, axis=-1, kind='introselect', order=None):
   669|         0|            0|            0|  0.00%|    """
   670|         0|            0|            0|  0.00%|    Return a partitioned copy of an array.
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    Creates a copy of the array with its elements rearranged in such a
   673|         0|            0|            0|  0.00%|    way that the value of the element in k-th position is in the
   674|         0|            0|            0|  0.00%|    position it would be in a sorted array. All elements smaller than
   675|         0|            0|            0|  0.00%|    the k-th element are moved before this element and all equal or
   676|         0|            0|            0|  0.00%|    greater are moved behind it. The ordering of the elements in the two
   677|         0|            0|            0|  0.00%|    partitions is undefined.
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|    Parameters
   682|         0|            0|            0|  0.00%|    ----------
   683|         0|            0|            0|  0.00%|    a : array_like
   684|         0|            0|            0|  0.00%|        Array to be sorted.
   685|         0|            0|            0|  0.00%|    kth : int or sequence of ints
   686|         0|            0|            0|  0.00%|        Element index to partition by. The k-th value of the element
   687|         0|            0|            0|  0.00%|        will be in its final sorted position and all smaller elements
   688|         0|            0|            0|  0.00%|        will be moved before it and all equal or greater elements behind
   689|         0|            0|            0|  0.00%|        it. The order of all elements in the partitions is undefined. If
   690|         0|            0|            0|  0.00%|        provided with a sequence of k-th it will partition all elements
   691|         0|            0|            0|  0.00%|        indexed by k-th  of them into their sorted position at once.
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|        .. deprecated:: 1.22.0
   694|         0|            0|            0|  0.00%|            Passing booleans as index is deprecated.
   695|         0|            0|            0|  0.00%|    axis : int or None, optional
   696|         0|            0|            0|  0.00%|        Axis along which to sort. If None, the array is flattened before
   697|         0|            0|            0|  0.00%|        sorting. The default is -1, which sorts along the last axis.
   698|         0|            0|            0|  0.00%|    kind : {'introselect'}, optional
   699|         0|            0|            0|  0.00%|        Selection algorithm. Default is 'introselect'.
   700|         0|            0|            0|  0.00%|    order : str or list of str, optional
   701|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument
   702|         0|            0|            0|  0.00%|        specifies which fields to compare first, second, etc.  A single
   703|         0|            0|            0|  0.00%|        field can be specified as a string.  Not all fields need be
   704|         0|            0|            0|  0.00%|        specified, but unspecified fields will still be used, in the
   705|         0|            0|            0|  0.00%|        order in which they come up in the dtype, to break ties.
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    Returns
   708|         0|            0|            0|  0.00%|    -------
   709|         0|            0|            0|  0.00%|    partitioned_array : ndarray
   710|         0|            0|            0|  0.00%|        Array of the same type and shape as `a`.
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|    See Also
   713|         0|            0|            0|  0.00%|    --------
   714|         0|            0|            0|  0.00%|    ndarray.partition : Method to sort an array in-place.
   715|         0|            0|            0|  0.00%|    argpartition : Indirect partition.
   716|         0|            0|            0|  0.00%|    sort : Full sorting
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|    Notes
   719|         0|            0|            0|  0.00%|    -----
   720|         0|            0|            0|  0.00%|    The various selection algorithms are characterized by their average
   721|         0|            0|            0|  0.00%|    speed, worst case performance, work space size, and whether they are
   722|         0|            0|            0|  0.00%|    stable. A stable sort keeps items with the same key in the same
   723|         0|            0|            0|  0.00%|    relative order. The available algorithms have the following
   724|         0|            0|            0|  0.00%|    properties:
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|    ================= ======= ============= ============ =======
   727|         0|            0|            0|  0.00%|       kind            speed   worst case    work space  stable
   728|         0|            0|            0|  0.00%|    ================= ======= ============= ============ =======
   729|         0|            0|            0|  0.00%|    'introselect'        1        O(n)           0         no
   730|         0|            0|            0|  0.00%|    ================= ======= ============= ============ =======
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|    All the partition algorithms make temporary copies of the data when
   733|         0|            0|            0|  0.00%|    partitioning along any but the last axis.  Consequently,
   734|         0|            0|            0|  0.00%|    partitioning along the last axis is faster and uses less space than
   735|         0|            0|            0|  0.00%|    partitioning along any other axis.
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|    The sort order for complex numbers is lexicographic. If both the
   738|         0|            0|            0|  0.00%|    real and imaginary parts are non-nan then the order is determined by
   739|         0|            0|            0|  0.00%|    the real parts except when they are equal, in which case the order
   740|         0|            0|            0|  0.00%|    is determined by the imaginary parts.
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|    Examples
   743|         0|            0|            0|  0.00%|    --------
   744|         0|            0|            0|  0.00%|    >>> a = np.array([3, 4, 2, 1])
   745|         0|            0|            0|  0.00%|    >>> np.partition(a, 3)
   746|         0|            0|            0|  0.00%|    array([2, 1, 3, 4])
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|    >>> np.partition(a, (1, 3))
   749|         0|            0|            0|  0.00%|    array([1, 2, 3, 4])
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|    """
   752|         0|            0|            0|  0.00%|    if axis is None:
   753|         0|            0|            0|  0.00%|        # flatten returns (1, N) for np.matrix, so always use the last axis
   754|         0|            0|            0|  0.00%|        a = asanyarray(a).flatten()
   755|         0|            0|            0|  0.00%|        axis = -1
   756|         0|            0|            0|  0.00%|    else:
   757|         0|            0|            0|  0.00%|        a = asanyarray(a).copy(order="K")
   758|         0|            0|            0|  0.00%|    a.partition(kth, axis=axis, kind=kind, order=order)
   759|         0|            0|            0|  0.00%|    return a
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|def _argpartition_dispatcher(a, kth, axis=None, kind=None, order=None):
   763|         0|            0|            0|  0.00%|    return (a,)
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|@array_function_dispatch(_argpartition_dispatcher)
   767|         0|            0|            0|  0.00%|def argpartition(a, kth, axis=-1, kind='introselect', order=None):
   768|         0|            0|            0|  0.00%|    """
   769|         0|            0|            0|  0.00%|    Perform an indirect partition along the given axis using the
   770|         0|            0|            0|  0.00%|    algorithm specified by the `kind` keyword. It returns an array of
   771|         0|            0|            0|  0.00%|    indices of the same shape as `a` that index data along the given
   772|         0|            0|            0|  0.00%|    axis in partitioned order.
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|    Parameters
   777|         0|            0|            0|  0.00%|    ----------
   778|         0|            0|            0|  0.00%|    a : array_like
   779|         0|            0|            0|  0.00%|        Array to sort.
   780|         0|            0|            0|  0.00%|    kth : int or sequence of ints
   781|         0|            0|            0|  0.00%|        Element index to partition by. The k-th element will be in its
   782|         0|            0|            0|  0.00%|        final sorted position and all smaller elements will be moved
   783|         0|            0|            0|  0.00%|        before it and all larger elements behind it. The order all
   784|         0|            0|            0|  0.00%|        elements in the partitions is undefined. If provided with a
   785|         0|            0|            0|  0.00%|        sequence of k-th it will partition all of them into their sorted
   786|         0|            0|            0|  0.00%|        position at once.
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|        .. deprecated:: 1.22.0
   789|         0|            0|            0|  0.00%|            Passing booleans as index is deprecated.
   790|         0|            0|            0|  0.00%|    axis : int or None, optional
   791|         0|            0|            0|  0.00%|        Axis along which to sort. The default is -1 (the last axis). If
   792|         0|            0|            0|  0.00%|        None, the flattened array is used.
   793|         0|            0|            0|  0.00%|    kind : {'introselect'}, optional
   794|         0|            0|            0|  0.00%|        Selection algorithm. Default is 'introselect'
   795|         0|            0|            0|  0.00%|    order : str or list of str, optional
   796|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument
   797|         0|            0|            0|  0.00%|        specifies which fields to compare first, second, etc. A single
   798|         0|            0|            0|  0.00%|        field can be specified as a string, and not all fields need be
   799|         0|            0|            0|  0.00%|        specified, but unspecified fields will still be used, in the
   800|         0|            0|            0|  0.00%|        order in which they come up in the dtype, to break ties.
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|    Returns
   803|         0|            0|            0|  0.00%|    -------
   804|         0|            0|            0|  0.00%|    index_array : ndarray, int
   805|         0|            0|            0|  0.00%|        Array of indices that partition `a` along the specified axis.
   806|         0|            0|            0|  0.00%|        If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.
   807|         0|            0|            0|  0.00%|        More generally, ``np.take_along_axis(a, index_array, axis=a)`` always
   808|         0|            0|            0|  0.00%|        yields the partitioned `a`, irrespective of dimensionality.
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|    See Also
   811|         0|            0|            0|  0.00%|    --------
   812|         0|            0|            0|  0.00%|    partition : Describes partition algorithms used.
   813|         0|            0|            0|  0.00%|    ndarray.partition : Inplace partition.
   814|         0|            0|            0|  0.00%|    argsort : Full indirect sort.
   815|         0|            0|            0|  0.00%|    take_along_axis : Apply ``index_array`` from argpartition
   816|         0|            0|            0|  0.00%|                      to an array as if by calling partition.
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|    Notes
   819|         0|            0|            0|  0.00%|    -----
   820|         0|            0|            0|  0.00%|    See `partition` for notes on the different selection algorithms.
   821|         0|            0|            0|  0.00%|
   822|         0|            0|            0|  0.00%|    Examples
   823|         0|            0|            0|  0.00%|    --------
   824|         0|            0|            0|  0.00%|    One dimensional array:
   825|         0|            0|            0|  0.00%|
   826|         0|            0|            0|  0.00%|    >>> x = np.array([3, 4, 2, 1])
   827|         0|            0|            0|  0.00%|    >>> x[np.argpartition(x, 3)]
   828|         0|            0|            0|  0.00%|    array([2, 1, 3, 4])
   829|         0|            0|            0|  0.00%|    >>> x[np.argpartition(x, (1, 3))]
   830|         0|            0|            0|  0.00%|    array([1, 2, 3, 4])
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    >>> x = [3, 4, 2, 1]
   833|         0|            0|            0|  0.00%|    >>> np.array(x)[np.argpartition(x, 3)]
   834|         0|            0|            0|  0.00%|    array([2, 1, 3, 4])
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|    Multi-dimensional array:
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|    >>> x = np.array([[3, 4, 2], [1, 3, 1]])
   839|         0|            0|            0|  0.00%|    >>> index_array = np.argpartition(x, kth=1, axis=-1)
   840|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)
   841|         0|            0|            0|  0.00%|    array([[2, 3, 4],
   842|         0|            0|            0|  0.00%|           [1, 1, 3]])
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|    """
   845|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argpartition', kth, axis=axis, kind=kind, order=order)
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|def _sort_dispatcher(a, axis=None, kind=None, order=None):
   849|         0|            0|            0|  0.00%|    return (a,)
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|@array_function_dispatch(_sort_dispatcher)
   853|         0|            0|            0|  0.00%|def sort(a, axis=-1, kind=None, order=None):
   854|         0|            0|            0|  0.00%|    """
   855|         0|            0|            0|  0.00%|    Return a sorted copy of an array.
   856|         0|            0|            0|  0.00%|
   857|         0|            0|            0|  0.00%|    Parameters
   858|         0|            0|            0|  0.00%|    ----------
   859|         0|            0|            0|  0.00%|    a : array_like
   860|         0|            0|            0|  0.00%|        Array to be sorted.
   861|         0|            0|            0|  0.00%|    axis : int or None, optional
   862|         0|            0|            0|  0.00%|        Axis along which to sort. If None, the array is flattened before
   863|         0|            0|            0|  0.00%|        sorting. The default is -1, which sorts along the last axis.
   864|         0|            0|            0|  0.00%|    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
   865|         0|            0|            0|  0.00%|        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
   866|         0|            0|            0|  0.00%|        and 'mergesort' use timsort or radix sort under the covers and, in general,
   867|         0|            0|            0|  0.00%|        the actual implementation will vary with data type. The 'mergesort' option
   868|         0|            0|            0|  0.00%|        is retained for backwards compatibility.
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|        .. versionchanged:: 1.15.0.
   871|         0|            0|            0|  0.00%|           The 'stable' option was added.
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|    order : str or list of str, optional
   874|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument specifies
   875|         0|            0|            0|  0.00%|        which fields to compare first, second, etc.  A single field can
   876|         0|            0|            0|  0.00%|        be specified as a string, and not all fields need be specified,
   877|         0|            0|            0|  0.00%|        but unspecified fields will still be used, in the order in which
   878|         0|            0|            0|  0.00%|        they come up in the dtype, to break ties.
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|    Returns
   881|         0|            0|            0|  0.00%|    -------
   882|         0|            0|            0|  0.00%|    sorted_array : ndarray
   883|         0|            0|            0|  0.00%|        Array of the same type and shape as `a`.
   884|         0|            0|            0|  0.00%|
   885|         0|            0|            0|  0.00%|    See Also
   886|         0|            0|            0|  0.00%|    --------
   887|         0|            0|            0|  0.00%|    ndarray.sort : Method to sort an array in-place.
   888|         0|            0|            0|  0.00%|    argsort : Indirect sort.
   889|         0|            0|            0|  0.00%|    lexsort : Indirect stable sort on multiple keys.
   890|         0|            0|            0|  0.00%|    searchsorted : Find elements in a sorted array.
   891|         0|            0|            0|  0.00%|    partition : Partial sort.
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|    Notes
   894|         0|            0|            0|  0.00%|    -----
   895|         0|            0|            0|  0.00%|    The various sorting algorithms are characterized by their average speed,
   896|         0|            0|            0|  0.00%|    worst case performance, work space size, and whether they are stable. A
   897|         0|            0|            0|  0.00%|    stable sort keeps items with the same key in the same relative
   898|         0|            0|            0|  0.00%|    order. The four algorithms implemented in NumPy have the following
   899|         0|            0|            0|  0.00%|    properties:
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|    =========== ======= ============= ============ ========
   902|         0|            0|            0|  0.00%|       kind      speed   worst case    work space   stable
   903|         0|            0|            0|  0.00%|    =========== ======= ============= ============ ========
   904|         0|            0|            0|  0.00%|    'quicksort'    1     O(n^2)            0          no
   905|         0|            0|            0|  0.00%|    'heapsort'     3     O(n*log(n))       0          no
   906|         0|            0|            0|  0.00%|    'mergesort'    2     O(n*log(n))      ~n/2        yes
   907|         0|            0|            0|  0.00%|    'timsort'      2     O(n*log(n))      ~n/2        yes
   908|         0|            0|            0|  0.00%|    =========== ======= ============= ============ ========
   909|         0|            0|            0|  0.00%|
   910|         0|            0|            0|  0.00%|    .. note:: The datatype determines which of 'mergesort' or 'timsort'
   911|         0|            0|            0|  0.00%|       is actually used, even if 'mergesort' is specified. User selection
   912|         0|            0|            0|  0.00%|       at a finer scale is not currently available.
   913|         0|            0|            0|  0.00%|
   914|         0|            0|            0|  0.00%|    All the sort algorithms make temporary copies of the data when
   915|         0|            0|            0|  0.00%|    sorting along any but the last axis.  Consequently, sorting along
   916|         0|            0|            0|  0.00%|    the last axis is faster and uses less space than sorting along
   917|         0|            0|            0|  0.00%|    any other axis.
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|    The sort order for complex numbers is lexicographic. If both the real
   920|         0|            0|            0|  0.00%|    and imaginary parts are non-nan then the order is determined by the
   921|         0|            0|            0|  0.00%|    real parts except when they are equal, in which case the order is
   922|         0|            0|            0|  0.00%|    determined by the imaginary parts.
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|    Previous to numpy 1.4.0 sorting real and complex arrays containing nan
   925|         0|            0|            0|  0.00%|    values led to undefined behaviour. In numpy versions >= 1.4.0 nan
   926|         0|            0|            0|  0.00%|    values are sorted to the end. The extended sort order is:
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|      * Real: [R, nan]
   929|         0|            0|            0|  0.00%|      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
   930|         0|            0|            0|  0.00%|
   931|         0|            0|            0|  0.00%|    where R is a non-nan real value. Complex values with the same nan
   932|         0|            0|            0|  0.00%|    placements are sorted according to the non-nan part if it exists.
   933|         0|            0|            0|  0.00%|    Non-nan values are sorted as before.
   934|         0|            0|            0|  0.00%|
   935|         0|            0|            0|  0.00%|    .. versionadded:: 1.12.0
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|    quicksort has been changed to `introsort <https://en.wikipedia.org/wiki/Introsort>`_.
   938|         0|            0|            0|  0.00%|    When sorting does not make enough progress it switches to
   939|         0|            0|            0|  0.00%|    `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_.
   940|         0|            0|            0|  0.00%|    This implementation makes quicksort O(n*log(n)) in the worst case.
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|    'stable' automatically chooses the best stable sorting algorithm
   943|         0|            0|            0|  0.00%|    for the data type being sorted.
   944|         0|            0|            0|  0.00%|    It, along with 'mergesort' is currently mapped to
   945|         0|            0|            0|  0.00%|    `timsort <https://en.wikipedia.org/wiki/Timsort>`_
   946|         0|            0|            0|  0.00%|    or `radix sort <https://en.wikipedia.org/wiki/Radix_sort>`_
   947|         0|            0|            0|  0.00%|    depending on the data type.
   948|         0|            0|            0|  0.00%|    API forward compatibility currently limits the
   949|         0|            0|            0|  0.00%|    ability to select the implementation and it is hardwired for the different
   950|         0|            0|            0|  0.00%|    data types.
   951|         0|            0|            0|  0.00%|
   952|         0|            0|            0|  0.00%|    .. versionadded:: 1.17.0
   953|         0|            0|            0|  0.00%|
   954|         0|            0|            0|  0.00%|    Timsort is added for better performance on already or nearly
   955|         0|            0|            0|  0.00%|    sorted data. On random data timsort is almost identical to
   956|         0|            0|            0|  0.00%|    mergesort. It is now used for stable sort while quicksort is still the
   957|         0|            0|            0|  0.00%|    default sort if none is chosen. For timsort details, refer to
   958|         0|            0|            0|  0.00%|    `CPython listsort.txt <https://github.com/python/cpython/blob/3.7/Objects/listsort.txt>`_.
   959|         0|            0|            0|  0.00%|    'mergesort' and 'stable' are mapped to radix sort for integer data types. Radix sort is an
   960|         0|            0|            0|  0.00%|    O(n) sort instead of O(n log n).
   961|         0|            0|            0|  0.00%|
   962|         0|            0|            0|  0.00%|    .. versionchanged:: 1.18.0
   963|         0|            0|            0|  0.00%|
   964|         0|            0|            0|  0.00%|    NaT now sorts to the end of arrays for consistency with NaN.
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|    Examples
   967|         0|            0|            0|  0.00%|    --------
   968|         0|            0|            0|  0.00%|    >>> a = np.array([[1,4],[3,1]])
   969|         0|            0|            0|  0.00%|    >>> np.sort(a)                # sort along the last axis
   970|         0|            0|            0|  0.00%|    array([[1, 4],
   971|         0|            0|            0|  0.00%|           [1, 3]])
   972|         0|            0|            0|  0.00%|    >>> np.sort(a, axis=None)     # sort the flattened array
   973|         0|            0|            0|  0.00%|    array([1, 1, 3, 4])
   974|         0|            0|            0|  0.00%|    >>> np.sort(a, axis=0)        # sort along the first axis
   975|         0|            0|            0|  0.00%|    array([[1, 1],
   976|         0|            0|            0|  0.00%|           [3, 4]])
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|    Use the `order` keyword to specify a field to use when sorting a
   979|         0|            0|            0|  0.00%|    structured array:
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]
   982|         0|            0|            0|  0.00%|    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
   983|         0|            0|            0|  0.00%|    ...           ('Galahad', 1.7, 38)]
   984|         0|            0|            0|  0.00%|    >>> a = np.array(values, dtype=dtype)       # create a structured array
   985|         0|            0|            0|  0.00%|    >>> np.sort(a, order='height')                        # doctest: +SKIP
   986|         0|            0|            0|  0.00%|    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
   987|         0|            0|            0|  0.00%|           ('Lancelot', 1.8999999999999999, 38)],
   988|         0|            0|            0|  0.00%|          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
   989|         0|            0|            0|  0.00%|
   990|         0|            0|            0|  0.00%|    Sort by age, then height if ages are equal:
   991|         0|            0|            0|  0.00%|
   992|         0|            0|            0|  0.00%|    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP
   993|         0|            0|            0|  0.00%|    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
   994|         0|            0|            0|  0.00%|           ('Arthur', 1.8, 41)],
   995|         0|            0|            0|  0.00%|          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
   996|         0|            0|            0|  0.00%|
   997|         0|            0|            0|  0.00%|    """
   998|         0|            0|            0|  0.00%|    if axis is None:
   999|         0|            0|            0|  0.00%|        # flatten returns (1, N) for np.matrix, so always use the last axis
  1000|         0|            0|            0|  0.00%|        a = asanyarray(a).flatten()
  1001|         0|            0|            0|  0.00%|        axis = -1
  1002|         0|            0|            0|  0.00%|    else:
  1003|         0|            0|            0|  0.00%|        a = asanyarray(a).copy(order="K")
  1004|         0|            0|            0|  0.00%|    a.sort(axis=axis, kind=kind, order=order)
  1005|         0|            0|            0|  0.00%|    return a
  1006|         0|            0|            0|  0.00%|
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|def _argsort_dispatcher(a, axis=None, kind=None, order=None):
  1009|         0|            0|            0|  0.00%|    return (a,)
  1010|         0|            0|            0|  0.00%|
  1011|         0|            0|            0|  0.00%|
  1012|         0|            0|            0|  0.00%|@array_function_dispatch(_argsort_dispatcher)
  1013|         0|            0|            0|  0.00%|def argsort(a, axis=-1, kind=None, order=None):
  1014|         0|            0|            0|  0.00%|    """
  1015|         0|            0|            0|  0.00%|    Returns the indices that would sort an array.
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|    Perform an indirect sort along the given axis using the algorithm specified
  1018|         0|            0|            0|  0.00%|    by the `kind` keyword. It returns an array of indices of the same shape as
  1019|         0|            0|            0|  0.00%|    `a` that index data along the given axis in sorted order.
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|    Parameters
  1022|         0|            0|            0|  0.00%|    ----------
  1023|         0|            0|            0|  0.00%|    a : array_like
  1024|         0|            0|            0|  0.00%|        Array to sort.
  1025|         0|            0|            0|  0.00%|    axis : int or None, optional
  1026|         0|            0|            0|  0.00%|        Axis along which to sort.  The default is -1 (the last axis). If None,
  1027|         0|            0|            0|  0.00%|        the flattened array is used.
  1028|         0|            0|            0|  0.00%|    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
  1029|         0|            0|            0|  0.00%|        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
  1030|         0|            0|            0|  0.00%|        and 'mergesort' use timsort under the covers and, in general, the
  1031|         0|            0|            0|  0.00%|        actual implementation will vary with data type. The 'mergesort' option
  1032|         0|            0|            0|  0.00%|        is retained for backwards compatibility.
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|        .. versionchanged:: 1.15.0.
  1035|         0|            0|            0|  0.00%|           The 'stable' option was added.
  1036|         0|            0|            0|  0.00%|    order : str or list of str, optional
  1037|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument specifies
  1038|         0|            0|            0|  0.00%|        which fields to compare first, second, etc.  A single field can
  1039|         0|            0|            0|  0.00%|        be specified as a string, and not all fields need be specified,
  1040|         0|            0|            0|  0.00%|        but unspecified fields will still be used, in the order in which
  1041|         0|            0|            0|  0.00%|        they come up in the dtype, to break ties.
  1042|         0|            0|            0|  0.00%|
  1043|         0|            0|            0|  0.00%|    Returns
  1044|         0|            0|            0|  0.00%|    -------
  1045|         0|            0|            0|  0.00%|    index_array : ndarray, int
  1046|         0|            0|            0|  0.00%|        Array of indices that sort `a` along the specified `axis`.
  1047|         0|            0|            0|  0.00%|        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.
  1048|         0|            0|            0|  0.00%|        More generally, ``np.take_along_axis(a, index_array, axis=axis)``
  1049|         0|            0|            0|  0.00%|        always yields the sorted `a`, irrespective of dimensionality.
  1050|         0|            0|            0|  0.00%|
  1051|         0|            0|            0|  0.00%|    See Also
  1052|         0|            0|            0|  0.00%|    --------
  1053|         0|            0|            0|  0.00%|    sort : Describes sorting algorithms used.
  1054|         0|            0|            0|  0.00%|    lexsort : Indirect stable sort with multiple keys.
  1055|         0|            0|            0|  0.00%|    ndarray.sort : Inplace sort.
  1056|         0|            0|            0|  0.00%|    argpartition : Indirect partial sort.
  1057|         0|            0|            0|  0.00%|    take_along_axis : Apply ``index_array`` from argsort
  1058|         0|            0|            0|  0.00%|                      to an array as if by calling sort.
  1059|         0|            0|            0|  0.00%|
  1060|         0|            0|            0|  0.00%|    Notes
  1061|         0|            0|            0|  0.00%|    -----
  1062|         0|            0|            0|  0.00%|    See `sort` for notes on the different sorting algorithms.
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
  1065|         0|            0|            0|  0.00%|    nan values. The enhanced sort order is documented in `sort`.
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|    Examples
  1068|         0|            0|            0|  0.00%|    --------
  1069|         0|            0|            0|  0.00%|    One dimensional array:
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    >>> x = np.array([3, 1, 2])
  1072|         0|            0|            0|  0.00%|    >>> np.argsort(x)
  1073|         0|            0|            0|  0.00%|    array([1, 2, 0])
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|    Two-dimensional array:
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|    >>> x = np.array([[0, 3], [2, 2]])
  1078|         0|            0|            0|  0.00%|    >>> x
  1079|         0|            0|            0|  0.00%|    array([[0, 3],
  1080|         0|            0|            0|  0.00%|           [2, 2]])
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|    >>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)
  1083|         0|            0|            0|  0.00%|    >>> ind
  1084|         0|            0|            0|  0.00%|    array([[0, 1],
  1085|         0|            0|            0|  0.00%|           [1, 0]])
  1086|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)
  1087|         0|            0|            0|  0.00%|    array([[0, 2],
  1088|         0|            0|            0|  0.00%|           [2, 3]])
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|    >>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)
  1091|         0|            0|            0|  0.00%|    >>> ind
  1092|         0|            0|            0|  0.00%|    array([[0, 1],
  1093|         0|            0|            0|  0.00%|           [0, 1]])
  1094|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)
  1095|         0|            0|            0|  0.00%|    array([[0, 3],
  1096|         0|            0|            0|  0.00%|           [2, 2]])
  1097|         0|            0|            0|  0.00%|
  1098|         0|            0|            0|  0.00%|    Indices of the sorted elements of a N-dimensional array:
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|    >>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
  1101|         0|            0|            0|  0.00%|    >>> ind
  1102|         0|            0|            0|  0.00%|    (array([0, 1, 1, 0]), array([0, 0, 1, 1]))
  1103|         0|            0|            0|  0.00%|    >>> x[ind]  # same as np.sort(x, axis=None)
  1104|         0|            0|            0|  0.00%|    array([0, 2, 2, 3])
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|    Sorting with keys:
  1107|         0|            0|            0|  0.00%|
  1108|         0|            0|            0|  0.00%|    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])
  1109|         0|            0|            0|  0.00%|    >>> x
  1110|         0|            0|            0|  0.00%|    array([(1, 0), (0, 1)],
  1111|         0|            0|            0|  0.00%|          dtype=[('x', '<i4'), ('y', '<i4')])
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    >>> np.argsort(x, order=('x','y'))
  1114|         0|            0|            0|  0.00%|    array([1, 0])
  1115|         0|            0|            0|  0.00%|
  1116|         0|            0|            0|  0.00%|    >>> np.argsort(x, order=('y','x'))
  1117|         0|            0|            0|  0.00%|    array([0, 1])
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|    """
  1120|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argsort', axis=axis, kind=kind, order=order)
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|
  1123|         0|            0|            0|  0.00%|def _argmax_dispatcher(a, axis=None, out=None, *, keepdims=np._NoValue):
  1124|         0|            0|            0|  0.00%|    return (a, out)
  1125|         0|            0|            0|  0.00%|
  1126|         0|            0|            0|  0.00%|
  1127|         0|            0|            0|  0.00%|@array_function_dispatch(_argmax_dispatcher)
  1128|         0|            0|            0|  0.00%|def argmax(a, axis=None, out=None, *, keepdims=np._NoValue):
  1129|         0|            0|            0|  0.00%|    """
  1130|         0|            0|            0|  0.00%|    Returns the indices of the maximum values along an axis.
  1131|         0|            0|            0|  0.00%|
  1132|         0|            0|            0|  0.00%|    Parameters
  1133|         0|            0|            0|  0.00%|    ----------
  1134|         0|            0|            0|  0.00%|    a : array_like
  1135|         0|            0|            0|  0.00%|        Input array.
  1136|         0|            0|            0|  0.00%|    axis : int, optional
  1137|         0|            0|            0|  0.00%|        By default, the index is into the flattened array, otherwise
  1138|         0|            0|            0|  0.00%|        along the specified axis.
  1139|         0|            0|            0|  0.00%|    out : array, optional
  1140|         0|            0|            0|  0.00%|        If provided, the result will be inserted into this array. It should
  1141|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype.
  1142|         0|            0|            0|  0.00%|    keepdims : bool, optional
  1143|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  1144|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  1145|         0|            0|            0|  0.00%|        the result will broadcast correctly against the array.
  1146|         0|            0|            0|  0.00%|
  1147|         0|            0|            0|  0.00%|        .. versionadded:: 1.22.0
  1148|         0|            0|            0|  0.00%|
  1149|         0|            0|            0|  0.00%|    Returns
  1150|         0|            0|            0|  0.00%|    -------
  1151|         0|            0|            0|  0.00%|    index_array : ndarray of ints
  1152|         0|            0|            0|  0.00%|        Array of indices into the array. It has the same shape as `a.shape`
  1153|         0|            0|            0|  0.00%|        with the dimension along `axis` removed. If `keepdims` is set to True,
  1154|         0|            0|            0|  0.00%|        then the size of `axis` will be 1 with the resulting array having same
  1155|         0|            0|            0|  0.00%|        shape as `a.shape`.
  1156|         0|            0|            0|  0.00%|
  1157|         0|            0|            0|  0.00%|    See Also
  1158|         0|            0|            0|  0.00%|    --------
  1159|         0|            0|            0|  0.00%|    ndarray.argmax, argmin
  1160|         0|            0|            0|  0.00%|    amax : The maximum value along a given axis.
  1161|         0|            0|            0|  0.00%|    unravel_index : Convert a flat index into an index tuple.
  1162|         0|            0|            0|  0.00%|    take_along_axis : Apply ``np.expand_dims(index_array, axis)``
  1163|         0|            0|            0|  0.00%|                      from argmax to an array as if by calling max.
  1164|         0|            0|            0|  0.00%|
  1165|         0|            0|            0|  0.00%|    Notes
  1166|         0|            0|            0|  0.00%|    -----
  1167|         0|            0|            0|  0.00%|    In case of multiple occurrences of the maximum values, the indices
  1168|         0|            0|            0|  0.00%|    corresponding to the first occurrence are returned.
  1169|         0|            0|            0|  0.00%|
  1170|         0|            0|            0|  0.00%|    Examples
  1171|         0|            0|            0|  0.00%|    --------
  1172|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape(2,3) + 10
  1173|         0|            0|            0|  0.00%|    >>> a
  1174|         0|            0|            0|  0.00%|    array([[10, 11, 12],
  1175|         0|            0|            0|  0.00%|           [13, 14, 15]])
  1176|         0|            0|            0|  0.00%|    >>> np.argmax(a)
  1177|         0|            0|            0|  0.00%|    5
  1178|         0|            0|            0|  0.00%|    >>> np.argmax(a, axis=0)
  1179|         0|            0|            0|  0.00%|    array([1, 1, 1])
  1180|         0|            0|            0|  0.00%|    >>> np.argmax(a, axis=1)
  1181|         0|            0|            0|  0.00%|    array([2, 2])
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|    Indexes of the maximal elements of a N-dimensional array:
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|    >>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)
  1186|         0|            0|            0|  0.00%|    >>> ind
  1187|         0|            0|            0|  0.00%|    (1, 2)
  1188|         0|            0|            0|  0.00%|    >>> a[ind]
  1189|         0|            0|            0|  0.00%|    15
  1190|         0|            0|            0|  0.00%|
  1191|         0|            0|            0|  0.00%|    >>> b = np.arange(6)
  1192|         0|            0|            0|  0.00%|    >>> b[1] = 5
  1193|         0|            0|            0|  0.00%|    >>> b
  1194|         0|            0|            0|  0.00%|    array([0, 5, 2, 3, 4, 5])
  1195|         0|            0|            0|  0.00%|    >>> np.argmax(b)  # Only the first occurrence is returned.
  1196|         0|            0|            0|  0.00%|    1
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|    >>> x = np.array([[4,2,3], [1,0,3]])
  1199|         0|            0|            0|  0.00%|    >>> index_array = np.argmax(x, axis=-1)
  1200|         0|            0|            0|  0.00%|    >>> # Same as np.amax(x, axis=-1, keepdims=True)
  1201|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
  1202|         0|            0|            0|  0.00%|    array([[4],
  1203|         0|            0|            0|  0.00%|           [3]])
  1204|         0|            0|            0|  0.00%|    >>> # Same as np.amax(x, axis=-1)
  1205|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
  1206|         0|            0|            0|  0.00%|    array([4, 3])
  1207|         0|            0|            0|  0.00%|
  1208|         0|            0|            0|  0.00%|    Setting `keepdims` to `True`,
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|    >>> x = np.arange(24).reshape((2, 3, 4))
  1211|         0|            0|            0|  0.00%|    >>> res = np.argmax(x, axis=1, keepdims=True)
  1212|         0|            0|            0|  0.00%|    >>> res.shape
  1213|         0|            0|            0|  0.00%|    (2, 1, 4)
  1214|         0|            0|            0|  0.00%|    """
  1215|         0|            0|            0|  0.00%|    kwds = {'keepdims': keepdims} if keepdims is not np._NoValue else {}
  1216|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argmax', axis=axis, out=out, **kwds)
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|
  1219|         0|            0|            0|  0.00%|def _argmin_dispatcher(a, axis=None, out=None, *, keepdims=np._NoValue):
  1220|         0|            0|            0|  0.00%|    return (a, out)
  1221|         0|            0|            0|  0.00%|
  1222|         0|            0|            0|  0.00%|
  1223|         0|            0|            0|  0.00%|@array_function_dispatch(_argmin_dispatcher)
  1224|         0|            0|            0|  0.00%|def argmin(a, axis=None, out=None, *, keepdims=np._NoValue):
  1225|         0|            0|            0|  0.00%|    """
  1226|         0|            0|            0|  0.00%|    Returns the indices of the minimum values along an axis.
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|    Parameters
  1229|         0|            0|            0|  0.00%|    ----------
  1230|         0|            0|            0|  0.00%|    a : array_like
  1231|         0|            0|            0|  0.00%|        Input array.
  1232|         0|            0|            0|  0.00%|    axis : int, optional
  1233|         0|            0|            0|  0.00%|        By default, the index is into the flattened array, otherwise
  1234|         0|            0|            0|  0.00%|        along the specified axis.
  1235|         0|            0|            0|  0.00%|    out : array, optional
  1236|         0|            0|            0|  0.00%|        If provided, the result will be inserted into this array. It should
  1237|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype.
  1238|         0|            0|            0|  0.00%|    keepdims : bool, optional
  1239|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  1240|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  1241|         0|            0|            0|  0.00%|        the result will broadcast correctly against the array.
  1242|         0|            0|            0|  0.00%|
  1243|         0|            0|            0|  0.00%|        .. versionadded:: 1.22.0
  1244|         0|            0|            0|  0.00%|
  1245|         0|            0|            0|  0.00%|    Returns
  1246|         0|            0|            0|  0.00%|    -------
  1247|         0|            0|            0|  0.00%|    index_array : ndarray of ints
  1248|         0|            0|            0|  0.00%|        Array of indices into the array. It has the same shape as `a.shape`
  1249|         0|            0|            0|  0.00%|        with the dimension along `axis` removed. If `keepdims` is set to True,
  1250|         0|            0|            0|  0.00%|        then the size of `axis` will be 1 with the resulting array having same
  1251|         0|            0|            0|  0.00%|        shape as `a.shape`.
  1252|         0|            0|            0|  0.00%|
  1253|         0|            0|            0|  0.00%|    See Also
  1254|         0|            0|            0|  0.00%|    --------
  1255|         0|            0|            0|  0.00%|    ndarray.argmin, argmax
  1256|         0|            0|            0|  0.00%|    amin : The minimum value along a given axis.
  1257|         0|            0|            0|  0.00%|    unravel_index : Convert a flat index into an index tuple.
  1258|         0|            0|            0|  0.00%|    take_along_axis : Apply ``np.expand_dims(index_array, axis)``
  1259|         0|            0|            0|  0.00%|                      from argmin to an array as if by calling min.
  1260|         0|            0|            0|  0.00%|
  1261|         0|            0|            0|  0.00%|    Notes
  1262|         0|            0|            0|  0.00%|    -----
  1263|         0|            0|            0|  0.00%|    In case of multiple occurrences of the minimum values, the indices
  1264|         0|            0|            0|  0.00%|    corresponding to the first occurrence are returned.
  1265|         0|            0|            0|  0.00%|
  1266|         0|            0|            0|  0.00%|    Examples
  1267|         0|            0|            0|  0.00%|    --------
  1268|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape(2,3) + 10
  1269|         0|            0|            0|  0.00%|    >>> a
  1270|         0|            0|            0|  0.00%|    array([[10, 11, 12],
  1271|         0|            0|            0|  0.00%|           [13, 14, 15]])
  1272|         0|            0|            0|  0.00%|    >>> np.argmin(a)
  1273|         0|            0|            0|  0.00%|    0
  1274|         0|            0|            0|  0.00%|    >>> np.argmin(a, axis=0)
  1275|         0|            0|            0|  0.00%|    array([0, 0, 0])
  1276|         0|            0|            0|  0.00%|    >>> np.argmin(a, axis=1)
  1277|         0|            0|            0|  0.00%|    array([0, 0])
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|    Indices of the minimum elements of a N-dimensional array:
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|    >>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
  1282|         0|            0|            0|  0.00%|    >>> ind
  1283|         0|            0|            0|  0.00%|    (0, 0)
  1284|         0|            0|            0|  0.00%|    >>> a[ind]
  1285|         0|            0|            0|  0.00%|    10
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    >>> b = np.arange(6) + 10
  1288|         0|            0|            0|  0.00%|    >>> b[4] = 10
  1289|         0|            0|            0|  0.00%|    >>> b
  1290|         0|            0|            0|  0.00%|    array([10, 11, 12, 13, 10, 15])
  1291|         0|            0|            0|  0.00%|    >>> np.argmin(b)  # Only the first occurrence is returned.
  1292|         0|            0|            0|  0.00%|    0
  1293|         0|            0|            0|  0.00%|
  1294|         0|            0|            0|  0.00%|    >>> x = np.array([[4,2,3], [1,0,3]])
  1295|         0|            0|            0|  0.00%|    >>> index_array = np.argmin(x, axis=-1)
  1296|         0|            0|            0|  0.00%|    >>> # Same as np.amin(x, axis=-1, keepdims=True)
  1297|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
  1298|         0|            0|            0|  0.00%|    array([[2],
  1299|         0|            0|            0|  0.00%|           [0]])
  1300|         0|            0|            0|  0.00%|    >>> # Same as np.amax(x, axis=-1)
  1301|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
  1302|         0|            0|            0|  0.00%|    array([2, 0])
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|    Setting `keepdims` to `True`,
  1305|         0|            0|            0|  0.00%|
  1306|         0|            0|            0|  0.00%|    >>> x = np.arange(24).reshape((2, 3, 4))
  1307|         0|            0|            0|  0.00%|    >>> res = np.argmin(x, axis=1, keepdims=True)
  1308|         0|            0|            0|  0.00%|    >>> res.shape
  1309|         0|            0|            0|  0.00%|    (2, 1, 4)
  1310|         0|            0|            0|  0.00%|    """
  1311|         0|            0|            0|  0.00%|    kwds = {'keepdims': keepdims} if keepdims is not np._NoValue else {}
  1312|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argmin', axis=axis, out=out, **kwds)
  1313|         0|            0|            0|  0.00%|
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|def _searchsorted_dispatcher(a, v, side=None, sorter=None):
  1316|         0|            0|            0|  0.00%|    return (a, v, sorter)
  1317|         0|            0|            0|  0.00%|
  1318|         0|            0|            0|  0.00%|
  1319|         0|            0|            0|  0.00%|@array_function_dispatch(_searchsorted_dispatcher)
  1320|         0|            0|            0|  0.00%|def searchsorted(a, v, side='left', sorter=None):
  1321|         0|            0|            0|  0.00%|    """
  1322|         0|            0|            0|  0.00%|    Find indices where elements should be inserted to maintain order.
  1323|         0|            0|            0|  0.00%|
  1324|         0|            0|            0|  0.00%|    Find the indices into a sorted array `a` such that, if the
  1325|         0|            0|            0|  0.00%|    corresponding elements in `v` were inserted before the indices, the
  1326|         0|            0|            0|  0.00%|    order of `a` would be preserved.
  1327|         0|            0|            0|  0.00%|
  1328|         0|            0|            0|  0.00%|    Assuming that `a` is sorted:
  1329|         0|            0|            0|  0.00%|
  1330|         0|            0|            0|  0.00%|    ======  ============================
  1331|         0|            0|            0|  0.00%|    `side`  returned index `i` satisfies
  1332|         0|            0|            0|  0.00%|    ======  ============================
  1333|         0|            0|            0|  0.00%|    left    ``a[i-1] < v <= a[i]``
  1334|         0|            0|            0|  0.00%|    right   ``a[i-1] <= v < a[i]``
  1335|         0|            0|            0|  0.00%|    ======  ============================
  1336|         0|            0|            0|  0.00%|
  1337|         0|            0|            0|  0.00%|    Parameters
  1338|         0|            0|            0|  0.00%|    ----------
  1339|         0|            0|            0|  0.00%|    a : 1-D array_like
  1340|         0|            0|            0|  0.00%|        Input array. If `sorter` is None, then it must be sorted in
  1341|         0|            0|            0|  0.00%|        ascending order, otherwise `sorter` must be an array of indices
  1342|         0|            0|            0|  0.00%|        that sort it.
  1343|         0|            0|            0|  0.00%|    v : array_like
  1344|         0|            0|            0|  0.00%|        Values to insert into `a`.
  1345|         0|            0|            0|  0.00%|    side : {'left', 'right'}, optional
  1346|         0|            0|            0|  0.00%|        If 'left', the index of the first suitable location found is given.
  1347|         0|            0|            0|  0.00%|        If 'right', return the last such index.  If there is no suitable
  1348|         0|            0|            0|  0.00%|        index, return either 0 or N (where N is the length of `a`).
  1349|         0|            0|            0|  0.00%|    sorter : 1-D array_like, optional
  1350|         0|            0|            0|  0.00%|        Optional array of integer indices that sort array a into ascending
  1351|         0|            0|            0|  0.00%|        order. They are typically the result of argsort.
  1352|         0|            0|            0|  0.00%|
  1353|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  1354|         0|            0|            0|  0.00%|
  1355|         0|            0|            0|  0.00%|    Returns
  1356|         0|            0|            0|  0.00%|    -------
  1357|         0|            0|            0|  0.00%|    indices : int or array of ints
  1358|         0|            0|            0|  0.00%|        Array of insertion points with the same shape as `v`,
  1359|         0|            0|            0|  0.00%|        or an integer if `v` is a scalar.
  1360|         0|            0|            0|  0.00%|
  1361|         0|            0|            0|  0.00%|    See Also
  1362|         0|            0|            0|  0.00%|    --------
  1363|         0|            0|            0|  0.00%|    sort : Return a sorted copy of an array.
  1364|         0|            0|            0|  0.00%|    histogram : Produce histogram from 1-D data.
  1365|         0|            0|            0|  0.00%|
  1366|         0|            0|            0|  0.00%|    Notes
  1367|         0|            0|            0|  0.00%|    -----
  1368|         0|            0|            0|  0.00%|    Binary search is used to find the required insertion points.
  1369|         0|            0|            0|  0.00%|
  1370|         0|            0|            0|  0.00%|    As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing
  1371|         0|            0|            0|  0.00%|    `nan` values. The enhanced sort order is documented in `sort`.
  1372|         0|            0|            0|  0.00%|
  1373|         0|            0|            0|  0.00%|    This function uses the same algorithm as the builtin python `bisect.bisect_left`
  1374|         0|            0|            0|  0.00%|    (``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,
  1375|         0|            0|            0|  0.00%|    which is also vectorized in the `v` argument.
  1376|         0|            0|            0|  0.00%|
  1377|         0|            0|            0|  0.00%|    Examples
  1378|         0|            0|            0|  0.00%|    --------
  1379|         0|            0|            0|  0.00%|    >>> np.searchsorted([1,2,3,4,5], 3)
  1380|         0|            0|            0|  0.00%|    2
  1381|         0|            0|            0|  0.00%|    >>> np.searchsorted([1,2,3,4,5], 3, side='right')
  1382|         0|            0|            0|  0.00%|    3
  1383|         0|            0|            0|  0.00%|    >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
  1384|         0|            0|            0|  0.00%|    array([0, 5, 1, 2])
  1385|         0|            0|            0|  0.00%|
  1386|         0|            0|            0|  0.00%|    """
  1387|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'searchsorted', v, side=side, sorter=sorter)
  1388|         0|            0|            0|  0.00%|
  1389|         0|            0|            0|  0.00%|
  1390|         0|            0|            0|  0.00%|def _resize_dispatcher(a, new_shape):
  1391|         0|            0|            0|  0.00%|    return (a,)
  1392|         0|            0|            0|  0.00%|
  1393|         0|            0|            0|  0.00%|
  1394|         0|            0|            0|  0.00%|@array_function_dispatch(_resize_dispatcher)
  1395|         0|            0|            0|  0.00%|def resize(a, new_shape):
  1396|         0|            0|            0|  0.00%|    """
  1397|         0|            0|            0|  0.00%|    Return a new array with the specified shape.
  1398|         0|            0|            0|  0.00%|
  1399|         0|            0|            0|  0.00%|    If the new array is larger than the original array, then the new
  1400|         0|            0|            0|  0.00%|    array is filled with repeated copies of `a`.  Note that this behavior
  1401|         0|            0|            0|  0.00%|    is different from a.resize(new_shape) which fills with zeros instead
  1402|         0|            0|            0|  0.00%|    of repeated copies of `a`.
  1403|         0|            0|            0|  0.00%|
  1404|         0|            0|            0|  0.00%|    Parameters
  1405|         0|            0|            0|  0.00%|    ----------
  1406|         0|            0|            0|  0.00%|    a : array_like
  1407|         0|            0|            0|  0.00%|        Array to be resized.
  1408|         0|            0|            0|  0.00%|
  1409|         0|            0|            0|  0.00%|    new_shape : int or tuple of int
  1410|         0|            0|            0|  0.00%|        Shape of resized array.
  1411|         0|            0|            0|  0.00%|
  1412|         0|            0|            0|  0.00%|    Returns
  1413|         0|            0|            0|  0.00%|    -------
  1414|         0|            0|            0|  0.00%|    reshaped_array : ndarray
  1415|         0|            0|            0|  0.00%|        The new array is formed from the data in the old array, repeated
  1416|         0|            0|            0|  0.00%|        if necessary to fill out the required number of elements.  The
  1417|         0|            0|            0|  0.00%|        data are repeated iterating over the array in C-order.
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|    See Also
  1420|         0|            0|            0|  0.00%|    --------
  1421|         0|            0|            0|  0.00%|    numpy.reshape : Reshape an array without changing the total size.
  1422|         0|            0|            0|  0.00%|    numpy.pad : Enlarge and pad an array.
  1423|         0|            0|            0|  0.00%|    numpy.repeat : Repeat elements of an array.
  1424|         0|            0|            0|  0.00%|    ndarray.resize : resize an array in-place.
  1425|         0|            0|            0|  0.00%|
  1426|         0|            0|            0|  0.00%|    Notes
  1427|         0|            0|            0|  0.00%|    -----
  1428|         0|            0|            0|  0.00%|    When the total size of the array does not change `~numpy.reshape` should
  1429|         0|            0|            0|  0.00%|    be used.  In most other cases either indexing (to reduce the size)
  1430|         0|            0|            0|  0.00%|    or padding (to increase the size) may be a more appropriate solution.
  1431|         0|            0|            0|  0.00%|
  1432|         0|            0|            0|  0.00%|    Warning: This functionality does **not** consider axes separately,
  1433|         0|            0|            0|  0.00%|    i.e. it does not apply interpolation/extrapolation.
  1434|         0|            0|            0|  0.00%|    It fills the return array with the required number of elements, iterating
  1435|         0|            0|            0|  0.00%|    over `a` in C-order, disregarding axes (and cycling back from the start if
  1436|         0|            0|            0|  0.00%|    the new shape is larger).  This functionality is therefore not suitable to
  1437|         0|            0|            0|  0.00%|    resize images, or data where each axis represents a separate and distinct
  1438|         0|            0|            0|  0.00%|    entity.
  1439|         0|            0|            0|  0.00%|
  1440|         0|            0|            0|  0.00%|    Examples
  1441|         0|            0|            0|  0.00%|    --------
  1442|         0|            0|            0|  0.00%|    >>> a=np.array([[0,1],[2,3]])
  1443|         0|            0|            0|  0.00%|    >>> np.resize(a,(2,3))
  1444|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1445|         0|            0|            0|  0.00%|           [3, 0, 1]])
  1446|         0|            0|            0|  0.00%|    >>> np.resize(a,(1,4))
  1447|         0|            0|            0|  0.00%|    array([[0, 1, 2, 3]])
  1448|         0|            0|            0|  0.00%|    >>> np.resize(a,(2,4))
  1449|         0|            0|            0|  0.00%|    array([[0, 1, 2, 3],
  1450|         0|            0|            0|  0.00%|           [0, 1, 2, 3]])
  1451|         0|            0|            0|  0.00%|
  1452|         0|            0|            0|  0.00%|    """
  1453|         0|            0|            0|  0.00%|    if isinstance(new_shape, (int, nt.integer)):
  1454|         0|            0|            0|  0.00%|        new_shape = (new_shape,)
  1455|         0|            0|            0|  0.00%|
  1456|         0|            0|            0|  0.00%|    a = ravel(a)
  1457|         0|            0|            0|  0.00%|
  1458|         0|            0|            0|  0.00%|    new_size = 1
  1459|         0|            0|            0|  0.00%|    for dim_length in new_shape:
  1460|         0|            0|            0|  0.00%|        new_size *= dim_length
  1461|         0|            0|            0|  0.00%|        if dim_length < 0:
  1462|         0|            0|            0|  0.00%|            raise ValueError('all elements of `new_shape` must be non-negative')
  1463|         0|            0|            0|  0.00%|
  1464|         0|            0|            0|  0.00%|    if a.size == 0 or new_size == 0:
  1465|         0|            0|            0|  0.00%|        # First case must zero fill. The second would have repeats == 0.
  1466|         0|            0|            0|  0.00%|        return np.zeros_like(a, shape=new_shape)
  1467|         0|            0|            0|  0.00%|
  1468|         0|            0|            0|  0.00%|    repeats = -(-new_size // a.size)  # ceil division
  1469|         0|            0|            0|  0.00%|    a = concatenate((a,) * repeats)[:new_size]
  1470|         0|            0|            0|  0.00%|
  1471|         0|            0|            0|  0.00%|    return reshape(a, new_shape)
  1472|         0|            0|            0|  0.00%|
  1473|         0|            0|            0|  0.00%|
  1474|         0|            0|            0|  0.00%|def _squeeze_dispatcher(a, axis=None):
  1475|         0|            0|            0|  0.00%|    return (a,)
  1476|         0|            0|            0|  0.00%|
  1477|         0|            0|            0|  0.00%|
  1478|         0|            0|            0|  0.00%|@array_function_dispatch(_squeeze_dispatcher)
  1479|         0|            0|            0|  0.00%|def squeeze(a, axis=None):
  1480|         0|            0|            0|  0.00%|    """
  1481|         0|            0|            0|  0.00%|    Remove axes of length one from `a`.
  1482|         0|            0|            0|  0.00%|
  1483|         0|            0|            0|  0.00%|    Parameters
  1484|         0|            0|            0|  0.00%|    ----------
  1485|         0|            0|            0|  0.00%|    a : array_like
  1486|         0|            0|            0|  0.00%|        Input data.
  1487|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  1488|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  1489|         0|            0|            0|  0.00%|
  1490|         0|            0|            0|  0.00%|        Selects a subset of the entries of length one in the
  1491|         0|            0|            0|  0.00%|        shape. If an axis is selected with shape entry greater than
  1492|         0|            0|            0|  0.00%|        one, an error is raised.
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|    Returns
  1495|         0|            0|            0|  0.00%|    -------
  1496|         0|            0|            0|  0.00%|    squeezed : ndarray
  1497|         0|            0|            0|  0.00%|        The input array, but with all or a subset of the
  1498|         0|            0|            0|  0.00%|        dimensions of length 1 removed. This is always `a` itself
  1499|         0|            0|            0|  0.00%|        or a view into `a`. Note that if all axes are squeezed,
  1500|         0|            0|            0|  0.00%|        the result is a 0d array and not a scalar.
  1501|         0|            0|            0|  0.00%|
  1502|         0|            0|            0|  0.00%|    Raises
  1503|         0|            0|            0|  0.00%|    ------
  1504|         0|            0|            0|  0.00%|    ValueError
  1505|         0|            0|            0|  0.00%|        If `axis` is not None, and an axis being squeezed is not of length 1
  1506|         0|            0|            0|  0.00%|
  1507|         0|            0|            0|  0.00%|    See Also
  1508|         0|            0|            0|  0.00%|    --------
  1509|         0|            0|            0|  0.00%|    expand_dims : The inverse operation, adding entries of length one
  1510|         0|            0|            0|  0.00%|    reshape : Insert, remove, and combine dimensions, and resize existing ones
  1511|         0|            0|            0|  0.00%|
  1512|         0|            0|            0|  0.00%|    Examples
  1513|         0|            0|            0|  0.00%|    --------
  1514|         0|            0|            0|  0.00%|    >>> x = np.array([[[0], [1], [2]]])
  1515|         0|            0|            0|  0.00%|    >>> x.shape
  1516|         0|            0|            0|  0.00%|    (1, 3, 1)
  1517|         0|            0|            0|  0.00%|    >>> np.squeeze(x).shape
  1518|         0|            0|            0|  0.00%|    (3,)
  1519|         0|            0|            0|  0.00%|    >>> np.squeeze(x, axis=0).shape
  1520|         0|            0|            0|  0.00%|    (3, 1)
  1521|         0|            0|            0|  0.00%|    >>> np.squeeze(x, axis=1).shape
  1522|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1523|         0|            0|            0|  0.00%|    ...
  1524|         0|            0|            0|  0.00%|    ValueError: cannot select an axis to squeeze out which has size not equal to one
  1525|         0|            0|            0|  0.00%|    >>> np.squeeze(x, axis=2).shape
  1526|         0|            0|            0|  0.00%|    (1, 3)
  1527|         0|            0|            0|  0.00%|    >>> x = np.array([[1234]])
  1528|         0|            0|            0|  0.00%|    >>> x.shape
  1529|         0|            0|            0|  0.00%|    (1, 1)
  1530|         0|            0|            0|  0.00%|    >>> np.squeeze(x)
  1531|         0|            0|            0|  0.00%|    array(1234)  # 0d array
  1532|         0|            0|            0|  0.00%|    >>> np.squeeze(x).shape
  1533|         0|            0|            0|  0.00%|    ()
  1534|         0|            0|            0|  0.00%|    >>> np.squeeze(x)[()]
  1535|         0|            0|            0|  0.00%|    1234
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|    """
  1538|         0|            0|            0|  0.00%|    try:
  1539|         0|            0|            0|  0.00%|        squeeze = a.squeeze
  1540|         0|            0|            0|  0.00%|    except AttributeError:
  1541|         0|            0|            0|  0.00%|        return _wrapit(a, 'squeeze', axis=axis)
  1542|         0|            0|            0|  0.00%|    if axis is None:
  1543|         0|            0|            0|  0.00%|        return squeeze()
  1544|         0|            0|            0|  0.00%|    else:
  1545|         0|            0|            0|  0.00%|        return squeeze(axis=axis)
  1546|         0|            0|            0|  0.00%|
  1547|         0|            0|            0|  0.00%|
  1548|         0|            0|            0|  0.00%|def _diagonal_dispatcher(a, offset=None, axis1=None, axis2=None):
  1549|         0|            0|            0|  0.00%|    return (a,)
  1550|         0|            0|            0|  0.00%|
  1551|         0|            0|            0|  0.00%|
  1552|         0|            0|            0|  0.00%|@array_function_dispatch(_diagonal_dispatcher)
  1553|         0|            0|            0|  0.00%|def diagonal(a, offset=0, axis1=0, axis2=1):
  1554|         0|            0|            0|  0.00%|    """
  1555|         0|            0|            0|  0.00%|    Return specified diagonals.
  1556|         0|            0|            0|  0.00%|
  1557|         0|            0|            0|  0.00%|    If `a` is 2-D, returns the diagonal of `a` with the given offset,
  1558|         0|            0|            0|  0.00%|    i.e., the collection of elements of the form ``a[i, i+offset]``.  If
  1559|         0|            0|            0|  0.00%|    `a` has more than two dimensions, then the axes specified by `axis1`
  1560|         0|            0|            0|  0.00%|    and `axis2` are used to determine the 2-D sub-array whose diagonal is
  1561|         0|            0|            0|  0.00%|    returned.  The shape of the resulting array can be determined by
  1562|         0|            0|            0|  0.00%|    removing `axis1` and `axis2` and appending an index to the right equal
  1563|         0|            0|            0|  0.00%|    to the size of the resulting diagonals.
  1564|         0|            0|            0|  0.00%|
  1565|         0|            0|            0|  0.00%|    In versions of NumPy prior to 1.7, this function always returned a new,
  1566|         0|            0|            0|  0.00%|    independent array containing a copy of the values in the diagonal.
  1567|         0|            0|            0|  0.00%|
  1568|         0|            0|            0|  0.00%|    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
  1569|         0|            0|            0|  0.00%|    but depending on this fact is deprecated. Writing to the resulting
  1570|         0|            0|            0|  0.00%|    array continues to work as it used to, but a FutureWarning is issued.
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|    Starting in NumPy 1.9 it returns a read-only view on the original array.
  1573|         0|            0|            0|  0.00%|    Attempting to write to the resulting array will produce an error.
  1574|         0|            0|            0|  0.00%|
  1575|         0|            0|            0|  0.00%|    In some future release, it will return a read/write view and writing to
  1576|         0|            0|            0|  0.00%|    the returned array will alter your original array.  The returned array
  1577|         0|            0|            0|  0.00%|    will have the same type as the input array.
  1578|         0|            0|            0|  0.00%|
  1579|         0|            0|            0|  0.00%|    If you don't write to the array returned by this function, then you can
  1580|         0|            0|            0|  0.00%|    just ignore all of the above.
  1581|         0|            0|            0|  0.00%|
  1582|         0|            0|            0|  0.00%|    If you depend on the current behavior, then we suggest copying the
  1583|         0|            0|            0|  0.00%|    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead
  1584|         0|            0|            0|  0.00%|    of just ``np.diagonal(a)``. This will work with both past and future
  1585|         0|            0|            0|  0.00%|    versions of NumPy.
  1586|         0|            0|            0|  0.00%|
  1587|         0|            0|            0|  0.00%|    Parameters
  1588|         0|            0|            0|  0.00%|    ----------
  1589|         0|            0|            0|  0.00%|    a : array_like
  1590|         0|            0|            0|  0.00%|        Array from which the diagonals are taken.
  1591|         0|            0|            0|  0.00%|    offset : int, optional
  1592|         0|            0|            0|  0.00%|        Offset of the diagonal from the main diagonal.  Can be positive or
  1593|         0|            0|            0|  0.00%|        negative.  Defaults to main diagonal (0).
  1594|         0|            0|            0|  0.00%|    axis1 : int, optional
  1595|         0|            0|            0|  0.00%|        Axis to be used as the first axis of the 2-D sub-arrays from which
  1596|         0|            0|            0|  0.00%|        the diagonals should be taken.  Defaults to first axis (0).
  1597|         0|            0|            0|  0.00%|    axis2 : int, optional
  1598|         0|            0|            0|  0.00%|        Axis to be used as the second axis of the 2-D sub-arrays from
  1599|         0|            0|            0|  0.00%|        which the diagonals should be taken. Defaults to second axis (1).
  1600|         0|            0|            0|  0.00%|
  1601|         0|            0|            0|  0.00%|    Returns
  1602|         0|            0|            0|  0.00%|    -------
  1603|         0|            0|            0|  0.00%|    array_of_diagonals : ndarray
  1604|         0|            0|            0|  0.00%|        If `a` is 2-D, then a 1-D array containing the diagonal and of the
  1605|         0|            0|            0|  0.00%|        same type as `a` is returned unless `a` is a `matrix`, in which case
  1606|         0|            0|            0|  0.00%|        a 1-D array rather than a (2-D) `matrix` is returned in order to
  1607|         0|            0|            0|  0.00%|        maintain backward compatibility.
  1608|         0|            0|            0|  0.00%|
  1609|         0|            0|            0|  0.00%|        If ``a.ndim > 2``, then the dimensions specified by `axis1` and `axis2`
  1610|         0|            0|            0|  0.00%|        are removed, and a new axis inserted at the end corresponding to the
  1611|         0|            0|            0|  0.00%|        diagonal.
  1612|         0|            0|            0|  0.00%|
  1613|         0|            0|            0|  0.00%|    Raises
  1614|         0|            0|            0|  0.00%|    ------
  1615|         0|            0|            0|  0.00%|    ValueError
  1616|         0|            0|            0|  0.00%|        If the dimension of `a` is less than 2.
  1617|         0|            0|            0|  0.00%|
  1618|         0|            0|            0|  0.00%|    See Also
  1619|         0|            0|            0|  0.00%|    --------
  1620|         0|            0|            0|  0.00%|    diag : MATLAB work-a-like for 1-D and 2-D arrays.
  1621|         0|            0|            0|  0.00%|    diagflat : Create diagonal arrays.
  1622|         0|            0|            0|  0.00%|    trace : Sum along diagonals.
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|    Examples
  1625|         0|            0|            0|  0.00%|    --------
  1626|         0|            0|            0|  0.00%|    >>> a = np.arange(4).reshape(2,2)
  1627|         0|            0|            0|  0.00%|    >>> a
  1628|         0|            0|            0|  0.00%|    array([[0, 1],
  1629|         0|            0|            0|  0.00%|           [2, 3]])
  1630|         0|            0|            0|  0.00%|    >>> a.diagonal()
  1631|         0|            0|            0|  0.00%|    array([0, 3])
  1632|         0|            0|            0|  0.00%|    >>> a.diagonal(1)
  1633|         0|            0|            0|  0.00%|    array([1])
  1634|         0|            0|            0|  0.00%|
  1635|         0|            0|            0|  0.00%|    A 3-D example:
  1636|         0|            0|            0|  0.00%|
  1637|         0|            0|            0|  0.00%|    >>> a = np.arange(8).reshape(2,2,2); a
  1638|         0|            0|            0|  0.00%|    array([[[0, 1],
  1639|         0|            0|            0|  0.00%|            [2, 3]],
  1640|         0|            0|            0|  0.00%|           [[4, 5],
  1641|         0|            0|            0|  0.00%|            [6, 7]]])
  1642|         0|            0|            0|  0.00%|    >>> a.diagonal(0,  # Main diagonals of two arrays created by skipping
  1643|         0|            0|            0|  0.00%|    ...            0,  # across the outer(left)-most axis last and
  1644|         0|            0|            0|  0.00%|    ...            1)  # the "middle" (row) axis first.
  1645|         0|            0|            0|  0.00%|    array([[0, 6],
  1646|         0|            0|            0|  0.00%|           [1, 7]])
  1647|         0|            0|            0|  0.00%|
  1648|         0|            0|            0|  0.00%|    The sub-arrays whose main diagonals we just obtained; note that each
  1649|         0|            0|            0|  0.00%|    corresponds to fixing the right-most (column) axis, and that the
  1650|         0|            0|            0|  0.00%|    diagonals are "packed" in rows.
  1651|         0|            0|            0|  0.00%|
  1652|         0|            0|            0|  0.00%|    >>> a[:,:,0]  # main diagonal is [0 6]
  1653|         0|            0|            0|  0.00%|    array([[0, 2],
  1654|         0|            0|            0|  0.00%|           [4, 6]])
  1655|         0|            0|            0|  0.00%|    >>> a[:,:,1]  # main diagonal is [1 7]
  1656|         0|            0|            0|  0.00%|    array([[1, 3],
  1657|         0|            0|            0|  0.00%|           [5, 7]])
  1658|         0|            0|            0|  0.00%|
  1659|         0|            0|            0|  0.00%|    The anti-diagonal can be obtained by reversing the order of elements
  1660|         0|            0|            0|  0.00%|    using either `numpy.flipud` or `numpy.fliplr`.
  1661|         0|            0|            0|  0.00%|
  1662|         0|            0|            0|  0.00%|    >>> a = np.arange(9).reshape(3, 3)
  1663|         0|            0|            0|  0.00%|    >>> a
  1664|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1665|         0|            0|            0|  0.00%|           [3, 4, 5],
  1666|         0|            0|            0|  0.00%|           [6, 7, 8]])
  1667|         0|            0|            0|  0.00%|    >>> np.fliplr(a).diagonal()  # Horizontal flip
  1668|         0|            0|            0|  0.00%|    array([2, 4, 6])
  1669|         0|            0|            0|  0.00%|    >>> np.flipud(a).diagonal()  # Vertical flip
  1670|         0|            0|            0|  0.00%|    array([6, 4, 2])
  1671|         0|            0|            0|  0.00%|
  1672|         0|            0|            0|  0.00%|    Note that the order in which the diagonal is retrieved varies depending
  1673|         0|            0|            0|  0.00%|    on the flip function.
  1674|         0|            0|            0|  0.00%|    """
  1675|         0|            0|            0|  0.00%|    if isinstance(a, np.matrix):
  1676|         0|            0|            0|  0.00%|        # Make diagonal of matrix 1-D to preserve backward compatibility.
  1677|         0|            0|            0|  0.00%|        return asarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)
  1678|         0|            0|            0|  0.00%|    else:
  1679|         0|            0|            0|  0.00%|        return asanyarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)
  1680|         0|            0|            0|  0.00%|
  1681|         0|            0|            0|  0.00%|
  1682|         0|            0|            0|  0.00%|def _trace_dispatcher(
  1683|         0|            0|            0|  0.00%|        a, offset=None, axis1=None, axis2=None, dtype=None, out=None):
  1684|         0|            0|            0|  0.00%|    return (a, out)
  1685|         0|            0|            0|  0.00%|
  1686|         0|            0|            0|  0.00%|
  1687|         0|            0|            0|  0.00%|@array_function_dispatch(_trace_dispatcher)
  1688|         0|            0|            0|  0.00%|def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):
  1689|         0|            0|            0|  0.00%|    """
  1690|         0|            0|            0|  0.00%|    Return the sum along diagonals of the array.
  1691|         0|            0|            0|  0.00%|
  1692|         0|            0|            0|  0.00%|    If `a` is 2-D, the sum along its diagonal with the given offset
  1693|         0|            0|            0|  0.00%|    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.
  1694|         0|            0|            0|  0.00%|
  1695|         0|            0|            0|  0.00%|    If `a` has more than two dimensions, then the axes specified by axis1 and
  1696|         0|            0|            0|  0.00%|    axis2 are used to determine the 2-D sub-arrays whose traces are returned.
  1697|         0|            0|            0|  0.00%|    The shape of the resulting array is the same as that of `a` with `axis1`
  1698|         0|            0|            0|  0.00%|    and `axis2` removed.
  1699|         0|            0|            0|  0.00%|
  1700|         0|            0|            0|  0.00%|    Parameters
  1701|         0|            0|            0|  0.00%|    ----------
  1702|         0|            0|            0|  0.00%|    a : array_like
  1703|         0|            0|            0|  0.00%|        Input array, from which the diagonals are taken.
  1704|         0|            0|            0|  0.00%|    offset : int, optional
  1705|         0|            0|            0|  0.00%|        Offset of the diagonal from the main diagonal. Can be both positive
  1706|         0|            0|            0|  0.00%|        and negative. Defaults to 0.
  1707|         0|            0|            0|  0.00%|    axis1, axis2 : int, optional
  1708|         0|            0|            0|  0.00%|        Axes to be used as the first and second axis of the 2-D sub-arrays
  1709|         0|            0|            0|  0.00%|        from which the diagonals should be taken. Defaults are the first two
  1710|         0|            0|            0|  0.00%|        axes of `a`.
  1711|         0|            0|            0|  0.00%|    dtype : dtype, optional
  1712|         0|            0|            0|  0.00%|        Determines the data-type of the returned array and of the accumulator
  1713|         0|            0|            0|  0.00%|        where the elements are summed. If dtype has the value None and `a` is
  1714|         0|            0|            0|  0.00%|        of integer type of precision less than the default integer
  1715|         0|            0|            0|  0.00%|        precision, then the default integer precision is used. Otherwise,
  1716|         0|            0|            0|  0.00%|        the precision is the same as that of `a`.
  1717|         0|            0|            0|  0.00%|    out : ndarray, optional
  1718|         0|            0|            0|  0.00%|        Array into which the output is placed. Its type is preserved and
  1719|         0|            0|            0|  0.00%|        it must be of the right shape to hold the output.
  1720|         0|            0|            0|  0.00%|
  1721|         0|            0|            0|  0.00%|    Returns
  1722|         0|            0|            0|  0.00%|    -------
  1723|         0|            0|            0|  0.00%|    sum_along_diagonals : ndarray
  1724|         0|            0|            0|  0.00%|        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has
  1725|         0|            0|            0|  0.00%|        larger dimensions, then an array of sums along diagonals is returned.
  1726|         0|            0|            0|  0.00%|
  1727|         0|            0|            0|  0.00%|    See Also
  1728|         0|            0|            0|  0.00%|    --------
  1729|         0|            0|            0|  0.00%|    diag, diagonal, diagflat
  1730|         0|            0|            0|  0.00%|
  1731|         0|            0|            0|  0.00%|    Examples
  1732|         0|            0|            0|  0.00%|    --------
  1733|         0|            0|            0|  0.00%|    >>> np.trace(np.eye(3))
  1734|         0|            0|            0|  0.00%|    3.0
  1735|         0|            0|            0|  0.00%|    >>> a = np.arange(8).reshape((2,2,2))
  1736|         0|            0|            0|  0.00%|    >>> np.trace(a)
  1737|         0|            0|            0|  0.00%|    array([6, 8])
  1738|         0|            0|            0|  0.00%|
  1739|         0|            0|            0|  0.00%|    >>> a = np.arange(24).reshape((2,2,2,3))
  1740|         0|            0|            0|  0.00%|    >>> np.trace(a).shape
  1741|         0|            0|            0|  0.00%|    (2, 3)
  1742|         0|            0|            0|  0.00%|
  1743|         0|            0|            0|  0.00%|    """
  1744|         0|            0|            0|  0.00%|    if isinstance(a, np.matrix):
  1745|         0|            0|            0|  0.00%|        # Get trace of matrix via an array to preserve backward compatibility.
  1746|         0|            0|            0|  0.00%|        return asarray(a).trace(offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out)
  1747|         0|            0|            0|  0.00%|    else:
  1748|         0|            0|            0|  0.00%|        return asanyarray(a).trace(offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out)
  1749|         0|            0|            0|  0.00%|
  1750|         0|            0|            0|  0.00%|
  1751|        24|            0|            0|  0.00%|def _ravel_dispatcher(a, order=None):
  1752|        24|            0|            0|  0.00%|    return (a,)
  1753|         0|            0|            0|  0.00%|
  1754|         0|            0|            0|  0.00%|
  1755|        24|            0|            0|  0.00%|@array_function_dispatch(_ravel_dispatcher)
  1756|         0|            0|            0|  0.00%|def ravel(a, order='C'):
  1757|         0|            0|            0|  0.00%|    """Return a contiguous flattened array.
  1758|         0|            0|            0|  0.00%|
  1759|         0|            0|            0|  0.00%|    A 1-D array, containing the elements of the input, is returned.  A copy is
  1760|         0|            0|            0|  0.00%|    made only if needed.
  1761|         0|            0|            0|  0.00%|
  1762|         0|            0|            0|  0.00%|    As of NumPy 1.10, the returned array will have the same type as the input
  1763|         0|            0|            0|  0.00%|    array. (for example, a masked array will be returned for a masked array
  1764|         0|            0|            0|  0.00%|    input)
  1765|         0|            0|            0|  0.00%|
  1766|         0|            0|            0|  0.00%|    Parameters
  1767|         0|            0|            0|  0.00%|    ----------
  1768|         0|            0|            0|  0.00%|    a : array_like
  1769|         0|            0|            0|  0.00%|        Input array.  The elements in `a` are read in the order specified by
  1770|         0|            0|            0|  0.00%|        `order`, and packed as a 1-D array.
  1771|         0|            0|            0|  0.00%|    order : {'C','F', 'A', 'K'}, optional
  1772|         0|            0|            0|  0.00%|
  1773|         0|            0|            0|  0.00%|        The elements of `a` are read using this index order. 'C' means
  1774|         0|            0|            0|  0.00%|        to index the elements in row-major, C-style order,
  1775|         0|            0|            0|  0.00%|        with the last axis index changing fastest, back to the first
  1776|         0|            0|            0|  0.00%|        axis index changing slowest.  'F' means to index the elements
  1777|         0|            0|            0|  0.00%|        in column-major, Fortran-style order, with the
  1778|         0|            0|            0|  0.00%|        first index changing fastest, and the last index changing
  1779|         0|            0|            0|  0.00%|        slowest. Note that the 'C' and 'F' options take no account of
  1780|         0|            0|            0|  0.00%|        the memory layout of the underlying array, and only refer to
  1781|         0|            0|            0|  0.00%|        the order of axis indexing.  'A' means to read the elements in
  1782|         0|            0|            0|  0.00%|        Fortran-like index order if `a` is Fortran *contiguous* in
  1783|         0|            0|            0|  0.00%|        memory, C-like order otherwise.  'K' means to read the
  1784|         0|            0|            0|  0.00%|        elements in the order they occur in memory, except for
  1785|         0|            0|            0|  0.00%|        reversing the data when strides are negative.  By default, 'C'
  1786|         0|            0|            0|  0.00%|        index order is used.
  1787|         0|            0|            0|  0.00%|
  1788|         0|            0|            0|  0.00%|    Returns
  1789|         0|            0|            0|  0.00%|    -------
  1790|         0|            0|            0|  0.00%|    y : array_like
  1791|         0|            0|            0|  0.00%|        y is an array of the same subtype as `a`, with shape ``(a.size,)``.
  1792|         0|            0|            0|  0.00%|        Note that matrices are special cased for backward compatibility, if `a`
  1793|         0|            0|            0|  0.00%|        is a matrix, then y is a 1-D ndarray.
  1794|         0|            0|            0|  0.00%|
  1795|         0|            0|            0|  0.00%|    See Also
  1796|         0|            0|            0|  0.00%|    --------
  1797|         0|            0|            0|  0.00%|    ndarray.flat : 1-D iterator over an array.
  1798|         0|            0|            0|  0.00%|    ndarray.flatten : 1-D array copy of the elements of an array
  1799|         0|            0|            0|  0.00%|                      in row-major order.
  1800|         0|            0|            0|  0.00%|    ndarray.reshape : Change the shape of an array without changing its data.
  1801|         0|            0|            0|  0.00%|
  1802|         0|            0|            0|  0.00%|    Notes
  1803|         0|            0|            0|  0.00%|    -----
  1804|         0|            0|            0|  0.00%|    In row-major, C-style order, in two dimensions, the row index
  1805|         0|            0|            0|  0.00%|    varies the slowest, and the column index the quickest.  This can
  1806|         0|            0|            0|  0.00%|    be generalized to multiple dimensions, where row-major order
  1807|         0|            0|            0|  0.00%|    implies that the index along the first axis varies slowest, and
  1808|         0|            0|            0|  0.00%|    the index along the last quickest.  The opposite holds for
  1809|         0|            0|            0|  0.00%|    column-major, Fortran-style index ordering.
  1810|         0|            0|            0|  0.00%|
  1811|         0|            0|            0|  0.00%|    When a view is desired in as many cases as possible, ``arr.reshape(-1)``
  1812|         0|            0|            0|  0.00%|    may be preferable.
  1813|         0|            0|            0|  0.00%|
  1814|         0|            0|            0|  0.00%|    Examples
  1815|         0|            0|            0|  0.00%|    --------
  1816|         0|            0|            0|  0.00%|    It is equivalent to ``reshape(-1, order=order)``.
  1817|         0|            0|            0|  0.00%|
  1818|         0|            0|            0|  0.00%|    >>> x = np.array([[1, 2, 3], [4, 5, 6]])
  1819|         0|            0|            0|  0.00%|    >>> np.ravel(x)
  1820|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
  1821|         0|            0|            0|  0.00%|
  1822|         0|            0|            0|  0.00%|    >>> x.reshape(-1)
  1823|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
  1824|         0|            0|            0|  0.00%|
  1825|         0|            0|            0|  0.00%|    >>> np.ravel(x, order='F')
  1826|         0|            0|            0|  0.00%|    array([1, 4, 2, 5, 3, 6])
  1827|         0|            0|            0|  0.00%|
  1828|         0|            0|            0|  0.00%|    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:
  1829|         0|            0|            0|  0.00%|
  1830|         0|            0|            0|  0.00%|    >>> np.ravel(x.T)
  1831|         0|            0|            0|  0.00%|    array([1, 4, 2, 5, 3, 6])
  1832|         0|            0|            0|  0.00%|    >>> np.ravel(x.T, order='A')
  1833|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
  1834|         0|            0|            0|  0.00%|
  1835|         0|            0|            0|  0.00%|    When ``order`` is 'K', it will preserve orderings that are neither 'C'
  1836|         0|            0|            0|  0.00%|    nor 'F', but won't reverse axes:
  1837|         0|            0|            0|  0.00%|
  1838|         0|            0|            0|  0.00%|    >>> a = np.arange(3)[::-1]; a
  1839|         0|            0|            0|  0.00%|    array([2, 1, 0])
  1840|         0|            0|            0|  0.00%|    >>> a.ravel(order='C')
  1841|         0|            0|            0|  0.00%|    array([2, 1, 0])
  1842|         0|            0|            0|  0.00%|    >>> a.ravel(order='K')
  1843|         0|            0|            0|  0.00%|    array([2, 1, 0])
  1844|         0|            0|            0|  0.00%|
  1845|         0|            0|            0|  0.00%|    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
  1846|         0|            0|            0|  0.00%|    array([[[ 0,  2,  4],
  1847|         0|            0|            0|  0.00%|            [ 1,  3,  5]],
  1848|         0|            0|            0|  0.00%|           [[ 6,  8, 10],
  1849|         0|            0|            0|  0.00%|            [ 7,  9, 11]]])
  1850|         0|            0|            0|  0.00%|    >>> a.ravel(order='C')
  1851|         0|            0|            0|  0.00%|    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
  1852|         0|            0|            0|  0.00%|    >>> a.ravel(order='K')
  1853|         0|            0|            0|  0.00%|    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
  1854|         0|            0|            0|  0.00%|
  1855|         0|            0|            0|  0.00%|    """
  1856|        24|  9.98974e-05|  4.16239e-06|  0.00%|    if isinstance(a, np.matrix):
  1857|        16|            0|            0|  0.00%|        return asarray(a).ravel(order=order)
  1858|         0|            0|            0|  0.00%|    else:
  1859|         8|            0|            0|  0.00%|        return asanyarray(a).ravel(order=order)
  1860|         0|            0|            0|  0.00%|
  1861|         0|            0|            0|  0.00%|
  1862|         8|            0|            0|  0.00%|def _nonzero_dispatcher(a):
  1863|         8|            0|            0|  0.00%|    return (a,)
  1864|         0|            0|            0|  0.00%|
  1865|         0|            0|            0|  0.00%|
  1866|         8|            0|            0|  0.00%|@array_function_dispatch(_nonzero_dispatcher)
  1867|         0|            0|            0|  0.00%|def nonzero(a):
  1868|         0|            0|            0|  0.00%|    """
  1869|         0|            0|            0|  0.00%|    Return the indices of the elements that are non-zero.
  1870|         0|            0|            0|  0.00%|
  1871|         0|            0|            0|  0.00%|    Returns a tuple of arrays, one for each dimension of `a`,
  1872|         0|            0|            0|  0.00%|    containing the indices of the non-zero elements in that
  1873|         0|            0|            0|  0.00%|    dimension. The values in `a` are always tested and returned in
  1874|         0|            0|            0|  0.00%|    row-major, C-style order.
  1875|         0|            0|            0|  0.00%|
  1876|         0|            0|            0|  0.00%|    To group the indices by element, rather than dimension, use `argwhere`,
  1877|         0|            0|            0|  0.00%|    which returns a row for each non-zero element.
  1878|         0|            0|            0|  0.00%|
  1879|         0|            0|            0|  0.00%|    .. note::
  1880|         0|            0|            0|  0.00%|
  1881|         0|            0|            0|  0.00%|       When called on a zero-d array or scalar, ``nonzero(a)`` is treated
  1882|         0|            0|            0|  0.00%|       as ``nonzero(atleast_1d(a))``.
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|       .. deprecated:: 1.17.0
  1885|         0|            0|            0|  0.00%|
  1886|         0|            0|            0|  0.00%|          Use `atleast_1d` explicitly if this behavior is deliberate.
  1887|         0|            0|            0|  0.00%|
  1888|         0|            0|            0|  0.00%|    Parameters
  1889|         0|            0|            0|  0.00%|    ----------
  1890|         0|            0|            0|  0.00%|    a : array_like
  1891|         0|            0|            0|  0.00%|        Input array.
  1892|         0|            0|            0|  0.00%|
  1893|         0|            0|            0|  0.00%|    Returns
  1894|         0|            0|            0|  0.00%|    -------
  1895|         0|            0|            0|  0.00%|    tuple_of_arrays : tuple
  1896|         0|            0|            0|  0.00%|        Indices of elements that are non-zero.
  1897|         0|            0|            0|  0.00%|
  1898|         0|            0|            0|  0.00%|    See Also
  1899|         0|            0|            0|  0.00%|    --------
  1900|         0|            0|            0|  0.00%|    flatnonzero :
  1901|         0|            0|            0|  0.00%|        Return indices that are non-zero in the flattened version of the input
  1902|         0|            0|            0|  0.00%|        array.
  1903|         0|            0|            0|  0.00%|    ndarray.nonzero :
  1904|         0|            0|            0|  0.00%|        Equivalent ndarray method.
  1905|         0|            0|            0|  0.00%|    count_nonzero :
  1906|         0|            0|            0|  0.00%|        Counts the number of non-zero elements in the input array.
  1907|         0|            0|            0|  0.00%|
  1908|         0|            0|            0|  0.00%|    Notes
  1909|         0|            0|            0|  0.00%|    -----
  1910|         0|            0|            0|  0.00%|    While the nonzero values can be obtained with ``a[nonzero(a)]``, it is
  1911|         0|            0|            0|  0.00%|    recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which
  1912|         0|            0|            0|  0.00%|    will correctly handle 0-d arrays.
  1913|         0|            0|            0|  0.00%|
  1914|         0|            0|            0|  0.00%|    Examples
  1915|         0|            0|            0|  0.00%|    --------
  1916|         0|            0|            0|  0.00%|    >>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
  1917|         0|            0|            0|  0.00%|    >>> x
  1918|         0|            0|            0|  0.00%|    array([[3, 0, 0],
  1919|         0|            0|            0|  0.00%|           [0, 4, 0],
  1920|         0|            0|            0|  0.00%|           [5, 6, 0]])
  1921|         0|            0|            0|  0.00%|    >>> np.nonzero(x)
  1922|         0|            0|            0|  0.00%|    (array([0, 1, 2, 2]), array([0, 1, 0, 1]))
  1923|         0|            0|            0|  0.00%|
  1924|         0|            0|            0|  0.00%|    >>> x[np.nonzero(x)]
  1925|         0|            0|            0|  0.00%|    array([3, 4, 5, 6])
  1926|         0|            0|            0|  0.00%|    >>> np.transpose(np.nonzero(x))
  1927|         0|            0|            0|  0.00%|    array([[0, 0],
  1928|         0|            0|            0|  0.00%|           [1, 1],
  1929|         0|            0|            0|  0.00%|           [2, 0],
  1930|         0|            0|            0|  0.00%|           [2, 1]])
  1931|         0|            0|            0|  0.00%|
  1932|         0|            0|            0|  0.00%|    A common use for ``nonzero`` is to find the indices of an array, where
  1933|         0|            0|            0|  0.00%|    a condition is True.  Given an array `a`, the condition `a` > 3 is a
  1934|         0|            0|            0|  0.00%|    boolean array and since False is interpreted as 0, np.nonzero(a > 3)
  1935|         0|            0|            0|  0.00%|    yields the indices of the `a` where the condition is true.
  1936|         0|            0|            0|  0.00%|
  1937|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  1938|         0|            0|            0|  0.00%|    >>> a > 3
  1939|         0|            0|            0|  0.00%|    array([[False, False, False],
  1940|         0|            0|            0|  0.00%|           [ True,  True,  True],
  1941|         0|            0|            0|  0.00%|           [ True,  True,  True]])
  1942|         0|            0|            0|  0.00%|    >>> np.nonzero(a > 3)
  1943|         0|            0|            0|  0.00%|    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
  1944|         0|            0|            0|  0.00%|
  1945|         0|            0|            0|  0.00%|    Using this result to index `a` is equivalent to using the mask directly:
  1946|         0|            0|            0|  0.00%|
  1947|         0|            0|            0|  0.00%|    >>> a[np.nonzero(a > 3)]
  1948|         0|            0|            0|  0.00%|    array([4, 5, 6, 7, 8, 9])
  1949|         0|            0|            0|  0.00%|    >>> a[a > 3]  # prefer this spelling
  1950|         0|            0|            0|  0.00%|    array([4, 5, 6, 7, 8, 9])
  1951|         0|            0|            0|  0.00%|
  1952|         0|            0|            0|  0.00%|    ``nonzero`` can also be called as a method of the array.
  1953|         0|            0|            0|  0.00%|
  1954|         0|            0|            0|  0.00%|    >>> (a > 3).nonzero()
  1955|         0|            0|            0|  0.00%|    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
  1956|         0|            0|            0|  0.00%|
  1957|         0|            0|            0|  0.00%|    """
  1958|         8|            0|            0|  0.00%|    return _wrapfunc(a, 'nonzero')
(call)|         8|  7.55787e-05|  9.44734e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:51 _wrapfunc
  1959|         0|            0|            0|  0.00%|
  1960|         0|            0|            0|  0.00%|
  1961|         0|            0|            0|  0.00%|def _shape_dispatcher(a):
  1962|         0|            0|            0|  0.00%|    return (a,)
  1963|         0|            0|            0|  0.00%|
  1964|         0|            0|            0|  0.00%|
  1965|         0|            0|            0|  0.00%|@array_function_dispatch(_shape_dispatcher)
  1966|         0|            0|            0|  0.00%|def shape(a):
  1967|         0|            0|            0|  0.00%|    """
  1968|         0|            0|            0|  0.00%|    Return the shape of an array.
  1969|         0|            0|            0|  0.00%|
  1970|         0|            0|            0|  0.00%|    Parameters
  1971|         0|            0|            0|  0.00%|    ----------
  1972|         0|            0|            0|  0.00%|    a : array_like
  1973|         0|            0|            0|  0.00%|        Input array.
  1974|         0|            0|            0|  0.00%|
  1975|         0|            0|            0|  0.00%|    Returns
  1976|         0|            0|            0|  0.00%|    -------
  1977|         0|            0|            0|  0.00%|    shape : tuple of ints
  1978|         0|            0|            0|  0.00%|        The elements of the shape tuple give the lengths of the
  1979|         0|            0|            0|  0.00%|        corresponding array dimensions.
  1980|         0|            0|            0|  0.00%|
  1981|         0|            0|            0|  0.00%|    See Also
  1982|         0|            0|            0|  0.00%|    --------
  1983|         0|            0|            0|  0.00%|    len
  1984|         0|            0|            0|  0.00%|    ndarray.shape : Equivalent array method.
  1985|         0|            0|            0|  0.00%|
  1986|         0|            0|            0|  0.00%|    Examples
  1987|         0|            0|            0|  0.00%|    --------
  1988|         0|            0|            0|  0.00%|    >>> np.shape(np.eye(3))
  1989|         0|            0|            0|  0.00%|    (3, 3)
  1990|         0|            0|            0|  0.00%|    >>> np.shape([[1, 2]])
  1991|         0|            0|            0|  0.00%|    (1, 2)
  1992|         0|            0|            0|  0.00%|    >>> np.shape([0])
  1993|         0|            0|            0|  0.00%|    (1,)
  1994|         0|            0|            0|  0.00%|    >>> np.shape(0)
  1995|         0|            0|            0|  0.00%|    ()
  1996|         0|            0|            0|  0.00%|
  1997|         0|            0|            0|  0.00%|    >>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
  1998|         0|            0|            0|  0.00%|    >>> np.shape(a)
  1999|         0|            0|            0|  0.00%|    (2,)
  2000|         0|            0|            0|  0.00%|    >>> a.shape
  2001|         0|            0|            0|  0.00%|    (2,)
  2002|         0|            0|            0|  0.00%|
  2003|         0|            0|            0|  0.00%|    """
  2004|         0|            0|            0|  0.00%|    try:
  2005|         0|            0|            0|  0.00%|        result = a.shape
  2006|         0|            0|            0|  0.00%|    except AttributeError:
  2007|         0|            0|            0|  0.00%|        result = asarray(a).shape
  2008|         0|            0|            0|  0.00%|    return result
  2009|         0|            0|            0|  0.00%|
  2010|         0|            0|            0|  0.00%|
  2011|         0|            0|            0|  0.00%|def _compress_dispatcher(condition, a, axis=None, out=None):
  2012|         0|            0|            0|  0.00%|    return (condition, a, out)
  2013|         0|            0|            0|  0.00%|
  2014|         0|            0|            0|  0.00%|
  2015|         0|            0|            0|  0.00%|@array_function_dispatch(_compress_dispatcher)
  2016|         0|            0|            0|  0.00%|def compress(condition, a, axis=None, out=None):
  2017|         0|            0|            0|  0.00%|    """
  2018|         0|            0|            0|  0.00%|    Return selected slices of an array along given axis.
  2019|         0|            0|            0|  0.00%|
  2020|         0|            0|            0|  0.00%|    When working along a given axis, a slice along that axis is returned in
  2021|         0|            0|            0|  0.00%|    `output` for each index where `condition` evaluates to True. When
  2022|         0|            0|            0|  0.00%|    working on a 1-D array, `compress` is equivalent to `extract`.
  2023|         0|            0|            0|  0.00%|
  2024|         0|            0|            0|  0.00%|    Parameters
  2025|         0|            0|            0|  0.00%|    ----------
  2026|         0|            0|            0|  0.00%|    condition : 1-D array of bools
  2027|         0|            0|            0|  0.00%|        Array that selects which entries to return. If len(condition)
  2028|         0|            0|            0|  0.00%|        is less than the size of `a` along the given axis, then output is
  2029|         0|            0|            0|  0.00%|        truncated to the length of the condition array.
  2030|         0|            0|            0|  0.00%|    a : array_like
  2031|         0|            0|            0|  0.00%|        Array from which to extract a part.
  2032|         0|            0|            0|  0.00%|    axis : int, optional
  2033|         0|            0|            0|  0.00%|        Axis along which to take slices. If None (default), work on the
  2034|         0|            0|            0|  0.00%|        flattened array.
  2035|         0|            0|            0|  0.00%|    out : ndarray, optional
  2036|         0|            0|            0|  0.00%|        Output array.  Its type is preserved and it must be of the right
  2037|         0|            0|            0|  0.00%|        shape to hold the output.
  2038|         0|            0|            0|  0.00%|
  2039|         0|            0|            0|  0.00%|    Returns
  2040|         0|            0|            0|  0.00%|    -------
  2041|         0|            0|            0|  0.00%|    compressed_array : ndarray
  2042|         0|            0|            0|  0.00%|        A copy of `a` without the slices along axis for which `condition`
  2043|         0|            0|            0|  0.00%|        is false.
  2044|         0|            0|            0|  0.00%|
  2045|         0|            0|            0|  0.00%|    See Also
  2046|         0|            0|            0|  0.00%|    --------
  2047|         0|            0|            0|  0.00%|    take, choose, diag, diagonal, select
  2048|         0|            0|            0|  0.00%|    ndarray.compress : Equivalent method in ndarray
  2049|         0|            0|            0|  0.00%|    extract : Equivalent method when working on 1-D arrays
  2050|         0|            0|            0|  0.00%|    :ref:`ufuncs-output-type`
  2051|         0|            0|            0|  0.00%|
  2052|         0|            0|            0|  0.00%|    Examples
  2053|         0|            0|            0|  0.00%|    --------
  2054|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4], [5, 6]])
  2055|         0|            0|            0|  0.00%|    >>> a
  2056|         0|            0|            0|  0.00%|    array([[1, 2],
  2057|         0|            0|            0|  0.00%|           [3, 4],
  2058|         0|            0|            0|  0.00%|           [5, 6]])
  2059|         0|            0|            0|  0.00%|    >>> np.compress([0, 1], a, axis=0)
  2060|         0|            0|            0|  0.00%|    array([[3, 4]])
  2061|         0|            0|            0|  0.00%|    >>> np.compress([False, True, True], a, axis=0)
  2062|         0|            0|            0|  0.00%|    array([[3, 4],
  2063|         0|            0|            0|  0.00%|           [5, 6]])
  2064|         0|            0|            0|  0.00%|    >>> np.compress([False, True], a, axis=1)
  2065|         0|            0|            0|  0.00%|    array([[2],
  2066|         0|            0|            0|  0.00%|           [4],
  2067|         0|            0|            0|  0.00%|           [6]])
  2068|         0|            0|            0|  0.00%|
  2069|         0|            0|            0|  0.00%|    Working on the flattened array does not return slices along an axis but
  2070|         0|            0|            0|  0.00%|    selects elements.
  2071|         0|            0|            0|  0.00%|
  2072|         0|            0|            0|  0.00%|    >>> np.compress([False, True], a)
  2073|         0|            0|            0|  0.00%|    array([2])
  2074|         0|            0|            0|  0.00%|
  2075|         0|            0|            0|  0.00%|    """
  2076|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'compress', condition, axis=axis, out=out)
  2077|         0|            0|            0|  0.00%|
  2078|         0|            0|            0|  0.00%|
  2079|         4|            0|            0|  0.00%|def _clip_dispatcher(a, a_min, a_max, out=None, **kwargs):
  2080|         4|            0|            0|  0.00%|    return (a, a_min, a_max)
  2081|         0|            0|            0|  0.00%|
  2082|         0|            0|            0|  0.00%|
  2083|         4|            0|            0|  0.00%|@array_function_dispatch(_clip_dispatcher)
  2084|         0|            0|            0|  0.00%|def clip(a, a_min, a_max, out=None, **kwargs):
  2085|         0|            0|            0|  0.00%|    """
  2086|         0|            0|            0|  0.00%|    Clip (limit) the values in an array.
  2087|         0|            0|            0|  0.00%|
  2088|         0|            0|            0|  0.00%|    Given an interval, values outside the interval are clipped to
  2089|         0|            0|            0|  0.00%|    the interval edges.  For example, if an interval of ``[0, 1]``
  2090|         0|            0|            0|  0.00%|    is specified, values smaller than 0 become 0, and values larger
  2091|         0|            0|            0|  0.00%|    than 1 become 1.
  2092|         0|            0|            0|  0.00%|
  2093|         0|            0|            0|  0.00%|    Equivalent to but faster than ``np.minimum(a_max, np.maximum(a, a_min))``.
  2094|         0|            0|            0|  0.00%|
  2095|         0|            0|            0|  0.00%|    No check is performed to ensure ``a_min < a_max``.
  2096|         0|            0|            0|  0.00%|
  2097|         0|            0|            0|  0.00%|    Parameters
  2098|         0|            0|            0|  0.00%|    ----------
  2099|         0|            0|            0|  0.00%|    a : array_like
  2100|         0|            0|            0|  0.00%|        Array containing elements to clip.
  2101|         0|            0|            0|  0.00%|    a_min, a_max : array_like or None
  2102|         0|            0|            0|  0.00%|        Minimum and maximum value. If ``None``, clipping is not performed on
  2103|         0|            0|            0|  0.00%|        the corresponding edge. Only one of `a_min` and `a_max` may be
  2104|         0|            0|            0|  0.00%|        ``None``. Both are broadcast against `a`.
  2105|         0|            0|            0|  0.00%|    out : ndarray, optional
  2106|         0|            0|            0|  0.00%|        The results will be placed in this array. It may be the input
  2107|         0|            0|            0|  0.00%|        array for in-place clipping.  `out` must be of the right shape
  2108|         0|            0|            0|  0.00%|        to hold the output.  Its type is preserved.
  2109|         0|            0|            0|  0.00%|    **kwargs
  2110|         0|            0|            0|  0.00%|        For other keyword-only arguments, see the
  2111|         0|            0|            0|  0.00%|        :ref:`ufunc docs <ufuncs.kwargs>`.
  2112|         0|            0|            0|  0.00%|
  2113|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2114|         0|            0|            0|  0.00%|
  2115|         0|            0|            0|  0.00%|    Returns
  2116|         0|            0|            0|  0.00%|    -------
  2117|         0|            0|            0|  0.00%|    clipped_array : ndarray
  2118|         0|            0|            0|  0.00%|        An array with the elements of `a`, but where values
  2119|         0|            0|            0|  0.00%|        < `a_min` are replaced with `a_min`, and those > `a_max`
  2120|         0|            0|            0|  0.00%|        with `a_max`.
  2121|         0|            0|            0|  0.00%|
  2122|         0|            0|            0|  0.00%|    See Also
  2123|         0|            0|            0|  0.00%|    --------
  2124|         0|            0|            0|  0.00%|    :ref:`ufuncs-output-type`
  2125|         0|            0|            0|  0.00%|
  2126|         0|            0|            0|  0.00%|    Notes
  2127|         0|            0|            0|  0.00%|    -----
  2128|         0|            0|            0|  0.00%|    When `a_min` is greater than `a_max`, `clip` returns an
  2129|         0|            0|            0|  0.00%|    array in which all values are equal to `a_max`,
  2130|         0|            0|            0|  0.00%|    as shown in the second example.
  2131|         0|            0|            0|  0.00%|
  2132|         0|            0|            0|  0.00%|    Examples
  2133|         0|            0|            0|  0.00%|    --------
  2134|         0|            0|            0|  0.00%|    >>> a = np.arange(10)
  2135|         0|            0|            0|  0.00%|    >>> a
  2136|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  2137|         0|            0|            0|  0.00%|    >>> np.clip(a, 1, 8)
  2138|         0|            0|            0|  0.00%|    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
  2139|         0|            0|            0|  0.00%|    >>> np.clip(a, 8, 1)
  2140|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
  2141|         0|            0|            0|  0.00%|    >>> np.clip(a, 3, 6, out=a)
  2142|         0|            0|            0|  0.00%|    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
  2143|         0|            0|            0|  0.00%|    >>> a
  2144|         0|            0|            0|  0.00%|    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
  2145|         0|            0|            0|  0.00%|    >>> a = np.arange(10)
  2146|         0|            0|            0|  0.00%|    >>> a
  2147|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  2148|         0|            0|            0|  0.00%|    >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
  2149|         0|            0|            0|  0.00%|    array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
  2150|         0|            0|            0|  0.00%|
  2151|         0|            0|            0|  0.00%|    """
  2152|         4|   0.00099802|  0.000249505|  0.00%|    return _wrapfunc(a, 'clip', a_min, a_max, out=out, **kwargs)
(call)|         4|   0.00048852|   0.00012213|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:51 _wrapfunc
  2153|         0|            0|            0|  0.00%|
  2154|         0|            0|            0|  0.00%|
  2155|      2108|   0.00495744|  2.35173e-06|  0.01%|def _sum_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,
  2156|         0|            0|            0|  0.00%|                    initial=None, where=None):
  2157|      2108|   0.00701666|  3.32859e-06|  0.02%|    return (a, out)
  2158|         0|            0|            0|  0.00%|
  2159|         0|            0|            0|  0.00%|
  2160|      2108|   0.00302315|  1.43413e-06|  0.01%|@array_function_dispatch(_sum_dispatcher)
  2161|         0|            0|            0|  0.00%|def sum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,
  2162|         0|            0|            0|  0.00%|        initial=np._NoValue, where=np._NoValue):
  2163|         0|            0|            0|  0.00%|    """
  2164|         0|            0|            0|  0.00%|    Sum of array elements over a given axis.
  2165|         0|            0|            0|  0.00%|
  2166|         0|            0|            0|  0.00%|    Parameters
  2167|         0|            0|            0|  0.00%|    ----------
  2168|         0|            0|            0|  0.00%|    a : array_like
  2169|         0|            0|            0|  0.00%|        Elements to sum.
  2170|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2171|         0|            0|            0|  0.00%|        Axis or axes along which a sum is performed.  The default,
  2172|         0|            0|            0|  0.00%|        axis=None, will sum all of the elements of the input array.  If
  2173|         0|            0|            0|  0.00%|        axis is negative it counts from the last to the first axis.
  2174|         0|            0|            0|  0.00%|
  2175|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2176|         0|            0|            0|  0.00%|
  2177|         0|            0|            0|  0.00%|        If axis is a tuple of ints, a sum is performed on all of the axes
  2178|         0|            0|            0|  0.00%|        specified in the tuple instead of a single axis or all the axes as
  2179|         0|            0|            0|  0.00%|        before.
  2180|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2181|         0|            0|            0|  0.00%|        The type of the returned array and of the accumulator in which the
  2182|         0|            0|            0|  0.00%|        elements are summed.  The dtype of `a` is used by default unless `a`
  2183|         0|            0|            0|  0.00%|        has an integer dtype of less precision than the default platform
  2184|         0|            0|            0|  0.00%|        integer.  In that case, if `a` is signed then the platform integer
  2185|         0|            0|            0|  0.00%|        is used while if `a` is unsigned then an unsigned integer of the
  2186|         0|            0|            0|  0.00%|        same precision as the platform integer is used.
  2187|         0|            0|            0|  0.00%|    out : ndarray, optional
  2188|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  2189|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type of the output
  2190|         0|            0|            0|  0.00%|        values will be cast if necessary.
  2191|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2192|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2193|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2194|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2195|         0|            0|            0|  0.00%|
  2196|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2197|         0|            0|            0|  0.00%|        passed through to the `sum` method of sub-classes of
  2198|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2199|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2200|         0|            0|            0|  0.00%|        exceptions will be raised.
  2201|         0|            0|            0|  0.00%|    initial : scalar, optional
  2202|         0|            0|            0|  0.00%|        Starting value for the sum. See `~numpy.ufunc.reduce` for details.
  2203|         0|            0|            0|  0.00%|
  2204|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2205|         0|            0|            0|  0.00%|
  2206|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2207|         0|            0|            0|  0.00%|        Elements to include in the sum. See `~numpy.ufunc.reduce` for details.
  2208|         0|            0|            0|  0.00%|
  2209|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2210|         0|            0|            0|  0.00%|
  2211|         0|            0|            0|  0.00%|    Returns
  2212|         0|            0|            0|  0.00%|    -------
  2213|         0|            0|            0|  0.00%|    sum_along_axis : ndarray
  2214|         0|            0|            0|  0.00%|        An array with the same shape as `a`, with the specified
  2215|         0|            0|            0|  0.00%|        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
  2216|         0|            0|            0|  0.00%|        is returned.  If an output array is specified, a reference to
  2217|         0|            0|            0|  0.00%|        `out` is returned.
  2218|         0|            0|            0|  0.00%|
  2219|         0|            0|            0|  0.00%|    See Also
  2220|         0|            0|            0|  0.00%|    --------
  2221|         0|            0|            0|  0.00%|    ndarray.sum : Equivalent method.
  2222|         0|            0|            0|  0.00%|
  2223|         0|            0|            0|  0.00%|    add.reduce : Equivalent functionality of `add`.
  2224|         0|            0|            0|  0.00%|
  2225|         0|            0|            0|  0.00%|    cumsum : Cumulative sum of array elements.
  2226|         0|            0|            0|  0.00%|
  2227|         0|            0|            0|  0.00%|    trapz : Integration of array values using the composite trapezoidal rule.
  2228|         0|            0|            0|  0.00%|
  2229|         0|            0|            0|  0.00%|    mean, average
  2230|         0|            0|            0|  0.00%|
  2231|         0|            0|            0|  0.00%|    Notes
  2232|         0|            0|            0|  0.00%|    -----
  2233|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  2234|         0|            0|            0|  0.00%|    raised on overflow.
  2235|         0|            0|            0|  0.00%|
  2236|         0|            0|            0|  0.00%|    The sum of an empty array is the neutral element 0:
  2237|         0|            0|            0|  0.00%|
  2238|         0|            0|            0|  0.00%|    >>> np.sum([])
  2239|         0|            0|            0|  0.00%|    0.0
  2240|         0|            0|            0|  0.00%|
  2241|         0|            0|            0|  0.00%|    For floating point numbers the numerical precision of sum (and
  2242|         0|            0|            0|  0.00%|    ``np.add.reduce``) is in general limited by directly adding each number
  2243|         0|            0|            0|  0.00%|    individually to the result causing rounding errors in every step.
  2244|         0|            0|            0|  0.00%|    However, often numpy will use a  numerically better approach (partial
  2245|         0|            0|            0|  0.00%|    pairwise summation) leading to improved precision in many use-cases.
  2246|         0|            0|            0|  0.00%|    This improved precision is always provided when no ``axis`` is given.
  2247|         0|            0|            0|  0.00%|    When ``axis`` is given, it will depend on which axis is summed.
  2248|         0|            0|            0|  0.00%|    Technically, to provide the best speed possible, the improved precision
  2249|         0|            0|            0|  0.00%|    is only used when the summation is along the fast axis in memory.
  2250|         0|            0|            0|  0.00%|    Note that the exact precision may vary depending on other parameters.
  2251|         0|            0|            0|  0.00%|    In contrast to NumPy, Python's ``math.fsum`` function uses a slower but
  2252|         0|            0|            0|  0.00%|    more precise approach to summation.
  2253|         0|            0|            0|  0.00%|    Especially when summing a large number of lower precision floating point
  2254|         0|            0|            0|  0.00%|    numbers, such as ``float32``, numerical errors can become significant.
  2255|         0|            0|            0|  0.00%|    In such cases it can be advisable to use `dtype="float64"` to use a higher
  2256|         0|            0|            0|  0.00%|    precision for the output.
  2257|         0|            0|            0|  0.00%|
  2258|         0|            0|            0|  0.00%|    Examples
  2259|         0|            0|            0|  0.00%|    --------
  2260|         0|            0|            0|  0.00%|    >>> np.sum([0.5, 1.5])
  2261|         0|            0|            0|  0.00%|    2.0
  2262|         0|            0|            0|  0.00%|    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
  2263|         0|            0|            0|  0.00%|    1
  2264|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [0, 5]])
  2265|         0|            0|            0|  0.00%|    6
  2266|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [0, 5]], axis=0)
  2267|         0|            0|            0|  0.00%|    array([0, 6])
  2268|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [0, 5]], axis=1)
  2269|         0|            0|            0|  0.00%|    array([1, 5])
  2270|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)
  2271|         0|            0|            0|  0.00%|    array([1., 5.])
  2272|         0|            0|            0|  0.00%|
  2273|         0|            0|            0|  0.00%|    If the accumulator is too small, overflow occurs:
  2274|         0|            0|            0|  0.00%|
  2275|         0|            0|            0|  0.00%|    >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
  2276|         0|            0|            0|  0.00%|    -128
  2277|         0|            0|            0|  0.00%|
  2278|         0|            0|            0|  0.00%|    You can also start the sum with a value other than zero:
  2279|         0|            0|            0|  0.00%|
  2280|         0|            0|            0|  0.00%|    >>> np.sum([10], initial=5)
  2281|         0|            0|            0|  0.00%|    15
  2282|         0|            0|            0|  0.00%|    """
  2283|      2108|   0.00712395|  3.37948e-06|  0.02%|    if isinstance(a, _gentype):
  2284|         0|            0|            0|  0.00%|        # 2018-02-25, 1.15.0
  2285|         0|            0|            0|  0.00%|        warnings.warn(
  2286|         0|            0|            0|  0.00%|            "Calling np.sum(generator) is deprecated, and in the future will give a different result. "
  2287|         0|            0|            0|  0.00%|            "Use np.sum(np.fromiter(generator)) or the python sum builtin instead.",
  2288|         0|            0|            0|  0.00%|            DeprecationWarning, stacklevel=3)
  2289|         0|            0|            0|  0.00%|
  2290|         0|            0|            0|  0.00%|        res = _sum_(a)
  2291|         0|            0|            0|  0.00%|        if out is not None:
  2292|         0|            0|            0|  0.00%|            out[...] = res
  2293|         0|            0|            0|  0.00%|            return out
  2294|         0|            0|            0|  0.00%|        return res
  2295|         0|            0|            0|  0.00%|
  2296|      4216|    0.0283308|  6.71983e-06|  0.08%|    return _wrapreduction(a, np.add, 'sum', axis, dtype, out, keepdims=keepdims,
(call)|      2108|    0.0600126|   2.8469e-05|  0.17%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:69 _wrapreduction
  2297|      2108|   0.00798464|  3.78778e-06|  0.02%|                          initial=initial, where=where)
  2298|         0|            0|            0|  0.00%|
  2299|         0|            0|            0|  0.00%|
  2300|         0|            0|            0|  0.00%|def _any_dispatcher(a, axis=None, out=None, keepdims=None, *,
  2301|         0|            0|            0|  0.00%|                    where=np._NoValue):
  2302|         0|            0|            0|  0.00%|    return (a, where, out)
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|
  2305|         0|            0|            0|  0.00%|@array_function_dispatch(_any_dispatcher)
  2306|         0|            0|            0|  0.00%|def any(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):
  2307|         0|            0|            0|  0.00%|    """
  2308|         0|            0|            0|  0.00%|    Test whether any array element along a given axis evaluates to True.
  2309|         0|            0|            0|  0.00%|
  2310|         0|            0|            0|  0.00%|    Returns single boolean unless `axis` is not ``None``
  2311|         0|            0|            0|  0.00%|
  2312|         0|            0|            0|  0.00%|    Parameters
  2313|         0|            0|            0|  0.00%|    ----------
  2314|         0|            0|            0|  0.00%|    a : array_like
  2315|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  2316|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2317|         0|            0|            0|  0.00%|        Axis or axes along which a logical OR reduction is performed.
  2318|         0|            0|            0|  0.00%|        The default (``axis=None``) is to perform a logical OR over all
  2319|         0|            0|            0|  0.00%|        the dimensions of the input array. `axis` may be negative, in
  2320|         0|            0|            0|  0.00%|        which case it counts from the last to the first axis.
  2321|         0|            0|            0|  0.00%|
  2322|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2323|         0|            0|            0|  0.00%|
  2324|         0|            0|            0|  0.00%|        If this is a tuple of ints, a reduction is performed on multiple
  2325|         0|            0|            0|  0.00%|        axes, instead of a single axis or all the axes as before.
  2326|         0|            0|            0|  0.00%|    out : ndarray, optional
  2327|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.  It must have
  2328|         0|            0|            0|  0.00%|        the same shape as the expected output and its type is preserved
  2329|         0|            0|            0|  0.00%|        (e.g., if it is of type float, then it will remain so, returning
  2330|         0|            0|            0|  0.00%|        1.0 for True and 0.0 for False, regardless of the type of `a`).
  2331|         0|            0|            0|  0.00%|        See :ref:`ufuncs-output-type` for more details.
  2332|         0|            0|            0|  0.00%|
  2333|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2334|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2335|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2336|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2337|         0|            0|            0|  0.00%|
  2338|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2339|         0|            0|            0|  0.00%|        passed through to the `any` method of sub-classes of
  2340|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2341|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2342|         0|            0|            0|  0.00%|        exceptions will be raised.
  2343|         0|            0|            0|  0.00%|
  2344|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2345|         0|            0|            0|  0.00%|        Elements to include in checking for any `True` values.
  2346|         0|            0|            0|  0.00%|        See `~numpy.ufunc.reduce` for details.
  2347|         0|            0|            0|  0.00%|
  2348|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
  2349|         0|            0|            0|  0.00%|
  2350|         0|            0|            0|  0.00%|    Returns
  2351|         0|            0|            0|  0.00%|    -------
  2352|         0|            0|            0|  0.00%|    any : bool or ndarray
  2353|         0|            0|            0|  0.00%|        A new boolean or `ndarray` is returned unless `out` is specified,
  2354|         0|            0|            0|  0.00%|        in which case a reference to `out` is returned.
  2355|         0|            0|            0|  0.00%|
  2356|         0|            0|            0|  0.00%|    See Also
  2357|         0|            0|            0|  0.00%|    --------
  2358|         0|            0|            0|  0.00%|    ndarray.any : equivalent method
  2359|         0|            0|            0|  0.00%|
  2360|         0|            0|            0|  0.00%|    all : Test whether all elements along a given axis evaluate to True.
  2361|         0|            0|            0|  0.00%|
  2362|         0|            0|            0|  0.00%|    Notes
  2363|         0|            0|            0|  0.00%|    -----
  2364|         0|            0|            0|  0.00%|    Not a Number (NaN), positive infinity and negative infinity evaluate
  2365|         0|            0|            0|  0.00%|    to `True` because these are not equal to zero.
  2366|         0|            0|            0|  0.00%|
  2367|         0|            0|            0|  0.00%|    Examples
  2368|         0|            0|            0|  0.00%|    --------
  2369|         0|            0|            0|  0.00%|    >>> np.any([[True, False], [True, True]])
  2370|         0|            0|            0|  0.00%|    True
  2371|         0|            0|            0|  0.00%|
  2372|         0|            0|            0|  0.00%|    >>> np.any([[True, False], [False, False]], axis=0)
  2373|         0|            0|            0|  0.00%|    array([ True, False])
  2374|         0|            0|            0|  0.00%|
  2375|         0|            0|            0|  0.00%|    >>> np.any([-1, 0, 5])
  2376|         0|            0|            0|  0.00%|    True
  2377|         0|            0|            0|  0.00%|
  2378|         0|            0|            0|  0.00%|    >>> np.any(np.nan)
  2379|         0|            0|            0|  0.00%|    True
  2380|         0|            0|            0|  0.00%|
  2381|         0|            0|            0|  0.00%|    >>> np.any([[True, False], [False, False]], where=[[False], [True]])
  2382|         0|            0|            0|  0.00%|    False
  2383|         0|            0|            0|  0.00%|
  2384|         0|            0|            0|  0.00%|    >>> o=np.array(False)
  2385|         0|            0|            0|  0.00%|    >>> z=np.any([-1, 4, 5], out=o)
  2386|         0|            0|            0|  0.00%|    >>> z, o
  2387|         0|            0|            0|  0.00%|    (array(True), array(True))
  2388|         0|            0|            0|  0.00%|    >>> # Check now that z is a reference to o
  2389|         0|            0|            0|  0.00%|    >>> z is o
  2390|         0|            0|            0|  0.00%|    True
  2391|         0|            0|            0|  0.00%|    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP
  2392|         0|            0|            0|  0.00%|    (191614240, 191614240)
  2393|         0|            0|            0|  0.00%|
  2394|         0|            0|            0|  0.00%|    """
  2395|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.logical_or, 'any', axis, None, out,
  2396|         0|            0|            0|  0.00%|                          keepdims=keepdims, where=where)
  2397|         0|            0|            0|  0.00%|
  2398|         0|            0|            0|  0.00%|
  2399|        88|            0|            0|  0.00%|def _all_dispatcher(a, axis=None, out=None, keepdims=None, *,
  2400|         0|            0|            0|  0.00%|                    where=None):
  2401|        88|  0.000997543|  1.13357e-05|  0.00%|    return (a, where, out)
  2402|         0|            0|            0|  0.00%|
  2403|         0|            0|            0|  0.00%|
  2404|        88|  0.000997543|  1.13357e-05|  0.00%|@array_function_dispatch(_all_dispatcher)
  2405|         0|            0|            0|  0.00%|def all(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):
  2406|         0|            0|            0|  0.00%|    """
  2407|         0|            0|            0|  0.00%|    Test whether all array elements along a given axis evaluate to True.
  2408|         0|            0|            0|  0.00%|
  2409|         0|            0|            0|  0.00%|    Parameters
  2410|         0|            0|            0|  0.00%|    ----------
  2411|         0|            0|            0|  0.00%|    a : array_like
  2412|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  2413|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2414|         0|            0|            0|  0.00%|        Axis or axes along which a logical AND reduction is performed.
  2415|         0|            0|            0|  0.00%|        The default (``axis=None``) is to perform a logical AND over all
  2416|         0|            0|            0|  0.00%|        the dimensions of the input array. `axis` may be negative, in
  2417|         0|            0|            0|  0.00%|        which case it counts from the last to the first axis.
  2418|         0|            0|            0|  0.00%|
  2419|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2420|         0|            0|            0|  0.00%|
  2421|         0|            0|            0|  0.00%|        If this is a tuple of ints, a reduction is performed on multiple
  2422|         0|            0|            0|  0.00%|        axes, instead of a single axis or all the axes as before.
  2423|         0|            0|            0|  0.00%|    out : ndarray, optional
  2424|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.
  2425|         0|            0|            0|  0.00%|        It must have the same shape as the expected output and its
  2426|         0|            0|            0|  0.00%|        type is preserved (e.g., if ``dtype(out)`` is float, the result
  2427|         0|            0|            0|  0.00%|        will consist of 0.0's and 1.0's). See :ref:`ufuncs-output-type` for more
  2428|         0|            0|            0|  0.00%|        details.
  2429|         0|            0|            0|  0.00%|
  2430|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2431|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2432|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2433|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2436|         0|            0|            0|  0.00%|        passed through to the `all` method of sub-classes of
  2437|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2438|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2439|         0|            0|            0|  0.00%|        exceptions will be raised.
  2440|         0|            0|            0|  0.00%|
  2441|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2442|         0|            0|            0|  0.00%|        Elements to include in checking for all `True` values.
  2443|         0|            0|            0|  0.00%|        See `~numpy.ufunc.reduce` for details.
  2444|         0|            0|            0|  0.00%|
  2445|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
  2446|         0|            0|            0|  0.00%|
  2447|         0|            0|            0|  0.00%|    Returns
  2448|         0|            0|            0|  0.00%|    -------
  2449|         0|            0|            0|  0.00%|    all : ndarray, bool
  2450|         0|            0|            0|  0.00%|        A new boolean or array is returned unless `out` is specified,
  2451|         0|            0|            0|  0.00%|        in which case a reference to `out` is returned.
  2452|         0|            0|            0|  0.00%|
  2453|         0|            0|            0|  0.00%|    See Also
  2454|         0|            0|            0|  0.00%|    --------
  2455|         0|            0|            0|  0.00%|    ndarray.all : equivalent method
  2456|         0|            0|            0|  0.00%|
  2457|         0|            0|            0|  0.00%|    any : Test whether any element along a given axis evaluates to True.
  2458|         0|            0|            0|  0.00%|
  2459|         0|            0|            0|  0.00%|    Notes
  2460|         0|            0|            0|  0.00%|    -----
  2461|         0|            0|            0|  0.00%|    Not a Number (NaN), positive infinity and negative infinity
  2462|         0|            0|            0|  0.00%|    evaluate to `True` because these are not equal to zero.
  2463|         0|            0|            0|  0.00%|
  2464|         0|            0|            0|  0.00%|    Examples
  2465|         0|            0|            0|  0.00%|    --------
  2466|         0|            0|            0|  0.00%|    >>> np.all([[True,False],[True,True]])
  2467|         0|            0|            0|  0.00%|    False
  2468|         0|            0|            0|  0.00%|
  2469|         0|            0|            0|  0.00%|    >>> np.all([[True,False],[True,True]], axis=0)
  2470|         0|            0|            0|  0.00%|    array([ True, False])
  2471|         0|            0|            0|  0.00%|
  2472|         0|            0|            0|  0.00%|    >>> np.all([-1, 4, 5])
  2473|         0|            0|            0|  0.00%|    True
  2474|         0|            0|            0|  0.00%|
  2475|         0|            0|            0|  0.00%|    >>> np.all([1.0, np.nan])
  2476|         0|            0|            0|  0.00%|    True
  2477|         0|            0|            0|  0.00%|
  2478|         0|            0|            0|  0.00%|    >>> np.all([[True, True], [False, True]], where=[[True], [False]])
  2479|         0|            0|            0|  0.00%|    True
  2480|         0|            0|            0|  0.00%|
  2481|         0|            0|            0|  0.00%|    >>> o=np.array(False)
  2482|         0|            0|            0|  0.00%|    >>> z=np.all([-1, 4, 5], out=o)
  2483|         0|            0|            0|  0.00%|    >>> id(z), id(o), z
  2484|         0|            0|            0|  0.00%|    (28293632, 28293632, array(True)) # may vary
  2485|         0|            0|            0|  0.00%|
  2486|         0|            0|            0|  0.00%|    """
  2487|       176|  7.10487e-05|  4.03686e-07|  0.00%|    return _wrapreduction(a, np.logical_and, 'all', axis, None, out,
(call)|        88|    0.0010519|  1.19534e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:69 _wrapreduction
  2488|        88|            0|            0|  0.00%|                          keepdims=keepdims, where=where)
  2489|         0|            0|            0|  0.00%|
  2490|         0|            0|            0|  0.00%|
  2491|        16|            0|            0|  0.00%|def _cumsum_dispatcher(a, axis=None, dtype=None, out=None):
  2492|        16|            0|            0|  0.00%|    return (a, out)
  2493|         0|            0|            0|  0.00%|
  2494|         0|            0|            0|  0.00%|
  2495|        16|            0|            0|  0.00%|@array_function_dispatch(_cumsum_dispatcher)
  2496|         0|            0|            0|  0.00%|def cumsum(a, axis=None, dtype=None, out=None):
  2497|         0|            0|            0|  0.00%|    """
  2498|         0|            0|            0|  0.00%|    Return the cumulative sum of the elements along a given axis.
  2499|         0|            0|            0|  0.00%|
  2500|         0|            0|            0|  0.00%|    Parameters
  2501|         0|            0|            0|  0.00%|    ----------
  2502|         0|            0|            0|  0.00%|    a : array_like
  2503|         0|            0|            0|  0.00%|        Input array.
  2504|         0|            0|            0|  0.00%|    axis : int, optional
  2505|         0|            0|            0|  0.00%|        Axis along which the cumulative sum is computed. The default
  2506|         0|            0|            0|  0.00%|        (None) is to compute the cumsum over the flattened array.
  2507|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2508|         0|            0|            0|  0.00%|        Type of the returned array and of the accumulator in which the
  2509|         0|            0|            0|  0.00%|        elements are summed.  If `dtype` is not specified, it defaults
  2510|         0|            0|            0|  0.00%|        to the dtype of `a`, unless `a` has an integer dtype with a
  2511|         0|            0|            0|  0.00%|        precision less than that of the default platform integer.  In
  2512|         0|            0|            0|  0.00%|        that case, the default platform integer is used.
  2513|         0|            0|            0|  0.00%|    out : ndarray, optional
  2514|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  2515|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output
  2516|         0|            0|            0|  0.00%|        but the type will be cast if necessary. See :ref:`ufuncs-output-type` for
  2517|         0|            0|            0|  0.00%|        more details.
  2518|         0|            0|            0|  0.00%|
  2519|         0|            0|            0|  0.00%|    Returns
  2520|         0|            0|            0|  0.00%|    -------
  2521|         0|            0|            0|  0.00%|    cumsum_along_axis : ndarray.
  2522|         0|            0|            0|  0.00%|        A new array holding the result is returned unless `out` is
  2523|         0|            0|            0|  0.00%|        specified, in which case a reference to `out` is returned. The
  2524|         0|            0|            0|  0.00%|        result has the same size as `a`, and the same shape as `a` if
  2525|         0|            0|            0|  0.00%|        `axis` is not None or `a` is a 1-d array.
  2526|         0|            0|            0|  0.00%|
  2527|         0|            0|            0|  0.00%|    See Also
  2528|         0|            0|            0|  0.00%|    --------
  2529|         0|            0|            0|  0.00%|    sum : Sum array elements.
  2530|         0|            0|            0|  0.00%|    trapz : Integration of array values using the composite trapezoidal rule.
  2531|         0|            0|            0|  0.00%|    diff : Calculate the n-th discrete difference along given axis.
  2532|         0|            0|            0|  0.00%|
  2533|         0|            0|            0|  0.00%|    Notes
  2534|         0|            0|            0|  0.00%|    -----
  2535|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  2536|         0|            0|            0|  0.00%|    raised on overflow.
  2537|         0|            0|            0|  0.00%|
  2538|         0|            0|            0|  0.00%|    ``cumsum(a)[-1]`` may not be equal to ``sum(a)`` for floating-point
  2539|         0|            0|            0|  0.00%|    values since ``sum`` may use a pairwise summation routine, reducing
  2540|         0|            0|            0|  0.00%|    the roundoff-error. See `sum` for more information.
  2541|         0|            0|            0|  0.00%|
  2542|         0|            0|            0|  0.00%|    Examples
  2543|         0|            0|            0|  0.00%|    --------
  2544|         0|            0|            0|  0.00%|    >>> a = np.array([[1,2,3], [4,5,6]])
  2545|         0|            0|            0|  0.00%|    >>> a
  2546|         0|            0|            0|  0.00%|    array([[1, 2, 3],
  2547|         0|            0|            0|  0.00%|           [4, 5, 6]])
  2548|         0|            0|            0|  0.00%|    >>> np.cumsum(a)
  2549|         0|            0|            0|  0.00%|    array([ 1,  3,  6, 10, 15, 21])
  2550|         0|            0|            0|  0.00%|    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
  2551|         0|            0|            0|  0.00%|    array([  1.,   3.,   6.,  10.,  15.,  21.])
  2552|         0|            0|            0|  0.00%|
  2553|         0|            0|            0|  0.00%|    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
  2554|         0|            0|            0|  0.00%|    array([[1, 2, 3],
  2555|         0|            0|            0|  0.00%|           [5, 7, 9]])
  2556|         0|            0|            0|  0.00%|    >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
  2557|         0|            0|            0|  0.00%|    array([[ 1,  3,  6],
  2558|         0|            0|            0|  0.00%|           [ 4,  9, 15]])
  2559|         0|            0|            0|  0.00%|
  2560|         0|            0|            0|  0.00%|    ``cumsum(b)[-1]`` may not be equal to ``sum(b)``
  2561|         0|            0|            0|  0.00%|
  2562|         0|            0|            0|  0.00%|    >>> b = np.array([1, 2e-9, 3e-9] * 1000000)
  2563|         0|            0|            0|  0.00%|    >>> b.cumsum()[-1]
  2564|         0|            0|            0|  0.00%|    1000000.0050045159
  2565|         0|            0|            0|  0.00%|    >>> b.sum()
  2566|         0|            0|            0|  0.00%|    1000000.0050000029
  2567|         0|            0|            0|  0.00%|
  2568|         0|            0|            0|  0.00%|    """
  2569|        16|            0|            0|  0.00%|    return _wrapfunc(a, 'cumsum', axis=axis, dtype=dtype, out=out)
(call)|        16|  0.000995398|  6.22123e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:51 _wrapfunc
  2570|         0|            0|            0|  0.00%|
  2571|         0|            0|            0|  0.00%|
  2572|         0|            0|            0|  0.00%|def _ptp_dispatcher(a, axis=None, out=None, keepdims=None):
  2573|         0|            0|            0|  0.00%|    return (a, out)
  2574|         0|            0|            0|  0.00%|
  2575|         0|            0|            0|  0.00%|
  2576|         0|            0|            0|  0.00%|@array_function_dispatch(_ptp_dispatcher)
  2577|         0|            0|            0|  0.00%|def ptp(a, axis=None, out=None, keepdims=np._NoValue):
  2578|         0|            0|            0|  0.00%|    """
  2579|         0|            0|            0|  0.00%|    Range of values (maximum - minimum) along an axis.
  2580|         0|            0|            0|  0.00%|
  2581|         0|            0|            0|  0.00%|    The name of the function comes from the acronym for 'peak to peak'.
  2582|         0|            0|            0|  0.00%|
  2583|         0|            0|            0|  0.00%|    .. warning::
  2584|         0|            0|            0|  0.00%|        `ptp` preserves the data type of the array. This means the
  2585|         0|            0|            0|  0.00%|        return value for an input of signed integers with n bits
  2586|         0|            0|            0|  0.00%|        (e.g. `np.int8`, `np.int16`, etc) is also a signed integer
  2587|         0|            0|            0|  0.00%|        with n bits.  In that case, peak-to-peak values greater than
  2588|         0|            0|            0|  0.00%|        ``2**(n-1)-1`` will be returned as negative values. An example
  2589|         0|            0|            0|  0.00%|        with a work-around is shown below.
  2590|         0|            0|            0|  0.00%|
  2591|         0|            0|            0|  0.00%|    Parameters
  2592|         0|            0|            0|  0.00%|    ----------
  2593|         0|            0|            0|  0.00%|    a : array_like
  2594|         0|            0|            0|  0.00%|        Input values.
  2595|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2596|         0|            0|            0|  0.00%|        Axis along which to find the peaks.  By default, flatten the
  2597|         0|            0|            0|  0.00%|        array.  `axis` may be negative, in
  2598|         0|            0|            0|  0.00%|        which case it counts from the last to the first axis.
  2599|         0|            0|            0|  0.00%|
  2600|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2601|         0|            0|            0|  0.00%|
  2602|         0|            0|            0|  0.00%|        If this is a tuple of ints, a reduction is performed on multiple
  2603|         0|            0|            0|  0.00%|        axes, instead of a single axis or all the axes as before.
  2604|         0|            0|            0|  0.00%|    out : array_like
  2605|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  2606|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output,
  2607|         0|            0|            0|  0.00%|        but the type of the output values will be cast if necessary.
  2608|         0|            0|            0|  0.00%|
  2609|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2610|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2611|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2612|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2613|         0|            0|            0|  0.00%|
  2614|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2615|         0|            0|            0|  0.00%|        passed through to the `ptp` method of sub-classes of
  2616|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2617|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2618|         0|            0|            0|  0.00%|        exceptions will be raised.
  2619|         0|            0|            0|  0.00%|
  2620|         0|            0|            0|  0.00%|    Returns
  2621|         0|            0|            0|  0.00%|    -------
  2622|         0|            0|            0|  0.00%|    ptp : ndarray
  2623|         0|            0|            0|  0.00%|        A new array holding the result, unless `out` was
  2624|         0|            0|            0|  0.00%|        specified, in which case a reference to `out` is returned.
  2625|         0|            0|            0|  0.00%|
  2626|         0|            0|            0|  0.00%|    Examples
  2627|         0|            0|            0|  0.00%|    --------
  2628|         0|            0|            0|  0.00%|    >>> x = np.array([[4, 9, 2, 10],
  2629|         0|            0|            0|  0.00%|    ...               [6, 9, 7, 12]])
  2630|         0|            0|            0|  0.00%|
  2631|         0|            0|            0|  0.00%|    >>> np.ptp(x, axis=1)
  2632|         0|            0|            0|  0.00%|    array([8, 6])
  2633|         0|            0|            0|  0.00%|
  2634|         0|            0|            0|  0.00%|    >>> np.ptp(x, axis=0)
  2635|         0|            0|            0|  0.00%|    array([2, 0, 5, 2])
  2636|         0|            0|            0|  0.00%|
  2637|         0|            0|            0|  0.00%|    >>> np.ptp(x)
  2638|         0|            0|            0|  0.00%|    10
  2639|         0|            0|            0|  0.00%|
  2640|         0|            0|            0|  0.00%|    This example shows that a negative value can be returned when
  2641|         0|            0|            0|  0.00%|    the input is an array of signed integers.
  2642|         0|            0|            0|  0.00%|
  2643|         0|            0|            0|  0.00%|    >>> y = np.array([[1, 127],
  2644|         0|            0|            0|  0.00%|    ...               [0, 127],
  2645|         0|            0|            0|  0.00%|    ...               [-1, 127],
  2646|         0|            0|            0|  0.00%|    ...               [-2, 127]], dtype=np.int8)
  2647|         0|            0|            0|  0.00%|    >>> np.ptp(y, axis=1)
  2648|         0|            0|            0|  0.00%|    array([ 126,  127, -128, -127], dtype=int8)
  2649|         0|            0|            0|  0.00%|
  2650|         0|            0|            0|  0.00%|    A work-around is to use the `view()` method to view the result as
  2651|         0|            0|            0|  0.00%|    unsigned integers with the same bit width:
  2652|         0|            0|            0|  0.00%|
  2653|         0|            0|            0|  0.00%|    >>> np.ptp(y, axis=1).view(np.uint8)
  2654|         0|            0|            0|  0.00%|    array([126, 127, 128, 129], dtype=uint8)
  2655|         0|            0|            0|  0.00%|
  2656|         0|            0|            0|  0.00%|    """
  2657|         0|            0|            0|  0.00%|    kwargs = {}
  2658|         0|            0|            0|  0.00%|    if keepdims is not np._NoValue:
  2659|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  2660|         0|            0|            0|  0.00%|    if type(a) is not mu.ndarray:
  2661|         0|            0|            0|  0.00%|        try:
  2662|         0|            0|            0|  0.00%|            ptp = a.ptp
  2663|         0|            0|            0|  0.00%|        except AttributeError:
  2664|         0|            0|            0|  0.00%|            pass
  2665|         0|            0|            0|  0.00%|        else:
  2666|         0|            0|            0|  0.00%|            return ptp(axis=axis, out=out, **kwargs)
  2667|         0|            0|            0|  0.00%|    return _methods._ptp(a, axis=axis, out=out, **kwargs)
  2668|         0|            0|            0|  0.00%|
  2669|         0|            0|            0|  0.00%|
  2670|         0|            0|            0|  0.00%|def _amax_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,
  2671|         0|            0|            0|  0.00%|                     where=None):
  2672|         0|            0|            0|  0.00%|    return (a, out)
  2673|         0|            0|            0|  0.00%|
  2674|         0|            0|            0|  0.00%|
  2675|         0|            0|            0|  0.00%|@array_function_dispatch(_amax_dispatcher)
  2676|         0|            0|            0|  0.00%|def amax(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,
  2677|         0|            0|            0|  0.00%|         where=np._NoValue):
  2678|         0|            0|            0|  0.00%|    """
  2679|         0|            0|            0|  0.00%|    Return the maximum of an array or maximum along an axis.
  2680|         0|            0|            0|  0.00%|
  2681|         0|            0|            0|  0.00%|    Parameters
  2682|         0|            0|            0|  0.00%|    ----------
  2683|         0|            0|            0|  0.00%|    a : array_like
  2684|         0|            0|            0|  0.00%|        Input data.
  2685|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2686|         0|            0|            0|  0.00%|        Axis or axes along which to operate.  By default, flattened input is
  2687|         0|            0|            0|  0.00%|        used.
  2688|         0|            0|            0|  0.00%|
  2689|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2690|         0|            0|            0|  0.00%|
  2691|         0|            0|            0|  0.00%|        If this is a tuple of ints, the maximum is selected over multiple axes,
  2692|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  2693|         0|            0|            0|  0.00%|    out : ndarray, optional
  2694|         0|            0|            0|  0.00%|        Alternative output array in which to place the result.  Must
  2695|         0|            0|            0|  0.00%|        be of the same shape and buffer length as the expected output.
  2696|         0|            0|            0|  0.00%|        See :ref:`ufuncs-output-type` for more details.
  2697|         0|            0|            0|  0.00%|
  2698|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2699|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2700|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2701|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2702|         0|            0|            0|  0.00%|
  2703|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2704|         0|            0|            0|  0.00%|        passed through to the `amax` method of sub-classes of
  2705|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2706|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2707|         0|            0|            0|  0.00%|        exceptions will be raised.
  2708|         0|            0|            0|  0.00%|
  2709|         0|            0|            0|  0.00%|    initial : scalar, optional
  2710|         0|            0|            0|  0.00%|        The minimum value of an output element. Must be present to allow
  2711|         0|            0|            0|  0.00%|        computation on empty slice. See `~numpy.ufunc.reduce` for details.
  2712|         0|            0|            0|  0.00%|
  2713|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2714|         0|            0|            0|  0.00%|
  2715|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2716|         0|            0|            0|  0.00%|        Elements to compare for the maximum. See `~numpy.ufunc.reduce`
  2717|         0|            0|            0|  0.00%|        for details.
  2718|         0|            0|            0|  0.00%|
  2719|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2720|         0|            0|            0|  0.00%|
  2721|         0|            0|            0|  0.00%|    Returns
  2722|         0|            0|            0|  0.00%|    -------
  2723|         0|            0|            0|  0.00%|    amax : ndarray or scalar
  2724|         0|            0|            0|  0.00%|        Maximum of `a`. If `axis` is None, the result is a scalar value.
  2725|         0|            0|            0|  0.00%|        If `axis` is given, the result is an array of dimension
  2726|         0|            0|            0|  0.00%|        ``a.ndim - 1``.
  2727|         0|            0|            0|  0.00%|
  2728|         0|            0|            0|  0.00%|    See Also
  2729|         0|            0|            0|  0.00%|    --------
  2730|         0|            0|            0|  0.00%|    amin :
  2731|         0|            0|            0|  0.00%|        The minimum value of an array along a given axis, propagating any NaNs.
  2732|         0|            0|            0|  0.00%|    nanmax :
  2733|         0|            0|            0|  0.00%|        The maximum value of an array along a given axis, ignoring any NaNs.
  2734|         0|            0|            0|  0.00%|    maximum :
  2735|         0|            0|            0|  0.00%|        Element-wise maximum of two arrays, propagating any NaNs.
  2736|         0|            0|            0|  0.00%|    fmax :
  2737|         0|            0|            0|  0.00%|        Element-wise maximum of two arrays, ignoring any NaNs.
  2738|         0|            0|            0|  0.00%|    argmax :
  2739|         0|            0|            0|  0.00%|        Return the indices of the maximum values.
  2740|         0|            0|            0|  0.00%|
  2741|         0|            0|            0|  0.00%|    nanmin, minimum, fmin
  2742|         0|            0|            0|  0.00%|
  2743|         0|            0|            0|  0.00%|    Notes
  2744|         0|            0|            0|  0.00%|    -----
  2745|         0|            0|            0|  0.00%|    NaN values are propagated, that is if at least one item is NaN, the
  2746|         0|            0|            0|  0.00%|    corresponding max value will be NaN as well. To ignore NaN values
  2747|         0|            0|            0|  0.00%|    (MATLAB behavior), please use nanmax.
  2748|         0|            0|            0|  0.00%|
  2749|         0|            0|            0|  0.00%|    Don't use `amax` for element-wise comparison of 2 arrays; when
  2750|         0|            0|            0|  0.00%|    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
  2751|         0|            0|            0|  0.00%|    ``amax(a, axis=0)``.
  2752|         0|            0|            0|  0.00%|
  2753|         0|            0|            0|  0.00%|    Examples
  2754|         0|            0|            0|  0.00%|    --------
  2755|         0|            0|            0|  0.00%|    >>> a = np.arange(4).reshape((2,2))
  2756|         0|            0|            0|  0.00%|    >>> a
  2757|         0|            0|            0|  0.00%|    array([[0, 1],
  2758|         0|            0|            0|  0.00%|           [2, 3]])
  2759|         0|            0|            0|  0.00%|    >>> np.amax(a)           # Maximum of the flattened array
  2760|         0|            0|            0|  0.00%|    3
  2761|         0|            0|            0|  0.00%|    >>> np.amax(a, axis=0)   # Maxima along the first axis
  2762|         0|            0|            0|  0.00%|    array([2, 3])
  2763|         0|            0|            0|  0.00%|    >>> np.amax(a, axis=1)   # Maxima along the second axis
  2764|         0|            0|            0|  0.00%|    array([1, 3])
  2765|         0|            0|            0|  0.00%|    >>> np.amax(a, where=[False, True], initial=-1, axis=0)
  2766|         0|            0|            0|  0.00%|    array([-1,  3])
  2767|         0|            0|            0|  0.00%|    >>> b = np.arange(5, dtype=float)
  2768|         0|            0|            0|  0.00%|    >>> b[2] = np.NaN
  2769|         0|            0|            0|  0.00%|    >>> np.amax(b)
  2770|         0|            0|            0|  0.00%|    nan
  2771|         0|            0|            0|  0.00%|    >>> np.amax(b, where=~np.isnan(b), initial=-1)
  2772|         0|            0|            0|  0.00%|    4.0
  2773|         0|            0|            0|  0.00%|    >>> np.nanmax(b)
  2774|         0|            0|            0|  0.00%|    4.0
  2775|         0|            0|            0|  0.00%|
  2776|         0|            0|            0|  0.00%|    You can use an initial value to compute the maximum of an empty slice, or
  2777|         0|            0|            0|  0.00%|    to initialize it to a different value:
  2778|         0|            0|            0|  0.00%|
  2779|         0|            0|            0|  0.00%|    >>> np.amax([[-50], [10]], axis=-1, initial=0)
  2780|         0|            0|            0|  0.00%|    array([ 0, 10])
  2781|         0|            0|            0|  0.00%|
  2782|         0|            0|            0|  0.00%|    Notice that the initial value is used as one of the elements for which the
  2783|         0|            0|            0|  0.00%|    maximum is determined, unlike for the default argument Python's max
  2784|         0|            0|            0|  0.00%|    function, which is only used for empty iterables.
  2785|         0|            0|            0|  0.00%|
  2786|         0|            0|            0|  0.00%|    >>> np.amax([5], initial=6)
  2787|         0|            0|            0|  0.00%|    6
  2788|         0|            0|            0|  0.00%|    >>> max([5], default=6)
  2789|         0|            0|            0|  0.00%|    5
  2790|         0|            0|            0|  0.00%|    """
  2791|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.maximum, 'max', axis, None, out,
  2792|         0|            0|            0|  0.00%|                          keepdims=keepdims, initial=initial, where=where)
  2793|         0|            0|            0|  0.00%|
  2794|         0|            0|            0|  0.00%|
  2795|         0|            0|            0|  0.00%|def _amin_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,
  2796|         0|            0|            0|  0.00%|                     where=None):
  2797|         0|            0|            0|  0.00%|    return (a, out)
  2798|         0|            0|            0|  0.00%|
  2799|         0|            0|            0|  0.00%|
  2800|         0|            0|            0|  0.00%|@array_function_dispatch(_amin_dispatcher)
  2801|         0|            0|            0|  0.00%|def amin(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,
  2802|         0|            0|            0|  0.00%|         where=np._NoValue):
  2803|         0|            0|            0|  0.00%|    """
  2804|         0|            0|            0|  0.00%|    Return the minimum of an array or minimum along an axis.
  2805|         0|            0|            0|  0.00%|
  2806|         0|            0|            0|  0.00%|    Parameters
  2807|         0|            0|            0|  0.00%|    ----------
  2808|         0|            0|            0|  0.00%|    a : array_like
  2809|         0|            0|            0|  0.00%|        Input data.
  2810|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2811|         0|            0|            0|  0.00%|        Axis or axes along which to operate.  By default, flattened input is
  2812|         0|            0|            0|  0.00%|        used.
  2813|         0|            0|            0|  0.00%|
  2814|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2815|         0|            0|            0|  0.00%|
  2816|         0|            0|            0|  0.00%|        If this is a tuple of ints, the minimum is selected over multiple axes,
  2817|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  2818|         0|            0|            0|  0.00%|    out : ndarray, optional
  2819|         0|            0|            0|  0.00%|        Alternative output array in which to place the result.  Must
  2820|         0|            0|            0|  0.00%|        be of the same shape and buffer length as the expected output.
  2821|         0|            0|            0|  0.00%|        See :ref:`ufuncs-output-type` for more details.
  2822|         0|            0|            0|  0.00%|
  2823|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2824|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2825|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2826|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2827|         0|            0|            0|  0.00%|
  2828|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2829|         0|            0|            0|  0.00%|        passed through to the `amin` method of sub-classes of
  2830|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2831|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2832|         0|            0|            0|  0.00%|        exceptions will be raised.
  2833|         0|            0|            0|  0.00%|
  2834|         0|            0|            0|  0.00%|    initial : scalar, optional
  2835|         0|            0|            0|  0.00%|        The maximum value of an output element. Must be present to allow
  2836|         0|            0|            0|  0.00%|        computation on empty slice. See `~numpy.ufunc.reduce` for details.
  2837|         0|            0|            0|  0.00%|
  2838|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2839|         0|            0|            0|  0.00%|
  2840|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2841|         0|            0|            0|  0.00%|        Elements to compare for the minimum. See `~numpy.ufunc.reduce`
  2842|         0|            0|            0|  0.00%|        for details.
  2843|         0|            0|            0|  0.00%|
  2844|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2845|         0|            0|            0|  0.00%|
  2846|         0|            0|            0|  0.00%|    Returns
  2847|         0|            0|            0|  0.00%|    -------
  2848|         0|            0|            0|  0.00%|    amin : ndarray or scalar
  2849|         0|            0|            0|  0.00%|        Minimum of `a`. If `axis` is None, the result is a scalar value.
  2850|         0|            0|            0|  0.00%|        If `axis` is given, the result is an array of dimension
  2851|         0|            0|            0|  0.00%|        ``a.ndim - 1``.
  2852|         0|            0|            0|  0.00%|
  2853|         0|            0|            0|  0.00%|    See Also
  2854|         0|            0|            0|  0.00%|    --------
  2855|         0|            0|            0|  0.00%|    amax :
  2856|         0|            0|            0|  0.00%|        The maximum value of an array along a given axis, propagating any NaNs.
  2857|         0|            0|            0|  0.00%|    nanmin :
  2858|         0|            0|            0|  0.00%|        The minimum value of an array along a given axis, ignoring any NaNs.
  2859|         0|            0|            0|  0.00%|    minimum :
  2860|         0|            0|            0|  0.00%|        Element-wise minimum of two arrays, propagating any NaNs.
  2861|         0|            0|            0|  0.00%|    fmin :
  2862|         0|            0|            0|  0.00%|        Element-wise minimum of two arrays, ignoring any NaNs.
  2863|         0|            0|            0|  0.00%|    argmin :
  2864|         0|            0|            0|  0.00%|        Return the indices of the minimum values.
  2865|         0|            0|            0|  0.00%|
  2866|         0|            0|            0|  0.00%|    nanmax, maximum, fmax
  2867|         0|            0|            0|  0.00%|
  2868|         0|            0|            0|  0.00%|    Notes
  2869|         0|            0|            0|  0.00%|    -----
  2870|         0|            0|            0|  0.00%|    NaN values are propagated, that is if at least one item is NaN, the
  2871|         0|            0|            0|  0.00%|    corresponding min value will be NaN as well. To ignore NaN values
  2872|         0|            0|            0|  0.00%|    (MATLAB behavior), please use nanmin.
  2873|         0|            0|            0|  0.00%|
  2874|         0|            0|            0|  0.00%|    Don't use `amin` for element-wise comparison of 2 arrays; when
  2875|         0|            0|            0|  0.00%|    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
  2876|         0|            0|            0|  0.00%|    ``amin(a, axis=0)``.
  2877|         0|            0|            0|  0.00%|
  2878|         0|            0|            0|  0.00%|    Examples
  2879|         0|            0|            0|  0.00%|    --------
  2880|         0|            0|            0|  0.00%|    >>> a = np.arange(4).reshape((2,2))
  2881|         0|            0|            0|  0.00%|    >>> a
  2882|         0|            0|            0|  0.00%|    array([[0, 1],
  2883|         0|            0|            0|  0.00%|           [2, 3]])
  2884|         0|            0|            0|  0.00%|    >>> np.amin(a)           # Minimum of the flattened array
  2885|         0|            0|            0|  0.00%|    0
  2886|         0|            0|            0|  0.00%|    >>> np.amin(a, axis=0)   # Minima along the first axis
  2887|         0|            0|            0|  0.00%|    array([0, 1])
  2888|         0|            0|            0|  0.00%|    >>> np.amin(a, axis=1)   # Minima along the second axis
  2889|         0|            0|            0|  0.00%|    array([0, 2])
  2890|         0|            0|            0|  0.00%|    >>> np.amin(a, where=[False, True], initial=10, axis=0)
  2891|         0|            0|            0|  0.00%|    array([10,  1])
  2892|         0|            0|            0|  0.00%|
  2893|         0|            0|            0|  0.00%|    >>> b = np.arange(5, dtype=float)
  2894|         0|            0|            0|  0.00%|    >>> b[2] = np.NaN
  2895|         0|            0|            0|  0.00%|    >>> np.amin(b)
  2896|         0|            0|            0|  0.00%|    nan
  2897|         0|            0|            0|  0.00%|    >>> np.amin(b, where=~np.isnan(b), initial=10)
  2898|         0|            0|            0|  0.00%|    0.0
  2899|         0|            0|            0|  0.00%|    >>> np.nanmin(b)
  2900|         0|            0|            0|  0.00%|    0.0
  2901|         0|            0|            0|  0.00%|
  2902|         0|            0|            0|  0.00%|    >>> np.amin([[-50], [10]], axis=-1, initial=0)
  2903|         0|            0|            0|  0.00%|    array([-50,   0])
  2904|         0|            0|            0|  0.00%|
  2905|         0|            0|            0|  0.00%|    Notice that the initial value is used as one of the elements for which the
  2906|         0|            0|            0|  0.00%|    minimum is determined, unlike for the default argument Python's max
  2907|         0|            0|            0|  0.00%|    function, which is only used for empty iterables.
  2908|         0|            0|            0|  0.00%|
  2909|         0|            0|            0|  0.00%|    Notice that this isn't the same as Python's ``default`` argument.
  2910|         0|            0|            0|  0.00%|
  2911|         0|            0|            0|  0.00%|    >>> np.amin([6], initial=5)
  2912|         0|            0|            0|  0.00%|    5
  2913|         0|            0|            0|  0.00%|    >>> min([6], default=5)
  2914|         0|            0|            0|  0.00%|    6
  2915|         0|            0|            0|  0.00%|    """
  2916|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.minimum, 'min', axis, None, out,
  2917|         0|            0|            0|  0.00%|                          keepdims=keepdims, initial=initial, where=where)
  2918|         0|            0|            0|  0.00%|
  2919|         0|            0|            0|  0.00%|
  2920|         0|            0|            0|  0.00%|def _alen_dispathcer(a):
  2921|         0|            0|            0|  0.00%|    return (a,)
  2922|         0|            0|            0|  0.00%|
  2923|         0|            0|            0|  0.00%|
  2924|         0|            0|            0|  0.00%|@array_function_dispatch(_alen_dispathcer)
  2925|         0|            0|            0|  0.00%|def alen(a):
  2926|         0|            0|            0|  0.00%|    """
  2927|         0|            0|            0|  0.00%|    Return the length of the first dimension of the input array.
  2928|         0|            0|            0|  0.00%|
  2929|         0|            0|            0|  0.00%|    .. deprecated:: 1.18
  2930|         0|            0|            0|  0.00%|       `numpy.alen` is deprecated, use `len` instead.
  2931|         0|            0|            0|  0.00%|
  2932|         0|            0|            0|  0.00%|    Parameters
  2933|         0|            0|            0|  0.00%|    ----------
  2934|         0|            0|            0|  0.00%|    a : array_like
  2935|         0|            0|            0|  0.00%|       Input array.
  2936|         0|            0|            0|  0.00%|
  2937|         0|            0|            0|  0.00%|    Returns
  2938|         0|            0|            0|  0.00%|    -------
  2939|         0|            0|            0|  0.00%|    alen : int
  2940|         0|            0|            0|  0.00%|       Length of the first dimension of `a`.
  2941|         0|            0|            0|  0.00%|
  2942|         0|            0|            0|  0.00%|    See Also
  2943|         0|            0|            0|  0.00%|    --------
  2944|         0|            0|            0|  0.00%|    shape, size
  2945|         0|            0|            0|  0.00%|
  2946|         0|            0|            0|  0.00%|    Examples
  2947|         0|            0|            0|  0.00%|    --------
  2948|         0|            0|            0|  0.00%|    >>> a = np.zeros((7,4,5))
  2949|         0|            0|            0|  0.00%|    >>> a.shape[0]
  2950|         0|            0|            0|  0.00%|    7
  2951|         0|            0|            0|  0.00%|    >>> np.alen(a)
  2952|         0|            0|            0|  0.00%|    7
  2953|         0|            0|            0|  0.00%|
  2954|         0|            0|            0|  0.00%|    """
  2955|         0|            0|            0|  0.00%|    # NumPy 1.18.0, 2019-08-02
  2956|         0|            0|            0|  0.00%|    warnings.warn(
  2957|         0|            0|            0|  0.00%|        "`np.alen` is deprecated, use `len` instead",
  2958|         0|            0|            0|  0.00%|        DeprecationWarning, stacklevel=2)
  2959|         0|            0|            0|  0.00%|    try:
  2960|         0|            0|            0|  0.00%|        return len(a)
  2961|         0|            0|            0|  0.00%|    except TypeError:
  2962|         0|            0|            0|  0.00%|        return len(array(a, ndmin=1))
  2963|         0|            0|            0|  0.00%|
  2964|         0|            0|            0|  0.00%|
  2965|         0|            0|            0|  0.00%|def _prod_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,
  2966|         0|            0|            0|  0.00%|                     initial=None, where=None):
  2967|         0|            0|            0|  0.00%|    return (a, out)
  2968|         0|            0|            0|  0.00%|
  2969|         0|            0|            0|  0.00%|
  2970|         0|            0|            0|  0.00%|@array_function_dispatch(_prod_dispatcher)
  2971|         0|            0|            0|  0.00%|def prod(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,
  2972|         0|            0|            0|  0.00%|         initial=np._NoValue, where=np._NoValue):
  2973|         0|            0|            0|  0.00%|    """
  2974|         0|            0|            0|  0.00%|    Return the product of array elements over a given axis.
  2975|         0|            0|            0|  0.00%|
  2976|         0|            0|            0|  0.00%|    Parameters
  2977|         0|            0|            0|  0.00%|    ----------
  2978|         0|            0|            0|  0.00%|    a : array_like
  2979|         0|            0|            0|  0.00%|        Input data.
  2980|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2981|         0|            0|            0|  0.00%|        Axis or axes along which a product is performed.  The default,
  2982|         0|            0|            0|  0.00%|        axis=None, will calculate the product of all the elements in the
  2983|         0|            0|            0|  0.00%|        input array. If axis is negative it counts from the last to the
  2984|         0|            0|            0|  0.00%|        first axis.
  2985|         0|            0|            0|  0.00%|
  2986|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2987|         0|            0|            0|  0.00%|
  2988|         0|            0|            0|  0.00%|        If axis is a tuple of ints, a product is performed on all of the
  2989|         0|            0|            0|  0.00%|        axes specified in the tuple instead of a single axis or all the
  2990|         0|            0|            0|  0.00%|        axes as before.
  2991|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2992|         0|            0|            0|  0.00%|        The type of the returned array, as well as of the accumulator in
  2993|         0|            0|            0|  0.00%|        which the elements are multiplied.  The dtype of `a` is used by
  2994|         0|            0|            0|  0.00%|        default unless `a` has an integer dtype of less precision than the
  2995|         0|            0|            0|  0.00%|        default platform integer.  In that case, if `a` is signed then the
  2996|         0|            0|            0|  0.00%|        platform integer is used while if `a` is unsigned then an unsigned
  2997|         0|            0|            0|  0.00%|        integer of the same precision as the platform integer is used.
  2998|         0|            0|            0|  0.00%|    out : ndarray, optional
  2999|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  3000|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type of the output
  3001|         0|            0|            0|  0.00%|        values will be cast if necessary.
  3002|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3003|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left in the
  3004|         0|            0|            0|  0.00%|        result as dimensions with size one. With this option, the result
  3005|         0|            0|            0|  0.00%|        will broadcast correctly against the input array.
  3006|         0|            0|            0|  0.00%|
  3007|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  3008|         0|            0|            0|  0.00%|        passed through to the `prod` method of sub-classes of
  3009|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  3010|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  3011|         0|            0|            0|  0.00%|        exceptions will be raised.
  3012|         0|            0|            0|  0.00%|    initial : scalar, optional
  3013|         0|            0|            0|  0.00%|        The starting value for this product. See `~numpy.ufunc.reduce` for details.
  3014|         0|            0|            0|  0.00%|
  3015|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  3016|         0|            0|            0|  0.00%|
  3017|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  3018|         0|            0|            0|  0.00%|        Elements to include in the product. See `~numpy.ufunc.reduce` for details.
  3019|         0|            0|            0|  0.00%|
  3020|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  3021|         0|            0|            0|  0.00%|
  3022|         0|            0|            0|  0.00%|    Returns
  3023|         0|            0|            0|  0.00%|    -------
  3024|         0|            0|            0|  0.00%|    product_along_axis : ndarray, see `dtype` parameter above.
  3025|         0|            0|            0|  0.00%|        An array shaped as `a` but with the specified axis removed.
  3026|         0|            0|            0|  0.00%|        Returns a reference to `out` if specified.
  3027|         0|            0|            0|  0.00%|
  3028|         0|            0|            0|  0.00%|    See Also
  3029|         0|            0|            0|  0.00%|    --------
  3030|         0|            0|            0|  0.00%|    ndarray.prod : equivalent method
  3031|         0|            0|            0|  0.00%|    :ref:`ufuncs-output-type`
  3032|         0|            0|            0|  0.00%|
  3033|         0|            0|            0|  0.00%|    Notes
  3034|         0|            0|            0|  0.00%|    -----
  3035|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  3036|         0|            0|            0|  0.00%|    raised on overflow.  That means that, on a 32-bit platform:
  3037|         0|            0|            0|  0.00%|
  3038|         0|            0|            0|  0.00%|    >>> x = np.array([536870910, 536870910, 536870910, 536870910])
  3039|         0|            0|            0|  0.00%|    >>> np.prod(x)
  3040|         0|            0|            0|  0.00%|    16 # may vary
  3041|         0|            0|            0|  0.00%|
  3042|         0|            0|            0|  0.00%|    The product of an empty array is the neutral element 1:
  3043|         0|            0|            0|  0.00%|
  3044|         0|            0|            0|  0.00%|    >>> np.prod([])
  3045|         0|            0|            0|  0.00%|    1.0
  3046|         0|            0|            0|  0.00%|
  3047|         0|            0|            0|  0.00%|    Examples
  3048|         0|            0|            0|  0.00%|    --------
  3049|         0|            0|            0|  0.00%|    By default, calculate the product of all elements:
  3050|         0|            0|            0|  0.00%|
  3051|         0|            0|            0|  0.00%|    >>> np.prod([1.,2.])
  3052|         0|            0|            0|  0.00%|    2.0
  3053|         0|            0|            0|  0.00%|
  3054|         0|            0|            0|  0.00%|    Even when the input array is two-dimensional:
  3055|         0|            0|            0|  0.00%|
  3056|         0|            0|            0|  0.00%|    >>> np.prod([[1.,2.],[3.,4.]])
  3057|         0|            0|            0|  0.00%|    24.0
  3058|         0|            0|            0|  0.00%|
  3059|         0|            0|            0|  0.00%|    But we can also specify the axis over which to multiply:
  3060|         0|            0|            0|  0.00%|
  3061|         0|            0|            0|  0.00%|    >>> np.prod([[1.,2.],[3.,4.]], axis=1)
  3062|         0|            0|            0|  0.00%|    array([  2.,  12.])
  3063|         0|            0|            0|  0.00%|
  3064|         0|            0|            0|  0.00%|    Or select specific elements to include:
  3065|         0|            0|            0|  0.00%|
  3066|         0|            0|            0|  0.00%|    >>> np.prod([1., np.nan, 3.], where=[True, False, True])
  3067|         0|            0|            0|  0.00%|    3.0
  3068|         0|            0|            0|  0.00%|
  3069|         0|            0|            0|  0.00%|    If the type of `x` is unsigned, then the output type is
  3070|         0|            0|            0|  0.00%|    the unsigned platform integer:
  3071|         0|            0|            0|  0.00%|
  3072|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 3], dtype=np.uint8)
  3073|         0|            0|            0|  0.00%|    >>> np.prod(x).dtype == np.uint
  3074|         0|            0|            0|  0.00%|    True
  3075|         0|            0|            0|  0.00%|
  3076|         0|            0|            0|  0.00%|    If `x` is of a signed integer type, then the output type
  3077|         0|            0|            0|  0.00%|    is the default platform integer:
  3078|         0|            0|            0|  0.00%|
  3079|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 3], dtype=np.int8)
  3080|         0|            0|            0|  0.00%|    >>> np.prod(x).dtype == int
  3081|         0|            0|            0|  0.00%|    True
  3082|         0|            0|            0|  0.00%|
  3083|         0|            0|            0|  0.00%|    You can also start the product with a value other than one:
  3084|         0|            0|            0|  0.00%|
  3085|         0|            0|            0|  0.00%|    >>> np.prod([1, 2], initial=5)
  3086|         0|            0|            0|  0.00%|    10
  3087|         0|            0|            0|  0.00%|    """
  3088|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.multiply, 'prod', axis, dtype, out,
  3089|         0|            0|            0|  0.00%|                          keepdims=keepdims, initial=initial, where=where)
  3090|         0|            0|            0|  0.00%|
  3091|         0|            0|            0|  0.00%|
  3092|         0|            0|            0|  0.00%|def _cumprod_dispatcher(a, axis=None, dtype=None, out=None):
  3093|         0|            0|            0|  0.00%|    return (a, out)
  3094|         0|            0|            0|  0.00%|
  3095|         0|            0|            0|  0.00%|
  3096|         0|            0|            0|  0.00%|@array_function_dispatch(_cumprod_dispatcher)
  3097|         0|            0|            0|  0.00%|def cumprod(a, axis=None, dtype=None, out=None):
  3098|         0|            0|            0|  0.00%|    """
  3099|         0|            0|            0|  0.00%|    Return the cumulative product of elements along a given axis.
  3100|         0|            0|            0|  0.00%|
  3101|         0|            0|            0|  0.00%|    Parameters
  3102|         0|            0|            0|  0.00%|    ----------
  3103|         0|            0|            0|  0.00%|    a : array_like
  3104|         0|            0|            0|  0.00%|        Input array.
  3105|         0|            0|            0|  0.00%|    axis : int, optional
  3106|         0|            0|            0|  0.00%|        Axis along which the cumulative product is computed.  By default
  3107|         0|            0|            0|  0.00%|        the input is flattened.
  3108|         0|            0|            0|  0.00%|    dtype : dtype, optional
  3109|         0|            0|            0|  0.00%|        Type of the returned array, as well as of the accumulator in which
  3110|         0|            0|            0|  0.00%|        the elements are multiplied.  If *dtype* is not specified, it
  3111|         0|            0|            0|  0.00%|        defaults to the dtype of `a`, unless `a` has an integer dtype with
  3112|         0|            0|            0|  0.00%|        a precision less than that of the default platform integer.  In
  3113|         0|            0|            0|  0.00%|        that case, the default platform integer is used instead.
  3114|         0|            0|            0|  0.00%|    out : ndarray, optional
  3115|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  3116|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output
  3117|         0|            0|            0|  0.00%|        but the type of the resulting values will be cast if necessary.
  3118|         0|            0|            0|  0.00%|
  3119|         0|            0|            0|  0.00%|    Returns
  3120|         0|            0|            0|  0.00%|    -------
  3121|         0|            0|            0|  0.00%|    cumprod : ndarray
  3122|         0|            0|            0|  0.00%|        A new array holding the result is returned unless `out` is
  3123|         0|            0|            0|  0.00%|        specified, in which case a reference to out is returned.
  3124|         0|            0|            0|  0.00%|
  3125|         0|            0|            0|  0.00%|    See Also
  3126|         0|            0|            0|  0.00%|    --------
  3127|         0|            0|            0|  0.00%|    :ref:`ufuncs-output-type`
  3128|         0|            0|            0|  0.00%|
  3129|         0|            0|            0|  0.00%|    Notes
  3130|         0|            0|            0|  0.00%|    -----
  3131|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  3132|         0|            0|            0|  0.00%|    raised on overflow.
  3133|         0|            0|            0|  0.00%|
  3134|         0|            0|            0|  0.00%|    Examples
  3135|         0|            0|            0|  0.00%|    --------
  3136|         0|            0|            0|  0.00%|    >>> a = np.array([1,2,3])
  3137|         0|            0|            0|  0.00%|    >>> np.cumprod(a) # intermediate results 1, 1*2
  3138|         0|            0|            0|  0.00%|    ...               # total product 1*2*3 = 6
  3139|         0|            0|            0|  0.00%|    array([1, 2, 6])
  3140|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6]])
  3141|         0|            0|            0|  0.00%|    >>> np.cumprod(a, dtype=float) # specify type of output
  3142|         0|            0|            0|  0.00%|    array([   1.,    2.,    6.,   24.,  120.,  720.])
  3143|         0|            0|            0|  0.00%|
  3144|         0|            0|            0|  0.00%|    The cumulative product for each column (i.e., over the rows) of `a`:
  3145|         0|            0|            0|  0.00%|
  3146|         0|            0|            0|  0.00%|    >>> np.cumprod(a, axis=0)
  3147|         0|            0|            0|  0.00%|    array([[ 1,  2,  3],
  3148|         0|            0|            0|  0.00%|           [ 4, 10, 18]])
  3149|         0|            0|            0|  0.00%|
  3150|         0|            0|            0|  0.00%|    The cumulative product for each row (i.e. over the columns) of `a`:
  3151|         0|            0|            0|  0.00%|
  3152|         0|            0|            0|  0.00%|    >>> np.cumprod(a,axis=1)
  3153|         0|            0|            0|  0.00%|    array([[  1,   2,   6],
  3154|         0|            0|            0|  0.00%|           [  4,  20, 120]])
  3155|         0|            0|            0|  0.00%|
  3156|         0|            0|            0|  0.00%|    """
  3157|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'cumprod', axis=axis, dtype=dtype, out=out)
  3158|         0|            0|            0|  0.00%|
  3159|         0|            0|            0|  0.00%|
  3160|        16|            0|            0|  0.00%|def _ndim_dispatcher(a):
  3161|        16|            0|            0|  0.00%|    return (a,)
  3162|         0|            0|            0|  0.00%|
  3163|         0|            0|            0|  0.00%|
  3164|        16|            0|            0|  0.00%|@array_function_dispatch(_ndim_dispatcher)
  3165|         0|            0|            0|  0.00%|def ndim(a):
  3166|         0|            0|            0|  0.00%|    """
  3167|         0|            0|            0|  0.00%|    Return the number of dimensions of an array.
  3168|         0|            0|            0|  0.00%|
  3169|         0|            0|            0|  0.00%|    Parameters
  3170|         0|            0|            0|  0.00%|    ----------
  3171|         0|            0|            0|  0.00%|    a : array_like
  3172|         0|            0|            0|  0.00%|        Input array.  If it is not already an ndarray, a conversion is
  3173|         0|            0|            0|  0.00%|        attempted.
  3174|         0|            0|            0|  0.00%|
  3175|         0|            0|            0|  0.00%|    Returns
  3176|         0|            0|            0|  0.00%|    -------
  3177|         0|            0|            0|  0.00%|    number_of_dimensions : int
  3178|         0|            0|            0|  0.00%|        The number of dimensions in `a`.  Scalars are zero-dimensional.
  3179|         0|            0|            0|  0.00%|
  3180|         0|            0|            0|  0.00%|    See Also
  3181|         0|            0|            0|  0.00%|    --------
  3182|         0|            0|            0|  0.00%|    ndarray.ndim : equivalent method
  3183|         0|            0|            0|  0.00%|    shape : dimensions of array
  3184|         0|            0|            0|  0.00%|    ndarray.shape : dimensions of array
  3185|         0|            0|            0|  0.00%|
  3186|         0|            0|            0|  0.00%|    Examples
  3187|         0|            0|            0|  0.00%|    --------
  3188|         0|            0|            0|  0.00%|    >>> np.ndim([[1,2,3],[4,5,6]])
  3189|         0|            0|            0|  0.00%|    2
  3190|         0|            0|            0|  0.00%|    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))
  3191|         0|            0|            0|  0.00%|    2
  3192|         0|            0|            0|  0.00%|    >>> np.ndim(1)
  3193|         0|            0|            0|  0.00%|    0
  3194|         0|            0|            0|  0.00%|
  3195|         0|            0|            0|  0.00%|    """
  3196|        16|            0|            0|  0.00%|    try:
  3197|        16|            0|            0|  0.00%|        return a.ndim
  3198|         8|            0|            0|  0.00%|    except AttributeError:
  3199|         8|            0|            0|  0.00%|        return asarray(a).ndim
  3200|         0|            0|            0|  0.00%|
  3201|         0|            0|            0|  0.00%|
  3202|         0|            0|            0|  0.00%|def _size_dispatcher(a, axis=None):
  3203|         0|            0|            0|  0.00%|    return (a,)
  3204|         0|            0|            0|  0.00%|
  3205|         0|            0|            0|  0.00%|
  3206|         0|            0|            0|  0.00%|@array_function_dispatch(_size_dispatcher)
  3207|         0|            0|            0|  0.00%|def size(a, axis=None):
  3208|         0|            0|            0|  0.00%|    """
  3209|         0|            0|            0|  0.00%|    Return the number of elements along a given axis.
  3210|         0|            0|            0|  0.00%|
  3211|         0|            0|            0|  0.00%|    Parameters
  3212|         0|            0|            0|  0.00%|    ----------
  3213|         0|            0|            0|  0.00%|    a : array_like
  3214|         0|            0|            0|  0.00%|        Input data.
  3215|         0|            0|            0|  0.00%|    axis : int, optional
  3216|         0|            0|            0|  0.00%|        Axis along which the elements are counted.  By default, give
  3217|         0|            0|            0|  0.00%|        the total number of elements.
  3218|         0|            0|            0|  0.00%|
  3219|         0|            0|            0|  0.00%|    Returns
  3220|         0|            0|            0|  0.00%|    -------
  3221|         0|            0|            0|  0.00%|    element_count : int
  3222|         0|            0|            0|  0.00%|        Number of elements along the specified axis.
  3223|         0|            0|            0|  0.00%|
  3224|         0|            0|            0|  0.00%|    See Also
  3225|         0|            0|            0|  0.00%|    --------
  3226|         0|            0|            0|  0.00%|    shape : dimensions of array
  3227|         0|            0|            0|  0.00%|    ndarray.shape : dimensions of array
  3228|         0|            0|            0|  0.00%|    ndarray.size : number of elements in array
  3229|         0|            0|            0|  0.00%|
  3230|         0|            0|            0|  0.00%|    Examples
  3231|         0|            0|            0|  0.00%|    --------
  3232|         0|            0|            0|  0.00%|    >>> a = np.array([[1,2,3],[4,5,6]])
  3233|         0|            0|            0|  0.00%|    >>> np.size(a)
  3234|         0|            0|            0|  0.00%|    6
  3235|         0|            0|            0|  0.00%|    >>> np.size(a,1)
  3236|         0|            0|            0|  0.00%|    3
  3237|         0|            0|            0|  0.00%|    >>> np.size(a,0)
  3238|         0|            0|            0|  0.00%|    2
  3239|         0|            0|            0|  0.00%|
  3240|         0|            0|            0|  0.00%|    """
  3241|         0|            0|            0|  0.00%|    if axis is None:
  3242|         0|            0|            0|  0.00%|        try:
  3243|         0|            0|            0|  0.00%|            return a.size
  3244|         0|            0|            0|  0.00%|        except AttributeError:
  3245|         0|            0|            0|  0.00%|            return asarray(a).size
  3246|         0|            0|            0|  0.00%|    else:
  3247|         0|            0|            0|  0.00%|        try:
  3248|         0|            0|            0|  0.00%|            return a.shape[axis]
  3249|         0|            0|            0|  0.00%|        except AttributeError:
  3250|         0|            0|            0|  0.00%|            return asarray(a).shape[axis]
  3251|         0|            0|            0|  0.00%|
  3252|         0|            0|            0|  0.00%|
  3253|        16|            0|            0|  0.00%|def _around_dispatcher(a, decimals=None, out=None):
  3254|        16|            0|            0|  0.00%|    return (a, out)
  3255|         0|            0|            0|  0.00%|
  3256|         0|            0|            0|  0.00%|
  3257|         8|            0|            0|  0.00%|@array_function_dispatch(_around_dispatcher)
  3258|         0|            0|            0|  0.00%|def around(a, decimals=0, out=None):
  3259|         0|            0|            0|  0.00%|    """
  3260|         0|            0|            0|  0.00%|    Evenly round to the given number of decimals.
  3261|         0|            0|            0|  0.00%|
  3262|         0|            0|            0|  0.00%|    Parameters
  3263|         0|            0|            0|  0.00%|    ----------
  3264|         0|            0|            0|  0.00%|    a : array_like
  3265|         0|            0|            0|  0.00%|        Input data.
  3266|         0|            0|            0|  0.00%|    decimals : int, optional
  3267|         0|            0|            0|  0.00%|        Number of decimal places to round to (default: 0).  If
  3268|         0|            0|            0|  0.00%|        decimals is negative, it specifies the number of positions to
  3269|         0|            0|            0|  0.00%|        the left of the decimal point.
  3270|         0|            0|            0|  0.00%|    out : ndarray, optional
  3271|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  3272|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type of the output
  3273|         0|            0|            0|  0.00%|        values will be cast if necessary. See :ref:`ufuncs-output-type` for more
  3274|         0|            0|            0|  0.00%|        details.
  3275|         0|            0|            0|  0.00%|
  3276|         0|            0|            0|  0.00%|    Returns
  3277|         0|            0|            0|  0.00%|    -------
  3278|         0|            0|            0|  0.00%|    rounded_array : ndarray
  3279|         0|            0|            0|  0.00%|        An array of the same type as `a`, containing the rounded values.
  3280|         0|            0|            0|  0.00%|        Unless `out` was specified, a new array is created.  A reference to
  3281|         0|            0|            0|  0.00%|        the result is returned.
  3282|         0|            0|            0|  0.00%|
  3283|         0|            0|            0|  0.00%|        The real and imaginary parts of complex numbers are rounded
  3284|         0|            0|            0|  0.00%|        separately.  The result of rounding a float is a float.
  3285|         0|            0|            0|  0.00%|
  3286|         0|            0|            0|  0.00%|    See Also
  3287|         0|            0|            0|  0.00%|    --------
  3288|         0|            0|            0|  0.00%|    ndarray.round : equivalent method
  3289|         0|            0|            0|  0.00%|
  3290|         0|            0|            0|  0.00%|    ceil, fix, floor, rint, trunc
  3291|         0|            0|            0|  0.00%|
  3292|         0|            0|            0|  0.00%|
  3293|         0|            0|            0|  0.00%|    Notes
  3294|         0|            0|            0|  0.00%|    -----
  3295|         0|            0|            0|  0.00%|    For values exactly halfway between rounded decimal values, NumPy
  3296|         0|            0|            0|  0.00%|    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
  3297|         0|            0|            0|  0.00%|    -0.5 and 0.5 round to 0.0, etc.
  3298|         0|            0|            0|  0.00%|
  3299|         0|            0|            0|  0.00%|    ``np.around`` uses a fast but sometimes inexact algorithm to round
  3300|         0|            0|            0|  0.00%|    floating-point datatypes. For positive `decimals` it is equivalent to
  3301|         0|            0|            0|  0.00%|    ``np.true_divide(np.rint(a * 10**decimals), 10**decimals)``, which has
  3302|         0|            0|            0|  0.00%|    error due to the inexact representation of decimal fractions in the IEEE
  3303|         0|            0|            0|  0.00%|    floating point standard [1]_ and errors introduced when scaling by powers
  3304|         0|            0|            0|  0.00%|    of ten. For instance, note the extra "1" in the following:
  3305|         0|            0|            0|  0.00%|
  3306|         0|            0|            0|  0.00%|        >>> np.round(56294995342131.5, 3)
  3307|         0|            0|            0|  0.00%|        56294995342131.51
  3308|         0|            0|            0|  0.00%|
  3309|         0|            0|            0|  0.00%|    If your goal is to print such values with a fixed number of decimals, it is
  3310|         0|            0|            0|  0.00%|    preferable to use numpy's float printing routines to limit the number of
  3311|         0|            0|            0|  0.00%|    printed decimals:
  3312|         0|            0|            0|  0.00%|
  3313|         0|            0|            0|  0.00%|        >>> np.format_float_positional(56294995342131.5, precision=3)
  3314|         0|            0|            0|  0.00%|        '56294995342131.5'
  3315|         0|            0|            0|  0.00%|
  3316|         0|            0|            0|  0.00%|    The float printing routines use an accurate but much more computationally
  3317|         0|            0|            0|  0.00%|    demanding algorithm to compute the number of digits after the decimal
  3318|         0|            0|            0|  0.00%|    point.
  3319|         0|            0|            0|  0.00%|
  3320|         0|            0|            0|  0.00%|    Alternatively, Python's builtin `round` function uses a more accurate
  3321|         0|            0|            0|  0.00%|    but slower algorithm for 64-bit floating point values:
  3322|         0|            0|            0|  0.00%|
  3323|         0|            0|            0|  0.00%|        >>> round(56294995342131.5, 3)
  3324|         0|            0|            0|  0.00%|        56294995342131.5
  3325|         0|            0|            0|  0.00%|        >>> np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
  3326|         0|            0|            0|  0.00%|        (16.06, 16.05)
  3327|         0|            0|            0|  0.00%|
  3328|         0|            0|            0|  0.00%|
  3329|         0|            0|            0|  0.00%|    References
  3330|         0|            0|            0|  0.00%|    ----------
  3331|         0|            0|            0|  0.00%|    .. [1] "Lecture Notes on the Status of IEEE 754", William Kahan,
  3332|         0|            0|            0|  0.00%|           https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF
  3333|         0|            0|            0|  0.00%|
  3334|         0|            0|            0|  0.00%|    Examples
  3335|         0|            0|            0|  0.00%|    --------
  3336|         0|            0|            0|  0.00%|    >>> np.around([0.37, 1.64])
  3337|         0|            0|            0|  0.00%|    array([0., 2.])
  3338|         0|            0|            0|  0.00%|    >>> np.around([0.37, 1.64], decimals=1)
  3339|         0|            0|            0|  0.00%|    array([0.4, 1.6])
  3340|         0|            0|            0|  0.00%|    >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
  3341|         0|            0|            0|  0.00%|    array([0., 2., 2., 4., 4.])
  3342|         0|            0|            0|  0.00%|    >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
  3343|         0|            0|            0|  0.00%|    array([ 1,  2,  3, 11])
  3344|         0|            0|            0|  0.00%|    >>> np.around([1,2,3,11], decimals=-1)
  3345|         0|            0|            0|  0.00%|    array([ 0,  0,  0, 10])
  3346|         0|            0|            0|  0.00%|
  3347|         0|            0|            0|  0.00%|    """
  3348|         8|            0|            0|  0.00%|    return _wrapfunc(a, 'round', decimals=decimals, out=out)
(call)|         8|  0.000998497|  0.000124812|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\fromnumeric.py:51 _wrapfunc
  3349|         0|            0|            0|  0.00%|
  3350|         0|            0|            0|  0.00%|
  3351|         4|            0|            0|  0.00%|def _mean_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None, *,
  3352|         0|            0|            0|  0.00%|                     where=None):
  3353|         4|            0|            0|  0.00%|    return (a, where, out)
  3354|         0|            0|            0|  0.00%|
  3355|         0|            0|            0|  0.00%|
  3356|         4|            0|            0|  0.00%|@array_function_dispatch(_mean_dispatcher)
  3357|         0|            0|            0|  0.00%|def mean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue, *,
  3358|         0|            0|            0|  0.00%|         where=np._NoValue):
  3359|         0|            0|            0|  0.00%|    """
  3360|         0|            0|            0|  0.00%|    Compute the arithmetic mean along the specified axis.
  3361|         0|            0|            0|  0.00%|
  3362|         0|            0|            0|  0.00%|    Returns the average of the array elements.  The average is taken over
  3363|         0|            0|            0|  0.00%|    the flattened array by default, otherwise over the specified axis.
  3364|         0|            0|            0|  0.00%|    `float64` intermediate and return values are used for integer inputs.
  3365|         0|            0|            0|  0.00%|
  3366|         0|            0|            0|  0.00%|    Parameters
  3367|         0|            0|            0|  0.00%|    ----------
  3368|         0|            0|            0|  0.00%|    a : array_like
  3369|         0|            0|            0|  0.00%|        Array containing numbers whose mean is desired. If `a` is not an
  3370|         0|            0|            0|  0.00%|        array, a conversion is attempted.
  3371|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  3372|         0|            0|            0|  0.00%|        Axis or axes along which the means are computed. The default is to
  3373|         0|            0|            0|  0.00%|        compute the mean of the flattened array.
  3374|         0|            0|            0|  0.00%|
  3375|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  3376|         0|            0|            0|  0.00%|
  3377|         0|            0|            0|  0.00%|        If this is a tuple of ints, a mean is performed over multiple axes,
  3378|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  3379|         0|            0|            0|  0.00%|    dtype : data-type, optional
  3380|         0|            0|            0|  0.00%|        Type to use in computing the mean.  For integer inputs, the default
  3381|         0|            0|            0|  0.00%|        is `float64`; for floating point inputs, it is the same as the
  3382|         0|            0|            0|  0.00%|        input dtype.
  3383|         0|            0|            0|  0.00%|    out : ndarray, optional
  3384|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.  The default
  3385|         0|            0|            0|  0.00%|        is ``None``; if provided, it must have the same shape as the
  3386|         0|            0|            0|  0.00%|        expected output, but the type will be cast if necessary.
  3387|         0|            0|            0|  0.00%|        See :ref:`ufuncs-output-type` for more details.
  3388|         0|            0|            0|  0.00%|
  3389|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3390|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3391|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3392|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  3393|         0|            0|            0|  0.00%|
  3394|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  3395|         0|            0|            0|  0.00%|        passed through to the `mean` method of sub-classes of
  3396|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  3397|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  3398|         0|            0|            0|  0.00%|        exceptions will be raised.
  3399|         0|            0|            0|  0.00%|
  3400|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  3401|         0|            0|            0|  0.00%|        Elements to include in the mean. See `~numpy.ufunc.reduce` for details.
  3402|         0|            0|            0|  0.00%|
  3403|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
  3404|         0|            0|            0|  0.00%|
  3405|         0|            0|            0|  0.00%|    Returns
  3406|         0|            0|            0|  0.00%|    -------
  3407|         0|            0|            0|  0.00%|    m : ndarray, see dtype parameter above
  3408|         0|            0|            0|  0.00%|        If `out=None`, returns a new array containing the mean values,
  3409|         0|            0|            0|  0.00%|        otherwise a reference to the output array is returned.
  3410|         0|            0|            0|  0.00%|
  3411|         0|            0|            0|  0.00%|    See Also
  3412|         0|            0|            0|  0.00%|    --------
  3413|         0|            0|            0|  0.00%|    average : Weighted average
  3414|         0|            0|            0|  0.00%|    std, var, nanmean, nanstd, nanvar
  3415|         0|            0|            0|  0.00%|
  3416|         0|            0|            0|  0.00%|    Notes
  3417|         0|            0|            0|  0.00%|    -----
  3418|         0|            0|            0|  0.00%|    The arithmetic mean is the sum of the elements along the axis divided
  3419|         0|            0|            0|  0.00%|    by the number of elements.
  3420|         0|            0|            0|  0.00%|
  3421|         0|            0|            0|  0.00%|    Note that for floating-point input, the mean is computed using the
  3422|         0|            0|            0|  0.00%|    same precision the input has.  Depending on the input data, this can
  3423|         0|            0|            0|  0.00%|    cause the results to be inaccurate, especially for `float32` (see
  3424|         0|            0|            0|  0.00%|    example below).  Specifying a higher-precision accumulator using the
  3425|         0|            0|            0|  0.00%|    `dtype` keyword can alleviate this issue.
  3426|         0|            0|            0|  0.00%|
  3427|         0|            0|            0|  0.00%|    By default, `float16` results are computed using `float32` intermediates
  3428|         0|            0|            0|  0.00%|    for extra precision.
  3429|         0|            0|            0|  0.00%|
  3430|         0|            0|            0|  0.00%|    Examples
  3431|         0|            0|            0|  0.00%|    --------
  3432|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  3433|         0|            0|            0|  0.00%|    >>> np.mean(a)
  3434|         0|            0|            0|  0.00%|    2.5
  3435|         0|            0|            0|  0.00%|    >>> np.mean(a, axis=0)
  3436|         0|            0|            0|  0.00%|    array([2., 3.])
  3437|         0|            0|            0|  0.00%|    >>> np.mean(a, axis=1)
  3438|         0|            0|            0|  0.00%|    array([1.5, 3.5])
  3439|         0|            0|            0|  0.00%|
  3440|         0|            0|            0|  0.00%|    In single precision, `mean` can be inaccurate:
  3441|         0|            0|            0|  0.00%|
  3442|         0|            0|            0|  0.00%|    >>> a = np.zeros((2, 512*512), dtype=np.float32)
  3443|         0|            0|            0|  0.00%|    >>> a[0, :] = 1.0
  3444|         0|            0|            0|  0.00%|    >>> a[1, :] = 0.1
  3445|         0|            0|            0|  0.00%|    >>> np.mean(a)
  3446|         0|            0|            0|  0.00%|    0.54999924
  3447|         0|            0|            0|  0.00%|
  3448|         0|            0|            0|  0.00%|    Computing the mean in float64 is more accurate:
  3449|         0|            0|            0|  0.00%|
  3450|         0|            0|            0|  0.00%|    >>> np.mean(a, dtype=np.float64)
  3451|         0|            0|            0|  0.00%|    0.55000000074505806 # may vary
  3452|         0|            0|            0|  0.00%|
  3453|         0|            0|            0|  0.00%|    Specifying a where argument:
  3454|         0|            0|            0|  0.00%|    >>> a = np.array([[5, 9, 13], [14, 10, 12], [11, 15, 19]])
  3455|         0|            0|            0|  0.00%|    >>> np.mean(a)
  3456|         0|            0|            0|  0.00%|    12.0
  3457|         0|            0|            0|  0.00%|    >>> np.mean(a, where=[[True], [False], [False]])
  3458|         0|            0|            0|  0.00%|    9.0
  3459|         0|            0|            0|  0.00%|
  3460|         0|            0|            0|  0.00%|    """
  3461|         4|            0|            0|  0.00%|    kwargs = {}
  3462|         4|            0|            0|  0.00%|    if keepdims is not np._NoValue:
  3463|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  3464|         4|            0|            0|  0.00%|    if where is not np._NoValue:
  3465|         0|            0|            0|  0.00%|        kwargs['where'] = where
  3466|         4|            0|            0|  0.00%|    if type(a) is not mu.ndarray:
  3467|         4|            0|            0|  0.00%|        try:
  3468|         4|            0|            0|  0.00%|            mean = a.mean
  3469|         4|            0|            0|  0.00%|        except AttributeError:
  3470|         4|            0|            0|  0.00%|            pass
  3471|         0|            0|            0|  0.00%|        else:
  3472|         0|            0|            0|  0.00%|            return mean(axis=axis, dtype=dtype, out=out, **kwargs)
  3473|         0|            0|            0|  0.00%|
  3474|        12|            0|            0|  0.00%|    return _methods._mean(a, axis=axis, dtype=dtype,
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:162 _mean
  3475|         8|            0|            0|  0.00%|                          out=out, **kwargs)
  3476|         0|            0|            0|  0.00%|
  3477|         0|            0|            0|  0.00%|
  3478|         0|            0|            0|  0.00%|def _std_dispatcher(a, axis=None, dtype=None, out=None, ddof=None,
  3479|         0|            0|            0|  0.00%|                    keepdims=None, *, where=None):
  3480|         0|            0|            0|  0.00%|    return (a, where, out)
  3481|         0|            0|            0|  0.00%|
  3482|         0|            0|            0|  0.00%|
  3483|         0|            0|            0|  0.00%|@array_function_dispatch(_std_dispatcher)
  3484|         0|            0|            0|  0.00%|def std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *,
  3485|         0|            0|            0|  0.00%|        where=np._NoValue):
  3486|         0|            0|            0|  0.00%|    """
  3487|         0|            0|            0|  0.00%|    Compute the standard deviation along the specified axis.
  3488|         0|            0|            0|  0.00%|
  3489|         0|            0|            0|  0.00%|    Returns the standard deviation, a measure of the spread of a distribution,
  3490|         0|            0|            0|  0.00%|    of the array elements. The standard deviation is computed for the
  3491|         0|            0|            0|  0.00%|    flattened array by default, otherwise over the specified axis.
  3492|         0|            0|            0|  0.00%|
  3493|         0|            0|            0|  0.00%|    Parameters
  3494|         0|            0|            0|  0.00%|    ----------
  3495|         0|            0|            0|  0.00%|    a : array_like
  3496|         0|            0|            0|  0.00%|        Calculate the standard deviation of these values.
  3497|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  3498|         0|            0|            0|  0.00%|        Axis or axes along which the standard deviation is computed. The
  3499|         0|            0|            0|  0.00%|        default is to compute the standard deviation of the flattened array.
  3500|         0|            0|            0|  0.00%|
  3501|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  3502|         0|            0|            0|  0.00%|
  3503|         0|            0|            0|  0.00%|        If this is a tuple of ints, a standard deviation is performed over
  3504|         0|            0|            0|  0.00%|        multiple axes, instead of a single axis or all the axes as before.
  3505|         0|            0|            0|  0.00%|    dtype : dtype, optional
  3506|         0|            0|            0|  0.00%|        Type to use in computing the standard deviation. For arrays of
  3507|         0|            0|            0|  0.00%|        integer type the default is float64, for arrays of float types it is
  3508|         0|            0|            0|  0.00%|        the same as the array type.
  3509|         0|            0|            0|  0.00%|    out : ndarray, optional
  3510|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  3511|         0|            0|            0|  0.00%|        the same shape as the expected output but the type (of the calculated
  3512|         0|            0|            0|  0.00%|        values) will be cast if necessary.
  3513|         0|            0|            0|  0.00%|    ddof : int, optional
  3514|         0|            0|            0|  0.00%|        Means Delta Degrees of Freedom.  The divisor used in calculations
  3515|         0|            0|            0|  0.00%|        is ``N - ddof``, where ``N`` represents the number of elements.
  3516|         0|            0|            0|  0.00%|        By default `ddof` is zero.
  3517|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3518|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3519|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3520|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  3521|         0|            0|            0|  0.00%|
  3522|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  3523|         0|            0|            0|  0.00%|        passed through to the `std` method of sub-classes of
  3524|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  3525|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  3526|         0|            0|            0|  0.00%|        exceptions will be raised.
  3527|         0|            0|            0|  0.00%|
  3528|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  3529|         0|            0|            0|  0.00%|        Elements to include in the standard deviation.
  3530|         0|            0|            0|  0.00%|        See `~numpy.ufunc.reduce` for details.
  3531|         0|            0|            0|  0.00%|
  3532|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
  3533|         0|            0|            0|  0.00%|
  3534|         0|            0|            0|  0.00%|    Returns
  3535|         0|            0|            0|  0.00%|    -------
  3536|         0|            0|            0|  0.00%|    standard_deviation : ndarray, see dtype parameter above.
  3537|         0|            0|            0|  0.00%|        If `out` is None, return a new array containing the standard deviation,
  3538|         0|            0|            0|  0.00%|        otherwise return a reference to the output array.
  3539|         0|            0|            0|  0.00%|
  3540|         0|            0|            0|  0.00%|    See Also
  3541|         0|            0|            0|  0.00%|    --------
  3542|         0|            0|            0|  0.00%|    var, mean, nanmean, nanstd, nanvar
  3543|         0|            0|            0|  0.00%|    :ref:`ufuncs-output-type`
  3544|         0|            0|            0|  0.00%|
  3545|         0|            0|            0|  0.00%|    Notes
  3546|         0|            0|            0|  0.00%|    -----
  3547|         0|            0|            0|  0.00%|    The standard deviation is the square root of the average of the squared
  3548|         0|            0|            0|  0.00%|    deviations from the mean, i.e., ``std = sqrt(mean(x))``, where
  3549|         0|            0|            0|  0.00%|    ``x = abs(a - a.mean())**2``.
  3550|         0|            0|            0|  0.00%|
  3551|         0|            0|            0|  0.00%|    The average squared deviation is typically calculated as ``x.sum() / N``,
  3552|         0|            0|            0|  0.00%|    where ``N = len(x)``. If, however, `ddof` is specified, the divisor
  3553|         0|            0|            0|  0.00%|    ``N - ddof`` is used instead. In standard statistical practice, ``ddof=1``
  3554|         0|            0|            0|  0.00%|    provides an unbiased estimator of the variance of the infinite population.
  3555|         0|            0|            0|  0.00%|    ``ddof=0`` provides a maximum likelihood estimate of the variance for
  3556|         0|            0|            0|  0.00%|    normally distributed variables. The standard deviation computed in this
  3557|         0|            0|            0|  0.00%|    function is the square root of the estimated variance, so even with
  3558|         0|            0|            0|  0.00%|    ``ddof=1``, it will not be an unbiased estimate of the standard deviation
  3559|         0|            0|            0|  0.00%|    per se.
  3560|         0|            0|            0|  0.00%|
  3561|         0|            0|            0|  0.00%|    Note that, for complex numbers, `std` takes the absolute
  3562|         0|            0|            0|  0.00%|    value before squaring, so that the result is always real and nonnegative.
  3563|         0|            0|            0|  0.00%|
  3564|         0|            0|            0|  0.00%|    For floating-point input, the *std* is computed using the same
  3565|         0|            0|            0|  0.00%|    precision the input has. Depending on the input data, this can cause
  3566|         0|            0|            0|  0.00%|    the results to be inaccurate, especially for float32 (see example below).
  3567|         0|            0|            0|  0.00%|    Specifying a higher-accuracy accumulator using the `dtype` keyword can
  3568|         0|            0|            0|  0.00%|    alleviate this issue.
  3569|         0|            0|            0|  0.00%|
  3570|         0|            0|            0|  0.00%|    Examples
  3571|         0|            0|            0|  0.00%|    --------
  3572|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  3573|         0|            0|            0|  0.00%|    >>> np.std(a)
  3574|         0|            0|            0|  0.00%|    1.1180339887498949 # may vary
  3575|         0|            0|            0|  0.00%|    >>> np.std(a, axis=0)
  3576|         0|            0|            0|  0.00%|    array([1.,  1.])
  3577|         0|            0|            0|  0.00%|    >>> np.std(a, axis=1)
  3578|         0|            0|            0|  0.00%|    array([0.5,  0.5])
  3579|         0|            0|            0|  0.00%|
  3580|         0|            0|            0|  0.00%|    In single precision, std() can be inaccurate:
  3581|         0|            0|            0|  0.00%|
  3582|         0|            0|            0|  0.00%|    >>> a = np.zeros((2, 512*512), dtype=np.float32)
  3583|         0|            0|            0|  0.00%|    >>> a[0, :] = 1.0
  3584|         0|            0|            0|  0.00%|    >>> a[1, :] = 0.1
  3585|         0|            0|            0|  0.00%|    >>> np.std(a)
  3586|         0|            0|            0|  0.00%|    0.45000005
  3587|         0|            0|            0|  0.00%|
  3588|         0|            0|            0|  0.00%|    Computing the standard deviation in float64 is more accurate:
  3589|         0|            0|            0|  0.00%|
  3590|         0|            0|            0|  0.00%|    >>> np.std(a, dtype=np.float64)
  3591|         0|            0|            0|  0.00%|    0.44999999925494177 # may vary
  3592|         0|            0|            0|  0.00%|
  3593|         0|            0|            0|  0.00%|    Specifying a where argument:
  3594|         0|            0|            0|  0.00%|
  3595|         0|            0|            0|  0.00%|    >>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
  3596|         0|            0|            0|  0.00%|    >>> np.std(a)
  3597|         0|            0|            0|  0.00%|    2.614064523559687 # may vary
  3598|         0|            0|            0|  0.00%|    >>> np.std(a, where=[[True], [True], [False]])
  3599|         0|            0|            0|  0.00%|    2.0
  3600|         0|            0|            0|  0.00%|
  3601|         0|            0|            0|  0.00%|    """
  3602|         0|            0|            0|  0.00%|    kwargs = {}
  3603|         0|            0|            0|  0.00%|    if keepdims is not np._NoValue:
  3604|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  3605|         0|            0|            0|  0.00%|    if where is not np._NoValue:
  3606|         0|            0|            0|  0.00%|        kwargs['where'] = where
  3607|         0|            0|            0|  0.00%|    if type(a) is not mu.ndarray:
  3608|         0|            0|            0|  0.00%|        try:
  3609|         0|            0|            0|  0.00%|            std = a.std
  3610|         0|            0|            0|  0.00%|        except AttributeError:
  3611|         0|            0|            0|  0.00%|            pass
  3612|         0|            0|            0|  0.00%|        else:
  3613|         0|            0|            0|  0.00%|            return std(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)
  3614|         0|            0|            0|  0.00%|
  3615|         0|            0|            0|  0.00%|    return _methods._std(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
  3616|         0|            0|            0|  0.00%|                         **kwargs)
  3617|         0|            0|            0|  0.00%|
  3618|         0|            0|            0|  0.00%|
  3619|         0|            0|            0|  0.00%|def _var_dispatcher(a, axis=None, dtype=None, out=None, ddof=None,
  3620|         0|            0|            0|  0.00%|                    keepdims=None, *, where=None):
  3621|         0|            0|            0|  0.00%|    return (a, where, out)
  3622|         0|            0|            0|  0.00%|
  3623|         0|            0|            0|  0.00%|
  3624|         0|            0|            0|  0.00%|@array_function_dispatch(_var_dispatcher)
  3625|         0|            0|            0|  0.00%|def var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *,
  3626|         0|            0|            0|  0.00%|        where=np._NoValue):
  3627|         0|            0|            0|  0.00%|    """
  3628|         0|            0|            0|  0.00%|    Compute the variance along the specified axis.
  3629|         0|            0|            0|  0.00%|
  3630|         0|            0|            0|  0.00%|    Returns the variance of the array elements, a measure of the spread of a
  3631|         0|            0|            0|  0.00%|    distribution.  The variance is computed for the flattened array by
  3632|         0|            0|            0|  0.00%|    default, otherwise over the specified axis.
  3633|         0|            0|            0|  0.00%|
  3634|         0|            0|            0|  0.00%|    Parameters
  3635|         0|            0|            0|  0.00%|    ----------
  3636|         0|            0|            0|  0.00%|    a : array_like
  3637|         0|            0|            0|  0.00%|        Array containing numbers whose variance is desired.  If `a` is not an
  3638|         0|            0|            0|  0.00%|        array, a conversion is attempted.
  3639|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  3640|         0|            0|            0|  0.00%|        Axis or axes along which the variance is computed.  The default is to
  3641|         0|            0|            0|  0.00%|        compute the variance of the flattened array.
  3642|         0|            0|            0|  0.00%|
  3643|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  3644|         0|            0|            0|  0.00%|
  3645|         0|            0|            0|  0.00%|        If this is a tuple of ints, a variance is performed over multiple axes,
  3646|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  3647|         0|            0|            0|  0.00%|    dtype : data-type, optional
  3648|         0|            0|            0|  0.00%|        Type to use in computing the variance.  For arrays of integer type
  3649|         0|            0|            0|  0.00%|        the default is `float64`; for arrays of float types it is the same as
  3650|         0|            0|            0|  0.00%|        the array type.
  3651|         0|            0|            0|  0.00%|    out : ndarray, optional
  3652|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.  It must have
  3653|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type is cast if
  3654|         0|            0|            0|  0.00%|        necessary.
  3655|         0|            0|            0|  0.00%|    ddof : int, optional
  3656|         0|            0|            0|  0.00%|        "Delta Degrees of Freedom": the divisor used in the calculation is
  3657|         0|            0|            0|  0.00%|        ``N - ddof``, where ``N`` represents the number of elements. By
  3658|         0|            0|            0|  0.00%|        default `ddof` is zero.
  3659|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3660|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3661|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3662|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  3663|         0|            0|            0|  0.00%|
  3664|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  3665|         0|            0|            0|  0.00%|        passed through to the `var` method of sub-classes of
  3666|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  3667|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  3668|         0|            0|            0|  0.00%|        exceptions will be raised.
  3669|         0|            0|            0|  0.00%|
  3670|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  3671|         0|            0|            0|  0.00%|        Elements to include in the variance. See `~numpy.ufunc.reduce` for
  3672|         0|            0|            0|  0.00%|        details.
  3673|         0|            0|            0|  0.00%|
  3674|         0|            0|            0|  0.00%|        .. versionadded:: 1.20.0
  3675|         0|            0|            0|  0.00%|
  3676|         0|            0|            0|  0.00%|    Returns
  3677|         0|            0|            0|  0.00%|    -------
  3678|         0|            0|            0|  0.00%|    variance : ndarray, see dtype parameter above
  3679|         0|            0|            0|  0.00%|        If ``out=None``, returns a new array containing the variance;
  3680|         0|            0|            0|  0.00%|        otherwise, a reference to the output array is returned.
  3681|         0|            0|            0|  0.00%|
  3682|         0|            0|            0|  0.00%|    See Also
  3683|         0|            0|            0|  0.00%|    --------
  3684|         0|            0|            0|  0.00%|    std, mean, nanmean, nanstd, nanvar
  3685|         0|            0|            0|  0.00%|    :ref:`ufuncs-output-type`
  3686|         0|            0|            0|  0.00%|
  3687|         0|            0|            0|  0.00%|    Notes
  3688|         0|            0|            0|  0.00%|    -----
  3689|         0|            0|            0|  0.00%|    The variance is the average of the squared deviations from the mean,
  3690|         0|            0|            0|  0.00%|    i.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.
  3691|         0|            0|            0|  0.00%|
  3692|         0|            0|            0|  0.00%|    The mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.
  3693|         0|            0|            0|  0.00%|    If, however, `ddof` is specified, the divisor ``N - ddof`` is used
  3694|         0|            0|            0|  0.00%|    instead.  In standard statistical practice, ``ddof=1`` provides an
  3695|         0|            0|            0|  0.00%|    unbiased estimator of the variance of a hypothetical infinite population.
  3696|         0|            0|            0|  0.00%|    ``ddof=0`` provides a maximum likelihood estimate of the variance for
  3697|         0|            0|            0|  0.00%|    normally distributed variables.
  3698|         0|            0|            0|  0.00%|
  3699|         0|            0|            0|  0.00%|    Note that for complex numbers, the absolute value is taken before
  3700|         0|            0|            0|  0.00%|    squaring, so that the result is always real and nonnegative.
  3701|         0|            0|            0|  0.00%|
  3702|         0|            0|            0|  0.00%|    For floating-point input, the variance is computed using the same
  3703|         0|            0|            0|  0.00%|    precision the input has.  Depending on the input data, this can cause
  3704|         0|            0|            0|  0.00%|    the results to be inaccurate, especially for `float32` (see example
  3705|         0|            0|            0|  0.00%|    below).  Specifying a higher-accuracy accumulator using the ``dtype``
  3706|         0|            0|            0|  0.00%|    keyword can alleviate this issue.
  3707|         0|            0|            0|  0.00%|
  3708|         0|            0|            0|  0.00%|    Examples
  3709|         0|            0|            0|  0.00%|    --------
  3710|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  3711|         0|            0|            0|  0.00%|    >>> np.var(a)
  3712|         0|            0|            0|  0.00%|    1.25
  3713|         0|            0|            0|  0.00%|    >>> np.var(a, axis=0)
  3714|         0|            0|            0|  0.00%|    array([1.,  1.])
  3715|         0|            0|            0|  0.00%|    >>> np.var(a, axis=1)
  3716|         0|            0|            0|  0.00%|    array([0.25,  0.25])
  3717|         0|            0|            0|  0.00%|
  3718|         0|            0|            0|  0.00%|    In single precision, var() can be inaccurate:
  3719|         0|            0|            0|  0.00%|
  3720|         0|            0|            0|  0.00%|    >>> a = np.zeros((2, 512*512), dtype=np.float32)
  3721|         0|            0|            0|  0.00%|    >>> a[0, :] = 1.0
  3722|         0|            0|            0|  0.00%|    >>> a[1, :] = 0.1
  3723|         0|            0|            0|  0.00%|    >>> np.var(a)
  3724|         0|            0|            0|  0.00%|    0.20250003
  3725|         0|            0|            0|  0.00%|
  3726|         0|            0|            0|  0.00%|    Computing the variance in float64 is more accurate:
  3727|         0|            0|            0|  0.00%|
  3728|         0|            0|            0|  0.00%|    >>> np.var(a, dtype=np.float64)
  3729|         0|            0|            0|  0.00%|    0.20249999932944759 # may vary
  3730|         0|            0|            0|  0.00%|    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
  3731|         0|            0|            0|  0.00%|    0.2025
  3732|         0|            0|            0|  0.00%|
  3733|         0|            0|            0|  0.00%|    Specifying a where argument:
  3734|         0|            0|            0|  0.00%|
  3735|         0|            0|            0|  0.00%|    >>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
  3736|         0|            0|            0|  0.00%|    >>> np.var(a)
  3737|         0|            0|            0|  0.00%|    6.833333333333333 # may vary
  3738|         0|            0|            0|  0.00%|    >>> np.var(a, where=[[True], [True], [False]])
  3739|         0|            0|            0|  0.00%|    4.0
  3740|         0|            0|            0|  0.00%|
  3741|         0|            0|            0|  0.00%|    """
  3742|         0|            0|            0|  0.00%|    kwargs = {}
  3743|         0|            0|            0|  0.00%|    if keepdims is not np._NoValue:
  3744|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  3745|         0|            0|            0|  0.00%|    if where is not np._NoValue:
  3746|         0|            0|            0|  0.00%|        kwargs['where'] = where
  3747|         0|            0|            0|  0.00%|
  3748|         0|            0|            0|  0.00%|    if type(a) is not mu.ndarray:
  3749|         0|            0|            0|  0.00%|        try:
  3750|         0|            0|            0|  0.00%|            var = a.var
  3751|         0|            0|            0|  0.00%|
  3752|         0|            0|            0|  0.00%|        except AttributeError:
  3753|         0|            0|            0|  0.00%|            pass
  3754|         0|            0|            0|  0.00%|        else:
  3755|         0|            0|            0|  0.00%|            return var(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)
  3756|         0|            0|            0|  0.00%|
  3757|         0|            0|            0|  0.00%|    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
  3758|         0|            0|            0|  0.00%|                         **kwargs)
  3759|         0|            0|            0|  0.00%|
  3760|         0|            0|            0|  0.00%|
  3761|         0|            0|            0|  0.00%|# Aliases of other functions. These have their own definitions only so that
  3762|         0|            0|            0|  0.00%|# they can have unique docstrings.
  3763|         0|            0|            0|  0.00%|
  3764|         8|            0|            0|  0.00%|@array_function_dispatch(_around_dispatcher)
  3765|         0|            0|            0|  0.00%|def round_(a, decimals=0, out=None):
  3766|         0|            0|            0|  0.00%|    """
  3767|         0|            0|            0|  0.00%|    Round an array to the given number of decimals.
  3768|         0|            0|            0|  0.00%|
  3769|         0|            0|            0|  0.00%|    See Also
  3770|         0|            0|            0|  0.00%|    --------
  3771|         0|            0|            0|  0.00%|    around : equivalent function; see for details.
  3772|         0|            0|            0|  0.00%|    """
  3773|         8|            0|            0|  0.00%|    return around(a, decimals=decimals, out=out)
(call)|         8|  0.000998497|  0.000124812|  0.00%|# <__array_function__ internals>:177 around
  3774|         0|            0|            0|  0.00%|
  3775|         0|            0|            0|  0.00%|
  3776|         0|            0|            0|  0.00%|@array_function_dispatch(_prod_dispatcher, verify=False)
  3777|         0|            0|            0|  0.00%|def product(*args, **kwargs):
  3778|         0|            0|            0|  0.00%|    """
  3779|         0|            0|            0|  0.00%|    Return the product of array elements over a given axis.
  3780|         0|            0|            0|  0.00%|
  3781|         0|            0|            0|  0.00%|    See Also
  3782|         0|            0|            0|  0.00%|    --------
  3783|         0|            0|            0|  0.00%|    prod : equivalent function; see for details.
  3784|         0|            0|            0|  0.00%|    """
  3785|         0|            0|            0|  0.00%|    return prod(*args, **kwargs)
  3786|         0|            0|            0|  0.00%|
  3787|         0|            0|            0|  0.00%|
  3788|         0|            0|            0|  0.00%|@array_function_dispatch(_cumprod_dispatcher, verify=False)
  3789|         0|            0|            0|  0.00%|def cumproduct(*args, **kwargs):
  3790|         0|            0|            0|  0.00%|    """
  3791|         0|            0|            0|  0.00%|    Return the cumulative product over the given axis.
  3792|         0|            0|            0|  0.00%|
  3793|         0|            0|            0|  0.00%|    See Also
  3794|         0|            0|            0|  0.00%|    --------
  3795|         0|            0|            0|  0.00%|    cumprod : equivalent function; see for details.
  3796|         0|            0|            0|  0.00%|    """
  3797|         0|            0|            0|  0.00%|    return cumprod(*args, **kwargs)
  3798|         0|            0|            0|  0.00%|
  3799|         0|            0|            0|  0.00%|
  3800|         0|            0|            0|  0.00%|@array_function_dispatch(_any_dispatcher, verify=False)
  3801|         0|            0|            0|  0.00%|def sometrue(*args, **kwargs):
  3802|         0|            0|            0|  0.00%|    """
  3803|         0|            0|            0|  0.00%|    Check whether some values are true.
  3804|         0|            0|            0|  0.00%|
  3805|         0|            0|            0|  0.00%|    Refer to `any` for full documentation.
  3806|         0|            0|            0|  0.00%|
  3807|         0|            0|            0|  0.00%|    See Also
  3808|         0|            0|            0|  0.00%|    --------
  3809|         0|            0|            0|  0.00%|    any : equivalent function; see for details.
  3810|         0|            0|            0|  0.00%|    """
  3811|         0|            0|            0|  0.00%|    return any(*args, **kwargs)
  3812|         0|            0|            0|  0.00%|
  3813|         0|            0|            0|  0.00%|
  3814|         0|            0|            0|  0.00%|@array_function_dispatch(_all_dispatcher, verify=False)
  3815|         0|            0|            0|  0.00%|def alltrue(*args, **kwargs):
  3816|         0|            0|            0|  0.00%|    """
  3817|         0|            0|            0|  0.00%|    Check if all elements of input array are true.
  3818|         0|            0|            0|  0.00%|
  3819|         0|            0|            0|  0.00%|    See Also
  3820|         0|            0|            0|  0.00%|    --------
  3821|         0|            0|            0|  0.00%|    numpy.all : Equivalent function; see for details.
  3822|         0|            0|            0|  0.00%|    """
  3823|         0|            0|            0|  0.00%|    return all(*args, **kwargs)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\ntpath.py
File duration: 0.114591s (0.33%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# Module 'ntpath' -- common operations on WinNT/Win95 pathnames
     2|         0|            0|            0|  0.00%|"""Common pathname manipulations, WindowsNT/95 version.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|Instead of importing this module directly, import os and refer to this
     5|         0|            0|            0|  0.00%|module as os.path.
     6|         0|            0|            0|  0.00%|"""
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|# strings representing various path-related bits and pieces
     9|         0|            0|            0|  0.00%|# These are primarily for export; internally, they are hardcoded.
    10|         0|            0|            0|  0.00%|# Should be set before imports for resolving cyclic dependency.
    11|         0|            0|            0|  0.00%|curdir = '.'
    12|         0|            0|            0|  0.00%|pardir = '..'
    13|         0|            0|            0|  0.00%|extsep = '.'
    14|         0|            0|            0|  0.00%|sep = '\\'
    15|         0|            0|            0|  0.00%|pathsep = ';'
    16|         0|            0|            0|  0.00%|altsep = '/'
    17|         0|            0|            0|  0.00%|defpath = '.;C:\\bin'
    18|         0|            0|            0|  0.00%|devnull = 'nul'
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|import os
    21|         0|            0|            0|  0.00%|import sys
    22|         0|            0|            0|  0.00%|import stat
    23|         0|            0|            0|  0.00%|import genericpath
    24|         0|            0|            0|  0.00%|from genericpath import *
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
    27|         0|            0|            0|  0.00%|           "basename","dirname","commonprefix","getsize","getmtime",
    28|         0|            0|            0|  0.00%|           "getatime","getctime", "islink","exists","lexists","isdir","isfile",
    29|         0|            0|            0|  0.00%|           "ismount", "expanduser","expandvars","normpath","abspath",
    30|         0|            0|            0|  0.00%|           "curdir","pardir","sep","pathsep","defpath","altsep",
    31|         0|            0|            0|  0.00%|           "extsep","devnull","realpath","supports_unicode_filenames","relpath",
    32|         0|            0|            0|  0.00%|           "samefile", "sameopenfile", "samestat", "commonpath"]
    33|         0|            0|            0|  0.00%|
    34|       120|  0.000957966|  7.98305e-06|  0.00%|def _get_bothseps(path):
    35|       120|            0|            0|  0.00%|    if isinstance(path, bytes):
    36|         0|            0|            0|  0.00%|        return b'\\/'
    37|         0|            0|            0|  0.00%|    else:
    38|       120|            0|            0|  0.00%|        return '\\/'
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|# Normalize the case of a pathname and map slashes to backslashes.
    41|         0|            0|            0|  0.00%|# Other normalizations (such as optimizing '../' away) are not done
    42|         0|            0|            0|  0.00%|# (this is done by normpath).
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|def normcase(s):
    45|         0|            0|            0|  0.00%|    """Normalize case of pathname.
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    Makes all characters lowercase and all slashes into backslashes."""
    48|         0|            0|            0|  0.00%|    s = os.fspath(s)
    49|         0|            0|            0|  0.00%|    if isinstance(s, bytes):
    50|         0|            0|            0|  0.00%|        return s.replace(b'/', b'\\').lower()
    51|         0|            0|            0|  0.00%|    else:
    52|         0|            0|            0|  0.00%|        return s.replace('/', '\\').lower()
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|# Return whether a path is absolute.
    56|         0|            0|            0|  0.00%|# Trivial in Posix, harder on Windows.
    57|         0|            0|            0|  0.00%|# For Windows it is absolute if it starts with a slash or backslash (current
    58|         0|            0|            0|  0.00%|# volume), or if a pathname after the volume-letter-and-colon or UNC-resource
    59|         0|            0|            0|  0.00%|# starts with a slash or backslash.
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|def isabs(s):
    62|         0|            0|            0|  0.00%|    """Test whether a path is absolute"""
    63|         0|            0|            0|  0.00%|    s = os.fspath(s)
    64|         0|            0|            0|  0.00%|    s = splitdrive(s)[1]
    65|         0|            0|            0|  0.00%|    return len(s) > 0 and s[0] in _get_bothseps(s)
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|# Join two (or more) paths.
    69|         0|            0|            0|  0.00%|def join(path, *paths):
    70|         0|            0|            0|  0.00%|    path = os.fspath(path)
    71|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
    72|         0|            0|            0|  0.00%|        sep = b'\\'
    73|         0|            0|            0|  0.00%|        seps = b'\\/'
    74|         0|            0|            0|  0.00%|        colon = b':'
    75|         0|            0|            0|  0.00%|    else:
    76|         0|            0|            0|  0.00%|        sep = '\\'
    77|         0|            0|            0|  0.00%|        seps = '\\/'
    78|         0|            0|            0|  0.00%|        colon = ':'
    79|         0|            0|            0|  0.00%|    try:
    80|         0|            0|            0|  0.00%|        if not paths:
    81|         0|            0|            0|  0.00%|            path[:0] + sep  #23780: Ensure compatible data type even if p is null.
    82|         0|            0|            0|  0.00%|        result_drive, result_path = splitdrive(path)
    83|         0|            0|            0|  0.00%|        for p in map(os.fspath, paths):
    84|         0|            0|            0|  0.00%|            p_drive, p_path = splitdrive(p)
    85|         0|            0|            0|  0.00%|            if p_path and p_path[0] in seps:
    86|         0|            0|            0|  0.00%|                # Second path is absolute
    87|         0|            0|            0|  0.00%|                if p_drive or not result_drive:
    88|         0|            0|            0|  0.00%|                    result_drive = p_drive
    89|         0|            0|            0|  0.00%|                result_path = p_path
    90|         0|            0|            0|  0.00%|                continue
    91|         0|            0|            0|  0.00%|            elif p_drive and p_drive != result_drive:
    92|         0|            0|            0|  0.00%|                if p_drive.lower() != result_drive.lower():
    93|         0|            0|            0|  0.00%|                    # Different drives => ignore the first path entirely
    94|         0|            0|            0|  0.00%|                    result_drive = p_drive
    95|         0|            0|            0|  0.00%|                    result_path = p_path
    96|         0|            0|            0|  0.00%|                    continue
    97|         0|            0|            0|  0.00%|                # Same drive in different case
    98|         0|            0|            0|  0.00%|                result_drive = p_drive
    99|         0|            0|            0|  0.00%|            # Second path is relative to the first
   100|         0|            0|            0|  0.00%|            if result_path and result_path[-1] not in seps:
   101|         0|            0|            0|  0.00%|                result_path = result_path + sep
   102|         0|            0|            0|  0.00%|            result_path = result_path + p_path
   103|         0|            0|            0|  0.00%|        ## add separator between UNC and non-absolute path
   104|         0|            0|            0|  0.00%|        if (result_path and result_path[0] not in seps and
   105|         0|            0|            0|  0.00%|            result_drive and result_drive[-1:] != colon):
   106|         0|            0|            0|  0.00%|            return result_drive + sep + result_path
   107|         0|            0|            0|  0.00%|        return result_drive + result_path
   108|         0|            0|            0|  0.00%|    except (TypeError, AttributeError, BytesWarning):
   109|         0|            0|            0|  0.00%|        genericpath._check_arg_types('join', path, *paths)
   110|         0|            0|            0|  0.00%|        raise
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|# Split a path in a drive specification (a drive letter followed by a
   114|         0|            0|            0|  0.00%|# colon) and the path specification.
   115|         0|            0|            0|  0.00%|# It is always true that drivespec + pathspec == p
   116|       120|  0.000997305|  8.31087e-06|  0.00%|def splitdrive(p):
   117|         0|            0|            0|  0.00%|    """Split a pathname into drive/UNC sharepoint and relative path specifiers.
   118|         0|            0|            0|  0.00%|    Returns a 2-tuple (drive_or_unc, path); either part may be empty.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    If you assign
   121|         0|            0|            0|  0.00%|        result = splitdrive(p)
   122|         0|            0|            0|  0.00%|    It is always true that:
   123|         0|            0|            0|  0.00%|        result[0] + result[1] == p
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    If the path contained a drive letter, drive_or_unc will contain everything
   126|         0|            0|            0|  0.00%|    up to and including the colon.  e.g. splitdrive("c:/dir") returns ("c:", "/dir")
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|    If the path contained a UNC path, the drive_or_unc will contain the host name
   129|         0|            0|            0|  0.00%|    and share up to but not including the fourth directory separator character.
   130|         0|            0|            0|  0.00%|    e.g. splitdrive("//host/computer/dir") returns ("//host/computer", "/dir")
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|    Paths cannot contain both a drive letter and a UNC path.
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    """
   135|       120|            0|            0|  0.00%|    p = os.fspath(p)
   136|       120|   0.00200438|  1.67032e-05|  0.01%|    if len(p) >= 2:
   137|       120|  0.000949621|  7.91351e-06|  0.00%|        if isinstance(p, bytes):
   138|         0|            0|            0|  0.00%|            sep = b'\\'
   139|         0|            0|            0|  0.00%|            altsep = b'/'
   140|         0|            0|            0|  0.00%|            colon = b':'
   141|         0|            0|            0|  0.00%|        else:
   142|       120|            0|            0|  0.00%|            sep = '\\'
   143|       120|            0|            0|  0.00%|            altsep = '/'
   144|       120|  0.000997782|  8.31485e-06|  0.00%|            colon = ':'
   145|       120|            0|            0|  0.00%|        normp = p.replace(altsep, sep)
   146|       120|            0|            0|  0.00%|        if (normp[0:2] == sep*2) and (normp[2:3] != sep):
   147|         0|            0|            0|  0.00%|            # is a UNC path:
   148|         0|            0|            0|  0.00%|            # vvvvvvvvvvvvvvvvvvvv drive letter or UNC path
   149|         0|            0|            0|  0.00%|            # \\machine\mountpoint\directory\etc\...
   150|         0|            0|            0|  0.00%|            #           directory ^^^^^^^^^^^^^^^
   151|         0|            0|            0|  0.00%|            index = normp.find(sep, 2)
   152|         0|            0|            0|  0.00%|            if index == -1:
   153|         0|            0|            0|  0.00%|                return p[:0], p
   154|         0|            0|            0|  0.00%|            index2 = normp.find(sep, index + 1)
   155|         0|            0|            0|  0.00%|            # a UNC path can't have two slashes in a row
   156|         0|            0|            0|  0.00%|            # (after the initial two)
   157|         0|            0|            0|  0.00%|            if index2 == index + 1:
   158|         0|            0|            0|  0.00%|                return p[:0], p
   159|         0|            0|            0|  0.00%|            if index2 == -1:
   160|         0|            0|            0|  0.00%|                index2 = len(p)
   161|         0|            0|            0|  0.00%|            return p[:index2], p[index2:]
   162|       120|            0|            0|  0.00%|        if normp[1:2] == colon:
   163|         0|            0|            0|  0.00%|            return p[:2], p[2:]
   164|       120|            0|            0|  0.00%|    return p[:0], p
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|# Split a path in head (everything up to the last '/') and tail (the
   168|         0|            0|            0|  0.00%|# rest).  After the trailing '/' is stripped, the invariant
   169|         0|            0|            0|  0.00%|# join(head, tail) == p holds.
   170|         0|            0|            0|  0.00%|# The resulting head won't end in '/' unless it is the root.
   171|         0|            0|            0|  0.00%|
   172|       120|  0.000971556|   8.0963e-06|  0.00%|def split(p):
   173|         0|            0|            0|  0.00%|    """Split a pathname.
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    Return tuple (head, tail) where tail is everything after the final slash.
   176|         0|            0|            0|  0.00%|    Either part may be empty."""
   177|       120|            0|            0|  0.00%|    p = os.fspath(p)
   178|       120|            0|            0|  0.00%|    seps = _get_bothseps(p)
(call)|       120|  0.000957966|  7.98305e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\ntpath.py:34 _get_bothseps
   179|       120|            0|            0|  0.00%|    d, p = splitdrive(p)
(call)|       120|   0.00494909|  4.12424e-05|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\ntpath.py:116 splitdrive
   180|         0|            0|            0|  0.00%|    # set i to index beyond p's last slash
   181|       120|            0|            0|  0.00%|    i = len(p)
   182|     25255|    0.0611393|  2.42088e-06|  0.17%|    while i and p[i-1] not in seps:
   183|     25135|    0.0436399|  1.73622e-06|  0.12%|        i -= 1
   184|       120|            0|            0|  0.00%|    head, tail = p[:i], p[i:]  # now tail has no slashes
   185|         0|            0|            0|  0.00%|    # remove trailing slashes from head, unless it's all slashes
   186|       120|            0|            0|  0.00%|    head = head.rstrip(seps) or head
   187|       120|  0.000997782|  8.31485e-06|  0.00%|    return d + head, tail
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|# Split a path in root and extension.
   191|         0|            0|            0|  0.00%|# The extension is everything starting at the last dot in the last
   192|         0|            0|            0|  0.00%|# pathname component; the root is everything before that.
   193|         0|            0|            0|  0.00%|# It is always true that root + ext == p.
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|def splitext(p):
   196|         0|            0|            0|  0.00%|    p = os.fspath(p)
   197|         0|            0|            0|  0.00%|    if isinstance(p, bytes):
   198|         0|            0|            0|  0.00%|        return genericpath._splitext(p, b'\\', b'/', b'.')
   199|         0|            0|            0|  0.00%|    else:
   200|         0|            0|            0|  0.00%|        return genericpath._splitext(p, '\\', '/', '.')
   201|         0|            0|            0|  0.00%|splitext.__doc__ = genericpath._splitext.__doc__
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|# Return the tail (basename) part of a path.
   205|         0|            0|            0|  0.00%|
   206|       120|            0|            0|  0.00%|def basename(p):
   207|         0|            0|            0|  0.00%|    """Returns the final component of a pathname"""
   208|       120|   0.00193524|   1.6127e-05|  0.01%|    return split(p)[1]
(call)|       120|     0.112656|  0.000938797|  0.32%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\ntpath.py:172 split
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|# Return the head (dirname) part of a path.
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|def dirname(p):
   214|         0|            0|            0|  0.00%|    """Returns the directory component of a pathname"""
   215|         0|            0|            0|  0.00%|    return split(p)[0]
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|# Is a path a symbolic link?
   218|         0|            0|            0|  0.00%|# This will always return false on systems where os.lstat doesn't exist.
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|def islink(path):
   221|         0|            0|            0|  0.00%|    """Test whether a path is a symbolic link.
   222|         0|            0|            0|  0.00%|    This will always return false for Windows prior to 6.0.
   223|         0|            0|            0|  0.00%|    """
   224|         0|            0|            0|  0.00%|    try:
   225|         0|            0|            0|  0.00%|        st = os.lstat(path)
   226|         0|            0|            0|  0.00%|    except (OSError, ValueError, AttributeError):
   227|         0|            0|            0|  0.00%|        return False
   228|         0|            0|            0|  0.00%|    return stat.S_ISLNK(st.st_mode)
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|# Being true for dangling symbolic links is also useful.
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|def lexists(path):
   233|         0|            0|            0|  0.00%|    """Test whether a path exists.  Returns True for broken symbolic links"""
   234|         0|            0|            0|  0.00%|    try:
   235|         0|            0|            0|  0.00%|        st = os.lstat(path)
   236|         0|            0|            0|  0.00%|    except (OSError, ValueError):
   237|         0|            0|            0|  0.00%|        return False
   238|         0|            0|            0|  0.00%|    return True
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|# Is a path a mount point?
   241|         0|            0|            0|  0.00%|# Any drive letter root (eg c:\)
   242|         0|            0|            0|  0.00%|# Any share UNC (eg \\server\share)
   243|         0|            0|            0|  0.00%|# Any volume mounted on a filesystem folder
   244|         0|            0|            0|  0.00%|#
   245|         0|            0|            0|  0.00%|# No one method detects all three situations. Historically we've lexically
   246|         0|            0|            0|  0.00%|# detected drive letter roots and share UNCs. The canonical approach to
   247|         0|            0|            0|  0.00%|# detecting mounted volumes (querying the reparse tag) fails for the most
   248|         0|            0|            0|  0.00%|# common case: drive letter roots. The alternative which uses GetVolumePathName
   249|         0|            0|            0|  0.00%|# fails if the drive letter is the result of a SUBST.
   250|         0|            0|            0|  0.00%|try:
   251|         0|            0|            0|  0.00%|    from nt import _getvolumepathname
   252|         0|            0|            0|  0.00%|except ImportError:
   253|         0|            0|            0|  0.00%|    _getvolumepathname = None
   254|         0|            0|            0|  0.00%|def ismount(path):
   255|         0|            0|            0|  0.00%|    """Test whether a path is a mount point (a drive root, the root of a
   256|         0|            0|            0|  0.00%|    share, or a mounted volume)"""
   257|         0|            0|            0|  0.00%|    path = os.fspath(path)
   258|         0|            0|            0|  0.00%|    seps = _get_bothseps(path)
   259|         0|            0|            0|  0.00%|    path = abspath(path)
   260|         0|            0|            0|  0.00%|    root, rest = splitdrive(path)
   261|         0|            0|            0|  0.00%|    if root and root[0] in seps:
   262|         0|            0|            0|  0.00%|        return (not rest) or (rest in seps)
   263|         0|            0|            0|  0.00%|    if rest in seps:
   264|         0|            0|            0|  0.00%|        return True
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|    if _getvolumepathname:
   267|         0|            0|            0|  0.00%|        return path.rstrip(seps) == _getvolumepathname(path).rstrip(seps)
   268|         0|            0|            0|  0.00%|    else:
   269|         0|            0|            0|  0.00%|        return False
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|# Expand paths beginning with '~' or '~user'.
   273|         0|            0|            0|  0.00%|# '~' means $HOME; '~user' means that user's home directory.
   274|         0|            0|            0|  0.00%|# If the path doesn't begin with '~', or if the user or $HOME is unknown,
   275|         0|            0|            0|  0.00%|# the path is returned unchanged (leaving error reporting to whatever
   276|         0|            0|            0|  0.00%|# function is called with the expanded path as argument).
   277|         0|            0|            0|  0.00%|# See also module 'glob' for expansion of *, ? and [...] in pathnames.
   278|         0|            0|            0|  0.00%|# (A function should also be defined to do full *sh-style environment
   279|         0|            0|            0|  0.00%|# variable expansion.)
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|def expanduser(path):
   282|         0|            0|            0|  0.00%|    """Expand ~ and ~user constructs.
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    If user or $HOME is unknown, do nothing."""
   285|         0|            0|            0|  0.00%|    path = os.fspath(path)
   286|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   287|         0|            0|            0|  0.00%|        tilde = b'~'
   288|         0|            0|            0|  0.00%|    else:
   289|         0|            0|            0|  0.00%|        tilde = '~'
   290|         0|            0|            0|  0.00%|    if not path.startswith(tilde):
   291|         0|            0|            0|  0.00%|        return path
   292|         0|            0|            0|  0.00%|    i, n = 1, len(path)
   293|         0|            0|            0|  0.00%|    while i < n and path[i] not in _get_bothseps(path):
   294|         0|            0|            0|  0.00%|        i += 1
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|    if 'USERPROFILE' in os.environ:
   297|         0|            0|            0|  0.00%|        userhome = os.environ['USERPROFILE']
   298|         0|            0|            0|  0.00%|    elif not 'HOMEPATH' in os.environ:
   299|         0|            0|            0|  0.00%|        return path
   300|         0|            0|            0|  0.00%|    else:
   301|         0|            0|            0|  0.00%|        try:
   302|         0|            0|            0|  0.00%|            drive = os.environ['HOMEDRIVE']
   303|         0|            0|            0|  0.00%|        except KeyError:
   304|         0|            0|            0|  0.00%|            drive = ''
   305|         0|            0|            0|  0.00%|        userhome = join(drive, os.environ['HOMEPATH'])
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   308|         0|            0|            0|  0.00%|        userhome = os.fsencode(userhome)
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    if i != 1: #~user
   311|         0|            0|            0|  0.00%|        userhome = join(dirname(userhome), path[1:i])
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|    return userhome + path[i:]
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|# Expand paths containing shell variable substitutions.
   317|         0|            0|            0|  0.00%|# The following rules apply:
   318|         0|            0|            0|  0.00%|#       - no expansion within single quotes
   319|         0|            0|            0|  0.00%|#       - '$$' is translated into '$'
   320|         0|            0|            0|  0.00%|#       - '%%' is translated into '%' if '%%' are not seen in %var1%%var2%
   321|         0|            0|            0|  0.00%|#       - ${varname} is accepted.
   322|         0|            0|            0|  0.00%|#       - $varname is accepted.
   323|         0|            0|            0|  0.00%|#       - %varname% is accepted.
   324|         0|            0|            0|  0.00%|#       - varnames can be made out of letters, digits and the characters '_-'
   325|         0|            0|            0|  0.00%|#         (though is not verified in the ${varname} and %varname% cases)
   326|         0|            0|            0|  0.00%|# XXX With COMMAND.COM you can use any characters in a variable name,
   327|         0|            0|            0|  0.00%|# XXX except '^|<>='.
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|def expandvars(path):
   330|         0|            0|            0|  0.00%|    """Expand shell variables of the forms $var, ${var} and %var%.
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|    Unknown variables are left unchanged."""
   333|         0|            0|            0|  0.00%|    path = os.fspath(path)
   334|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   335|         0|            0|            0|  0.00%|        if b'$' not in path and b'%' not in path:
   336|         0|            0|            0|  0.00%|            return path
   337|         0|            0|            0|  0.00%|        import string
   338|         0|            0|            0|  0.00%|        varchars = bytes(string.ascii_letters + string.digits + '_-', 'ascii')
   339|         0|            0|            0|  0.00%|        quote = b'\''
   340|         0|            0|            0|  0.00%|        percent = b'%'
   341|         0|            0|            0|  0.00%|        brace = b'{'
   342|         0|            0|            0|  0.00%|        rbrace = b'}'
   343|         0|            0|            0|  0.00%|        dollar = b'$'
   344|         0|            0|            0|  0.00%|        environ = getattr(os, 'environb', None)
   345|         0|            0|            0|  0.00%|    else:
   346|         0|            0|            0|  0.00%|        if '$' not in path and '%' not in path:
   347|         0|            0|            0|  0.00%|            return path
   348|         0|            0|            0|  0.00%|        import string
   349|         0|            0|            0|  0.00%|        varchars = string.ascii_letters + string.digits + '_-'
   350|         0|            0|            0|  0.00%|        quote = '\''
   351|         0|            0|            0|  0.00%|        percent = '%'
   352|         0|            0|            0|  0.00%|        brace = '{'
   353|         0|            0|            0|  0.00%|        rbrace = '}'
   354|         0|            0|            0|  0.00%|        dollar = '$'
   355|         0|            0|            0|  0.00%|        environ = os.environ
   356|         0|            0|            0|  0.00%|    res = path[:0]
   357|         0|            0|            0|  0.00%|    index = 0
   358|         0|            0|            0|  0.00%|    pathlen = len(path)
   359|         0|            0|            0|  0.00%|    while index < pathlen:
   360|         0|            0|            0|  0.00%|        c = path[index:index+1]
   361|         0|            0|            0|  0.00%|        if c == quote:   # no expansion within single quotes
   362|         0|            0|            0|  0.00%|            path = path[index + 1:]
   363|         0|            0|            0|  0.00%|            pathlen = len(path)
   364|         0|            0|            0|  0.00%|            try:
   365|         0|            0|            0|  0.00%|                index = path.index(c)
   366|         0|            0|            0|  0.00%|                res += c + path[:index + 1]
   367|         0|            0|            0|  0.00%|            except ValueError:
   368|         0|            0|            0|  0.00%|                res += c + path
   369|         0|            0|            0|  0.00%|                index = pathlen - 1
   370|         0|            0|            0|  0.00%|        elif c == percent:  # variable or '%'
   371|         0|            0|            0|  0.00%|            if path[index + 1:index + 2] == percent:
   372|         0|            0|            0|  0.00%|                res += c
   373|         0|            0|            0|  0.00%|                index += 1
   374|         0|            0|            0|  0.00%|            else:
   375|         0|            0|            0|  0.00%|                path = path[index+1:]
   376|         0|            0|            0|  0.00%|                pathlen = len(path)
   377|         0|            0|            0|  0.00%|                try:
   378|         0|            0|            0|  0.00%|                    index = path.index(percent)
   379|         0|            0|            0|  0.00%|                except ValueError:
   380|         0|            0|            0|  0.00%|                    res += percent + path
   381|         0|            0|            0|  0.00%|                    index = pathlen - 1
   382|         0|            0|            0|  0.00%|                else:
   383|         0|            0|            0|  0.00%|                    var = path[:index]
   384|         0|            0|            0|  0.00%|                    try:
   385|         0|            0|            0|  0.00%|                        if environ is None:
   386|         0|            0|            0|  0.00%|                            value = os.fsencode(os.environ[os.fsdecode(var)])
   387|         0|            0|            0|  0.00%|                        else:
   388|         0|            0|            0|  0.00%|                            value = environ[var]
   389|         0|            0|            0|  0.00%|                    except KeyError:
   390|         0|            0|            0|  0.00%|                        value = percent + var + percent
   391|         0|            0|            0|  0.00%|                    res += value
   392|         0|            0|            0|  0.00%|        elif c == dollar:  # variable or '$$'
   393|         0|            0|            0|  0.00%|            if path[index + 1:index + 2] == dollar:
   394|         0|            0|            0|  0.00%|                res += c
   395|         0|            0|            0|  0.00%|                index += 1
   396|         0|            0|            0|  0.00%|            elif path[index + 1:index + 2] == brace:
   397|         0|            0|            0|  0.00%|                path = path[index+2:]
   398|         0|            0|            0|  0.00%|                pathlen = len(path)
   399|         0|            0|            0|  0.00%|                try:
   400|         0|            0|            0|  0.00%|                    index = path.index(rbrace)
   401|         0|            0|            0|  0.00%|                except ValueError:
   402|         0|            0|            0|  0.00%|                    res += dollar + brace + path
   403|         0|            0|            0|  0.00%|                    index = pathlen - 1
   404|         0|            0|            0|  0.00%|                else:
   405|         0|            0|            0|  0.00%|                    var = path[:index]
   406|         0|            0|            0|  0.00%|                    try:
   407|         0|            0|            0|  0.00%|                        if environ is None:
   408|         0|            0|            0|  0.00%|                            value = os.fsencode(os.environ[os.fsdecode(var)])
   409|         0|            0|            0|  0.00%|                        else:
   410|         0|            0|            0|  0.00%|                            value = environ[var]
   411|         0|            0|            0|  0.00%|                    except KeyError:
   412|         0|            0|            0|  0.00%|                        value = dollar + brace + var + rbrace
   413|         0|            0|            0|  0.00%|                    res += value
   414|         0|            0|            0|  0.00%|            else:
   415|         0|            0|            0|  0.00%|                var = path[:0]
   416|         0|            0|            0|  0.00%|                index += 1
   417|         0|            0|            0|  0.00%|                c = path[index:index + 1]
   418|         0|            0|            0|  0.00%|                while c and c in varchars:
   419|         0|            0|            0|  0.00%|                    var += c
   420|         0|            0|            0|  0.00%|                    index += 1
   421|         0|            0|            0|  0.00%|                    c = path[index:index + 1]
   422|         0|            0|            0|  0.00%|                try:
   423|         0|            0|            0|  0.00%|                    if environ is None:
   424|         0|            0|            0|  0.00%|                        value = os.fsencode(os.environ[os.fsdecode(var)])
   425|         0|            0|            0|  0.00%|                    else:
   426|         0|            0|            0|  0.00%|                        value = environ[var]
   427|         0|            0|            0|  0.00%|                except KeyError:
   428|         0|            0|            0|  0.00%|                    value = dollar + var
   429|         0|            0|            0|  0.00%|                res += value
   430|         0|            0|            0|  0.00%|                if c:
   431|         0|            0|            0|  0.00%|                    index -= 1
   432|         0|            0|            0|  0.00%|        else:
   433|         0|            0|            0|  0.00%|            res += c
   434|         0|            0|            0|  0.00%|        index += 1
   435|         0|            0|            0|  0.00%|    return res
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A\B.
   439|         0|            0|            0|  0.00%|# Previously, this function also truncated pathnames to 8+3 format,
   440|         0|            0|            0|  0.00%|# but as this module is called "ntpath", that's obviously wrong!
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|def normpath(path):
   443|         0|            0|            0|  0.00%|    """Normalize path, eliminating double slashes, etc."""
   444|         0|            0|            0|  0.00%|    path = os.fspath(path)
   445|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   446|         0|            0|            0|  0.00%|        sep = b'\\'
   447|         0|            0|            0|  0.00%|        altsep = b'/'
   448|         0|            0|            0|  0.00%|        curdir = b'.'
   449|         0|            0|            0|  0.00%|        pardir = b'..'
   450|         0|            0|            0|  0.00%|        special_prefixes = (b'\\\\.\\', b'\\\\?\\')
   451|         0|            0|            0|  0.00%|    else:
   452|         0|            0|            0|  0.00%|        sep = '\\'
   453|         0|            0|            0|  0.00%|        altsep = '/'
   454|         0|            0|            0|  0.00%|        curdir = '.'
   455|         0|            0|            0|  0.00%|        pardir = '..'
   456|         0|            0|            0|  0.00%|        special_prefixes = ('\\\\.\\', '\\\\?\\')
   457|         0|            0|            0|  0.00%|    if path.startswith(special_prefixes):
   458|         0|            0|            0|  0.00%|        # in the case of paths with these prefixes:
   459|         0|            0|            0|  0.00%|        # \\.\ -> device names
   460|         0|            0|            0|  0.00%|        # \\?\ -> literal paths
   461|         0|            0|            0|  0.00%|        # do not do any normalization, but return the path
   462|         0|            0|            0|  0.00%|        # unchanged apart from the call to os.fspath()
   463|         0|            0|            0|  0.00%|        return path
   464|         0|            0|            0|  0.00%|    path = path.replace(altsep, sep)
   465|         0|            0|            0|  0.00%|    prefix, path = splitdrive(path)
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|    # collapse initial backslashes
   468|         0|            0|            0|  0.00%|    if path.startswith(sep):
   469|         0|            0|            0|  0.00%|        prefix += sep
   470|         0|            0|            0|  0.00%|        path = path.lstrip(sep)
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|    comps = path.split(sep)
   473|         0|            0|            0|  0.00%|    i = 0
   474|         0|            0|            0|  0.00%|    while i < len(comps):
   475|         0|            0|            0|  0.00%|        if not comps[i] or comps[i] == curdir:
   476|         0|            0|            0|  0.00%|            del comps[i]
   477|         0|            0|            0|  0.00%|        elif comps[i] == pardir:
   478|         0|            0|            0|  0.00%|            if i > 0 and comps[i-1] != pardir:
   479|         0|            0|            0|  0.00%|                del comps[i-1:i+1]
   480|         0|            0|            0|  0.00%|                i -= 1
   481|         0|            0|            0|  0.00%|            elif i == 0 and prefix.endswith(sep):
   482|         0|            0|            0|  0.00%|                del comps[i]
   483|         0|            0|            0|  0.00%|            else:
   484|         0|            0|            0|  0.00%|                i += 1
   485|         0|            0|            0|  0.00%|        else:
   486|         0|            0|            0|  0.00%|            i += 1
   487|         0|            0|            0|  0.00%|    # If the path is now empty, substitute '.'
   488|         0|            0|            0|  0.00%|    if not prefix and not comps:
   489|         0|            0|            0|  0.00%|        comps.append(curdir)
   490|         0|            0|            0|  0.00%|    return prefix + sep.join(comps)
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|def _abspath_fallback(path):
   493|         0|            0|            0|  0.00%|    """Return the absolute version of a path as a fallback function in case
   494|         0|            0|            0|  0.00%|    `nt._getfullpathname` is not available or raises OSError. See bpo-31047 for
   495|         0|            0|            0|  0.00%|    more.
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    """
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    path = os.fspath(path)
   500|         0|            0|            0|  0.00%|    if not isabs(path):
   501|         0|            0|            0|  0.00%|        if isinstance(path, bytes):
   502|         0|            0|            0|  0.00%|            cwd = os.getcwdb()
   503|         0|            0|            0|  0.00%|        else:
   504|         0|            0|            0|  0.00%|            cwd = os.getcwd()
   505|         0|            0|            0|  0.00%|        path = join(cwd, path)
   506|         0|            0|            0|  0.00%|    return normpath(path)
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|# Return an absolute path.
   509|         0|            0|            0|  0.00%|try:
   510|         0|            0|            0|  0.00%|    from nt import _getfullpathname
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|except ImportError: # not running on Windows - mock up something sensible
   513|         0|            0|            0|  0.00%|    abspath = _abspath_fallback
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|else:  # use native Windows method on Windows
   516|         0|            0|            0|  0.00%|    def abspath(path):
   517|         0|            0|            0|  0.00%|        """Return the absolute version of a path."""
   518|         0|            0|            0|  0.00%|        try:
   519|         0|            0|            0|  0.00%|            return normpath(_getfullpathname(path))
   520|         0|            0|            0|  0.00%|        except (OSError, ValueError):
   521|         0|            0|            0|  0.00%|            return _abspath_fallback(path)
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|try:
   524|         0|            0|            0|  0.00%|    from nt import _getfinalpathname, readlink as _nt_readlink
   525|         0|            0|            0|  0.00%|except ImportError:
   526|         0|            0|            0|  0.00%|    # realpath is a no-op on systems without _getfinalpathname support.
   527|         0|            0|            0|  0.00%|    realpath = abspath
   528|         0|            0|            0|  0.00%|else:
   529|         0|            0|            0|  0.00%|    def _readlink_deep(path, seen=None):
   530|         0|            0|            0|  0.00%|        if seen is None:
   531|         0|            0|            0|  0.00%|            seen = set()
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|        # These error codes indicate that we should stop reading links and
   534|         0|            0|            0|  0.00%|        # return the path we currently have.
   535|         0|            0|            0|  0.00%|        # 1: ERROR_INVALID_FUNCTION
   536|         0|            0|            0|  0.00%|        # 2: ERROR_FILE_NOT_FOUND
   537|         0|            0|            0|  0.00%|        # 3: ERROR_DIRECTORY_NOT_FOUND
   538|         0|            0|            0|  0.00%|        # 5: ERROR_ACCESS_DENIED
   539|         0|            0|            0|  0.00%|        # 21: ERROR_NOT_READY (implies drive with no media)
   540|         0|            0|            0|  0.00%|        # 32: ERROR_SHARING_VIOLATION (probably an NTFS paging file)
   541|         0|            0|            0|  0.00%|        # 50: ERROR_NOT_SUPPORTED (implies no support for reparse points)
   542|         0|            0|            0|  0.00%|        # 67: ERROR_BAD_NET_NAME (implies remote server unavailable)
   543|         0|            0|            0|  0.00%|        # 87: ERROR_INVALID_PARAMETER
   544|         0|            0|            0|  0.00%|        # 4390: ERROR_NOT_A_REPARSE_POINT
   545|         0|            0|            0|  0.00%|        # 4392: ERROR_INVALID_REPARSE_DATA
   546|         0|            0|            0|  0.00%|        # 4393: ERROR_REPARSE_TAG_INVALID
   547|         0|            0|            0|  0.00%|        allowed_winerror = 1, 2, 3, 5, 21, 32, 50, 67, 87, 4390, 4392, 4393
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|        while normcase(path) not in seen:
   550|         0|            0|            0|  0.00%|            seen.add(normcase(path))
   551|         0|            0|            0|  0.00%|            try:
   552|         0|            0|            0|  0.00%|                path = _nt_readlink(path)
   553|         0|            0|            0|  0.00%|            except OSError as ex:
   554|         0|            0|            0|  0.00%|                if ex.winerror in allowed_winerror:
   555|         0|            0|            0|  0.00%|                    break
   556|         0|            0|            0|  0.00%|                raise
   557|         0|            0|            0|  0.00%|            except ValueError:
   558|         0|            0|            0|  0.00%|                # Stop on reparse points that are not symlinks
   559|         0|            0|            0|  0.00%|                break
   560|         0|            0|            0|  0.00%|        return path
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    def _getfinalpathname_nonstrict(path):
   563|         0|            0|            0|  0.00%|        # These error codes indicate that we should stop resolving the path
   564|         0|            0|            0|  0.00%|        # and return the value we currently have.
   565|         0|            0|            0|  0.00%|        # 1: ERROR_INVALID_FUNCTION
   566|         0|            0|            0|  0.00%|        # 2: ERROR_FILE_NOT_FOUND
   567|         0|            0|            0|  0.00%|        # 3: ERROR_DIRECTORY_NOT_FOUND
   568|         0|            0|            0|  0.00%|        # 5: ERROR_ACCESS_DENIED
   569|         0|            0|            0|  0.00%|        # 21: ERROR_NOT_READY (implies drive with no media)
   570|         0|            0|            0|  0.00%|        # 32: ERROR_SHARING_VIOLATION (probably an NTFS paging file)
   571|         0|            0|            0|  0.00%|        # 50: ERROR_NOT_SUPPORTED
   572|         0|            0|            0|  0.00%|        # 67: ERROR_BAD_NET_NAME (implies remote server unavailable)
   573|         0|            0|            0|  0.00%|        # 87: ERROR_INVALID_PARAMETER
   574|         0|            0|            0|  0.00%|        # 123: ERROR_INVALID_NAME
   575|         0|            0|            0|  0.00%|        # 1920: ERROR_CANT_ACCESS_FILE
   576|         0|            0|            0|  0.00%|        # 1921: ERROR_CANT_RESOLVE_FILENAME (implies unfollowable symlink)
   577|         0|            0|            0|  0.00%|        allowed_winerror = 1, 2, 3, 5, 21, 32, 50, 67, 87, 123, 1920, 1921
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|        # Non-strict algorithm is to find as much of the target directory
   580|         0|            0|            0|  0.00%|        # as we can and join the rest.
   581|         0|            0|            0|  0.00%|        tail = ''
   582|         0|            0|            0|  0.00%|        seen = set()
   583|         0|            0|            0|  0.00%|        while path:
   584|         0|            0|            0|  0.00%|            try:
   585|         0|            0|            0|  0.00%|                path = _readlink_deep(path, seen)
   586|         0|            0|            0|  0.00%|                path = _getfinalpathname(path)
   587|         0|            0|            0|  0.00%|                return join(path, tail) if tail else path
   588|         0|            0|            0|  0.00%|            except OSError as ex:
   589|         0|            0|            0|  0.00%|                if ex.winerror not in allowed_winerror:
   590|         0|            0|            0|  0.00%|                    raise
   591|         0|            0|            0|  0.00%|                path, name = split(path)
   592|         0|            0|            0|  0.00%|                # TODO (bpo-38186): Request the real file name from the directory
   593|         0|            0|            0|  0.00%|                # entry using FindFirstFileW. For now, we will return the path
   594|         0|            0|            0|  0.00%|                # as best we have it
   595|         0|            0|            0|  0.00%|                if path and not name:
   596|         0|            0|            0|  0.00%|                    return abspath(path + tail)
   597|         0|            0|            0|  0.00%|                tail = join(name, tail) if tail else name
   598|         0|            0|            0|  0.00%|        return abspath(tail)
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|    def realpath(path):
   601|         0|            0|            0|  0.00%|        path = normpath(path)
   602|         0|            0|            0|  0.00%|        if isinstance(path, bytes):
   603|         0|            0|            0|  0.00%|            prefix = b'\\\\?\\'
   604|         0|            0|            0|  0.00%|            unc_prefix = b'\\\\?\\UNC\\'
   605|         0|            0|            0|  0.00%|            new_unc_prefix = b'\\\\'
   606|         0|            0|            0|  0.00%|            cwd = os.getcwdb()
   607|         0|            0|            0|  0.00%|        else:
   608|         0|            0|            0|  0.00%|            prefix = '\\\\?\\'
   609|         0|            0|            0|  0.00%|            unc_prefix = '\\\\?\\UNC\\'
   610|         0|            0|            0|  0.00%|            new_unc_prefix = '\\\\'
   611|         0|            0|            0|  0.00%|            cwd = os.getcwd()
   612|         0|            0|            0|  0.00%|        had_prefix = path.startswith(prefix)
   613|         0|            0|            0|  0.00%|        try:
   614|         0|            0|            0|  0.00%|            path = _getfinalpathname(path)
   615|         0|            0|            0|  0.00%|            initial_winerror = 0
   616|         0|            0|            0|  0.00%|        except OSError as ex:
   617|         0|            0|            0|  0.00%|            initial_winerror = ex.winerror
   618|         0|            0|            0|  0.00%|            path = _getfinalpathname_nonstrict(path)
   619|         0|            0|            0|  0.00%|        # The path returned by _getfinalpathname will always start with \\?\ -
   620|         0|            0|            0|  0.00%|        # strip off that prefix unless it was already provided on the original
   621|         0|            0|            0|  0.00%|        # path.
   622|         0|            0|            0|  0.00%|        if not had_prefix and path.startswith(prefix):
   623|         0|            0|            0|  0.00%|            # For UNC paths, the prefix will actually be \\?\UNC\
   624|         0|            0|            0|  0.00%|            # Handle that case as well.
   625|         0|            0|            0|  0.00%|            if path.startswith(unc_prefix):
   626|         0|            0|            0|  0.00%|                spath = new_unc_prefix + path[len(unc_prefix):]
   627|         0|            0|            0|  0.00%|            else:
   628|         0|            0|            0|  0.00%|                spath = path[len(prefix):]
   629|         0|            0|            0|  0.00%|            # Ensure that the non-prefixed path resolves to the same path
   630|         0|            0|            0|  0.00%|            try:
   631|         0|            0|            0|  0.00%|                if _getfinalpathname(spath) == path:
   632|         0|            0|            0|  0.00%|                    path = spath
   633|         0|            0|            0|  0.00%|            except OSError as ex:
   634|         0|            0|            0|  0.00%|                # If the path does not exist and originally did not exist, then
   635|         0|            0|            0|  0.00%|                # strip the prefix anyway.
   636|         0|            0|            0|  0.00%|                if ex.winerror == initial_winerror:
   637|         0|            0|            0|  0.00%|                    path = spath
   638|         0|            0|            0|  0.00%|        return path
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|# Win9x family and earlier have no Unicode filename support.
   642|         0|            0|            0|  0.00%|supports_unicode_filenames = (hasattr(sys, "getwindowsversion") and
   643|         0|            0|            0|  0.00%|                              sys.getwindowsversion()[3] >= 2)
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|def relpath(path, start=None):
   646|         0|            0|            0|  0.00%|    """Return a relative version of a path"""
   647|         0|            0|            0|  0.00%|    path = os.fspath(path)
   648|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   649|         0|            0|            0|  0.00%|        sep = b'\\'
   650|         0|            0|            0|  0.00%|        curdir = b'.'
   651|         0|            0|            0|  0.00%|        pardir = b'..'
   652|         0|            0|            0|  0.00%|    else:
   653|         0|            0|            0|  0.00%|        sep = '\\'
   654|         0|            0|            0|  0.00%|        curdir = '.'
   655|         0|            0|            0|  0.00%|        pardir = '..'
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|    if start is None:
   658|         0|            0|            0|  0.00%|        start = curdir
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    if not path:
   661|         0|            0|            0|  0.00%|        raise ValueError("no path specified")
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    start = os.fspath(start)
   664|         0|            0|            0|  0.00%|    try:
   665|         0|            0|            0|  0.00%|        start_abs = abspath(normpath(start))
   666|         0|            0|            0|  0.00%|        path_abs = abspath(normpath(path))
   667|         0|            0|            0|  0.00%|        start_drive, start_rest = splitdrive(start_abs)
   668|         0|            0|            0|  0.00%|        path_drive, path_rest = splitdrive(path_abs)
   669|         0|            0|            0|  0.00%|        if normcase(start_drive) != normcase(path_drive):
   670|         0|            0|            0|  0.00%|            raise ValueError("path is on mount %r, start on mount %r" % (
   671|         0|            0|            0|  0.00%|                path_drive, start_drive))
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|        start_list = [x for x in start_rest.split(sep) if x]
   674|         0|            0|            0|  0.00%|        path_list = [x for x in path_rest.split(sep) if x]
   675|         0|            0|            0|  0.00%|        # Work out how much of the filepath is shared by start and path.
   676|         0|            0|            0|  0.00%|        i = 0
   677|         0|            0|            0|  0.00%|        for e1, e2 in zip(start_list, path_list):
   678|         0|            0|            0|  0.00%|            if normcase(e1) != normcase(e2):
   679|         0|            0|            0|  0.00%|                break
   680|         0|            0|            0|  0.00%|            i += 1
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|        rel_list = [pardir] * (len(start_list)-i) + path_list[i:]
   683|         0|            0|            0|  0.00%|        if not rel_list:
   684|         0|            0|            0|  0.00%|            return curdir
   685|         0|            0|            0|  0.00%|        return join(*rel_list)
   686|         0|            0|            0|  0.00%|    except (TypeError, ValueError, AttributeError, BytesWarning, DeprecationWarning):
   687|         0|            0|            0|  0.00%|        genericpath._check_arg_types('relpath', path, start)
   688|         0|            0|            0|  0.00%|        raise
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|# Return the longest common sub-path of the sequence of paths given as input.
   692|         0|            0|            0|  0.00%|# The function is case-insensitive and 'separator-insensitive', i.e. if the
   693|         0|            0|            0|  0.00%|# only difference between two paths is the use of '\' versus '/' as separator,
   694|         0|            0|            0|  0.00%|# they are deemed to be equal.
   695|         0|            0|            0|  0.00%|#
   696|         0|            0|            0|  0.00%|# However, the returned path will have the standard '\' separator (even if the
   697|         0|            0|            0|  0.00%|# given paths had the alternative '/' separator) and will have the case of the
   698|         0|            0|            0|  0.00%|# first path given in the sequence. Additionally, any trailing separator is
   699|         0|            0|            0|  0.00%|# stripped from the returned path.
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|def commonpath(paths):
   702|         0|            0|            0|  0.00%|    """Given a sequence of path names, returns the longest common sub-path."""
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|    if not paths:
   705|         0|            0|            0|  0.00%|        raise ValueError('commonpath() arg is an empty sequence')
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    paths = tuple(map(os.fspath, paths))
   708|         0|            0|            0|  0.00%|    if isinstance(paths[0], bytes):
   709|         0|            0|            0|  0.00%|        sep = b'\\'
   710|         0|            0|            0|  0.00%|        altsep = b'/'
   711|         0|            0|            0|  0.00%|        curdir = b'.'
   712|         0|            0|            0|  0.00%|    else:
   713|         0|            0|            0|  0.00%|        sep = '\\'
   714|         0|            0|            0|  0.00%|        altsep = '/'
   715|         0|            0|            0|  0.00%|        curdir = '.'
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|    try:
   718|         0|            0|            0|  0.00%|        drivesplits = [splitdrive(p.replace(altsep, sep).lower()) for p in paths]
   719|         0|            0|            0|  0.00%|        split_paths = [p.split(sep) for d, p in drivesplits]
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|        try:
   722|         0|            0|            0|  0.00%|            isabs, = set(p[:1] == sep for d, p in drivesplits)
   723|         0|            0|            0|  0.00%|        except ValueError:
   724|         0|            0|            0|  0.00%|            raise ValueError("Can't mix absolute and relative paths") from None
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|        # Check that all drive letters or UNC paths match. The check is made only
   727|         0|            0|            0|  0.00%|        # now otherwise type errors for mixing strings and bytes would not be
   728|         0|            0|            0|  0.00%|        # caught.
   729|         0|            0|            0|  0.00%|        if len(set(d for d, p in drivesplits)) != 1:
   730|         0|            0|            0|  0.00%|            raise ValueError("Paths don't have the same drive")
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|        drive, path = splitdrive(paths[0].replace(altsep, sep))
   733|         0|            0|            0|  0.00%|        common = path.split(sep)
   734|         0|            0|            0|  0.00%|        common = [c for c in common if c and c != curdir]
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|        split_paths = [[c for c in s if c and c != curdir] for s in split_paths]
   737|         0|            0|            0|  0.00%|        s1 = min(split_paths)
   738|         0|            0|            0|  0.00%|        s2 = max(split_paths)
   739|         0|            0|            0|  0.00%|        for i, c in enumerate(s1):
   740|         0|            0|            0|  0.00%|            if c != s2[i]:
   741|         0|            0|            0|  0.00%|                common = common[:i]
   742|         0|            0|            0|  0.00%|                break
   743|         0|            0|            0|  0.00%|        else:
   744|         0|            0|            0|  0.00%|            common = common[:len(s1)]
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|        prefix = drive + sep if isabs else drive
   747|         0|            0|            0|  0.00%|        return prefix + sep.join(common)
   748|         0|            0|            0|  0.00%|    except (TypeError, AttributeError):
   749|         0|            0|            0|  0.00%|        genericpath._check_arg_types('commonpath', *paths)
   750|         0|            0|            0|  0.00%|        raise
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|try:
   754|         0|            0|            0|  0.00%|    # The genericpath.isdir implementation uses os.stat and checks the mode
   755|         0|            0|            0|  0.00%|    # attribute to tell whether or not the path is a directory.
   756|         0|            0|            0|  0.00%|    # This is overkill on Windows - just pass the path to GetFileAttributes
   757|         0|            0|            0|  0.00%|    # and check the attribute from there.
   758|         0|            0|            0|  0.00%|    from nt import _isdir as isdir
   759|         0|            0|            0|  0.00%|except ImportError:
   760|         0|            0|            0|  0.00%|    # Use genericpath.isdir as imported above.
   761|         0|            0|            0|  0.00%|    pass
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\__init__.py
File duration: 0.0600336s (0.17%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|NumPy
     3|         0|            0|            0|  0.00%|=====
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|Provides
     6|         0|            0|            0|  0.00%|  1. An array object of arbitrary homogeneous items
     7|         0|            0|            0|  0.00%|  2. Fast mathematical operations over arrays
     8|         0|            0|            0|  0.00%|  3. Linear Algebra, Fourier Transforms, Random Number Generation
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|How to use the documentation
    11|         0|            0|            0|  0.00%|----------------------------
    12|         0|            0|            0|  0.00%|Documentation is available in two forms: docstrings provided
    13|         0|            0|            0|  0.00%|with the code, and a loose standing reference guide, available from
    14|         0|            0|            0|  0.00%|`the NumPy homepage <https://www.scipy.org>`_.
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|We recommend exploring the docstrings using
    17|         0|            0|            0|  0.00%|`IPython <https://ipython.org>`_, an advanced Python shell with
    18|         0|            0|            0|  0.00%|TAB-completion and introspection capabilities.  See below for further
    19|         0|            0|            0|  0.00%|instructions.
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|The docstring examples assume that `numpy` has been imported as `np`::
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|  >>> import numpy as np
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|Code snippets are indicated by three greater-than signs::
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|  >>> x = 42
    28|         0|            0|            0|  0.00%|  >>> x = x + 1
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|Use the built-in ``help`` function to view a function's docstring::
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|  >>> help(np.sort)
    33|         0|            0|            0|  0.00%|  ... # doctest: +SKIP
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|For some objects, ``np.info(obj)`` may provide additional help.  This is
    36|         0|            0|            0|  0.00%|particularly true if you see the line "Help on ufunc object:" at the top
    37|         0|            0|            0|  0.00%|of the help() page.  Ufuncs are implemented in C, not Python, for speed.
    38|         0|            0|            0|  0.00%|The native Python help() does not know how to view their help, but our
    39|         0|            0|            0|  0.00%|np.info() function does.
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|To search for documents containing a keyword, do::
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|  >>> np.lookfor('keyword')
    44|         0|            0|            0|  0.00%|  ... # doctest: +SKIP
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|General-purpose documents like a glossary and help on the basic concepts
    47|         0|            0|            0|  0.00%|of numpy are available under the ``doc`` sub-module::
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|  >>> from numpy import doc
    50|         0|            0|            0|  0.00%|  >>> help(doc)
    51|         0|            0|            0|  0.00%|  ... # doctest: +SKIP
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|Available subpackages
    54|         0|            0|            0|  0.00%|---------------------
    55|         0|            0|            0|  0.00%|doc
    56|         0|            0|            0|  0.00%|    Topical documentation on broadcasting, indexing, etc.
    57|         0|            0|            0|  0.00%|lib
    58|         0|            0|            0|  0.00%|    Basic functions used by several sub-packages.
    59|         0|            0|            0|  0.00%|random
    60|         0|            0|            0|  0.00%|    Core Random Tools
    61|         0|            0|            0|  0.00%|linalg
    62|         0|            0|            0|  0.00%|    Core Linear Algebra Tools
    63|         0|            0|            0|  0.00%|fft
    64|         0|            0|            0|  0.00%|    Core FFT routines
    65|         0|            0|            0|  0.00%|polynomial
    66|         0|            0|            0|  0.00%|    Polynomial tools
    67|         0|            0|            0|  0.00%|testing
    68|         0|            0|            0|  0.00%|    NumPy testing tools
    69|         0|            0|            0|  0.00%|f2py
    70|         0|            0|            0|  0.00%|    Fortran to Python Interface Generator.
    71|         0|            0|            0|  0.00%|distutils
    72|         0|            0|            0|  0.00%|    Enhancements to distutils with support for
    73|         0|            0|            0|  0.00%|    Fortran compilers support and more.
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|Utilities
    76|         0|            0|            0|  0.00%|---------
    77|         0|            0|            0|  0.00%|test
    78|         0|            0|            0|  0.00%|    Run numpy unittests
    79|         0|            0|            0|  0.00%|show_config
    80|         0|            0|            0|  0.00%|    Show numpy build configuration
    81|         0|            0|            0|  0.00%|dual
    82|         0|            0|            0|  0.00%|    Overwrite certain functions with high-performance SciPy tools.
    83|         0|            0|            0|  0.00%|    Note: `numpy.dual` is deprecated.  Use the functions from NumPy or Scipy
    84|         0|            0|            0|  0.00%|    directly instead of importing them from `numpy.dual`.
    85|         0|            0|            0|  0.00%|matlib
    86|         0|            0|            0|  0.00%|    Make everything matrices.
    87|         0|            0|            0|  0.00%|__version__
    88|         0|            0|            0|  0.00%|    NumPy version string
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|Viewing documentation using IPython
    91|         0|            0|            0|  0.00%|-----------------------------------
    92|         0|            0|            0|  0.00%|Start IPython with the NumPy profile (``ipython -p numpy``), which will
    93|         0|            0|            0|  0.00%|import `numpy` under the alias `np`.  Then, use the ``cpaste`` command to
    94|         0|            0|            0|  0.00%|paste examples into the shell.  To see which functions are available in
    95|         0|            0|            0|  0.00%|`numpy`, type ``np.<TAB>`` (where ``<TAB>`` refers to the TAB key), or use
    96|         0|            0|            0|  0.00%|``np.*cos*?<ENTER>`` (where ``<ENTER>`` refers to the ENTER key) to narrow
    97|         0|            0|            0|  0.00%|down the list.  To view the docstring for a function, use
    98|         0|            0|            0|  0.00%|``np.cos?<ENTER>`` (to view the docstring) and ``np.cos??<ENTER>`` (to view
    99|         0|            0|            0|  0.00%|the source code).
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|Copies vs. in-place operation
   102|         0|            0|            0|  0.00%|-----------------------------
   103|         0|            0|            0|  0.00%|Most of the functions in `numpy` return a copy of the array argument
   104|         0|            0|            0|  0.00%|(e.g., `np.sort`).  In-place versions of these functions are often
   105|         0|            0|            0|  0.00%|available as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.
   106|         0|            0|            0|  0.00%|Exceptions to this rule are documented.
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|"""
   109|         0|            0|            0|  0.00%|import sys
   110|         0|            0|            0|  0.00%|import warnings
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|from ._globals import (
   113|         0|            0|            0|  0.00%|    ModuleDeprecationWarning, VisibleDeprecationWarning,
   114|         0|            0|            0|  0.00%|    _NoValue, _CopyMode
   115|         0|            0|            0|  0.00%|)
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|# We first need to detect if we're being called as part of the numpy setup
   118|         0|            0|            0|  0.00%|# procedure itself in a reliable manner.
   119|         0|            0|            0|  0.00%|try:
   120|         0|            0|            0|  0.00%|    __NUMPY_SETUP__
   121|         0|            0|            0|  0.00%|except NameError:
   122|         0|            0|            0|  0.00%|    __NUMPY_SETUP__ = False
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|if __NUMPY_SETUP__:
   125|         0|            0|            0|  0.00%|    sys.stderr.write('Running from numpy source directory.\n')
   126|         0|            0|            0|  0.00%|else:
   127|         0|            0|            0|  0.00%|    try:
   128|         0|            0|            0|  0.00%|        from numpy.__config__ import show as show_config
   129|         0|            0|            0|  0.00%|    except ImportError as e:
   130|         0|            0|            0|  0.00%|        msg = """Error importing numpy: you should not try to import numpy from
   131|         0|            0|            0|  0.00%|        its source directory; please exit the numpy source tree, and relaunch
   132|         0|            0|            0|  0.00%|        your python interpreter from there."""
   133|         0|            0|            0|  0.00%|        raise ImportError(msg) from e
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|    __all__ = ['ModuleDeprecationWarning',
   136|         0|            0|            0|  0.00%|               'VisibleDeprecationWarning']
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    # mapping of {name: (value, deprecation_msg)}
   139|         0|            0|            0|  0.00%|    __deprecated_attrs__ = {}
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    # Allow distributors to run custom init code
   142|         0|            0|            0|  0.00%|    from . import _distributor_init
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    from . import core
   145|         0|            0|            0|  0.00%|    from .core import *
   146|         0|            0|            0|  0.00%|    from . import compat
   147|         0|            0|            0|  0.00%|    from . import lib
   148|         0|            0|            0|  0.00%|    # NOTE: to be revisited following future namespace cleanup.
   149|         0|            0|            0|  0.00%|    # See gh-14454 and gh-15672 for discussion.
   150|         0|            0|            0|  0.00%|    from .lib import *
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    from . import linalg
   153|         0|            0|            0|  0.00%|    from . import fft
   154|         0|            0|            0|  0.00%|    from . import polynomial
   155|         0|            0|            0|  0.00%|    from . import random
   156|         0|            0|            0|  0.00%|    from . import ctypeslib
   157|         0|            0|            0|  0.00%|    from . import ma
   158|         0|            0|            0|  0.00%|    from . import matrixlib as _mat
   159|         0|            0|            0|  0.00%|    from .matrixlib import *
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|    # Deprecations introduced in NumPy 1.20.0, 2020-06-06
   162|         0|            0|            0|  0.00%|    import builtins as _builtins
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    _msg = (
   165|         0|            0|            0|  0.00%|        "`np.{n}` is a deprecated alias for the builtin `{n}`. "
   166|         0|            0|            0|  0.00%|        "To silence this warning, use `{n}` by itself. Doing this will not "
   167|         0|            0|            0|  0.00%|        "modify any behavior and is safe. {extended_msg}\n"
   168|         0|            0|            0|  0.00%|        "Deprecated in NumPy 1.20; for more details and guidance: "
   169|         0|            0|            0|  0.00%|        "https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations")
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    _specific_msg = (
   172|         0|            0|            0|  0.00%|        "If you specifically wanted the numpy scalar type, use `np.{}` here.")
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|    _int_extended_msg = (
   175|         0|            0|            0|  0.00%|        "When replacing `np.{}`, you may wish to use e.g. `np.int64` "
   176|         0|            0|            0|  0.00%|        "or `np.int32` to specify the precision. If you wish to review "
   177|         0|            0|            0|  0.00%|        "your current use, check the release note link for "
   178|         0|            0|            0|  0.00%|        "additional information.")
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|    _type_info = [
   181|         0|            0|            0|  0.00%|        ("object", ""),  # The NumPy scalar only exists by name.
   182|         0|            0|            0|  0.00%|        ("bool", _specific_msg.format("bool_")),
   183|         0|            0|            0|  0.00%|        ("float", _specific_msg.format("float64")),
   184|         0|            0|            0|  0.00%|        ("complex", _specific_msg.format("complex128")),
   185|         0|            0|            0|  0.00%|        ("str", _specific_msg.format("str_")),
   186|         0|            0|            0|  0.00%|        ("int", _int_extended_msg.format("int"))]
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    __deprecated_attrs__.update({
   189|         0|            0|            0|  0.00%|        n: (getattr(_builtins, n), _msg.format(n=n, extended_msg=extended_msg))
   190|         0|            0|            0|  0.00%|        for n, extended_msg in _type_info
   191|         0|            0|            0|  0.00%|    })
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    # Numpy 1.20.0, 2020-10-19
   194|         0|            0|            0|  0.00%|    __deprecated_attrs__["typeDict"] = (
   195|         0|            0|            0|  0.00%|        core.numerictypes.typeDict,
   196|         0|            0|            0|  0.00%|        "`np.typeDict` is a deprecated alias for `np.sctypeDict`."
   197|         0|            0|            0|  0.00%|    )
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    # NumPy 1.22, 2021-10-20
   200|         0|            0|            0|  0.00%|    __deprecated_attrs__["MachAr"] = (
   201|         0|            0|            0|  0.00%|        core._machar.MachAr,
   202|         0|            0|            0|  0.00%|        "`np.MachAr` is deprecated (NumPy 1.22)."
   203|         0|            0|            0|  0.00%|    )
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|    _msg = (
   206|         0|            0|            0|  0.00%|        "`np.{n}` is a deprecated alias for `np.compat.{n}`. "
   207|         0|            0|            0|  0.00%|        "To silence this warning, use `np.compat.{n}` by itself. "
   208|         0|            0|            0|  0.00%|        "In the likely event your code does not need to work on Python 2 "
   209|         0|            0|            0|  0.00%|        "you can use the builtin `{n2}` for which `np.compat.{n}` is itself "
   210|         0|            0|            0|  0.00%|        "an alias. Doing this will not modify any behaviour and is safe. "
   211|         0|            0|            0|  0.00%|        "{extended_msg}\n"
   212|         0|            0|            0|  0.00%|        "Deprecated in NumPy 1.20; for more details and guidance: "
   213|         0|            0|            0|  0.00%|        "https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations")
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    __deprecated_attrs__["long"] = (
   216|         0|            0|            0|  0.00%|        getattr(compat, "long"),
   217|         0|            0|            0|  0.00%|        _msg.format(n="long", n2="int",
   218|         0|            0|            0|  0.00%|                    extended_msg=_int_extended_msg.format("long")))
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    __deprecated_attrs__["unicode"] = (
   221|         0|            0|            0|  0.00%|        getattr(compat, "unicode"),
   222|         0|            0|            0|  0.00%|        _msg.format(n="unicode", n2="str",
   223|         0|            0|            0|  0.00%|                    extended_msg=_specific_msg.format("str_")))
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|    del _msg, _specific_msg, _int_extended_msg, _type_info, _builtins
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    from .core import round, abs, max, min
   228|         0|            0|            0|  0.00%|    # now that numpy modules are imported, can initialize limits
   229|         0|            0|            0|  0.00%|    core.getlimits._register_known_types()
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    __all__.extend(['__version__', 'show_config'])
   232|         0|            0|            0|  0.00%|    __all__.extend(core.__all__)
   233|         0|            0|            0|  0.00%|    __all__.extend(_mat.__all__)
   234|         0|            0|            0|  0.00%|    __all__.extend(lib.__all__)
   235|         0|            0|            0|  0.00%|    __all__.extend(['linalg', 'fft', 'random', 'ctypeslib', 'ma'])
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    # Remove one of the two occurrences of `issubdtype`, which is exposed as
   238|         0|            0|            0|  0.00%|    # both `numpy.core.issubdtype` and `numpy.lib.issubdtype`.
   239|         0|            0|            0|  0.00%|    __all__.remove('issubdtype')
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    # These are exported by np.core, but are replaced by the builtins below
   242|         0|            0|            0|  0.00%|    # remove them to ensure that we don't end up with `np.long == np.int_`,
   243|         0|            0|            0|  0.00%|    # which would be a breaking change.
   244|         0|            0|            0|  0.00%|    del long, unicode
   245|         0|            0|            0|  0.00%|    __all__.remove('long')
   246|         0|            0|            0|  0.00%|    __all__.remove('unicode')
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    # Remove things that are in the numpy.lib but not in the numpy namespace
   249|         0|            0|            0|  0.00%|    # Note that there is a test (numpy/tests/test_public_api.py:test_numpy_namespace)
   250|         0|            0|            0|  0.00%|    # that prevents adding more things to the main namespace by accident.
   251|         0|            0|            0|  0.00%|    # The list below will grow until the `from .lib import *` fixme above is
   252|         0|            0|            0|  0.00%|    # taken care of
   253|         0|            0|            0|  0.00%|    __all__.remove('Arrayterator')
   254|         0|            0|            0|  0.00%|    del Arrayterator
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|    # These names were removed in NumPy 1.20.  For at least one release,
   257|         0|            0|            0|  0.00%|    # attempts to access these names in the numpy namespace will trigger
   258|         0|            0|            0|  0.00%|    # a warning, and calling the function will raise an exception.
   259|         0|            0|            0|  0.00%|    _financial_names = ['fv', 'ipmt', 'irr', 'mirr', 'nper', 'npv', 'pmt',
   260|         0|            0|            0|  0.00%|                        'ppmt', 'pv', 'rate']
   261|         0|            0|            0|  0.00%|    __expired_functions__ = {
   262|         0|            0|            0|  0.00%|        name: (f'In accordance with NEP 32, the function {name} was removed '
   263|         0|            0|            0|  0.00%|               'from NumPy version 1.20.  A replacement for this function '
   264|         0|            0|            0|  0.00%|               'is available in the numpy_financial library: '
   265|         0|            0|            0|  0.00%|               'https://pypi.org/project/numpy-financial')
   266|         0|            0|            0|  0.00%|        for name in _financial_names}
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|    # Filter out Cython harmless warnings
   269|         0|            0|            0|  0.00%|    warnings.filterwarnings("ignore", message="numpy.dtype size changed")
   270|         0|            0|            0|  0.00%|    warnings.filterwarnings("ignore", message="numpy.ufunc size changed")
   271|         0|            0|            0|  0.00%|    warnings.filterwarnings("ignore", message="numpy.ndarray size changed")
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    # oldnumeric and numarray were removed in 1.9. In case some packages import
   274|         0|            0|            0|  0.00%|    # but do not use them, we define them here for backward compatibility.
   275|         0|            0|            0|  0.00%|    oldnumeric = 'removed'
   276|         0|            0|            0|  0.00%|    numarray = 'removed'
   277|         0|            0|            0|  0.00%|
   278|      2896|    0.0050602|  1.74731e-06|  0.01%|    def __getattr__(attr):
   279|         0|            0|            0|  0.00%|        # Warn for expired attributes, and return a dummy function
   280|         0|            0|            0|  0.00%|        # that always raises an exception.
   281|      2896|   0.00812364|  2.80512e-06|  0.02%|        try:
   282|      2896|   0.00506592|  1.74928e-06|  0.01%|            msg = __expired_functions__[attr]
   283|      2896|   0.00303006|  1.04629e-06|  0.01%|        except KeyError:
   284|      2896|   0.00702596|  2.42609e-06|  0.02%|            pass
   285|         0|            0|            0|  0.00%|        else:
   286|         0|            0|            0|  0.00%|            warnings.warn(msg, DeprecationWarning, stacklevel=2)
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|            def _expired(*args, **kwds):
   289|         0|            0|            0|  0.00%|                raise RuntimeError(msg)
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|            return _expired
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|        # Emit warnings for deprecated attributes
   294|      2896|   0.00230646|   7.9643e-07|  0.01%|        try:
   295|      2896|   0.00306082|  1.05691e-06|  0.01%|            val, msg = __deprecated_attrs__[attr]
   296|         0|            0|            0|  0.00%|        except KeyError:
   297|         0|            0|            0|  0.00%|            pass
   298|         0|            0|            0|  0.00%|        else:
   299|      2896|     0.018209|  6.28763e-06|  0.05%|            warnings.warn(msg, DeprecationWarning, stacklevel=2)
   300|      2896|   0.00815153|  2.81476e-06|  0.02%|            return val
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|        # Importing Tester requires importing all of UnitTest which is not a
   303|         0|            0|            0|  0.00%|        # cheap import Since it is mainly used in test suits, we lazy import it
   304|         0|            0|            0|  0.00%|        # here to save on the order of 10 ms of import time for most users
   305|         0|            0|            0|  0.00%|        #
   306|         0|            0|            0|  0.00%|        # The previous way Tester was imported also had a side effect of adding
   307|         0|            0|            0|  0.00%|        # the full `numpy.testing` namespace
   308|         0|            0|            0|  0.00%|        if attr == 'testing':
   309|         0|            0|            0|  0.00%|            import numpy.testing as testing
   310|         0|            0|            0|  0.00%|            return testing
   311|         0|            0|            0|  0.00%|        elif attr == 'Tester':
   312|         0|            0|            0|  0.00%|            from .testing import Tester
   313|         0|            0|            0|  0.00%|            return Tester
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|        raise AttributeError("module {!r} has no attribute "
   316|         0|            0|            0|  0.00%|                             "{!r}".format(__name__, attr))
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    def __dir__():
   319|         0|            0|            0|  0.00%|        return list(globals().keys() | {'Tester', 'testing'})
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|    # Pytest testing
   322|         0|            0|            0|  0.00%|    from numpy._pytesttester import PytestTester
   323|         0|            0|            0|  0.00%|    test = PytestTester(__name__)
   324|         0|            0|            0|  0.00%|    del PytestTester
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    def _sanity_check():
   327|         0|            0|            0|  0.00%|        """
   328|         0|            0|            0|  0.00%|        Quick sanity checks for common bugs caused by environment.
   329|         0|            0|            0|  0.00%|        There are some cases e.g. with wrong BLAS ABI that cause wrong
   330|         0|            0|            0|  0.00%|        results under specific runtime conditions that are not necessarily
   331|         0|            0|            0|  0.00%|        achieved during test suite runs, and it is useful to catch those early.
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|        See https://github.com/numpy/numpy/issues/8577 and other
   334|         0|            0|            0|  0.00%|        similar bug reports.
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|        """
   337|         0|            0|            0|  0.00%|        try:
   338|         0|            0|            0|  0.00%|            x = ones(2, dtype=float32)
   339|         0|            0|            0|  0.00%|            if not abs(x.dot(x) - 2.0) < 1e-5:
   340|         0|            0|            0|  0.00%|                raise AssertionError()
   341|         0|            0|            0|  0.00%|        except AssertionError:
   342|         0|            0|            0|  0.00%|            msg = ("The current Numpy installation ({!r}) fails to "
   343|         0|            0|            0|  0.00%|                   "pass simple sanity checks. This can be caused for example "
   344|         0|            0|            0|  0.00%|                   "by incorrect BLAS library being linked in, or by mixing "
   345|         0|            0|            0|  0.00%|                   "package managers (pip, conda, apt, ...). Search closed "
   346|         0|            0|            0|  0.00%|                   "numpy issues for similar problems.")
   347|         0|            0|            0|  0.00%|            raise RuntimeError(msg.format(__file__)) from None
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|    _sanity_check()
   350|         0|            0|            0|  0.00%|    del _sanity_check
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    def _mac_os_check():
   353|         0|            0|            0|  0.00%|        """
   354|         0|            0|            0|  0.00%|        Quick Sanity check for Mac OS look for accelerate build bugs.
   355|         0|            0|            0|  0.00%|        Testing numpy polyfit calls init_dgelsd(LAPACK)
   356|         0|            0|            0|  0.00%|        """
   357|         0|            0|            0|  0.00%|        try:
   358|         0|            0|            0|  0.00%|            c = array([3., 2., 1.])
   359|         0|            0|            0|  0.00%|            x = linspace(0, 2, 5)
   360|         0|            0|            0|  0.00%|            y = polyval(c, x)
   361|         0|            0|            0|  0.00%|            _ = polyfit(x, y, 2, cov=True)
   362|         0|            0|            0|  0.00%|        except ValueError:
   363|         0|            0|            0|  0.00%|            pass
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|    import sys
   366|         0|            0|            0|  0.00%|    if sys.platform == "darwin":
   367|         0|            0|            0|  0.00%|        with warnings.catch_warnings(record=True) as w:
   368|         0|            0|            0|  0.00%|            _mac_os_check()
   369|         0|            0|            0|  0.00%|            # Throw runtime error, if the test failed Check for warning and error_message
   370|         0|            0|            0|  0.00%|            error_message = ""
   371|         0|            0|            0|  0.00%|            if len(w) > 0:
   372|         0|            0|            0|  0.00%|                error_message = "{}: {}".format(w[-1].category.__name__, str(w[-1].message))
   373|         0|            0|            0|  0.00%|                msg = (
   374|         0|            0|            0|  0.00%|                    "Polyfit sanity test emitted a warning, most likely due "
   375|         0|            0|            0|  0.00%|                    "to using a buggy Accelerate backend."
   376|         0|            0|            0|  0.00%|                    "\nIf you compiled yourself, more information is available at:"
   377|         0|            0|            0|  0.00%|                    "\nhttps://numpy.org/doc/stable/user/building.html#accelerated-blas-lapack-libraries"
   378|         0|            0|            0|  0.00%|                    "\nOtherwise report this to the vendor "
   379|         0|            0|            0|  0.00%|                    "that provided NumPy.\n{}\n".format(error_message))
   380|         0|            0|            0|  0.00%|                raise RuntimeError(msg)
   381|         0|            0|            0|  0.00%|    del _mac_os_check
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|    # We usually use madvise hugepages support, but on some old kernels it
   384|         0|            0|            0|  0.00%|    # is slow and thus better avoided.
   385|         0|            0|            0|  0.00%|    # Specifically kernel version 4.6 had a bug fix which probably fixed this:
   386|         0|            0|            0|  0.00%|    # https://github.com/torvalds/linux/commit/7cf91a98e607c2f935dbcc177d70011e95b8faff
   387|         0|            0|            0|  0.00%|    import os
   388|         0|            0|            0|  0.00%|    use_hugepage = os.environ.get("NUMPY_MADVISE_HUGEPAGE", None)
   389|         0|            0|            0|  0.00%|    if sys.platform == "linux" and use_hugepage is None:
   390|         0|            0|            0|  0.00%|        # If there is an issue with parsing the kernel version,
   391|         0|            0|            0|  0.00%|        # set use_hugepages to 0. Usage of LooseVersion will handle
   392|         0|            0|            0|  0.00%|        # the kernel version parsing better, but avoided since it
   393|         0|            0|            0|  0.00%|        # will increase the import time. See: #16679 for related discussion.
   394|         0|            0|            0|  0.00%|        try:
   395|         0|            0|            0|  0.00%|            use_hugepage = 1
   396|         0|            0|            0|  0.00%|            kernel_version = os.uname().release.split(".")[:2]
   397|         0|            0|            0|  0.00%|            kernel_version = tuple(int(v) for v in kernel_version)
   398|         0|            0|            0|  0.00%|            if kernel_version < (4, 6):
   399|         0|            0|            0|  0.00%|                use_hugepage = 0
   400|         0|            0|            0|  0.00%|        except ValueError:
   401|         0|            0|            0|  0.00%|            use_hugepages = 0
   402|         0|            0|            0|  0.00%|    elif use_hugepage is None:
   403|         0|            0|            0|  0.00%|        # This is not Linux, so it should not matter, just enable anyway
   404|         0|            0|            0|  0.00%|        use_hugepage = 1
   405|         0|            0|            0|  0.00%|    else:
   406|         0|            0|            0|  0.00%|        use_hugepage = int(use_hugepage)
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|    # Note that this will currently only make a difference on Linux
   409|         0|            0|            0|  0.00%|    core.multiarray._set_madvise_hugepage(use_hugepage)
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    # Give a warning if NumPy is reloaded or imported on a sub-interpreter
   412|         0|            0|            0|  0.00%|    # We do this from python, since the C-module may not be reloaded and
   413|         0|            0|            0|  0.00%|    # it is tidier organized.
   414|         0|            0|            0|  0.00%|    core.multiarray._multiarray_umath._reload_guard()
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|# get the version using versioneer
   418|         0|            0|            0|  0.00%|from .version import __version__, git_revision as __git_version__
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\function_base.py
File duration: 0.0293431s (0.08%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import collections.abc
     2|         0|            0|            0|  0.00%|import functools
     3|         0|            0|            0|  0.00%|import re
     4|         0|            0|            0|  0.00%|import sys
     5|         0|            0|            0|  0.00%|import warnings
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|import numpy as np
     8|         0|            0|            0|  0.00%|import numpy.core.numeric as _nx
     9|         0|            0|            0|  0.00%|from numpy.core import transpose
    10|         0|            0|            0|  0.00%|from numpy.core.numeric import (
    11|         0|            0|            0|  0.00%|    ones, zeros_like, arange, concatenate, array, asarray, asanyarray, empty,
    12|         0|            0|            0|  0.00%|    ndarray, take, dot, where, intp, integer, isscalar, absolute
    13|         0|            0|            0|  0.00%|    )
    14|         0|            0|            0|  0.00%|from numpy.core.umath import (
    15|         0|            0|            0|  0.00%|    pi, add, arctan2, frompyfunc, cos, less_equal, sqrt, sin,
    16|         0|            0|            0|  0.00%|    mod, exp, not_equal, subtract
    17|         0|            0|            0|  0.00%|    )
    18|         0|            0|            0|  0.00%|from numpy.core.fromnumeric import (
    19|         0|            0|            0|  0.00%|    ravel, nonzero, partition, mean, any, sum
    20|         0|            0|            0|  0.00%|    )
    21|         0|            0|            0|  0.00%|from numpy.core.numerictypes import typecodes
    22|         0|            0|            0|  0.00%|from numpy.core.overrides import set_module
    23|         0|            0|            0|  0.00%|from numpy.core import overrides
    24|         0|            0|            0|  0.00%|from numpy.core.function_base import add_newdoc
    25|         0|            0|            0|  0.00%|from numpy.lib.twodim_base import diag
    26|         0|            0|            0|  0.00%|from numpy.core.multiarray import (
    27|         0|            0|            0|  0.00%|    _insert, add_docstring, bincount, normalize_axis_index, _monotonicity,
    28|         0|            0|            0|  0.00%|    interp as compiled_interp, interp_complex as compiled_interp_complex
    29|         0|            0|            0|  0.00%|    )
    30|         0|            0|            0|  0.00%|from numpy.core.umath import _add_newdoc_ufunc as add_newdoc_ufunc
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|import builtins
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|# needed in this module for compatibility
    35|         0|            0|            0|  0.00%|from numpy.lib.histograms import histogram, histogramdd  # noqa: F401
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    39|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|__all__ = [
    43|         0|            0|            0|  0.00%|    'select', 'piecewise', 'trim_zeros', 'copy', 'iterable', 'percentile',
    44|         0|            0|            0|  0.00%|    'diff', 'gradient', 'angle', 'unwrap', 'sort_complex', 'disp', 'flip',
    45|         0|            0|            0|  0.00%|    'rot90', 'extract', 'place', 'vectorize', 'asarray_chkfinite', 'average',
    46|         0|            0|            0|  0.00%|    'bincount', 'digitize', 'cov', 'corrcoef',
    47|         0|            0|            0|  0.00%|    'msort', 'median', 'sinc', 'hamming', 'hanning', 'bartlett',
    48|         0|            0|            0|  0.00%|    'blackman', 'kaiser', 'trapz', 'i0', 'add_newdoc', 'add_docstring',
    49|         0|            0|            0|  0.00%|    'meshgrid', 'delete', 'insert', 'append', 'interp', 'add_newdoc_ufunc',
    50|         0|            0|            0|  0.00%|    'quantile'
    51|         0|            0|            0|  0.00%|    ]
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|# _QuantileMethods is a dictionary listing all the supported methods to
    54|         0|            0|            0|  0.00%|# compute quantile/percentile.
    55|         0|            0|            0|  0.00%|#
    56|         0|            0|            0|  0.00%|# Below virtual_index refer to the index of the element where the percentile
    57|         0|            0|            0|  0.00%|# would be found in the sorted sample.
    58|         0|            0|            0|  0.00%|# When the sample contains exactly the percentile wanted, the virtual_index is
    59|         0|            0|            0|  0.00%|# an integer to the index of this element.
    60|         0|            0|            0|  0.00%|# When the percentile wanted is in between two elements, the virtual_index
    61|         0|            0|            0|  0.00%|# is made of a integer part (a.k.a 'i' or 'left') and a fractional part
    62|         0|            0|            0|  0.00%|# (a.k.a 'g' or 'gamma')
    63|         0|            0|            0|  0.00%|#
    64|         0|            0|            0|  0.00%|# Each method in _QuantileMethods has two properties
    65|         0|            0|            0|  0.00%|# get_virtual_index : Callable
    66|         0|            0|            0|  0.00%|#   The function used to compute the virtual_index.
    67|         0|            0|            0|  0.00%|# fix_gamma : Callable
    68|         0|            0|            0|  0.00%|#   A function used for discret methods to force the index to a specific value.
    69|         0|            0|            0|  0.00%|_QuantileMethods = dict(
    70|         0|            0|            0|  0.00%|    # --- HYNDMAN and FAN METHODS
    71|         0|            0|            0|  0.00%|    # Discrete methods
    72|         0|            0|            0|  0.00%|    inverted_cdf=dict(
    73|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: _inverted_cdf(n, quantiles),
    74|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,  # should never be called
    75|         0|            0|            0|  0.00%|    ),
    76|         0|            0|            0|  0.00%|    averaged_inverted_cdf=dict(
    77|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: (n * quantiles) - 1,
    78|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: _get_gamma_mask(
    79|         0|            0|            0|  0.00%|            shape=gamma.shape,
    80|         0|            0|            0|  0.00%|            default_value=1.,
    81|         0|            0|            0|  0.00%|            conditioned_value=0.5,
    82|         0|            0|            0|  0.00%|            where=gamma == 0),
    83|         0|            0|            0|  0.00%|    ),
    84|         0|            0|            0|  0.00%|    closest_observation=dict(
    85|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: _closest_observation(n,
    86|         0|            0|            0|  0.00%|                                                                    quantiles),
    87|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,  # should never be called
    88|         0|            0|            0|  0.00%|    ),
    89|         0|            0|            0|  0.00%|    # Continuous methods
    90|         0|            0|            0|  0.00%|    interpolated_inverted_cdf=dict(
    91|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles:
    92|         0|            0|            0|  0.00%|        _compute_virtual_index(n, quantiles, 0, 1),
    93|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
    94|         0|            0|            0|  0.00%|    ),
    95|         0|            0|            0|  0.00%|    hazen=dict(
    96|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles:
    97|         0|            0|            0|  0.00%|        _compute_virtual_index(n, quantiles, 0.5, 0.5),
    98|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
    99|         0|            0|            0|  0.00%|    ),
   100|         0|            0|            0|  0.00%|    weibull=dict(
   101|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles:
   102|         0|            0|            0|  0.00%|        _compute_virtual_index(n, quantiles, 0, 0),
   103|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
   104|         0|            0|            0|  0.00%|    ),
   105|         0|            0|            0|  0.00%|    # Default method.
   106|         0|            0|            0|  0.00%|    # To avoid some rounding issues, `(n-1) * quantiles` is preferred to
   107|         0|            0|            0|  0.00%|    # `_compute_virtual_index(n, quantiles, 1, 1)`.
   108|         0|            0|            0|  0.00%|    # They are mathematically equivalent.
   109|         0|            0|            0|  0.00%|    linear=dict(
   110|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: (n - 1) * quantiles,
   111|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
   112|         0|            0|            0|  0.00%|    ),
   113|         0|            0|            0|  0.00%|    median_unbiased=dict(
   114|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles:
   115|         0|            0|            0|  0.00%|        _compute_virtual_index(n, quantiles, 1 / 3.0, 1 / 3.0),
   116|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
   117|         0|            0|            0|  0.00%|    ),
   118|         0|            0|            0|  0.00%|    normal_unbiased=dict(
   119|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles:
   120|         0|            0|            0|  0.00%|        _compute_virtual_index(n, quantiles, 3 / 8.0, 3 / 8.0),
   121|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
   122|         0|            0|            0|  0.00%|    ),
   123|         0|            0|            0|  0.00%|    # --- OTHER METHODS
   124|         0|            0|            0|  0.00%|    lower=dict(
   125|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: np.floor(
   126|         0|            0|            0|  0.00%|            (n - 1) * quantiles).astype(np.intp),
   127|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
   128|         0|            0|            0|  0.00%|        # should never be called, index dtype is int
   129|         0|            0|            0|  0.00%|    ),
   130|         0|            0|            0|  0.00%|    higher=dict(
   131|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: np.ceil(
   132|         0|            0|            0|  0.00%|            (n - 1) * quantiles).astype(np.intp),
   133|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
   134|         0|            0|            0|  0.00%|        # should never be called, index dtype is int
   135|         0|            0|            0|  0.00%|    ),
   136|         0|            0|            0|  0.00%|    midpoint=dict(
   137|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: 0.5 * (
   138|         0|            0|            0|  0.00%|                np.floor((n - 1) * quantiles)
   139|         0|            0|            0|  0.00%|                + np.ceil((n - 1) * quantiles)),
   140|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, index: _get_gamma_mask(
   141|         0|            0|            0|  0.00%|            shape=gamma.shape,
   142|         0|            0|            0|  0.00%|            default_value=0.5,
   143|         0|            0|            0|  0.00%|            conditioned_value=0.,
   144|         0|            0|            0|  0.00%|            where=index % 1 == 0),
   145|         0|            0|            0|  0.00%|    ),
   146|         0|            0|            0|  0.00%|    nearest=dict(
   147|         0|            0|            0|  0.00%|        get_virtual_index=lambda n, quantiles: np.around(
   148|         0|            0|            0|  0.00%|            (n - 1) * quantiles).astype(np.intp),
   149|         0|            0|            0|  0.00%|        fix_gamma=lambda gamma, _: gamma,
   150|         0|            0|            0|  0.00%|        # should never be called, index dtype is int
   151|         0|            0|            0|  0.00%|    ))
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|def _rot90_dispatcher(m, k=None, axes=None):
   155|         0|            0|            0|  0.00%|    return (m,)
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|@array_function_dispatch(_rot90_dispatcher)
   159|         0|            0|            0|  0.00%|def rot90(m, k=1, axes=(0, 1)):
   160|         0|            0|            0|  0.00%|    """
   161|         0|            0|            0|  0.00%|    Rotate an array by 90 degrees in the plane specified by axes.
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|    Rotation direction is from the first towards the second axis.
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    Parameters
   166|         0|            0|            0|  0.00%|    ----------
   167|         0|            0|            0|  0.00%|    m : array_like
   168|         0|            0|            0|  0.00%|        Array of two or more dimensions.
   169|         0|            0|            0|  0.00%|    k : integer
   170|         0|            0|            0|  0.00%|        Number of times the array is rotated by 90 degrees.
   171|         0|            0|            0|  0.00%|    axes: (2,) array_like
   172|         0|            0|            0|  0.00%|        The array is rotated in the plane defined by the axes.
   173|         0|            0|            0|  0.00%|        Axes must be different.
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|        .. versionadded:: 1.12.0
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|    Returns
   178|         0|            0|            0|  0.00%|    -------
   179|         0|            0|            0|  0.00%|    y : ndarray
   180|         0|            0|            0|  0.00%|        A rotated view of `m`.
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    See Also
   183|         0|            0|            0|  0.00%|    --------
   184|         0|            0|            0|  0.00%|    flip : Reverse the order of elements in an array along the given axis.
   185|         0|            0|            0|  0.00%|    fliplr : Flip an array horizontally.
   186|         0|            0|            0|  0.00%|    flipud : Flip an array vertically.
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    Notes
   189|         0|            0|            0|  0.00%|    -----
   190|         0|            0|            0|  0.00%|    ``rot90(m, k=1, axes=(1,0))``  is the reverse of
   191|         0|            0|            0|  0.00%|    ``rot90(m, k=1, axes=(0,1))``
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    ``rot90(m, k=1, axes=(1,0))`` is equivalent to
   194|         0|            0|            0|  0.00%|    ``rot90(m, k=-1, axes=(0,1))``
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|    Examples
   197|         0|            0|            0|  0.00%|    --------
   198|         0|            0|            0|  0.00%|    >>> m = np.array([[1,2],[3,4]], int)
   199|         0|            0|            0|  0.00%|    >>> m
   200|         0|            0|            0|  0.00%|    array([[1, 2],
   201|         0|            0|            0|  0.00%|           [3, 4]])
   202|         0|            0|            0|  0.00%|    >>> np.rot90(m)
   203|         0|            0|            0|  0.00%|    array([[2, 4],
   204|         0|            0|            0|  0.00%|           [1, 3]])
   205|         0|            0|            0|  0.00%|    >>> np.rot90(m, 2)
   206|         0|            0|            0|  0.00%|    array([[4, 3],
   207|         0|            0|            0|  0.00%|           [2, 1]])
   208|         0|            0|            0|  0.00%|    >>> m = np.arange(8).reshape((2,2,2))
   209|         0|            0|            0|  0.00%|    >>> np.rot90(m, 1, (1,2))
   210|         0|            0|            0|  0.00%|    array([[[1, 3],
   211|         0|            0|            0|  0.00%|            [0, 2]],
   212|         0|            0|            0|  0.00%|           [[5, 7],
   213|         0|            0|            0|  0.00%|            [4, 6]]])
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    """
   216|         0|            0|            0|  0.00%|    axes = tuple(axes)
   217|         0|            0|            0|  0.00%|    if len(axes) != 2:
   218|         0|            0|            0|  0.00%|        raise ValueError("len(axes) must be 2.")
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    m = asanyarray(m)
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|    if axes[0] == axes[1] or absolute(axes[0] - axes[1]) == m.ndim:
   223|         0|            0|            0|  0.00%|        raise ValueError("Axes must be different.")
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|    if (axes[0] >= m.ndim or axes[0] < -m.ndim
   226|         0|            0|            0|  0.00%|        or axes[1] >= m.ndim or axes[1] < -m.ndim):
   227|         0|            0|            0|  0.00%|        raise ValueError("Axes={} out of range for array of ndim={}."
   228|         0|            0|            0|  0.00%|            .format(axes, m.ndim))
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|    k %= 4
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    if k == 0:
   233|         0|            0|            0|  0.00%|        return m[:]
   234|         0|            0|            0|  0.00%|    if k == 2:
   235|         0|            0|            0|  0.00%|        return flip(flip(m, axes[0]), axes[1])
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    axes_list = arange(0, m.ndim)
   238|         0|            0|            0|  0.00%|    (axes_list[axes[0]], axes_list[axes[1]]) = (axes_list[axes[1]],
   239|         0|            0|            0|  0.00%|                                                axes_list[axes[0]])
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    if k == 1:
   242|         0|            0|            0|  0.00%|        return transpose(flip(m, axes[1]), axes_list)
   243|         0|            0|            0|  0.00%|    else:
   244|         0|            0|            0|  0.00%|        # k == 3
   245|         0|            0|            0|  0.00%|        return flip(transpose(m, axes_list), axes[1])
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|def _flip_dispatcher(m, axis=None):
   249|         0|            0|            0|  0.00%|    return (m,)
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|@array_function_dispatch(_flip_dispatcher)
   253|         0|            0|            0|  0.00%|def flip(m, axis=None):
   254|         0|            0|            0|  0.00%|    """
   255|         0|            0|            0|  0.00%|    Reverse the order of elements in an array along the given axis.
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    The shape of the array is preserved, but the elements are reordered.
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|    .. versionadded:: 1.12.0
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    Parameters
   262|         0|            0|            0|  0.00%|    ----------
   263|         0|            0|            0|  0.00%|    m : array_like
   264|         0|            0|            0|  0.00%|        Input array.
   265|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
   266|         0|            0|            0|  0.00%|         Axis or axes along which to flip over. The default,
   267|         0|            0|            0|  0.00%|         axis=None, will flip over all of the axes of the input array.
   268|         0|            0|            0|  0.00%|         If axis is negative it counts from the last to the first axis.
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|         If axis is a tuple of ints, flipping is performed on all of the axes
   271|         0|            0|            0|  0.00%|         specified in the tuple.
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|         .. versionchanged:: 1.15.0
   274|         0|            0|            0|  0.00%|            None and tuples of axes are supported
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    Returns
   277|         0|            0|            0|  0.00%|    -------
   278|         0|            0|            0|  0.00%|    out : array_like
   279|         0|            0|            0|  0.00%|        A view of `m` with the entries of axis reversed.  Since a view is
   280|         0|            0|            0|  0.00%|        returned, this operation is done in constant time.
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    See Also
   283|         0|            0|            0|  0.00%|    --------
   284|         0|            0|            0|  0.00%|    flipud : Flip an array vertically (axis=0).
   285|         0|            0|            0|  0.00%|    fliplr : Flip an array horizontally (axis=1).
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|    Notes
   288|         0|            0|            0|  0.00%|    -----
   289|         0|            0|            0|  0.00%|    flip(m, 0) is equivalent to flipud(m).
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|    flip(m, 1) is equivalent to fliplr(m).
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all
   296|         0|            0|            0|  0.00%|    positions.
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at
   299|         0|            0|            0|  0.00%|    position 0 and position 1.
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    Examples
   302|         0|            0|            0|  0.00%|    --------
   303|         0|            0|            0|  0.00%|    >>> A = np.arange(8).reshape((2,2,2))
   304|         0|            0|            0|  0.00%|    >>> A
   305|         0|            0|            0|  0.00%|    array([[[0, 1],
   306|         0|            0|            0|  0.00%|            [2, 3]],
   307|         0|            0|            0|  0.00%|           [[4, 5],
   308|         0|            0|            0|  0.00%|            [6, 7]]])
   309|         0|            0|            0|  0.00%|    >>> np.flip(A, 0)
   310|         0|            0|            0|  0.00%|    array([[[4, 5],
   311|         0|            0|            0|  0.00%|            [6, 7]],
   312|         0|            0|            0|  0.00%|           [[0, 1],
   313|         0|            0|            0|  0.00%|            [2, 3]]])
   314|         0|            0|            0|  0.00%|    >>> np.flip(A, 1)
   315|         0|            0|            0|  0.00%|    array([[[2, 3],
   316|         0|            0|            0|  0.00%|            [0, 1]],
   317|         0|            0|            0|  0.00%|           [[6, 7],
   318|         0|            0|            0|  0.00%|            [4, 5]]])
   319|         0|            0|            0|  0.00%|    >>> np.flip(A)
   320|         0|            0|            0|  0.00%|    array([[[7, 6],
   321|         0|            0|            0|  0.00%|            [5, 4]],
   322|         0|            0|            0|  0.00%|           [[3, 2],
   323|         0|            0|            0|  0.00%|            [1, 0]]])
   324|         0|            0|            0|  0.00%|    >>> np.flip(A, (0, 2))
   325|         0|            0|            0|  0.00%|    array([[[5, 4],
   326|         0|            0|            0|  0.00%|            [7, 6]],
   327|         0|            0|            0|  0.00%|           [[1, 0],
   328|         0|            0|            0|  0.00%|            [3, 2]]])
   329|         0|            0|            0|  0.00%|    >>> A = np.random.randn(3,4,5)
   330|         0|            0|            0|  0.00%|    >>> np.all(np.flip(A,2) == A[:,:,::-1,...])
   331|         0|            0|            0|  0.00%|    True
   332|         0|            0|            0|  0.00%|    """
   333|         0|            0|            0|  0.00%|    if not hasattr(m, 'ndim'):
   334|         0|            0|            0|  0.00%|        m = asarray(m)
   335|         0|            0|            0|  0.00%|    if axis is None:
   336|         0|            0|            0|  0.00%|        indexer = (np.s_[::-1],) * m.ndim
   337|         0|            0|            0|  0.00%|    else:
   338|         0|            0|            0|  0.00%|        axis = _nx.normalize_axis_tuple(axis, m.ndim)
   339|         0|            0|            0|  0.00%|        indexer = [np.s_[:]] * m.ndim
   340|         0|            0|            0|  0.00%|        for ax in axis:
   341|         0|            0|            0|  0.00%|            indexer[ax] = np.s_[::-1]
   342|         0|            0|            0|  0.00%|        indexer = tuple(indexer)
   343|         0|            0|            0|  0.00%|    return m[indexer]
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|@set_module('numpy')
   347|         0|            0|            0|  0.00%|def iterable(y):
   348|         0|            0|            0|  0.00%|    """
   349|         0|            0|            0|  0.00%|    Check whether or not an object can be iterated over.
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|    Parameters
   352|         0|            0|            0|  0.00%|    ----------
   353|         0|            0|            0|  0.00%|    y : object
   354|         0|            0|            0|  0.00%|      Input object.
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|    Returns
   357|         0|            0|            0|  0.00%|    -------
   358|         0|            0|            0|  0.00%|    b : bool
   359|         0|            0|            0|  0.00%|      Return ``True`` if the object has an iterator method or is a
   360|         0|            0|            0|  0.00%|      sequence and ``False`` otherwise.
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    Examples
   364|         0|            0|            0|  0.00%|    --------
   365|         0|            0|            0|  0.00%|    >>> np.iterable([1, 2, 3])
   366|         0|            0|            0|  0.00%|    True
   367|         0|            0|            0|  0.00%|    >>> np.iterable(2)
   368|         0|            0|            0|  0.00%|    False
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    Notes
   371|         0|            0|            0|  0.00%|    -----
   372|         0|            0|            0|  0.00%|    In most cases, the results of ``np.iterable(obj)`` are consistent with
   373|         0|            0|            0|  0.00%|    ``isinstance(obj, collections.abc.Iterable)``. One notable exception is
   374|         0|            0|            0|  0.00%|    the treatment of 0-dimensional arrays::
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|        >>> from collections.abc import Iterable
   377|         0|            0|            0|  0.00%|        >>> a = np.array(1.0)  # 0-dimensional numpy array
   378|         0|            0|            0|  0.00%|        >>> isinstance(a, Iterable)
   379|         0|            0|            0|  0.00%|        True
   380|         0|            0|            0|  0.00%|        >>> np.iterable(a)
   381|         0|            0|            0|  0.00%|        False
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|    """
   384|         0|            0|            0|  0.00%|    try:
   385|         0|            0|            0|  0.00%|        iter(y)
   386|         0|            0|            0|  0.00%|    except TypeError:
   387|         0|            0|            0|  0.00%|        return False
   388|         0|            0|            0|  0.00%|    return True
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|def _average_dispatcher(a, axis=None, weights=None, returned=None):
   392|         0|            0|            0|  0.00%|    return (a, weights)
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|@array_function_dispatch(_average_dispatcher)
   396|         0|            0|            0|  0.00%|def average(a, axis=None, weights=None, returned=False):
   397|         0|            0|            0|  0.00%|    """
   398|         0|            0|            0|  0.00%|    Compute the weighted average along the specified axis.
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|    Parameters
   401|         0|            0|            0|  0.00%|    ----------
   402|         0|            0|            0|  0.00%|    a : array_like
   403|         0|            0|            0|  0.00%|        Array containing data to be averaged. If `a` is not an array, a
   404|         0|            0|            0|  0.00%|        conversion is attempted.
   405|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
   406|         0|            0|            0|  0.00%|        Axis or axes along which to average `a`.  The default,
   407|         0|            0|            0|  0.00%|        axis=None, will average over all of the elements of the input array.
   408|         0|            0|            0|  0.00%|        If axis is negative it counts from the last to the first axis.
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|        If axis is a tuple of ints, averaging is performed on all of the axes
   413|         0|            0|            0|  0.00%|        specified in the tuple instead of a single axis or all the axes as
   414|         0|            0|            0|  0.00%|        before.
   415|         0|            0|            0|  0.00%|    weights : array_like, optional
   416|         0|            0|            0|  0.00%|        An array of weights associated with the values in `a`. Each value in
   417|         0|            0|            0|  0.00%|        `a` contributes to the average according to its associated weight.
   418|         0|            0|            0|  0.00%|        The weights array can either be 1-D (in which case its length must be
   419|         0|            0|            0|  0.00%|        the size of `a` along the given axis) or of the same shape as `a`.
   420|         0|            0|            0|  0.00%|        If `weights=None`, then all data in `a` are assumed to have a
   421|         0|            0|            0|  0.00%|        weight equal to one.  The 1-D calculation is::
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|            avg = sum(a * weights) / sum(weights)
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|        The only constraint on `weights` is that `sum(weights)` must not be 0.
   426|         0|            0|            0|  0.00%|    returned : bool, optional
   427|         0|            0|            0|  0.00%|        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
   428|         0|            0|            0|  0.00%|        is returned, otherwise only the average is returned.
   429|         0|            0|            0|  0.00%|        If `weights=None`, `sum_of_weights` is equivalent to the number of
   430|         0|            0|            0|  0.00%|        elements over which the average is taken.
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    Returns
   433|         0|            0|            0|  0.00%|    -------
   434|         0|            0|            0|  0.00%|    retval, [sum_of_weights] : array_type or double
   435|         0|            0|            0|  0.00%|        Return the average along the specified axis. When `returned` is `True`,
   436|         0|            0|            0|  0.00%|        return a tuple with the average as the first element and the sum
   437|         0|            0|            0|  0.00%|        of the weights as the second element. `sum_of_weights` is of the
   438|         0|            0|            0|  0.00%|        same type as `retval`. The result dtype follows a genereal pattern.
   439|         0|            0|            0|  0.00%|        If `weights` is None, the result dtype will be that of `a` , or ``float64``
   440|         0|            0|            0|  0.00%|        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-
   441|         0|            0|            0|  0.00%|        integral, the result type will be the type of lowest precision capable of
   442|         0|            0|            0|  0.00%|        representing values of both `a` and `weights`. If `a` happens to be
   443|         0|            0|            0|  0.00%|        integral, the previous rules still applies but the result dtype will
   444|         0|            0|            0|  0.00%|        at least be ``float64``.
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|    Raises
   447|         0|            0|            0|  0.00%|    ------
   448|         0|            0|            0|  0.00%|    ZeroDivisionError
   449|         0|            0|            0|  0.00%|        When all weights along axis are zero. See `numpy.ma.average` for a
   450|         0|            0|            0|  0.00%|        version robust to this type of error.
   451|         0|            0|            0|  0.00%|    TypeError
   452|         0|            0|            0|  0.00%|        When the length of 1D `weights` is not the same as the shape of `a`
   453|         0|            0|            0|  0.00%|        along axis.
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    See Also
   456|         0|            0|            0|  0.00%|    --------
   457|         0|            0|            0|  0.00%|    mean
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    ma.average : average for masked arrays -- useful if your data contains
   460|         0|            0|            0|  0.00%|                 "missing" values
   461|         0|            0|            0|  0.00%|    numpy.result_type : Returns the type that results from applying the
   462|         0|            0|            0|  0.00%|                        numpy type promotion rules to the arguments.
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|    Examples
   465|         0|            0|            0|  0.00%|    --------
   466|         0|            0|            0|  0.00%|    >>> data = np.arange(1, 5)
   467|         0|            0|            0|  0.00%|    >>> data
   468|         0|            0|            0|  0.00%|    array([1, 2, 3, 4])
   469|         0|            0|            0|  0.00%|    >>> np.average(data)
   470|         0|            0|            0|  0.00%|    2.5
   471|         0|            0|            0|  0.00%|    >>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))
   472|         0|            0|            0|  0.00%|    4.0
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|    >>> data = np.arange(6).reshape((3,2))
   475|         0|            0|            0|  0.00%|    >>> data
   476|         0|            0|            0|  0.00%|    array([[0, 1],
   477|         0|            0|            0|  0.00%|           [2, 3],
   478|         0|            0|            0|  0.00%|           [4, 5]])
   479|         0|            0|            0|  0.00%|    >>> np.average(data, axis=1, weights=[1./4, 3./4])
   480|         0|            0|            0|  0.00%|    array([0.75, 2.75, 4.75])
   481|         0|            0|            0|  0.00%|    >>> np.average(data, weights=[1./4, 3./4])
   482|         0|            0|            0|  0.00%|    Traceback (most recent call last):
   483|         0|            0|            0|  0.00%|        ...
   484|         0|            0|            0|  0.00%|    TypeError: Axis must be specified when shapes of a and weights differ.
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|    >>> a = np.ones(5, dtype=np.float128)
   487|         0|            0|            0|  0.00%|    >>> w = np.ones(5, dtype=np.complex64)
   488|         0|            0|            0|  0.00%|    >>> avg = np.average(a, weights=w)
   489|         0|            0|            0|  0.00%|    >>> print(avg.dtype)
   490|         0|            0|            0|  0.00%|    complex256
   491|         0|            0|            0|  0.00%|    """
   492|         0|            0|            0|  0.00%|    a = np.asanyarray(a)
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    if weights is None:
   495|         0|            0|            0|  0.00%|        avg = a.mean(axis)
   496|         0|            0|            0|  0.00%|        scl = avg.dtype.type(a.size/avg.size)
   497|         0|            0|            0|  0.00%|    else:
   498|         0|            0|            0|  0.00%|        wgt = np.asanyarray(weights)
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|        if issubclass(a.dtype.type, (np.integer, np.bool_)):
   501|         0|            0|            0|  0.00%|            result_dtype = np.result_type(a.dtype, wgt.dtype, 'f8')
   502|         0|            0|            0|  0.00%|        else:
   503|         0|            0|            0|  0.00%|            result_dtype = np.result_type(a.dtype, wgt.dtype)
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|        # Sanity checks
   506|         0|            0|            0|  0.00%|        if a.shape != wgt.shape:
   507|         0|            0|            0|  0.00%|            if axis is None:
   508|         0|            0|            0|  0.00%|                raise TypeError(
   509|         0|            0|            0|  0.00%|                    "Axis must be specified when shapes of a and weights "
   510|         0|            0|            0|  0.00%|                    "differ.")
   511|         0|            0|            0|  0.00%|            if wgt.ndim != 1:
   512|         0|            0|            0|  0.00%|                raise TypeError(
   513|         0|            0|            0|  0.00%|                    "1D weights expected when shapes of a and weights differ.")
   514|         0|            0|            0|  0.00%|            if wgt.shape[0] != a.shape[axis]:
   515|         0|            0|            0|  0.00%|                raise ValueError(
   516|         0|            0|            0|  0.00%|                    "Length of weights not compatible with specified axis.")
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|            # setup wgt to broadcast along axis
   519|         0|            0|            0|  0.00%|            wgt = np.broadcast_to(wgt, (a.ndim-1)*(1,) + wgt.shape)
   520|         0|            0|            0|  0.00%|            wgt = wgt.swapaxes(-1, axis)
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|        scl = wgt.sum(axis=axis, dtype=result_dtype)
   523|         0|            0|            0|  0.00%|        if np.any(scl == 0.0):
   524|         0|            0|            0|  0.00%|            raise ZeroDivisionError(
   525|         0|            0|            0|  0.00%|                "Weights sum to zero, can't be normalized")
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|        avg = np.multiply(a, wgt, dtype=result_dtype).sum(axis)/scl
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|    if returned:
   530|         0|            0|            0|  0.00%|        if scl.shape != avg.shape:
   531|         0|            0|            0|  0.00%|            scl = np.broadcast_to(scl, avg.shape).copy()
   532|         0|            0|            0|  0.00%|        return avg, scl
   533|         0|            0|            0|  0.00%|    else:
   534|         0|            0|            0|  0.00%|        return avg
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|@set_module('numpy')
   538|         0|            0|            0|  0.00%|def asarray_chkfinite(a, dtype=None, order=None):
   539|         0|            0|            0|  0.00%|    """Convert the input to an array, checking for NaNs or Infs.
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|    Parameters
   542|         0|            0|            0|  0.00%|    ----------
   543|         0|            0|            0|  0.00%|    a : array_like
   544|         0|            0|            0|  0.00%|        Input data, in any form that can be converted to an array.  This
   545|         0|            0|            0|  0.00%|        includes lists, lists of tuples, tuples, tuples of tuples, tuples
   546|         0|            0|            0|  0.00%|        of lists and ndarrays.  Success requires no NaNs or Infs.
   547|         0|            0|            0|  0.00%|    dtype : data-type, optional
   548|         0|            0|            0|  0.00%|        By default, the data-type is inferred from the input data.
   549|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', 'K'}, optional
   550|         0|            0|            0|  0.00%|        Memory layout.  'A' and 'K' depend on the order of input array a.
   551|         0|            0|            0|  0.00%|        'C' row-major (C-style),
   552|         0|            0|            0|  0.00%|        'F' column-major (Fortran-style) memory representation.
   553|         0|            0|            0|  0.00%|        'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise
   554|         0|            0|            0|  0.00%|        'K' (keep) preserve input order
   555|         0|            0|            0|  0.00%|        Defaults to 'C'.
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|    Returns
   558|         0|            0|            0|  0.00%|    -------
   559|         0|            0|            0|  0.00%|    out : ndarray
   560|         0|            0|            0|  0.00%|        Array interpretation of `a`.  No copy is performed if the input
   561|         0|            0|            0|  0.00%|        is already an ndarray.  If `a` is a subclass of ndarray, a base
   562|         0|            0|            0|  0.00%|        class ndarray is returned.
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|    Raises
   565|         0|            0|            0|  0.00%|    ------
   566|         0|            0|            0|  0.00%|    ValueError
   567|         0|            0|            0|  0.00%|        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|    See Also
   570|         0|            0|            0|  0.00%|    --------
   571|         0|            0|            0|  0.00%|    asarray : Create and array.
   572|         0|            0|            0|  0.00%|    asanyarray : Similar function which passes through subclasses.
   573|         0|            0|            0|  0.00%|    ascontiguousarray : Convert input to a contiguous array.
   574|         0|            0|            0|  0.00%|    asfarray : Convert input to a floating point ndarray.
   575|         0|            0|            0|  0.00%|    asfortranarray : Convert input to an ndarray with column-major
   576|         0|            0|            0|  0.00%|                     memory order.
   577|         0|            0|            0|  0.00%|    fromiter : Create an array from an iterator.
   578|         0|            0|            0|  0.00%|    fromfunction : Construct an array by executing a function on grid
   579|         0|            0|            0|  0.00%|                   positions.
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|    Examples
   582|         0|            0|            0|  0.00%|    --------
   583|         0|            0|            0|  0.00%|    Convert a list into an array.  If all elements are finite
   584|         0|            0|            0|  0.00%|    ``asarray_chkfinite`` is identical to ``asarray``.
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|    >>> a = [1, 2]
   587|         0|            0|            0|  0.00%|    >>> np.asarray_chkfinite(a, dtype=float)
   588|         0|            0|            0|  0.00%|    array([1., 2.])
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|    Raises ValueError if array_like contains Nans or Infs.
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|    >>> a = [1, 2, np.inf]
   593|         0|            0|            0|  0.00%|    >>> try:
   594|         0|            0|            0|  0.00%|    ...     np.asarray_chkfinite(a)
   595|         0|            0|            0|  0.00%|    ... except ValueError:
   596|         0|            0|            0|  0.00%|    ...     print('ValueError')
   597|         0|            0|            0|  0.00%|    ...
   598|         0|            0|            0|  0.00%|    ValueError
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|    """
   601|         0|            0|            0|  0.00%|    a = asarray(a, dtype=dtype, order=order)
   602|         0|            0|            0|  0.00%|    if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():
   603|         0|            0|            0|  0.00%|        raise ValueError(
   604|         0|            0|            0|  0.00%|            "array must not contain infs or NaNs")
   605|         0|            0|            0|  0.00%|    return a
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|def _piecewise_dispatcher(x, condlist, funclist, *args, **kw):
   609|         0|            0|            0|  0.00%|    yield x
   610|         0|            0|            0|  0.00%|    # support the undocumented behavior of allowing scalars
   611|         0|            0|            0|  0.00%|    if np.iterable(condlist):
   612|         0|            0|            0|  0.00%|        yield from condlist
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|@array_function_dispatch(_piecewise_dispatcher)
   616|         0|            0|            0|  0.00%|def piecewise(x, condlist, funclist, *args, **kw):
   617|         0|            0|            0|  0.00%|    """
   618|         0|            0|            0|  0.00%|    Evaluate a piecewise-defined function.
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|    Given a set of conditions and corresponding functions, evaluate each
   621|         0|            0|            0|  0.00%|    function on the input data wherever its condition is true.
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    Parameters
   624|         0|            0|            0|  0.00%|    ----------
   625|         0|            0|            0|  0.00%|    x : ndarray or scalar
   626|         0|            0|            0|  0.00%|        The input domain.
   627|         0|            0|            0|  0.00%|    condlist : list of bool arrays or bool scalars
   628|         0|            0|            0|  0.00%|        Each boolean array corresponds to a function in `funclist`.  Wherever
   629|         0|            0|            0|  0.00%|        `condlist[i]` is True, `funclist[i](x)` is used as the output value.
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|        Each boolean array in `condlist` selects a piece of `x`,
   632|         0|            0|            0|  0.00%|        and should therefore be of the same shape as `x`.
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|        The length of `condlist` must correspond to that of `funclist`.
   635|         0|            0|            0|  0.00%|        If one extra function is given, i.e. if
   636|         0|            0|            0|  0.00%|        ``len(funclist) == len(condlist) + 1``, then that extra function
   637|         0|            0|            0|  0.00%|        is the default value, used wherever all conditions are false.
   638|         0|            0|            0|  0.00%|    funclist : list of callables, f(x,*args,**kw), or scalars
   639|         0|            0|            0|  0.00%|        Each function is evaluated over `x` wherever its corresponding
   640|         0|            0|            0|  0.00%|        condition is True.  It should take a 1d array as input and give an 1d
   641|         0|            0|            0|  0.00%|        array or a scalar value as output.  If, instead of a callable,
   642|         0|            0|            0|  0.00%|        a scalar is provided then a constant function (``lambda x: scalar``) is
   643|         0|            0|            0|  0.00%|        assumed.
   644|         0|            0|            0|  0.00%|    args : tuple, optional
   645|         0|            0|            0|  0.00%|        Any further arguments given to `piecewise` are passed to the functions
   646|         0|            0|            0|  0.00%|        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then
   647|         0|            0|            0|  0.00%|        each function is called as ``f(x, 1, 'a')``.
   648|         0|            0|            0|  0.00%|    kw : dict, optional
   649|         0|            0|            0|  0.00%|        Keyword arguments used in calling `piecewise` are passed to the
   650|         0|            0|            0|  0.00%|        functions upon execution, i.e., if called
   651|         0|            0|            0|  0.00%|        ``piecewise(..., ..., alpha=1)``, then each function is called as
   652|         0|            0|            0|  0.00%|        ``f(x, alpha=1)``.
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|    Returns
   655|         0|            0|            0|  0.00%|    -------
   656|         0|            0|            0|  0.00%|    out : ndarray
   657|         0|            0|            0|  0.00%|        The output is the same shape and type as x and is found by
   658|         0|            0|            0|  0.00%|        calling the functions in `funclist` on the appropriate portions of `x`,
   659|         0|            0|            0|  0.00%|        as defined by the boolean arrays in `condlist`.  Portions not covered
   660|         0|            0|            0|  0.00%|        by any condition have a default value of 0.
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    See Also
   664|         0|            0|            0|  0.00%|    --------
   665|         0|            0|            0|  0.00%|    choose, select, where
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|    Notes
   668|         0|            0|            0|  0.00%|    -----
   669|         0|            0|            0|  0.00%|    This is similar to choose or select, except that functions are
   670|         0|            0|            0|  0.00%|    evaluated on elements of `x` that satisfy the corresponding condition from
   671|         0|            0|            0|  0.00%|    `condlist`.
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|    The result is::
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|            |--
   676|         0|            0|            0|  0.00%|            |funclist[0](x[condlist[0]])
   677|         0|            0|            0|  0.00%|      out = |funclist[1](x[condlist[1]])
   678|         0|            0|            0|  0.00%|            |...
   679|         0|            0|            0|  0.00%|            |funclist[n2](x[condlist[n2]])
   680|         0|            0|            0|  0.00%|            |--
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|    Examples
   683|         0|            0|            0|  0.00%|    --------
   684|         0|            0|            0|  0.00%|    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|    >>> x = np.linspace(-2.5, 2.5, 6)
   687|         0|            0|            0|  0.00%|    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])
   688|         0|            0|            0|  0.00%|    array([-1., -1., -1.,  1.,  1.,  1.])
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for
   691|         0|            0|            0|  0.00%|    ``x >= 0``.
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])
   694|         0|            0|            0|  0.00%|    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])
   695|         0|            0|            0|  0.00%|
   696|         0|            0|            0|  0.00%|    Apply the same function to a scalar value.
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    >>> y = -2
   699|         0|            0|            0|  0.00%|    >>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])
   700|         0|            0|            0|  0.00%|    array(2)
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|    """
   703|         0|            0|            0|  0.00%|    x = asanyarray(x)
   704|         0|            0|            0|  0.00%|    n2 = len(funclist)
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|    # undocumented: single condition is promoted to a list of one condition
   707|         0|            0|            0|  0.00%|    if isscalar(condlist) or (
   708|         0|            0|            0|  0.00%|            not isinstance(condlist[0], (list, ndarray)) and x.ndim != 0):
   709|         0|            0|            0|  0.00%|        condlist = [condlist]
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    condlist = asarray(condlist, dtype=bool)
   712|         0|            0|            0|  0.00%|    n = len(condlist)
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    if n == n2 - 1:  # compute the "otherwise" condition.
   715|         0|            0|            0|  0.00%|        condelse = ~np.any(condlist, axis=0, keepdims=True)
   716|         0|            0|            0|  0.00%|        condlist = np.concatenate([condlist, condelse], axis=0)
   717|         0|            0|            0|  0.00%|        n += 1
   718|         0|            0|            0|  0.00%|    elif n != n2:
   719|         0|            0|            0|  0.00%|        raise ValueError(
   720|         0|            0|            0|  0.00%|            "with {} condition(s), either {} or {} functions are expected"
   721|         0|            0|            0|  0.00%|            .format(n, n, n+1)
   722|         0|            0|            0|  0.00%|        )
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|    y = zeros_like(x)
   725|         0|            0|            0|  0.00%|    for cond, func in zip(condlist, funclist):
   726|         0|            0|            0|  0.00%|        if not isinstance(func, collections.abc.Callable):
   727|         0|            0|            0|  0.00%|            y[cond] = func
   728|         0|            0|            0|  0.00%|        else:
   729|         0|            0|            0|  0.00%|            vals = x[cond]
   730|         0|            0|            0|  0.00%|            if vals.size > 0:
   731|         0|            0|            0|  0.00%|                y[cond] = func(vals, *args, **kw)
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|    return y
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|def _select_dispatcher(condlist, choicelist, default=None):
   737|         0|            0|            0|  0.00%|    yield from condlist
   738|         0|            0|            0|  0.00%|    yield from choicelist
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|@array_function_dispatch(_select_dispatcher)
   742|         0|            0|            0|  0.00%|def select(condlist, choicelist, default=0):
   743|         0|            0|            0|  0.00%|    """
   744|         0|            0|            0|  0.00%|    Return an array drawn from elements in choicelist, depending on conditions.
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|    Parameters
   747|         0|            0|            0|  0.00%|    ----------
   748|         0|            0|            0|  0.00%|    condlist : list of bool ndarrays
   749|         0|            0|            0|  0.00%|        The list of conditions which determine from which array in `choicelist`
   750|         0|            0|            0|  0.00%|        the output elements are taken. When multiple conditions are satisfied,
   751|         0|            0|            0|  0.00%|        the first one encountered in `condlist` is used.
   752|         0|            0|            0|  0.00%|    choicelist : list of ndarrays
   753|         0|            0|            0|  0.00%|        The list of arrays from which the output elements are taken. It has
   754|         0|            0|            0|  0.00%|        to be of the same length as `condlist`.
   755|         0|            0|            0|  0.00%|    default : scalar, optional
   756|         0|            0|            0|  0.00%|        The element inserted in `output` when all conditions evaluate to False.
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|    Returns
   759|         0|            0|            0|  0.00%|    -------
   760|         0|            0|            0|  0.00%|    output : ndarray
   761|         0|            0|            0|  0.00%|        The output at position m is the m-th element of the array in
   762|         0|            0|            0|  0.00%|        `choicelist` where the m-th element of the corresponding array in
   763|         0|            0|            0|  0.00%|        `condlist` is True.
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|    See Also
   766|         0|            0|            0|  0.00%|    --------
   767|         0|            0|            0|  0.00%|    where : Return elements from one of two arrays depending on condition.
   768|         0|            0|            0|  0.00%|    take, choose, compress, diag, diagonal
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|    Examples
   771|         0|            0|            0|  0.00%|    --------
   772|         0|            0|            0|  0.00%|    >>> x = np.arange(6)
   773|         0|            0|            0|  0.00%|    >>> condlist = [x<3, x>3]
   774|         0|            0|            0|  0.00%|    >>> choicelist = [x, x**2]
   775|         0|            0|            0|  0.00%|    >>> np.select(condlist, choicelist, 42)
   776|         0|            0|            0|  0.00%|    array([ 0,  1,  2, 42, 16, 25])
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|    >>> condlist = [x<=4, x>3]
   779|         0|            0|            0|  0.00%|    >>> choicelist = [x, x**2]
   780|         0|            0|            0|  0.00%|    >>> np.select(condlist, choicelist, 55)
   781|         0|            0|            0|  0.00%|    array([ 0,  1,  2,  3,  4, 25])
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|    """
   784|         0|            0|            0|  0.00%|    # Check the size of condlist and choicelist are the same, or abort.
   785|         0|            0|            0|  0.00%|    if len(condlist) != len(choicelist):
   786|         0|            0|            0|  0.00%|        raise ValueError(
   787|         0|            0|            0|  0.00%|            'list of cases must be same length as list of conditions')
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|    # Now that the dtype is known, handle the deprecated select([], []) case
   790|         0|            0|            0|  0.00%|    if len(condlist) == 0:
   791|         0|            0|            0|  0.00%|        raise ValueError("select with an empty condition list is not possible")
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|    choicelist = [np.asarray(choice) for choice in choicelist]
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|    try:
   796|         0|            0|            0|  0.00%|        intermediate_dtype = np.result_type(*choicelist)
   797|         0|            0|            0|  0.00%|    except TypeError as e:
   798|         0|            0|            0|  0.00%|        msg = f'Choicelist elements do not have a common dtype: {e}'
   799|         0|            0|            0|  0.00%|        raise TypeError(msg) from None
   800|         0|            0|            0|  0.00%|    default_array = np.asarray(default)
   801|         0|            0|            0|  0.00%|    choicelist.append(default_array)
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|    # need to get the result type before broadcasting for correct scalar
   804|         0|            0|            0|  0.00%|    # behaviour
   805|         0|            0|            0|  0.00%|    try:
   806|         0|            0|            0|  0.00%|        dtype = np.result_type(intermediate_dtype, default_array)
   807|         0|            0|            0|  0.00%|    except TypeError as e:
   808|         0|            0|            0|  0.00%|        msg = f'Choicelists and default value do not have a common dtype: {e}'
   809|         0|            0|            0|  0.00%|        raise TypeError(msg) from None
   810|         0|            0|            0|  0.00%|
   811|         0|            0|            0|  0.00%|    # Convert conditions to arrays and broadcast conditions and choices
   812|         0|            0|            0|  0.00%|    # as the shape is needed for the result. Doing it separately optimizes
   813|         0|            0|            0|  0.00%|    # for example when all choices are scalars.
   814|         0|            0|            0|  0.00%|    condlist = np.broadcast_arrays(*condlist)
   815|         0|            0|            0|  0.00%|    choicelist = np.broadcast_arrays(*choicelist)
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|    # If cond array is not an ndarray in boolean format or scalar bool, abort.
   818|         0|            0|            0|  0.00%|    for i, cond in enumerate(condlist):
   819|         0|            0|            0|  0.00%|        if cond.dtype.type is not np.bool_:
   820|         0|            0|            0|  0.00%|            raise TypeError(
   821|         0|            0|            0|  0.00%|                'invalid entry {} in condlist: should be boolean ndarray'.format(i))
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|    if choicelist[0].ndim == 0:
   824|         0|            0|            0|  0.00%|        # This may be common, so avoid the call.
   825|         0|            0|            0|  0.00%|        result_shape = condlist[0].shape
   826|         0|            0|            0|  0.00%|    else:
   827|         0|            0|            0|  0.00%|        result_shape = np.broadcast_arrays(condlist[0], choicelist[0])[0].shape
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|    result = np.full(result_shape, choicelist[-1], dtype)
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|    # Use np.copyto to burn each choicelist array onto result, using the
   832|         0|            0|            0|  0.00%|    # corresponding condlist as a boolean mask. This is done in reverse
   833|         0|            0|            0|  0.00%|    # order since the first choice should take precedence.
   834|         0|            0|            0|  0.00%|    choicelist = choicelist[-2::-1]
   835|         0|            0|            0|  0.00%|    condlist = condlist[::-1]
   836|         0|            0|            0|  0.00%|    for choice, cond in zip(choicelist, condlist):
   837|         0|            0|            0|  0.00%|        np.copyto(result, choice, where=cond)
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|    return result
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|
   842|       106|            0|            0|  0.00%|def _copy_dispatcher(a, order=None, subok=None):
   843|       106|   0.00102472|   9.6672e-06|  0.00%|    return (a,)
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|
   846|       106|            0|            0|  0.00%|@array_function_dispatch(_copy_dispatcher)
   847|         0|            0|            0|  0.00%|def copy(a, order='K', subok=False):
   848|         0|            0|            0|  0.00%|    """
   849|         0|            0|            0|  0.00%|    Return an array copy of the given object.
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|    Parameters
   852|         0|            0|            0|  0.00%|    ----------
   853|         0|            0|            0|  0.00%|    a : array_like
   854|         0|            0|            0|  0.00%|        Input data.
   855|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', 'K'}, optional
   856|         0|            0|            0|  0.00%|        Controls the memory layout of the copy. 'C' means C-order,
   857|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
   858|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
   859|         0|            0|            0|  0.00%|        as possible. (Note that this function and :meth:`ndarray.copy` are very
   860|         0|            0|            0|  0.00%|        similar, but have different default values for their order=
   861|         0|            0|            0|  0.00%|        arguments.)
   862|         0|            0|            0|  0.00%|    subok : bool, optional
   863|         0|            0|            0|  0.00%|        If True, then sub-classes will be passed-through, otherwise the
   864|         0|            0|            0|  0.00%|        returned array will be forced to be a base-class array (defaults to False).
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|        .. versionadded:: 1.19.0
   867|         0|            0|            0|  0.00%|
   868|         0|            0|            0|  0.00%|    Returns
   869|         0|            0|            0|  0.00%|    -------
   870|         0|            0|            0|  0.00%|    arr : ndarray
   871|         0|            0|            0|  0.00%|        Array interpretation of `a`.
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|    See Also
   874|         0|            0|            0|  0.00%|    --------
   875|         0|            0|            0|  0.00%|    ndarray.copy : Preferred method for creating an array copy
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|    Notes
   878|         0|            0|            0|  0.00%|    -----
   879|         0|            0|            0|  0.00%|    This is equivalent to:
   880|         0|            0|            0|  0.00%|
   881|         0|            0|            0|  0.00%|    >>> np.array(a, copy=True)  #doctest: +SKIP
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|    Examples
   884|         0|            0|            0|  0.00%|    --------
   885|         0|            0|            0|  0.00%|    Create an array x, with a reference y and a copy z:
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 3])
   888|         0|            0|            0|  0.00%|    >>> y = x
   889|         0|            0|            0|  0.00%|    >>> z = np.copy(x)
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|    Note that, when we modify x, y changes, but not z:
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|    >>> x[0] = 10
   894|         0|            0|            0|  0.00%|    >>> x[0] == y[0]
   895|         0|            0|            0|  0.00%|    True
   896|         0|            0|            0|  0.00%|    >>> x[0] == z[0]
   897|         0|            0|            0|  0.00%|    False
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|    Note that, np.copy clears previously set WRITEABLE=False flag.
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3])
   902|         0|            0|            0|  0.00%|    >>> a.flags["WRITEABLE"] = False
   903|         0|            0|            0|  0.00%|    >>> b = np.copy(a)
   904|         0|            0|            0|  0.00%|    >>> b.flags["WRITEABLE"]
   905|         0|            0|            0|  0.00%|    True
   906|         0|            0|            0|  0.00%|    >>> b[0] = 3
   907|         0|            0|            0|  0.00%|    >>> b
   908|         0|            0|            0|  0.00%|    array([3, 2, 3])
   909|         0|            0|            0|  0.00%|
   910|         0|            0|            0|  0.00%|    Note that np.copy is a shallow copy and will not copy object
   911|         0|            0|            0|  0.00%|    elements within arrays. This is mainly important for arrays
   912|         0|            0|            0|  0.00%|    containing Python objects. The new array will contain the
   913|         0|            0|            0|  0.00%|    same object which may lead to surprises if that object can
   914|         0|            0|            0|  0.00%|    be modified (is mutable):
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|    >>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
   917|         0|            0|            0|  0.00%|    >>> b = np.copy(a)
   918|         0|            0|            0|  0.00%|    >>> b[2][0] = 10
   919|         0|            0|            0|  0.00%|    >>> a
   920|         0|            0|            0|  0.00%|    array([1, 'm', list([10, 3, 4])], dtype=object)
   921|         0|            0|            0|  0.00%|
   922|         0|            0|            0|  0.00%|    To ensure all elements within an ``object`` array are copied,
   923|         0|            0|            0|  0.00%|    use `copy.deepcopy`:
   924|         0|            0|            0|  0.00%|
   925|         0|            0|            0|  0.00%|    >>> import copy
   926|         0|            0|            0|  0.00%|    >>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
   927|         0|            0|            0|  0.00%|    >>> c = copy.deepcopy(a)
   928|         0|            0|            0|  0.00%|    >>> c[2][0] = 10
   929|         0|            0|            0|  0.00%|    >>> c
   930|         0|            0|            0|  0.00%|    array([1, 'm', list([10, 3, 4])], dtype=object)
   931|         0|            0|            0|  0.00%|    >>> a
   932|         0|            0|            0|  0.00%|    array([1, 'm', list([2, 3, 4])], dtype=object)
   933|         0|            0|            0|  0.00%|
   934|         0|            0|            0|  0.00%|    """
   935|       106|   0.00099802|  9.41528e-06|  0.00%|    return array(a, order=order, subok=subok, copy=True)
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|# Basic operations
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|def _gradient_dispatcher(f, *varargs, axis=None, edge_order=None):
   941|         0|            0|            0|  0.00%|    yield f
   942|         0|            0|            0|  0.00%|    yield from varargs
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|@array_function_dispatch(_gradient_dispatcher)
   946|         0|            0|            0|  0.00%|def gradient(f, *varargs, axis=None, edge_order=1):
   947|         0|            0|            0|  0.00%|    """
   948|         0|            0|            0|  0.00%|    Return the gradient of an N-dimensional array.
   949|         0|            0|            0|  0.00%|
   950|         0|            0|            0|  0.00%|    The gradient is computed using second order accurate central differences
   951|         0|            0|            0|  0.00%|    in the interior points and either first or second order accurate one-sides
   952|         0|            0|            0|  0.00%|    (forward or backwards) differences at the boundaries.
   953|         0|            0|            0|  0.00%|    The returned gradient hence has the same shape as the input array.
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|    Parameters
   956|         0|            0|            0|  0.00%|    ----------
   957|         0|            0|            0|  0.00%|    f : array_like
   958|         0|            0|            0|  0.00%|        An N-dimensional array containing samples of a scalar function.
   959|         0|            0|            0|  0.00%|    varargs : list of scalar or array, optional
   960|         0|            0|            0|  0.00%|        Spacing between f values. Default unitary spacing for all dimensions.
   961|         0|            0|            0|  0.00%|        Spacing can be specified using:
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|        1. single scalar to specify a sample distance for all dimensions.
   964|         0|            0|            0|  0.00%|        2. N scalars to specify a constant sample distance for each dimension.
   965|         0|            0|            0|  0.00%|           i.e. `dx`, `dy`, `dz`, ...
   966|         0|            0|            0|  0.00%|        3. N arrays to specify the coordinates of the values along each
   967|         0|            0|            0|  0.00%|           dimension of F. The length of the array must match the size of
   968|         0|            0|            0|  0.00%|           the corresponding dimension
   969|         0|            0|            0|  0.00%|        4. Any combination of N scalars/arrays with the meaning of 2. and 3.
   970|         0|            0|            0|  0.00%|
   971|         0|            0|            0|  0.00%|        If `axis` is given, the number of varargs must equal the number of axes.
   972|         0|            0|            0|  0.00%|        Default: 1.
   973|         0|            0|            0|  0.00%|
   974|         0|            0|            0|  0.00%|    edge_order : {1, 2}, optional
   975|         0|            0|            0|  0.00%|        Gradient is calculated using N-th order accurate differences
   976|         0|            0|            0|  0.00%|        at the boundaries. Default: 1.
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.1
   979|         0|            0|            0|  0.00%|
   980|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
   981|         0|            0|            0|  0.00%|        Gradient is calculated only along the given axis or axes
   982|         0|            0|            0|  0.00%|        The default (axis = None) is to calculate the gradient for all the axes
   983|         0|            0|            0|  0.00%|        of the input array. axis may be negative, in which case it counts from
   984|         0|            0|            0|  0.00%|        the last to the first axis.
   985|         0|            0|            0|  0.00%|
   986|         0|            0|            0|  0.00%|        .. versionadded:: 1.11.0
   987|         0|            0|            0|  0.00%|
   988|         0|            0|            0|  0.00%|    Returns
   989|         0|            0|            0|  0.00%|    -------
   990|         0|            0|            0|  0.00%|    gradient : ndarray or list of ndarray
   991|         0|            0|            0|  0.00%|        A list of ndarrays (or a single ndarray if there is only one dimension)
   992|         0|            0|            0|  0.00%|        corresponding to the derivatives of f with respect to each dimension.
   993|         0|            0|            0|  0.00%|        Each derivative has the same shape as f.
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|    Examples
   996|         0|            0|            0|  0.00%|    --------
   997|         0|            0|            0|  0.00%|    >>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
   998|         0|            0|            0|  0.00%|    >>> np.gradient(f)
   999|         0|            0|            0|  0.00%|    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])
  1000|         0|            0|            0|  0.00%|    >>> np.gradient(f, 2)
  1001|         0|            0|            0|  0.00%|    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])
  1002|         0|            0|            0|  0.00%|
  1003|         0|            0|            0|  0.00%|    Spacing can be also specified with an array that represents the coordinates
  1004|         0|            0|            0|  0.00%|    of the values F along the dimensions.
  1005|         0|            0|            0|  0.00%|    For instance a uniform spacing:
  1006|         0|            0|            0|  0.00%|
  1007|         0|            0|            0|  0.00%|    >>> x = np.arange(f.size)
  1008|         0|            0|            0|  0.00%|    >>> np.gradient(f, x)
  1009|         0|            0|            0|  0.00%|    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
  1010|         0|            0|            0|  0.00%|
  1011|         0|            0|            0|  0.00%|    Or a non uniform one:
  1012|         0|            0|            0|  0.00%|
  1013|         0|            0|            0|  0.00%|    >>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
  1014|         0|            0|            0|  0.00%|    >>> np.gradient(f, x)
  1015|         0|            0|            0|  0.00%|    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|    For two dimensional arrays, the return will be two arrays ordered by
  1018|         0|            0|            0|  0.00%|    axis. In this example the first array stands for the gradient in
  1019|         0|            0|            0|  0.00%|    rows and the second one in columns direction:
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
  1022|         0|            0|            0|  0.00%|    [array([[ 2.,  2., -1.],
  1023|         0|            0|            0|  0.00%|           [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],
  1024|         0|            0|            0|  0.00%|           [1. , 1. , 1. ]])]
  1025|         0|            0|            0|  0.00%|
  1026|         0|            0|            0|  0.00%|    In this example the spacing is also specified:
  1027|         0|            0|            0|  0.00%|    uniform for axis=0 and non uniform for axis=1
  1028|         0|            0|            0|  0.00%|
  1029|         0|            0|            0|  0.00%|    >>> dx = 2.
  1030|         0|            0|            0|  0.00%|    >>> y = [1., 1.5, 3.5]
  1031|         0|            0|            0|  0.00%|    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
  1032|         0|            0|            0|  0.00%|    [array([[ 1. ,  1. , -0.5],
  1033|         0|            0|            0|  0.00%|           [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],
  1034|         0|            0|            0|  0.00%|           [2. , 1.7, 0.5]])]
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|    It is possible to specify how boundaries are treated using `edge_order`
  1037|         0|            0|            0|  0.00%|
  1038|         0|            0|            0|  0.00%|    >>> x = np.array([0, 1, 2, 3, 4])
  1039|         0|            0|            0|  0.00%|    >>> f = x**2
  1040|         0|            0|            0|  0.00%|    >>> np.gradient(f, edge_order=1)
  1041|         0|            0|            0|  0.00%|    array([1.,  2.,  4.,  6.,  7.])
  1042|         0|            0|            0|  0.00%|    >>> np.gradient(f, edge_order=2)
  1043|         0|            0|            0|  0.00%|    array([0., 2., 4., 6., 8.])
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|    The `axis` keyword can be used to specify a subset of axes of which the
  1046|         0|            0|            0|  0.00%|    gradient is calculated
  1047|         0|            0|            0|  0.00%|
  1048|         0|            0|            0|  0.00%|    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
  1049|         0|            0|            0|  0.00%|    array([[ 2.,  2., -1.],
  1050|         0|            0|            0|  0.00%|           [ 2.,  2., -1.]])
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|    Notes
  1053|         0|            0|            0|  0.00%|    -----
  1054|         0|            0|            0|  0.00%|    Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous
  1055|         0|            0|            0|  0.00%|    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we
  1056|         0|            0|            0|  0.00%|    minimize the "consistency error" :math:`\\eta_{i}` between the true gradient
  1057|         0|            0|            0|  0.00%|    and its estimate from a linear combination of the neighboring grid-points:
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|    .. math::
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|        \\eta_{i} = f_{i}^{\\left(1\\right)} -
  1062|         0|            0|            0|  0.00%|                    \\left[ \\alpha f\\left(x_{i}\\right) +
  1063|         0|            0|            0|  0.00%|                            \\beta f\\left(x_{i} + h_{d}\\right) +
  1064|         0|            0|            0|  0.00%|                            \\gamma f\\left(x_{i}-h_{s}\\right)
  1065|         0|            0|            0|  0.00%|                    \\right]
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`
  1068|         0|            0|            0|  0.00%|    with their Taylor series expansion, this translates into solving
  1069|         0|            0|            0|  0.00%|    the following the linear system:
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    .. math::
  1072|         0|            0|            0|  0.00%|
  1073|         0|            0|            0|  0.00%|        \\left\\{
  1074|         0|            0|            0|  0.00%|            \\begin{array}{r}
  1075|         0|            0|            0|  0.00%|                \\alpha+\\beta+\\gamma=0 \\\\
  1076|         0|            0|            0|  0.00%|                \\beta h_{d}-\\gamma h_{s}=1 \\\\
  1077|         0|            0|            0|  0.00%|                \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0
  1078|         0|            0|            0|  0.00%|            \\end{array}
  1079|         0|            0|            0|  0.00%|        \\right.
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|    The resulting approximation of :math:`f_{i}^{(1)}` is the following:
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|    .. math::
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|        \\hat f_{i}^{(1)} =
  1086|         0|            0|            0|  0.00%|            \\frac{
  1087|         0|            0|            0|  0.00%|                h_{s}^{2}f\\left(x_{i} + h_{d}\\right)
  1088|         0|            0|            0|  0.00%|                + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)
  1089|         0|            0|            0|  0.00%|                - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}
  1090|         0|            0|            0|  0.00%|                { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}
  1091|         0|            0|            0|  0.00%|            + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}
  1092|         0|            0|            0|  0.00%|                                + h_{s}h_{d}^{2}}{h_{d}
  1093|         0|            0|            0|  0.00%|                                + h_{s}}\\right)
  1094|         0|            0|            0|  0.00%|
  1095|         0|            0|            0|  0.00%|    It is worth noting that if :math:`h_{s}=h_{d}`
  1096|         0|            0|            0|  0.00%|    (i.e., data are evenly spaced)
  1097|         0|            0|            0|  0.00%|    we find the standard second order approximation:
  1098|         0|            0|            0|  0.00%|
  1099|         0|            0|            0|  0.00%|    .. math::
  1100|         0|            0|            0|  0.00%|
  1101|         0|            0|            0|  0.00%|        \\hat f_{i}^{(1)}=
  1102|         0|            0|            0|  0.00%|            \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}
  1103|         0|            0|            0|  0.00%|            + \\mathcal{O}\\left(h^{2}\\right)
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|    With a similar procedure the forward/backward approximations used for
  1106|         0|            0|            0|  0.00%|    boundaries can be derived.
  1107|         0|            0|            0|  0.00%|
  1108|         0|            0|            0|  0.00%|    References
  1109|         0|            0|            0|  0.00%|    ----------
  1110|         0|            0|            0|  0.00%|    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
  1111|         0|            0|            0|  0.00%|            (Texts in Applied Mathematics). New York: Springer.
  1112|         0|            0|            0|  0.00%|    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations
  1113|         0|            0|            0|  0.00%|            in Geophysical Fluid Dynamics. New York: Springer.
  1114|         0|            0|            0|  0.00%|    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on
  1115|         0|            0|            0|  0.00%|            Arbitrarily Spaced Grids,
  1116|         0|            0|            0|  0.00%|            Mathematics of Computation 51, no. 184 : 699-706.
  1117|         0|            0|            0|  0.00%|            `PDF <http://www.ams.org/journals/mcom/1988-51-184/
  1118|         0|            0|            0|  0.00%|            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.
  1119|         0|            0|            0|  0.00%|    """
  1120|         0|            0|            0|  0.00%|    f = np.asanyarray(f)
  1121|         0|            0|            0|  0.00%|    N = f.ndim  # number of dimensions
  1122|         0|            0|            0|  0.00%|
  1123|         0|            0|            0|  0.00%|    if axis is None:
  1124|         0|            0|            0|  0.00%|        axes = tuple(range(N))
  1125|         0|            0|            0|  0.00%|    else:
  1126|         0|            0|            0|  0.00%|        axes = _nx.normalize_axis_tuple(axis, N)
  1127|         0|            0|            0|  0.00%|
  1128|         0|            0|            0|  0.00%|    len_axes = len(axes)
  1129|         0|            0|            0|  0.00%|    n = len(varargs)
  1130|         0|            0|            0|  0.00%|    if n == 0:
  1131|         0|            0|            0|  0.00%|        # no spacing argument - use 1 in all axes
  1132|         0|            0|            0|  0.00%|        dx = [1.0] * len_axes
  1133|         0|            0|            0|  0.00%|    elif n == 1 and np.ndim(varargs[0]) == 0:
  1134|         0|            0|            0|  0.00%|        # single scalar for all axes
  1135|         0|            0|            0|  0.00%|        dx = varargs * len_axes
  1136|         0|            0|            0|  0.00%|    elif n == len_axes:
  1137|         0|            0|            0|  0.00%|        # scalar or 1d array for each axis
  1138|         0|            0|            0|  0.00%|        dx = list(varargs)
  1139|         0|            0|            0|  0.00%|        for i, distances in enumerate(dx):
  1140|         0|            0|            0|  0.00%|            distances = np.asanyarray(distances)
  1141|         0|            0|            0|  0.00%|            if distances.ndim == 0:
  1142|         0|            0|            0|  0.00%|                continue
  1143|         0|            0|            0|  0.00%|            elif distances.ndim != 1:
  1144|         0|            0|            0|  0.00%|                raise ValueError("distances must be either scalars or 1d")
  1145|         0|            0|            0|  0.00%|            if len(distances) != f.shape[axes[i]]:
  1146|         0|            0|            0|  0.00%|                raise ValueError("when 1d, distances must match "
  1147|         0|            0|            0|  0.00%|                                 "the length of the corresponding dimension")
  1148|         0|            0|            0|  0.00%|            if np.issubdtype(distances.dtype, np.integer):
  1149|         0|            0|            0|  0.00%|                # Convert numpy integer types to float64 to avoid modular
  1150|         0|            0|            0|  0.00%|                # arithmetic in np.diff(distances).
  1151|         0|            0|            0|  0.00%|                distances = distances.astype(np.float64)
  1152|         0|            0|            0|  0.00%|            diffx = np.diff(distances)
  1153|         0|            0|            0|  0.00%|            # if distances are constant reduce to the scalar case
  1154|         0|            0|            0|  0.00%|            # since it brings a consistent speedup
  1155|         0|            0|            0|  0.00%|            if (diffx == diffx[0]).all():
  1156|         0|            0|            0|  0.00%|                diffx = diffx[0]
  1157|         0|            0|            0|  0.00%|            dx[i] = diffx
  1158|         0|            0|            0|  0.00%|    else:
  1159|         0|            0|            0|  0.00%|        raise TypeError("invalid number of arguments")
  1160|         0|            0|            0|  0.00%|
  1161|         0|            0|            0|  0.00%|    if edge_order > 2:
  1162|         0|            0|            0|  0.00%|        raise ValueError("'edge_order' greater than 2 not supported")
  1163|         0|            0|            0|  0.00%|
  1164|         0|            0|            0|  0.00%|    # use central differences on interior and one-sided differences on the
  1165|         0|            0|            0|  0.00%|    # endpoints. This preserves second order-accuracy over the full domain.
  1166|         0|            0|            0|  0.00%|
  1167|         0|            0|            0|  0.00%|    outvals = []
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|    # create slice objects --- initially all are [:, :, ..., :]
  1170|         0|            0|            0|  0.00%|    slice1 = [slice(None)]*N
  1171|         0|            0|            0|  0.00%|    slice2 = [slice(None)]*N
  1172|         0|            0|            0|  0.00%|    slice3 = [slice(None)]*N
  1173|         0|            0|            0|  0.00%|    slice4 = [slice(None)]*N
  1174|         0|            0|            0|  0.00%|
  1175|         0|            0|            0|  0.00%|    otype = f.dtype
  1176|         0|            0|            0|  0.00%|    if otype.type is np.datetime64:
  1177|         0|            0|            0|  0.00%|        # the timedelta dtype with the same unit information
  1178|         0|            0|            0|  0.00%|        otype = np.dtype(otype.name.replace('datetime', 'timedelta'))
  1179|         0|            0|            0|  0.00%|        # view as timedelta to allow addition
  1180|         0|            0|            0|  0.00%|        f = f.view(otype)
  1181|         0|            0|            0|  0.00%|    elif otype.type is np.timedelta64:
  1182|         0|            0|            0|  0.00%|        pass
  1183|         0|            0|            0|  0.00%|    elif np.issubdtype(otype, np.inexact):
  1184|         0|            0|            0|  0.00%|        pass
  1185|         0|            0|            0|  0.00%|    else:
  1186|         0|            0|            0|  0.00%|        # All other types convert to floating point.
  1187|         0|            0|            0|  0.00%|        # First check if f is a numpy integer type; if so, convert f to float64
  1188|         0|            0|            0|  0.00%|        # to avoid modular arithmetic when computing the changes in f.
  1189|         0|            0|            0|  0.00%|        if np.issubdtype(otype, np.integer):
  1190|         0|            0|            0|  0.00%|            f = f.astype(np.float64)
  1191|         0|            0|            0|  0.00%|        otype = np.float64
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|    for axis, ax_dx in zip(axes, dx):
  1194|         0|            0|            0|  0.00%|        if f.shape[axis] < edge_order + 1:
  1195|         0|            0|            0|  0.00%|            raise ValueError(
  1196|         0|            0|            0|  0.00%|                "Shape of array too small to calculate a numerical gradient, "
  1197|         0|            0|            0|  0.00%|                "at least (edge_order + 1) elements are required.")
  1198|         0|            0|            0|  0.00%|        # result allocation
  1199|         0|            0|            0|  0.00%|        out = np.empty_like(f, dtype=otype)
  1200|         0|            0|            0|  0.00%|
  1201|         0|            0|            0|  0.00%|        # spacing for the current axis
  1202|         0|            0|            0|  0.00%|        uniform_spacing = np.ndim(ax_dx) == 0
  1203|         0|            0|            0|  0.00%|
  1204|         0|            0|            0|  0.00%|        # Numerical differentiation: 2nd order interior
  1205|         0|            0|            0|  0.00%|        slice1[axis] = slice(1, -1)
  1206|         0|            0|            0|  0.00%|        slice2[axis] = slice(None, -2)
  1207|         0|            0|            0|  0.00%|        slice3[axis] = slice(1, -1)
  1208|         0|            0|            0|  0.00%|        slice4[axis] = slice(2, None)
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|        if uniform_spacing:
  1211|         0|            0|            0|  0.00%|            out[tuple(slice1)] = (f[tuple(slice4)] - f[tuple(slice2)]) / (2. * ax_dx)
  1212|         0|            0|            0|  0.00%|        else:
  1213|         0|            0|            0|  0.00%|            dx1 = ax_dx[0:-1]
  1214|         0|            0|            0|  0.00%|            dx2 = ax_dx[1:]
  1215|         0|            0|            0|  0.00%|            a = -(dx2)/(dx1 * (dx1 + dx2))
  1216|         0|            0|            0|  0.00%|            b = (dx2 - dx1) / (dx1 * dx2)
  1217|         0|            0|            0|  0.00%|            c = dx1 / (dx2 * (dx1 + dx2))
  1218|         0|            0|            0|  0.00%|            # fix the shape for broadcasting
  1219|         0|            0|            0|  0.00%|            shape = np.ones(N, dtype=int)
  1220|         0|            0|            0|  0.00%|            shape[axis] = -1
  1221|         0|            0|            0|  0.00%|            a.shape = b.shape = c.shape = shape
  1222|         0|            0|            0|  0.00%|            # 1D equivalent -- out[1:-1] = a * f[:-2] + b * f[1:-1] + c * f[2:]
  1223|         0|            0|            0|  0.00%|            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|        # Numerical differentiation: 1st order edges
  1226|         0|            0|            0|  0.00%|        if edge_order == 1:
  1227|         0|            0|            0|  0.00%|            slice1[axis] = 0
  1228|         0|            0|            0|  0.00%|            slice2[axis] = 1
  1229|         0|            0|            0|  0.00%|            slice3[axis] = 0
  1230|         0|            0|            0|  0.00%|            dx_0 = ax_dx if uniform_spacing else ax_dx[0]
  1231|         0|            0|            0|  0.00%|            # 1D equivalent -- out[0] = (f[1] - f[0]) / (x[1] - x[0])
  1232|         0|            0|            0|  0.00%|            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_0
  1233|         0|            0|            0|  0.00%|
  1234|         0|            0|            0|  0.00%|            slice1[axis] = -1
  1235|         0|            0|            0|  0.00%|            slice2[axis] = -1
  1236|         0|            0|            0|  0.00%|            slice3[axis] = -2
  1237|         0|            0|            0|  0.00%|            dx_n = ax_dx if uniform_spacing else ax_dx[-1]
  1238|         0|            0|            0|  0.00%|            # 1D equivalent -- out[-1] = (f[-1] - f[-2]) / (x[-1] - x[-2])
  1239|         0|            0|            0|  0.00%|            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_n
  1240|         0|            0|            0|  0.00%|
  1241|         0|            0|            0|  0.00%|        # Numerical differentiation: 2nd order edges
  1242|         0|            0|            0|  0.00%|        else:
  1243|         0|            0|            0|  0.00%|            slice1[axis] = 0
  1244|         0|            0|            0|  0.00%|            slice2[axis] = 0
  1245|         0|            0|            0|  0.00%|            slice3[axis] = 1
  1246|         0|            0|            0|  0.00%|            slice4[axis] = 2
  1247|         0|            0|            0|  0.00%|            if uniform_spacing:
  1248|         0|            0|            0|  0.00%|                a = -1.5 / ax_dx
  1249|         0|            0|            0|  0.00%|                b = 2. / ax_dx
  1250|         0|            0|            0|  0.00%|                c = -0.5 / ax_dx
  1251|         0|            0|            0|  0.00%|            else:
  1252|         0|            0|            0|  0.00%|                dx1 = ax_dx[0]
  1253|         0|            0|            0|  0.00%|                dx2 = ax_dx[1]
  1254|         0|            0|            0|  0.00%|                a = -(2. * dx1 + dx2)/(dx1 * (dx1 + dx2))
  1255|         0|            0|            0|  0.00%|                b = (dx1 + dx2) / (dx1 * dx2)
  1256|         0|            0|            0|  0.00%|                c = - dx1 / (dx2 * (dx1 + dx2))
  1257|         0|            0|            0|  0.00%|            # 1D equivalent -- out[0] = a * f[0] + b * f[1] + c * f[2]
  1258|         0|            0|            0|  0.00%|            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]
  1259|         0|            0|            0|  0.00%|
  1260|         0|            0|            0|  0.00%|            slice1[axis] = -1
  1261|         0|            0|            0|  0.00%|            slice2[axis] = -3
  1262|         0|            0|            0|  0.00%|            slice3[axis] = -2
  1263|         0|            0|            0|  0.00%|            slice4[axis] = -1
  1264|         0|            0|            0|  0.00%|            if uniform_spacing:
  1265|         0|            0|            0|  0.00%|                a = 0.5 / ax_dx
  1266|         0|            0|            0|  0.00%|                b = -2. / ax_dx
  1267|         0|            0|            0|  0.00%|                c = 1.5 / ax_dx
  1268|         0|            0|            0|  0.00%|            else:
  1269|         0|            0|            0|  0.00%|                dx1 = ax_dx[-2]
  1270|         0|            0|            0|  0.00%|                dx2 = ax_dx[-1]
  1271|         0|            0|            0|  0.00%|                a = (dx2) / (dx1 * (dx1 + dx2))
  1272|         0|            0|            0|  0.00%|                b = - (dx2 + dx1) / (dx1 * dx2)
  1273|         0|            0|            0|  0.00%|                c = (2. * dx2 + dx1) / (dx2 * (dx1 + dx2))
  1274|         0|            0|            0|  0.00%|            # 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]
  1275|         0|            0|            0|  0.00%|            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|        outvals.append(out)
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|        # reset the slice object in this dimension to ":"
  1280|         0|            0|            0|  0.00%|        slice1[axis] = slice(None)
  1281|         0|            0|            0|  0.00%|        slice2[axis] = slice(None)
  1282|         0|            0|            0|  0.00%|        slice3[axis] = slice(None)
  1283|         0|            0|            0|  0.00%|        slice4[axis] = slice(None)
  1284|         0|            0|            0|  0.00%|
  1285|         0|            0|            0|  0.00%|    if len_axes == 1:
  1286|         0|            0|            0|  0.00%|        return outvals[0]
  1287|         0|            0|            0|  0.00%|    else:
  1288|         0|            0|            0|  0.00%|        return outvals
  1289|         0|            0|            0|  0.00%|
  1290|         0|            0|            0|  0.00%|
  1291|         4|            0|            0|  0.00%|def _diff_dispatcher(a, n=None, axis=None, prepend=None, append=None):
  1292|         4|            0|            0|  0.00%|    return (a, prepend, append)
  1293|         0|            0|            0|  0.00%|
  1294|         0|            0|            0|  0.00%|
  1295|         4|            0|            0|  0.00%|@array_function_dispatch(_diff_dispatcher)
  1296|         0|            0|            0|  0.00%|def diff(a, n=1, axis=-1, prepend=np._NoValue, append=np._NoValue):
  1297|         0|            0|            0|  0.00%|    """
  1298|         0|            0|            0|  0.00%|    Calculate the n-th discrete difference along the given axis.
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|    The first difference is given by ``out[i] = a[i+1] - a[i]`` along
  1301|         0|            0|            0|  0.00%|    the given axis, higher differences are calculated by using `diff`
  1302|         0|            0|            0|  0.00%|    recursively.
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|    Parameters
  1305|         0|            0|            0|  0.00%|    ----------
  1306|         0|            0|            0|  0.00%|    a : array_like
  1307|         0|            0|            0|  0.00%|        Input array
  1308|         0|            0|            0|  0.00%|    n : int, optional
  1309|         0|            0|            0|  0.00%|        The number of times values are differenced. If zero, the input
  1310|         0|            0|            0|  0.00%|        is returned as-is.
  1311|         0|            0|            0|  0.00%|    axis : int, optional
  1312|         0|            0|            0|  0.00%|        The axis along which the difference is taken, default is the
  1313|         0|            0|            0|  0.00%|        last axis.
  1314|         0|            0|            0|  0.00%|    prepend, append : array_like, optional
  1315|         0|            0|            0|  0.00%|        Values to prepend or append to `a` along axis prior to
  1316|         0|            0|            0|  0.00%|        performing the difference.  Scalar values are expanded to
  1317|         0|            0|            0|  0.00%|        arrays with length 1 in the direction of axis and the shape
  1318|         0|            0|            0|  0.00%|        of the input array in along all other axes.  Otherwise the
  1319|         0|            0|            0|  0.00%|        dimension and shape must match `a` except along axis.
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|        .. versionadded:: 1.16.0
  1322|         0|            0|            0|  0.00%|
  1323|         0|            0|            0|  0.00%|    Returns
  1324|         0|            0|            0|  0.00%|    -------
  1325|         0|            0|            0|  0.00%|    diff : ndarray
  1326|         0|            0|            0|  0.00%|        The n-th differences. The shape of the output is the same as `a`
  1327|         0|            0|            0|  0.00%|        except along `axis` where the dimension is smaller by `n`. The
  1328|         0|            0|            0|  0.00%|        type of the output is the same as the type of the difference
  1329|         0|            0|            0|  0.00%|        between any two elements of `a`. This is the same as the type of
  1330|         0|            0|            0|  0.00%|        `a` in most cases. A notable exception is `datetime64`, which
  1331|         0|            0|            0|  0.00%|        results in a `timedelta64` output array.
  1332|         0|            0|            0|  0.00%|
  1333|         0|            0|            0|  0.00%|    See Also
  1334|         0|            0|            0|  0.00%|    --------
  1335|         0|            0|            0|  0.00%|    gradient, ediff1d, cumsum
  1336|         0|            0|            0|  0.00%|
  1337|         0|            0|            0|  0.00%|    Notes
  1338|         0|            0|            0|  0.00%|    -----
  1339|         0|            0|            0|  0.00%|    Type is preserved for boolean arrays, so the result will contain
  1340|         0|            0|            0|  0.00%|    `False` when consecutive elements are the same and `True` when they
  1341|         0|            0|            0|  0.00%|    differ.
  1342|         0|            0|            0|  0.00%|
  1343|         0|            0|            0|  0.00%|    For unsigned integer arrays, the results will also be unsigned. This
  1344|         0|            0|            0|  0.00%|    should not be surprising, as the result is consistent with
  1345|         0|            0|            0|  0.00%|    calculating the difference directly:
  1346|         0|            0|            0|  0.00%|
  1347|         0|            0|            0|  0.00%|    >>> u8_arr = np.array([1, 0], dtype=np.uint8)
  1348|         0|            0|            0|  0.00%|    >>> np.diff(u8_arr)
  1349|         0|            0|            0|  0.00%|    array([255], dtype=uint8)
  1350|         0|            0|            0|  0.00%|    >>> u8_arr[1,...] - u8_arr[0,...]
  1351|         0|            0|            0|  0.00%|    255
  1352|         0|            0|            0|  0.00%|
  1353|         0|            0|            0|  0.00%|    If this is not desirable, then the array should be cast to a larger
  1354|         0|            0|            0|  0.00%|    integer type first:
  1355|         0|            0|            0|  0.00%|
  1356|         0|            0|            0|  0.00%|    >>> i16_arr = u8_arr.astype(np.int16)
  1357|         0|            0|            0|  0.00%|    >>> np.diff(i16_arr)
  1358|         0|            0|            0|  0.00%|    array([-1], dtype=int16)
  1359|         0|            0|            0|  0.00%|
  1360|         0|            0|            0|  0.00%|    Examples
  1361|         0|            0|            0|  0.00%|    --------
  1362|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 4, 7, 0])
  1363|         0|            0|            0|  0.00%|    >>> np.diff(x)
  1364|         0|            0|            0|  0.00%|    array([ 1,  2,  3, -7])
  1365|         0|            0|            0|  0.00%|    >>> np.diff(x, n=2)
  1366|         0|            0|            0|  0.00%|    array([  1,   1, -10])
  1367|         0|            0|            0|  0.00%|
  1368|         0|            0|            0|  0.00%|    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
  1369|         0|            0|            0|  0.00%|    >>> np.diff(x)
  1370|         0|            0|            0|  0.00%|    array([[2, 3, 4],
  1371|         0|            0|            0|  0.00%|           [5, 1, 2]])
  1372|         0|            0|            0|  0.00%|    >>> np.diff(x, axis=0)
  1373|         0|            0|            0|  0.00%|    array([[-1,  2,  0, -2]])
  1374|         0|            0|            0|  0.00%|
  1375|         0|            0|            0|  0.00%|    >>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
  1376|         0|            0|            0|  0.00%|    >>> np.diff(x)
  1377|         0|            0|            0|  0.00%|    array([1, 1], dtype='timedelta64[D]')
  1378|         0|            0|            0|  0.00%|
  1379|         0|            0|            0|  0.00%|    """
  1380|         4|            0|            0|  0.00%|    if n == 0:
  1381|         0|            0|            0|  0.00%|        return a
  1382|         4|            0|            0|  0.00%|    if n < 0:
  1383|         0|            0|            0|  0.00%|        raise ValueError(
  1384|         0|            0|            0|  0.00%|            "order must be non-negative but got " + repr(n))
  1385|         0|            0|            0|  0.00%|
  1386|         4|            0|            0|  0.00%|    a = asanyarray(a)
  1387|         4|            0|            0|  0.00%|    nd = a.ndim
  1388|         4|            0|            0|  0.00%|    if nd == 0:
  1389|         0|            0|            0|  0.00%|        raise ValueError("diff requires input that is at least one dimensional")
  1390|         4|            0|            0|  0.00%|    axis = normalize_axis_index(axis, nd)
  1391|         0|            0|            0|  0.00%|
  1392|         4|            0|            0|  0.00%|    combined = []
  1393|         4|            0|            0|  0.00%|    if prepend is not np._NoValue:
  1394|         0|            0|            0|  0.00%|        prepend = np.asanyarray(prepend)
  1395|         0|            0|            0|  0.00%|        if prepend.ndim == 0:
  1396|         0|            0|            0|  0.00%|            shape = list(a.shape)
  1397|         0|            0|            0|  0.00%|            shape[axis] = 1
  1398|         0|            0|            0|  0.00%|            prepend = np.broadcast_to(prepend, tuple(shape))
  1399|         0|            0|            0|  0.00%|        combined.append(prepend)
  1400|         0|            0|            0|  0.00%|
  1401|         4|            0|            0|  0.00%|    combined.append(a)
  1402|         0|            0|            0|  0.00%|
  1403|         4|            0|            0|  0.00%|    if append is not np._NoValue:
  1404|         0|            0|            0|  0.00%|        append = np.asanyarray(append)
  1405|         0|            0|            0|  0.00%|        if append.ndim == 0:
  1406|         0|            0|            0|  0.00%|            shape = list(a.shape)
  1407|         0|            0|            0|  0.00%|            shape[axis] = 1
  1408|         0|            0|            0|  0.00%|            append = np.broadcast_to(append, tuple(shape))
  1409|         0|            0|            0|  0.00%|        combined.append(append)
  1410|         0|            0|            0|  0.00%|
  1411|         4|            0|            0|  0.00%|    if len(combined) > 1:
  1412|         0|            0|            0|  0.00%|        a = np.concatenate(combined, axis)
  1413|         0|            0|            0|  0.00%|
  1414|         4|            0|            0|  0.00%|    slice1 = [slice(None)] * nd
  1415|         4|            0|            0|  0.00%|    slice2 = [slice(None)] * nd
  1416|         4|            0|            0|  0.00%|    slice1[axis] = slice(1, None)
  1417|         4|            0|            0|  0.00%|    slice2[axis] = slice(None, -1)
  1418|         4|            0|            0|  0.00%|    slice1 = tuple(slice1)
  1419|         4|            0|            0|  0.00%|    slice2 = tuple(slice2)
  1420|         0|            0|            0|  0.00%|
  1421|         4|            0|            0|  0.00%|    op = not_equal if a.dtype == np.bool_ else subtract
  1422|         8|            0|            0|  0.00%|    for _ in range(n):
  1423|         4|            0|            0|  0.00%|        a = op(a[slice1], a[slice2])
  1424|         0|            0|            0|  0.00%|
  1425|         4|            0|            0|  0.00%|    return a
  1426|         0|            0|            0|  0.00%|
  1427|         0|            0|            0|  0.00%|
  1428|         0|            0|            0|  0.00%|def _interp_dispatcher(x, xp, fp, left=None, right=None, period=None):
  1429|         0|            0|            0|  0.00%|    return (x, xp, fp)
  1430|         0|            0|            0|  0.00%|
  1431|         0|            0|            0|  0.00%|
  1432|         0|            0|            0|  0.00%|@array_function_dispatch(_interp_dispatcher)
  1433|         0|            0|            0|  0.00%|def interp(x, xp, fp, left=None, right=None, period=None):
  1434|         0|            0|            0|  0.00%|    """
  1435|         0|            0|            0|  0.00%|    One-dimensional linear interpolation for monotonically increasing sample points.
  1436|         0|            0|            0|  0.00%|
  1437|         0|            0|            0|  0.00%|    Returns the one-dimensional piecewise linear interpolant to a function
  1438|         0|            0|            0|  0.00%|    with given discrete data points (`xp`, `fp`), evaluated at `x`.
  1439|         0|            0|            0|  0.00%|
  1440|         0|            0|            0|  0.00%|    Parameters
  1441|         0|            0|            0|  0.00%|    ----------
  1442|         0|            0|            0|  0.00%|    x : array_like
  1443|         0|            0|            0|  0.00%|        The x-coordinates at which to evaluate the interpolated values.
  1444|         0|            0|            0|  0.00%|
  1445|         0|            0|            0|  0.00%|    xp : 1-D sequence of floats
  1446|         0|            0|            0|  0.00%|        The x-coordinates of the data points, must be increasing if argument
  1447|         0|            0|            0|  0.00%|        `period` is not specified. Otherwise, `xp` is internally sorted after
  1448|         0|            0|            0|  0.00%|        normalizing the periodic boundaries with ``xp = xp % period``.
  1449|         0|            0|            0|  0.00%|
  1450|         0|            0|            0|  0.00%|    fp : 1-D sequence of float or complex
  1451|         0|            0|            0|  0.00%|        The y-coordinates of the data points, same length as `xp`.
  1452|         0|            0|            0|  0.00%|
  1453|         0|            0|            0|  0.00%|    left : optional float or complex corresponding to fp
  1454|         0|            0|            0|  0.00%|        Value to return for `x < xp[0]`, default is `fp[0]`.
  1455|         0|            0|            0|  0.00%|
  1456|         0|            0|            0|  0.00%|    right : optional float or complex corresponding to fp
  1457|         0|            0|            0|  0.00%|        Value to return for `x > xp[-1]`, default is `fp[-1]`.
  1458|         0|            0|            0|  0.00%|
  1459|         0|            0|            0|  0.00%|    period : None or float, optional
  1460|         0|            0|            0|  0.00%|        A period for the x-coordinates. This parameter allows the proper
  1461|         0|            0|            0|  0.00%|        interpolation of angular x-coordinates. Parameters `left` and `right`
  1462|         0|            0|            0|  0.00%|        are ignored if `period` is specified.
  1463|         0|            0|            0|  0.00%|
  1464|         0|            0|            0|  0.00%|        .. versionadded:: 1.10.0
  1465|         0|            0|            0|  0.00%|
  1466|         0|            0|            0|  0.00%|    Returns
  1467|         0|            0|            0|  0.00%|    -------
  1468|         0|            0|            0|  0.00%|    y : float or complex (corresponding to fp) or ndarray
  1469|         0|            0|            0|  0.00%|        The interpolated values, same shape as `x`.
  1470|         0|            0|            0|  0.00%|
  1471|         0|            0|            0|  0.00%|    Raises
  1472|         0|            0|            0|  0.00%|    ------
  1473|         0|            0|            0|  0.00%|    ValueError
  1474|         0|            0|            0|  0.00%|        If `xp` and `fp` have different length
  1475|         0|            0|            0|  0.00%|        If `xp` or `fp` are not 1-D sequences
  1476|         0|            0|            0|  0.00%|        If `period == 0`
  1477|         0|            0|            0|  0.00%|
  1478|         0|            0|            0|  0.00%|    See Also
  1479|         0|            0|            0|  0.00%|    --------
  1480|         0|            0|            0|  0.00%|    scipy.interpolate
  1481|         0|            0|            0|  0.00%|
  1482|         0|            0|            0|  0.00%|    Warnings
  1483|         0|            0|            0|  0.00%|    --------
  1484|         0|            0|            0|  0.00%|    The x-coordinate sequence is expected to be increasing, but this is not
  1485|         0|            0|            0|  0.00%|    explicitly enforced.  However, if the sequence `xp` is non-increasing,
  1486|         0|            0|            0|  0.00%|    interpolation results are meaningless.
  1487|         0|            0|            0|  0.00%|
  1488|         0|            0|            0|  0.00%|    Note that, since NaN is unsortable, `xp` also cannot contain NaNs.
  1489|         0|            0|            0|  0.00%|
  1490|         0|            0|            0|  0.00%|    A simple check for `xp` being strictly increasing is::
  1491|         0|            0|            0|  0.00%|
  1492|         0|            0|            0|  0.00%|        np.all(np.diff(xp) > 0)
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|    Examples
  1495|         0|            0|            0|  0.00%|    --------
  1496|         0|            0|            0|  0.00%|    >>> xp = [1, 2, 3]
  1497|         0|            0|            0|  0.00%|    >>> fp = [3, 2, 0]
  1498|         0|            0|            0|  0.00%|    >>> np.interp(2.5, xp, fp)
  1499|         0|            0|            0|  0.00%|    1.0
  1500|         0|            0|            0|  0.00%|    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
  1501|         0|            0|            0|  0.00%|    array([3.  , 3.  , 2.5 , 0.56, 0.  ])
  1502|         0|            0|            0|  0.00%|    >>> UNDEF = -99.0
  1503|         0|            0|            0|  0.00%|    >>> np.interp(3.14, xp, fp, right=UNDEF)
  1504|         0|            0|            0|  0.00%|    -99.0
  1505|         0|            0|            0|  0.00%|
  1506|         0|            0|            0|  0.00%|    Plot an interpolant to the sine function:
  1507|         0|            0|            0|  0.00%|
  1508|         0|            0|            0|  0.00%|    >>> x = np.linspace(0, 2*np.pi, 10)
  1509|         0|            0|            0|  0.00%|    >>> y = np.sin(x)
  1510|         0|            0|            0|  0.00%|    >>> xvals = np.linspace(0, 2*np.pi, 50)
  1511|         0|            0|            0|  0.00%|    >>> yinterp = np.interp(xvals, x, y)
  1512|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  1513|         0|            0|            0|  0.00%|    >>> plt.plot(x, y, 'o')
  1514|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  1515|         0|            0|            0|  0.00%|    >>> plt.plot(xvals, yinterp, '-x')
  1516|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  1517|         0|            0|            0|  0.00%|    >>> plt.show()
  1518|         0|            0|            0|  0.00%|
  1519|         0|            0|            0|  0.00%|    Interpolation with periodic x-coordinates:
  1520|         0|            0|            0|  0.00%|
  1521|         0|            0|            0|  0.00%|    >>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
  1522|         0|            0|            0|  0.00%|    >>> xp = [190, -190, 350, -350]
  1523|         0|            0|            0|  0.00%|    >>> fp = [5, 10, 3, 4]
  1524|         0|            0|            0|  0.00%|    >>> np.interp(x, xp, fp, period=360)
  1525|         0|            0|            0|  0.00%|    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])
  1526|         0|            0|            0|  0.00%|
  1527|         0|            0|            0|  0.00%|    Complex interpolation:
  1528|         0|            0|            0|  0.00%|
  1529|         0|            0|            0|  0.00%|    >>> x = [1.5, 4.0]
  1530|         0|            0|            0|  0.00%|    >>> xp = [2,3,5]
  1531|         0|            0|            0|  0.00%|    >>> fp = [1.0j, 0, 2+3j]
  1532|         0|            0|            0|  0.00%|    >>> np.interp(x, xp, fp)
  1533|         0|            0|            0|  0.00%|    array([0.+1.j , 1.+1.5j])
  1534|         0|            0|            0|  0.00%|
  1535|         0|            0|            0|  0.00%|    """
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|    fp = np.asarray(fp)
  1538|         0|            0|            0|  0.00%|
  1539|         0|            0|            0|  0.00%|    if np.iscomplexobj(fp):
  1540|         0|            0|            0|  0.00%|        interp_func = compiled_interp_complex
  1541|         0|            0|            0|  0.00%|        input_dtype = np.complex128
  1542|         0|            0|            0|  0.00%|    else:
  1543|         0|            0|            0|  0.00%|        interp_func = compiled_interp
  1544|         0|            0|            0|  0.00%|        input_dtype = np.float64
  1545|         0|            0|            0|  0.00%|
  1546|         0|            0|            0|  0.00%|    if period is not None:
  1547|         0|            0|            0|  0.00%|        if period == 0:
  1548|         0|            0|            0|  0.00%|            raise ValueError("period must be a non-zero value")
  1549|         0|            0|            0|  0.00%|        period = abs(period)
  1550|         0|            0|            0|  0.00%|        left = None
  1551|         0|            0|            0|  0.00%|        right = None
  1552|         0|            0|            0|  0.00%|
  1553|         0|            0|            0|  0.00%|        x = np.asarray(x, dtype=np.float64)
  1554|         0|            0|            0|  0.00%|        xp = np.asarray(xp, dtype=np.float64)
  1555|         0|            0|            0|  0.00%|        fp = np.asarray(fp, dtype=input_dtype)
  1556|         0|            0|            0|  0.00%|
  1557|         0|            0|            0|  0.00%|        if xp.ndim != 1 or fp.ndim != 1:
  1558|         0|            0|            0|  0.00%|            raise ValueError("Data points must be 1-D sequences")
  1559|         0|            0|            0|  0.00%|        if xp.shape[0] != fp.shape[0]:
  1560|         0|            0|            0|  0.00%|            raise ValueError("fp and xp are not of the same length")
  1561|         0|            0|            0|  0.00%|        # normalizing periodic boundaries
  1562|         0|            0|            0|  0.00%|        x = x % period
  1563|         0|            0|            0|  0.00%|        xp = xp % period
  1564|         0|            0|            0|  0.00%|        asort_xp = np.argsort(xp)
  1565|         0|            0|            0|  0.00%|        xp = xp[asort_xp]
  1566|         0|            0|            0|  0.00%|        fp = fp[asort_xp]
  1567|         0|            0|            0|  0.00%|        xp = np.concatenate((xp[-1:]-period, xp, xp[0:1]+period))
  1568|         0|            0|            0|  0.00%|        fp = np.concatenate((fp[-1:], fp, fp[0:1]))
  1569|         0|            0|            0|  0.00%|
  1570|         0|            0|            0|  0.00%|    return interp_func(x, xp, fp, left, right)
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|
  1573|         0|            0|            0|  0.00%|def _angle_dispatcher(z, deg=None):
  1574|         0|            0|            0|  0.00%|    return (z,)
  1575|         0|            0|            0|  0.00%|
  1576|         0|            0|            0|  0.00%|
  1577|         0|            0|            0|  0.00%|@array_function_dispatch(_angle_dispatcher)
  1578|         0|            0|            0|  0.00%|def angle(z, deg=False):
  1579|         0|            0|            0|  0.00%|    """
  1580|         0|            0|            0|  0.00%|    Return the angle of the complex argument.
  1581|         0|            0|            0|  0.00%|
  1582|         0|            0|            0|  0.00%|    Parameters
  1583|         0|            0|            0|  0.00%|    ----------
  1584|         0|            0|            0|  0.00%|    z : array_like
  1585|         0|            0|            0|  0.00%|        A complex number or sequence of complex numbers.
  1586|         0|            0|            0|  0.00%|    deg : bool, optional
  1587|         0|            0|            0|  0.00%|        Return angle in degrees if True, radians if False (default).
  1588|         0|            0|            0|  0.00%|
  1589|         0|            0|            0|  0.00%|    Returns
  1590|         0|            0|            0|  0.00%|    -------
  1591|         0|            0|            0|  0.00%|    angle : ndarray or scalar
  1592|         0|            0|            0|  0.00%|        The counterclockwise angle from the positive real axis on the complex
  1593|         0|            0|            0|  0.00%|        plane in the range ``(-pi, pi]``, with dtype as numpy.float64.
  1594|         0|            0|            0|  0.00%|
  1595|         0|            0|            0|  0.00%|        .. versionchanged:: 1.16.0
  1596|         0|            0|            0|  0.00%|            This function works on subclasses of ndarray like `ma.array`.
  1597|         0|            0|            0|  0.00%|
  1598|         0|            0|            0|  0.00%|    See Also
  1599|         0|            0|            0|  0.00%|    --------
  1600|         0|            0|            0|  0.00%|    arctan2
  1601|         0|            0|            0|  0.00%|    absolute
  1602|         0|            0|            0|  0.00%|
  1603|         0|            0|            0|  0.00%|    Notes
  1604|         0|            0|            0|  0.00%|    -----
  1605|         0|            0|            0|  0.00%|    Although the angle of the complex number 0 is undefined, ``numpy.angle(0)``
  1606|         0|            0|            0|  0.00%|    returns the value 0.
  1607|         0|            0|            0|  0.00%|
  1608|         0|            0|            0|  0.00%|    Examples
  1609|         0|            0|            0|  0.00%|    --------
  1610|         0|            0|            0|  0.00%|    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians
  1611|         0|            0|            0|  0.00%|    array([ 0.        ,  1.57079633,  0.78539816]) # may vary
  1612|         0|            0|            0|  0.00%|    >>> np.angle(1+1j, deg=True)                  # in degrees
  1613|         0|            0|            0|  0.00%|    45.0
  1614|         0|            0|            0|  0.00%|
  1615|         0|            0|            0|  0.00%|    """
  1616|         0|            0|            0|  0.00%|    z = asanyarray(z)
  1617|         0|            0|            0|  0.00%|    if issubclass(z.dtype.type, _nx.complexfloating):
  1618|         0|            0|            0|  0.00%|        zimag = z.imag
  1619|         0|            0|            0|  0.00%|        zreal = z.real
  1620|         0|            0|            0|  0.00%|    else:
  1621|         0|            0|            0|  0.00%|        zimag = 0
  1622|         0|            0|            0|  0.00%|        zreal = z
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|    a = arctan2(zimag, zreal)
  1625|         0|            0|            0|  0.00%|    if deg:
  1626|         0|            0|            0|  0.00%|        a *= 180/pi
  1627|         0|            0|            0|  0.00%|    return a
  1628|         0|            0|            0|  0.00%|
  1629|         0|            0|            0|  0.00%|
  1630|         0|            0|            0|  0.00%|def _unwrap_dispatcher(p, discont=None, axis=None, *, period=None):
  1631|         0|            0|            0|  0.00%|    return (p,)
  1632|         0|            0|            0|  0.00%|
  1633|         0|            0|            0|  0.00%|
  1634|         0|            0|            0|  0.00%|@array_function_dispatch(_unwrap_dispatcher)
  1635|         0|            0|            0|  0.00%|def unwrap(p, discont=None, axis=-1, *, period=2*pi):
  1636|         0|            0|            0|  0.00%|    r"""
  1637|         0|            0|            0|  0.00%|    Unwrap by taking the complement of large deltas with respect to the period.
  1638|         0|            0|            0|  0.00%|
  1639|         0|            0|            0|  0.00%|    This unwraps a signal `p` by changing elements which have an absolute
  1640|         0|            0|            0|  0.00%|    difference from their predecessor of more than ``max(discont, period/2)``
  1641|         0|            0|            0|  0.00%|    to their `period`-complementary values.
  1642|         0|            0|            0|  0.00%|
  1643|         0|            0|            0|  0.00%|    For the default case where `period` is :math:`2\pi` and `discont` is
  1644|         0|            0|            0|  0.00%|    :math:`\pi`, this unwraps a radian phase `p` such that adjacent differences
  1645|         0|            0|            0|  0.00%|    are never greater than :math:`\pi` by adding :math:`2k\pi` for some
  1646|         0|            0|            0|  0.00%|    integer :math:`k`.
  1647|         0|            0|            0|  0.00%|
  1648|         0|            0|            0|  0.00%|    Parameters
  1649|         0|            0|            0|  0.00%|    ----------
  1650|         0|            0|            0|  0.00%|    p : array_like
  1651|         0|            0|            0|  0.00%|        Input array.
  1652|         0|            0|            0|  0.00%|    discont : float, optional
  1653|         0|            0|            0|  0.00%|        Maximum discontinuity between values, default is ``period/2``.
  1654|         0|            0|            0|  0.00%|        Values below ``period/2`` are treated as if they were ``period/2``.
  1655|         0|            0|            0|  0.00%|        To have an effect different from the default, `discont` should be
  1656|         0|            0|            0|  0.00%|        larger than ``period/2``.
  1657|         0|            0|            0|  0.00%|    axis : int, optional
  1658|         0|            0|            0|  0.00%|        Axis along which unwrap will operate, default is the last axis.
  1659|         0|            0|            0|  0.00%|    period: float, optional
  1660|         0|            0|            0|  0.00%|        Size of the range over which the input wraps. By default, it is
  1661|         0|            0|            0|  0.00%|        ``2 pi``.
  1662|         0|            0|            0|  0.00%|
  1663|         0|            0|            0|  0.00%|        .. versionadded:: 1.21.0
  1664|         0|            0|            0|  0.00%|
  1665|         0|            0|            0|  0.00%|    Returns
  1666|         0|            0|            0|  0.00%|    -------
  1667|         0|            0|            0|  0.00%|    out : ndarray
  1668|         0|            0|            0|  0.00%|        Output array.
  1669|         0|            0|            0|  0.00%|
  1670|         0|            0|            0|  0.00%|    See Also
  1671|         0|            0|            0|  0.00%|    --------
  1672|         0|            0|            0|  0.00%|    rad2deg, deg2rad
  1673|         0|            0|            0|  0.00%|
  1674|         0|            0|            0|  0.00%|    Notes
  1675|         0|            0|            0|  0.00%|    -----
  1676|         0|            0|            0|  0.00%|    If the discontinuity in `p` is smaller than ``period/2``,
  1677|         0|            0|            0|  0.00%|    but larger than `discont`, no unwrapping is done because taking
  1678|         0|            0|            0|  0.00%|    the complement would only make the discontinuity larger.
  1679|         0|            0|            0|  0.00%|
  1680|         0|            0|            0|  0.00%|    Examples
  1681|         0|            0|            0|  0.00%|    --------
  1682|         0|            0|            0|  0.00%|    >>> phase = np.linspace(0, np.pi, num=5)
  1683|         0|            0|            0|  0.00%|    >>> phase[3:] += np.pi
  1684|         0|            0|            0|  0.00%|    >>> phase
  1685|         0|            0|            0|  0.00%|    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary
  1686|         0|            0|            0|  0.00%|    >>> np.unwrap(phase)
  1687|         0|            0|            0|  0.00%|    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary
  1688|         0|            0|            0|  0.00%|    >>> np.unwrap([0, 1, 2, -1, 0], period=4)
  1689|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4])
  1690|         0|            0|            0|  0.00%|    >>> np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)
  1691|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6, 7, 8, 9])
  1692|         0|            0|            0|  0.00%|    >>> np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)
  1693|         0|            0|            0|  0.00%|    array([2, 3, 4, 5, 6, 7, 8, 9])
  1694|         0|            0|            0|  0.00%|    >>> phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180
  1695|         0|            0|            0|  0.00%|    >>> np.unwrap(phase_deg, period=360)
  1696|         0|            0|            0|  0.00%|    array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,
  1697|         0|            0|            0|  0.00%|            180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,
  1698|         0|            0|            0|  0.00%|            540.])
  1699|         0|            0|            0|  0.00%|    """
  1700|         0|            0|            0|  0.00%|    p = asarray(p)
  1701|         0|            0|            0|  0.00%|    nd = p.ndim
  1702|         0|            0|            0|  0.00%|    dd = diff(p, axis=axis)
  1703|         0|            0|            0|  0.00%|    if discont is None:
  1704|         0|            0|            0|  0.00%|        discont = period/2
  1705|         0|            0|            0|  0.00%|    slice1 = [slice(None, None)]*nd     # full slices
  1706|         0|            0|            0|  0.00%|    slice1[axis] = slice(1, None)
  1707|         0|            0|            0|  0.00%|    slice1 = tuple(slice1)
  1708|         0|            0|            0|  0.00%|    dtype = np.result_type(dd, period)
  1709|         0|            0|            0|  0.00%|    if _nx.issubdtype(dtype, _nx.integer):
  1710|         0|            0|            0|  0.00%|        interval_high, rem = divmod(period, 2)
  1711|         0|            0|            0|  0.00%|        boundary_ambiguous = rem == 0
  1712|         0|            0|            0|  0.00%|    else:
  1713|         0|            0|            0|  0.00%|        interval_high = period / 2
  1714|         0|            0|            0|  0.00%|        boundary_ambiguous = True
  1715|         0|            0|            0|  0.00%|    interval_low = -interval_high
  1716|         0|            0|            0|  0.00%|    ddmod = mod(dd - interval_low, period) + interval_low
  1717|         0|            0|            0|  0.00%|    if boundary_ambiguous:
  1718|         0|            0|            0|  0.00%|        # for `mask = (abs(dd) == period/2)`, the above line made
  1719|         0|            0|            0|  0.00%|        # `ddmod[mask] == -period/2`. correct these such that
  1720|         0|            0|            0|  0.00%|        # `ddmod[mask] == sign(dd[mask])*period/2`.
  1721|         0|            0|            0|  0.00%|        _nx.copyto(ddmod, interval_high,
  1722|         0|            0|            0|  0.00%|                   where=(ddmod == interval_low) & (dd > 0))
  1723|         0|            0|            0|  0.00%|    ph_correct = ddmod - dd
  1724|         0|            0|            0|  0.00%|    _nx.copyto(ph_correct, 0, where=abs(dd) < discont)
  1725|         0|            0|            0|  0.00%|    up = array(p, copy=True, dtype=dtype)
  1726|         0|            0|            0|  0.00%|    up[slice1] = p[slice1] + ph_correct.cumsum(axis)
  1727|         0|            0|            0|  0.00%|    return up
  1728|         0|            0|            0|  0.00%|
  1729|         0|            0|            0|  0.00%|
  1730|         0|            0|            0|  0.00%|def _sort_complex(a):
  1731|         0|            0|            0|  0.00%|    return (a,)
  1732|         0|            0|            0|  0.00%|
  1733|         0|            0|            0|  0.00%|
  1734|         0|            0|            0|  0.00%|@array_function_dispatch(_sort_complex)
  1735|         0|            0|            0|  0.00%|def sort_complex(a):
  1736|         0|            0|            0|  0.00%|    """
  1737|         0|            0|            0|  0.00%|    Sort a complex array using the real part first, then the imaginary part.
  1738|         0|            0|            0|  0.00%|
  1739|         0|            0|            0|  0.00%|    Parameters
  1740|         0|            0|            0|  0.00%|    ----------
  1741|         0|            0|            0|  0.00%|    a : array_like
  1742|         0|            0|            0|  0.00%|        Input array
  1743|         0|            0|            0|  0.00%|
  1744|         0|            0|            0|  0.00%|    Returns
  1745|         0|            0|            0|  0.00%|    -------
  1746|         0|            0|            0|  0.00%|    out : complex ndarray
  1747|         0|            0|            0|  0.00%|        Always returns a sorted complex array.
  1748|         0|            0|            0|  0.00%|
  1749|         0|            0|            0|  0.00%|    Examples
  1750|         0|            0|            0|  0.00%|    --------
  1751|         0|            0|            0|  0.00%|    >>> np.sort_complex([5, 3, 6, 2, 1])
  1752|         0|            0|            0|  0.00%|    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])
  1753|         0|            0|            0|  0.00%|
  1754|         0|            0|            0|  0.00%|    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
  1755|         0|            0|            0|  0.00%|    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])
  1756|         0|            0|            0|  0.00%|
  1757|         0|            0|            0|  0.00%|    """
  1758|         0|            0|            0|  0.00%|    b = array(a, copy=True)
  1759|         0|            0|            0|  0.00%|    b.sort()
  1760|         0|            0|            0|  0.00%|    if not issubclass(b.dtype.type, _nx.complexfloating):
  1761|         0|            0|            0|  0.00%|        if b.dtype.char in 'bhBH':
  1762|         0|            0|            0|  0.00%|            return b.astype('F')
  1763|         0|            0|            0|  0.00%|        elif b.dtype.char == 'g':
  1764|         0|            0|            0|  0.00%|            return b.astype('G')
  1765|         0|            0|            0|  0.00%|        else:
  1766|         0|            0|            0|  0.00%|            return b.astype('D')
  1767|         0|            0|            0|  0.00%|    else:
  1768|         0|            0|            0|  0.00%|        return b
  1769|         0|            0|            0|  0.00%|
  1770|         0|            0|            0|  0.00%|
  1771|         0|            0|            0|  0.00%|def _trim_zeros(filt, trim=None):
  1772|         0|            0|            0|  0.00%|    return (filt,)
  1773|         0|            0|            0|  0.00%|
  1774|         0|            0|            0|  0.00%|
  1775|         0|            0|            0|  0.00%|@array_function_dispatch(_trim_zeros)
  1776|         0|            0|            0|  0.00%|def trim_zeros(filt, trim='fb'):
  1777|         0|            0|            0|  0.00%|    """
  1778|         0|            0|            0|  0.00%|    Trim the leading and/or trailing zeros from a 1-D array or sequence.
  1779|         0|            0|            0|  0.00%|
  1780|         0|            0|            0|  0.00%|    Parameters
  1781|         0|            0|            0|  0.00%|    ----------
  1782|         0|            0|            0|  0.00%|    filt : 1-D array or sequence
  1783|         0|            0|            0|  0.00%|        Input array.
  1784|         0|            0|            0|  0.00%|    trim : str, optional
  1785|         0|            0|            0|  0.00%|        A string with 'f' representing trim from front and 'b' to trim from
  1786|         0|            0|            0|  0.00%|        back. Default is 'fb', trim zeros from both front and back of the
  1787|         0|            0|            0|  0.00%|        array.
  1788|         0|            0|            0|  0.00%|
  1789|         0|            0|            0|  0.00%|    Returns
  1790|         0|            0|            0|  0.00%|    -------
  1791|         0|            0|            0|  0.00%|    trimmed : 1-D array or sequence
  1792|         0|            0|            0|  0.00%|        The result of trimming the input. The input data type is preserved.
  1793|         0|            0|            0|  0.00%|
  1794|         0|            0|            0|  0.00%|    Examples
  1795|         0|            0|            0|  0.00%|    --------
  1796|         0|            0|            0|  0.00%|    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
  1797|         0|            0|            0|  0.00%|    >>> np.trim_zeros(a)
  1798|         0|            0|            0|  0.00%|    array([1, 2, 3, 0, 2, 1])
  1799|         0|            0|            0|  0.00%|
  1800|         0|            0|            0|  0.00%|    >>> np.trim_zeros(a, 'b')
  1801|         0|            0|            0|  0.00%|    array([0, 0, 0, ..., 0, 2, 1])
  1802|         0|            0|            0|  0.00%|
  1803|         0|            0|            0|  0.00%|    The input data type is preserved, list/tuple in means list/tuple out.
  1804|         0|            0|            0|  0.00%|
  1805|         0|            0|            0|  0.00%|    >>> np.trim_zeros([0, 1, 2, 0])
  1806|         0|            0|            0|  0.00%|    [1, 2]
  1807|         0|            0|            0|  0.00%|
  1808|         0|            0|            0|  0.00%|    """
  1809|         0|            0|            0|  0.00%|
  1810|         0|            0|            0|  0.00%|    first = 0
  1811|         0|            0|            0|  0.00%|    trim = trim.upper()
  1812|         0|            0|            0|  0.00%|    if 'F' in trim:
  1813|         0|            0|            0|  0.00%|        for i in filt:
  1814|         0|            0|            0|  0.00%|            if i != 0.:
  1815|         0|            0|            0|  0.00%|                break
  1816|         0|            0|            0|  0.00%|            else:
  1817|         0|            0|            0|  0.00%|                first = first + 1
  1818|         0|            0|            0|  0.00%|    last = len(filt)
  1819|         0|            0|            0|  0.00%|    if 'B' in trim:
  1820|         0|            0|            0|  0.00%|        for i in filt[::-1]:
  1821|         0|            0|            0|  0.00%|            if i != 0.:
  1822|         0|            0|            0|  0.00%|                break
  1823|         0|            0|            0|  0.00%|            else:
  1824|         0|            0|            0|  0.00%|                last = last - 1
  1825|         0|            0|            0|  0.00%|    return filt[first:last]
  1826|         0|            0|            0|  0.00%|
  1827|         0|            0|            0|  0.00%|
  1828|         0|            0|            0|  0.00%|def _extract_dispatcher(condition, arr):
  1829|         0|            0|            0|  0.00%|    return (condition, arr)
  1830|         0|            0|            0|  0.00%|
  1831|         0|            0|            0|  0.00%|
  1832|         0|            0|            0|  0.00%|@array_function_dispatch(_extract_dispatcher)
  1833|         0|            0|            0|  0.00%|def extract(condition, arr):
  1834|         0|            0|            0|  0.00%|    """
  1835|         0|            0|            0|  0.00%|    Return the elements of an array that satisfy some condition.
  1836|         0|            0|            0|  0.00%|
  1837|         0|            0|            0|  0.00%|    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
  1838|         0|            0|            0|  0.00%|    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.
  1839|         0|            0|            0|  0.00%|
  1840|         0|            0|            0|  0.00%|    Note that `place` does the exact opposite of `extract`.
  1841|         0|            0|            0|  0.00%|
  1842|         0|            0|            0|  0.00%|    Parameters
  1843|         0|            0|            0|  0.00%|    ----------
  1844|         0|            0|            0|  0.00%|    condition : array_like
  1845|         0|            0|            0|  0.00%|        An array whose nonzero or True entries indicate the elements of `arr`
  1846|         0|            0|            0|  0.00%|        to extract.
  1847|         0|            0|            0|  0.00%|    arr : array_like
  1848|         0|            0|            0|  0.00%|        Input array of the same size as `condition`.
  1849|         0|            0|            0|  0.00%|
  1850|         0|            0|            0|  0.00%|    Returns
  1851|         0|            0|            0|  0.00%|    -------
  1852|         0|            0|            0|  0.00%|    extract : ndarray
  1853|         0|            0|            0|  0.00%|        Rank 1 array of values from `arr` where `condition` is True.
  1854|         0|            0|            0|  0.00%|
  1855|         0|            0|            0|  0.00%|    See Also
  1856|         0|            0|            0|  0.00%|    --------
  1857|         0|            0|            0|  0.00%|    take, put, copyto, compress, place
  1858|         0|            0|            0|  0.00%|
  1859|         0|            0|            0|  0.00%|    Examples
  1860|         0|            0|            0|  0.00%|    --------
  1861|         0|            0|            0|  0.00%|    >>> arr = np.arange(12).reshape((3, 4))
  1862|         0|            0|            0|  0.00%|    >>> arr
  1863|         0|            0|            0|  0.00%|    array([[ 0,  1,  2,  3],
  1864|         0|            0|            0|  0.00%|           [ 4,  5,  6,  7],
  1865|         0|            0|            0|  0.00%|           [ 8,  9, 10, 11]])
  1866|         0|            0|            0|  0.00%|    >>> condition = np.mod(arr, 3)==0
  1867|         0|            0|            0|  0.00%|    >>> condition
  1868|         0|            0|            0|  0.00%|    array([[ True, False, False,  True],
  1869|         0|            0|            0|  0.00%|           [False, False,  True, False],
  1870|         0|            0|            0|  0.00%|           [False,  True, False, False]])
  1871|         0|            0|            0|  0.00%|    >>> np.extract(condition, arr)
  1872|         0|            0|            0|  0.00%|    array([0, 3, 6, 9])
  1873|         0|            0|            0|  0.00%|
  1874|         0|            0|            0|  0.00%|
  1875|         0|            0|            0|  0.00%|    If `condition` is boolean:
  1876|         0|            0|            0|  0.00%|
  1877|         0|            0|            0|  0.00%|    >>> arr[condition]
  1878|         0|            0|            0|  0.00%|    array([0, 3, 6, 9])
  1879|         0|            0|            0|  0.00%|
  1880|         0|            0|            0|  0.00%|    """
  1881|         0|            0|            0|  0.00%|    return _nx.take(ravel(arr), nonzero(ravel(condition))[0])
  1882|         0|            0|            0|  0.00%|
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|def _place_dispatcher(arr, mask, vals):
  1885|         0|            0|            0|  0.00%|    return (arr, mask, vals)
  1886|         0|            0|            0|  0.00%|
  1887|         0|            0|            0|  0.00%|
  1888|         0|            0|            0|  0.00%|@array_function_dispatch(_place_dispatcher)
  1889|         0|            0|            0|  0.00%|def place(arr, mask, vals):
  1890|         0|            0|            0|  0.00%|    """
  1891|         0|            0|            0|  0.00%|    Change elements of an array based on conditional and input values.
  1892|         0|            0|            0|  0.00%|
  1893|         0|            0|            0|  0.00%|    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that
  1894|         0|            0|            0|  0.00%|    `place` uses the first N elements of `vals`, where N is the number of
  1895|         0|            0|            0|  0.00%|    True values in `mask`, while `copyto` uses the elements where `mask`
  1896|         0|            0|            0|  0.00%|    is True.
  1897|         0|            0|            0|  0.00%|
  1898|         0|            0|            0|  0.00%|    Note that `extract` does the exact opposite of `place`.
  1899|         0|            0|            0|  0.00%|
  1900|         0|            0|            0|  0.00%|    Parameters
  1901|         0|            0|            0|  0.00%|    ----------
  1902|         0|            0|            0|  0.00%|    arr : ndarray
  1903|         0|            0|            0|  0.00%|        Array to put data into.
  1904|         0|            0|            0|  0.00%|    mask : array_like
  1905|         0|            0|            0|  0.00%|        Boolean mask array. Must have the same size as `a`.
  1906|         0|            0|            0|  0.00%|    vals : 1-D sequence
  1907|         0|            0|            0|  0.00%|        Values to put into `a`. Only the first N elements are used, where
  1908|         0|            0|            0|  0.00%|        N is the number of True values in `mask`. If `vals` is smaller
  1909|         0|            0|            0|  0.00%|        than N, it will be repeated, and if elements of `a` are to be masked,
  1910|         0|            0|            0|  0.00%|        this sequence must be non-empty.
  1911|         0|            0|            0|  0.00%|
  1912|         0|            0|            0|  0.00%|    See Also
  1913|         0|            0|            0|  0.00%|    --------
  1914|         0|            0|            0|  0.00%|    copyto, put, take, extract
  1915|         0|            0|            0|  0.00%|
  1916|         0|            0|            0|  0.00%|    Examples
  1917|         0|            0|            0|  0.00%|    --------
  1918|         0|            0|            0|  0.00%|    >>> arr = np.arange(6).reshape(2, 3)
  1919|         0|            0|            0|  0.00%|    >>> np.place(arr, arr>2, [44, 55])
  1920|         0|            0|            0|  0.00%|    >>> arr
  1921|         0|            0|            0|  0.00%|    array([[ 0,  1,  2],
  1922|         0|            0|            0|  0.00%|           [44, 55, 44]])
  1923|         0|            0|            0|  0.00%|
  1924|         0|            0|            0|  0.00%|    """
  1925|         0|            0|            0|  0.00%|    if not isinstance(arr, np.ndarray):
  1926|         0|            0|            0|  0.00%|        raise TypeError("argument 1 must be numpy.ndarray, "
  1927|         0|            0|            0|  0.00%|                        "not {name}".format(name=type(arr).__name__))
  1928|         0|            0|            0|  0.00%|
  1929|         0|            0|            0|  0.00%|    return _insert(arr, mask, vals)
  1930|         0|            0|            0|  0.00%|
  1931|         0|            0|            0|  0.00%|
  1932|         0|            0|            0|  0.00%|def disp(mesg, device=None, linefeed=True):
  1933|         0|            0|            0|  0.00%|    """
  1934|         0|            0|            0|  0.00%|    Display a message on a device.
  1935|         0|            0|            0|  0.00%|
  1936|         0|            0|            0|  0.00%|    Parameters
  1937|         0|            0|            0|  0.00%|    ----------
  1938|         0|            0|            0|  0.00%|    mesg : str
  1939|         0|            0|            0|  0.00%|        Message to display.
  1940|         0|            0|            0|  0.00%|    device : object
  1941|         0|            0|            0|  0.00%|        Device to write message. If None, defaults to ``sys.stdout`` which is
  1942|         0|            0|            0|  0.00%|        very similar to ``print``. `device` needs to have ``write()`` and
  1943|         0|            0|            0|  0.00%|        ``flush()`` methods.
  1944|         0|            0|            0|  0.00%|    linefeed : bool, optional
  1945|         0|            0|            0|  0.00%|        Option whether to print a line feed or not. Defaults to True.
  1946|         0|            0|            0|  0.00%|
  1947|         0|            0|            0|  0.00%|    Raises
  1948|         0|            0|            0|  0.00%|    ------
  1949|         0|            0|            0|  0.00%|    AttributeError
  1950|         0|            0|            0|  0.00%|        If `device` does not have a ``write()`` or ``flush()`` method.
  1951|         0|            0|            0|  0.00%|
  1952|         0|            0|            0|  0.00%|    Examples
  1953|         0|            0|            0|  0.00%|    --------
  1954|         0|            0|            0|  0.00%|    Besides ``sys.stdout``, a file-like object can also be used as it has
  1955|         0|            0|            0|  0.00%|    both required methods:
  1956|         0|            0|            0|  0.00%|
  1957|         0|            0|            0|  0.00%|    >>> from io import StringIO
  1958|         0|            0|            0|  0.00%|    >>> buf = StringIO()
  1959|         0|            0|            0|  0.00%|    >>> np.disp(u'"Display" in a file', device=buf)
  1960|         0|            0|            0|  0.00%|    >>> buf.getvalue()
  1961|         0|            0|            0|  0.00%|    '"Display" in a file\\n'
  1962|         0|            0|            0|  0.00%|
  1963|         0|            0|            0|  0.00%|    """
  1964|         0|            0|            0|  0.00%|    if device is None:
  1965|         0|            0|            0|  0.00%|        device = sys.stdout
  1966|         0|            0|            0|  0.00%|    if linefeed:
  1967|         0|            0|            0|  0.00%|        device.write('%s\n' % mesg)
  1968|         0|            0|            0|  0.00%|    else:
  1969|         0|            0|            0|  0.00%|        device.write('%s' % mesg)
  1970|         0|            0|            0|  0.00%|    device.flush()
  1971|         0|            0|            0|  0.00%|    return
  1972|         0|            0|            0|  0.00%|
  1973|         0|            0|            0|  0.00%|
  1974|         0|            0|            0|  0.00%|# See https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html
  1975|         0|            0|            0|  0.00%|_DIMENSION_NAME = r'\w+'
  1976|         0|            0|            0|  0.00%|_CORE_DIMENSION_LIST = '(?:{0:}(?:,{0:})*)?'.format(_DIMENSION_NAME)
  1977|         0|            0|            0|  0.00%|_ARGUMENT = r'\({}\)'.format(_CORE_DIMENSION_LIST)
  1978|         0|            0|            0|  0.00%|_ARGUMENT_LIST = '{0:}(?:,{0:})*'.format(_ARGUMENT)
  1979|         0|            0|            0|  0.00%|_SIGNATURE = '^{0:}->{0:}$'.format(_ARGUMENT_LIST)
  1980|         0|            0|            0|  0.00%|
  1981|         0|            0|            0|  0.00%|
  1982|         0|            0|            0|  0.00%|def _parse_gufunc_signature(signature):
  1983|         0|            0|            0|  0.00%|    """
  1984|         0|            0|            0|  0.00%|    Parse string signatures for a generalized universal function.
  1985|         0|            0|            0|  0.00%|
  1986|         0|            0|            0|  0.00%|    Arguments
  1987|         0|            0|            0|  0.00%|    ---------
  1988|         0|            0|            0|  0.00%|    signature : string
  1989|         0|            0|            0|  0.00%|        Generalized universal function signature, e.g., ``(m,n),(n,p)->(m,p)``
  1990|         0|            0|            0|  0.00%|        for ``np.matmul``.
  1991|         0|            0|            0|  0.00%|
  1992|         0|            0|            0|  0.00%|    Returns
  1993|         0|            0|            0|  0.00%|    -------
  1994|         0|            0|            0|  0.00%|    Tuple of input and output core dimensions parsed from the signature, each
  1995|         0|            0|            0|  0.00%|    of the form List[Tuple[str, ...]].
  1996|         0|            0|            0|  0.00%|    """
  1997|         0|            0|            0|  0.00%|    signature = re.sub(r'\s+', '', signature)
  1998|         0|            0|            0|  0.00%|
  1999|         0|            0|            0|  0.00%|    if not re.match(_SIGNATURE, signature):
  2000|         0|            0|            0|  0.00%|        raise ValueError(
  2001|         0|            0|            0|  0.00%|            'not a valid gufunc signature: {}'.format(signature))
  2002|         0|            0|            0|  0.00%|    return tuple([tuple(re.findall(_DIMENSION_NAME, arg))
  2003|         0|            0|            0|  0.00%|                  for arg in re.findall(_ARGUMENT, arg_list)]
  2004|         0|            0|            0|  0.00%|                 for arg_list in signature.split('->'))
  2005|         0|            0|            0|  0.00%|
  2006|         0|            0|            0|  0.00%|
  2007|         0|            0|            0|  0.00%|def _update_dim_sizes(dim_sizes, arg, core_dims):
  2008|         0|            0|            0|  0.00%|    """
  2009|         0|            0|            0|  0.00%|    Incrementally check and update core dimension sizes for a single argument.
  2010|         0|            0|            0|  0.00%|
  2011|         0|            0|            0|  0.00%|    Arguments
  2012|         0|            0|            0|  0.00%|    ---------
  2013|         0|            0|            0|  0.00%|    dim_sizes : Dict[str, int]
  2014|         0|            0|            0|  0.00%|        Sizes of existing core dimensions. Will be updated in-place.
  2015|         0|            0|            0|  0.00%|    arg : ndarray
  2016|         0|            0|            0|  0.00%|        Argument to examine.
  2017|         0|            0|            0|  0.00%|    core_dims : Tuple[str, ...]
  2018|         0|            0|            0|  0.00%|        Core dimensions for this argument.
  2019|         0|            0|            0|  0.00%|    """
  2020|         0|            0|            0|  0.00%|    if not core_dims:
  2021|         0|            0|            0|  0.00%|        return
  2022|         0|            0|            0|  0.00%|
  2023|         0|            0|            0|  0.00%|    num_core_dims = len(core_dims)
  2024|         0|            0|            0|  0.00%|    if arg.ndim < num_core_dims:
  2025|         0|            0|            0|  0.00%|        raise ValueError(
  2026|         0|            0|            0|  0.00%|            '%d-dimensional argument does not have enough '
  2027|         0|            0|            0|  0.00%|            'dimensions for all core dimensions %r'
  2028|         0|            0|            0|  0.00%|            % (arg.ndim, core_dims))
  2029|         0|            0|            0|  0.00%|
  2030|         0|            0|            0|  0.00%|    core_shape = arg.shape[-num_core_dims:]
  2031|         0|            0|            0|  0.00%|    for dim, size in zip(core_dims, core_shape):
  2032|         0|            0|            0|  0.00%|        if dim in dim_sizes:
  2033|         0|            0|            0|  0.00%|            if size != dim_sizes[dim]:
  2034|         0|            0|            0|  0.00%|                raise ValueError(
  2035|         0|            0|            0|  0.00%|                    'inconsistent size for core dimension %r: %r vs %r'
  2036|         0|            0|            0|  0.00%|                    % (dim, size, dim_sizes[dim]))
  2037|         0|            0|            0|  0.00%|        else:
  2038|         0|            0|            0|  0.00%|            dim_sizes[dim] = size
  2039|         0|            0|            0|  0.00%|
  2040|         0|            0|            0|  0.00%|
  2041|         0|            0|            0|  0.00%|def _parse_input_dimensions(args, input_core_dims):
  2042|         0|            0|            0|  0.00%|    """
  2043|         0|            0|            0|  0.00%|    Parse broadcast and core dimensions for vectorize with a signature.
  2044|         0|            0|            0|  0.00%|
  2045|         0|            0|            0|  0.00%|    Arguments
  2046|         0|            0|            0|  0.00%|    ---------
  2047|         0|            0|            0|  0.00%|    args : Tuple[ndarray, ...]
  2048|         0|            0|            0|  0.00%|        Tuple of input arguments to examine.
  2049|         0|            0|            0|  0.00%|    input_core_dims : List[Tuple[str, ...]]
  2050|         0|            0|            0|  0.00%|        List of core dimensions corresponding to each input.
  2051|         0|            0|            0|  0.00%|
  2052|         0|            0|            0|  0.00%|    Returns
  2053|         0|            0|            0|  0.00%|    -------
  2054|         0|            0|            0|  0.00%|    broadcast_shape : Tuple[int, ...]
  2055|         0|            0|            0|  0.00%|        Common shape to broadcast all non-core dimensions to.
  2056|         0|            0|            0|  0.00%|    dim_sizes : Dict[str, int]
  2057|         0|            0|            0|  0.00%|        Common sizes for named core dimensions.
  2058|         0|            0|            0|  0.00%|    """
  2059|         0|            0|            0|  0.00%|    broadcast_args = []
  2060|         0|            0|            0|  0.00%|    dim_sizes = {}
  2061|         0|            0|            0|  0.00%|    for arg, core_dims in zip(args, input_core_dims):
  2062|         0|            0|            0|  0.00%|        _update_dim_sizes(dim_sizes, arg, core_dims)
  2063|         0|            0|            0|  0.00%|        ndim = arg.ndim - len(core_dims)
  2064|         0|            0|            0|  0.00%|        dummy_array = np.lib.stride_tricks.as_strided(0, arg.shape[:ndim])
  2065|         0|            0|            0|  0.00%|        broadcast_args.append(dummy_array)
  2066|         0|            0|            0|  0.00%|    broadcast_shape = np.lib.stride_tricks._broadcast_shape(*broadcast_args)
  2067|         0|            0|            0|  0.00%|    return broadcast_shape, dim_sizes
  2068|         0|            0|            0|  0.00%|
  2069|         0|            0|            0|  0.00%|
  2070|         0|            0|            0|  0.00%|def _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims):
  2071|         0|            0|            0|  0.00%|    """Helper for calculating broadcast shapes with core dimensions."""
  2072|         0|            0|            0|  0.00%|    return [broadcast_shape + tuple(dim_sizes[dim] for dim in core_dims)
  2073|         0|            0|            0|  0.00%|            for core_dims in list_of_core_dims]
  2074|         0|            0|            0|  0.00%|
  2075|         0|            0|            0|  0.00%|
  2076|         0|            0|            0|  0.00%|def _create_arrays(broadcast_shape, dim_sizes, list_of_core_dims, dtypes,
  2077|         0|            0|            0|  0.00%|                   results=None):
  2078|         0|            0|            0|  0.00%|    """Helper for creating output arrays in vectorize."""
  2079|         0|            0|            0|  0.00%|    shapes = _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims)
  2080|         0|            0|            0|  0.00%|    if dtypes is None:
  2081|         0|            0|            0|  0.00%|        dtypes = [None] * len(shapes)
  2082|         0|            0|            0|  0.00%|    if results is None:
  2083|         0|            0|            0|  0.00%|        arrays = tuple(np.empty(shape=shape, dtype=dtype)
  2084|         0|            0|            0|  0.00%|                       for shape, dtype in zip(shapes, dtypes))
  2085|         0|            0|            0|  0.00%|    else:
  2086|         0|            0|            0|  0.00%|        arrays = tuple(np.empty_like(result, shape=shape, dtype=dtype)
  2087|         0|            0|            0|  0.00%|                       for result, shape, dtype
  2088|         0|            0|            0|  0.00%|                       in zip(results, shapes, dtypes))
  2089|         0|            0|            0|  0.00%|    return arrays
  2090|         0|            0|            0|  0.00%|
  2091|         0|            0|            0|  0.00%|
  2092|         0|            0|            0|  0.00%|@set_module('numpy')
  2093|         0|            0|            0|  0.00%|class vectorize:
  2094|         0|            0|            0|  0.00%|    """
  2095|         0|            0|            0|  0.00%|    vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,
  2096|         0|            0|            0|  0.00%|              signature=None)
  2097|         0|            0|            0|  0.00%|
  2098|         0|            0|            0|  0.00%|    Generalized function class.
  2099|         0|            0|            0|  0.00%|
  2100|         0|            0|            0|  0.00%|    Define a vectorized function which takes a nested sequence of objects or
  2101|         0|            0|            0|  0.00%|    numpy arrays as inputs and returns a single numpy array or a tuple of numpy
  2102|         0|            0|            0|  0.00%|    arrays. The vectorized function evaluates `pyfunc` over successive tuples
  2103|         0|            0|            0|  0.00%|    of the input arrays like the python map function, except it uses the
  2104|         0|            0|            0|  0.00%|    broadcasting rules of numpy.
  2105|         0|            0|            0|  0.00%|
  2106|         0|            0|            0|  0.00%|    The data type of the output of `vectorized` is determined by calling
  2107|         0|            0|            0|  0.00%|    the function with the first element of the input.  This can be avoided
  2108|         0|            0|            0|  0.00%|    by specifying the `otypes` argument.
  2109|         0|            0|            0|  0.00%|
  2110|         0|            0|            0|  0.00%|    Parameters
  2111|         0|            0|            0|  0.00%|    ----------
  2112|         0|            0|            0|  0.00%|    pyfunc : callable
  2113|         0|            0|            0|  0.00%|        A python function or method.
  2114|         0|            0|            0|  0.00%|    otypes : str or list of dtypes, optional
  2115|         0|            0|            0|  0.00%|        The output data type. It must be specified as either a string of
  2116|         0|            0|            0|  0.00%|        typecode characters or a list of data type specifiers. There should
  2117|         0|            0|            0|  0.00%|        be one data type specifier for each output.
  2118|         0|            0|            0|  0.00%|    doc : str, optional
  2119|         0|            0|            0|  0.00%|        The docstring for the function. If None, the docstring will be the
  2120|         0|            0|            0|  0.00%|        ``pyfunc.__doc__``.
  2121|         0|            0|            0|  0.00%|    excluded : set, optional
  2122|         0|            0|            0|  0.00%|        Set of strings or integers representing the positional or keyword
  2123|         0|            0|            0|  0.00%|        arguments for which the function will not be vectorized.  These will be
  2124|         0|            0|            0|  0.00%|        passed directly to `pyfunc` unmodified.
  2125|         0|            0|            0|  0.00%|
  2126|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2127|         0|            0|            0|  0.00%|
  2128|         0|            0|            0|  0.00%|    cache : bool, optional
  2129|         0|            0|            0|  0.00%|        If `True`, then cache the first function call that determines the number
  2130|         0|            0|            0|  0.00%|        of outputs if `otypes` is not provided.
  2131|         0|            0|            0|  0.00%|
  2132|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2133|         0|            0|            0|  0.00%|
  2134|         0|            0|            0|  0.00%|    signature : string, optional
  2135|         0|            0|            0|  0.00%|        Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for
  2136|         0|            0|            0|  0.00%|        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will
  2137|         0|            0|            0|  0.00%|        be called with (and expected to return) arrays with shapes given by the
  2138|         0|            0|            0|  0.00%|        size of corresponding core dimensions. By default, ``pyfunc`` is
  2139|         0|            0|            0|  0.00%|        assumed to take scalars as input and output.
  2140|         0|            0|            0|  0.00%|
  2141|         0|            0|            0|  0.00%|        .. versionadded:: 1.12.0
  2142|         0|            0|            0|  0.00%|
  2143|         0|            0|            0|  0.00%|    Returns
  2144|         0|            0|            0|  0.00%|    -------
  2145|         0|            0|            0|  0.00%|    vectorized : callable
  2146|         0|            0|            0|  0.00%|        Vectorized function.
  2147|         0|            0|            0|  0.00%|
  2148|         0|            0|            0|  0.00%|    See Also
  2149|         0|            0|            0|  0.00%|    --------
  2150|         0|            0|            0|  0.00%|    frompyfunc : Takes an arbitrary Python function and returns a ufunc
  2151|         0|            0|            0|  0.00%|
  2152|         0|            0|            0|  0.00%|    Notes
  2153|         0|            0|            0|  0.00%|    -----
  2154|         0|            0|            0|  0.00%|    The `vectorize` function is provided primarily for convenience, not for
  2155|         0|            0|            0|  0.00%|    performance. The implementation is essentially a for loop.
  2156|         0|            0|            0|  0.00%|
  2157|         0|            0|            0|  0.00%|    If `otypes` is not specified, then a call to the function with the
  2158|         0|            0|            0|  0.00%|    first argument will be used to determine the number of outputs.  The
  2159|         0|            0|            0|  0.00%|    results of this call will be cached if `cache` is `True` to prevent
  2160|         0|            0|            0|  0.00%|    calling the function twice.  However, to implement the cache, the
  2161|         0|            0|            0|  0.00%|    original function must be wrapped which will slow down subsequent
  2162|         0|            0|            0|  0.00%|    calls, so only do this if your function is expensive.
  2163|         0|            0|            0|  0.00%|
  2164|         0|            0|            0|  0.00%|    The new keyword argument interface and `excluded` argument support
  2165|         0|            0|            0|  0.00%|    further degrades performance.
  2166|         0|            0|            0|  0.00%|
  2167|         0|            0|            0|  0.00%|    References
  2168|         0|            0|            0|  0.00%|    ----------
  2169|         0|            0|            0|  0.00%|    .. [1] :doc:`/reference/c-api/generalized-ufuncs`
  2170|         0|            0|            0|  0.00%|
  2171|         0|            0|            0|  0.00%|    Examples
  2172|         0|            0|            0|  0.00%|    --------
  2173|         0|            0|            0|  0.00%|    >>> def myfunc(a, b):
  2174|         0|            0|            0|  0.00%|    ...     "Return a-b if a>b, otherwise return a+b"
  2175|         0|            0|            0|  0.00%|    ...     if a > b:
  2176|         0|            0|            0|  0.00%|    ...         return a - b
  2177|         0|            0|            0|  0.00%|    ...     else:
  2178|         0|            0|            0|  0.00%|    ...         return a + b
  2179|         0|            0|            0|  0.00%|
  2180|         0|            0|            0|  0.00%|    >>> vfunc = np.vectorize(myfunc)
  2181|         0|            0|            0|  0.00%|    >>> vfunc([1, 2, 3, 4], 2)
  2182|         0|            0|            0|  0.00%|    array([3, 4, 1, 2])
  2183|         0|            0|            0|  0.00%|
  2184|         0|            0|            0|  0.00%|    The docstring is taken from the input function to `vectorize` unless it
  2185|         0|            0|            0|  0.00%|    is specified:
  2186|         0|            0|            0|  0.00%|
  2187|         0|            0|            0|  0.00%|    >>> vfunc.__doc__
  2188|         0|            0|            0|  0.00%|    'Return a-b if a>b, otherwise return a+b'
  2189|         0|            0|            0|  0.00%|    >>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')
  2190|         0|            0|            0|  0.00%|    >>> vfunc.__doc__
  2191|         0|            0|            0|  0.00%|    'Vectorized `myfunc`'
  2192|         0|            0|            0|  0.00%|
  2193|         0|            0|            0|  0.00%|    The output type is determined by evaluating the first element of the input,
  2194|         0|            0|            0|  0.00%|    unless it is specified:
  2195|         0|            0|            0|  0.00%|
  2196|         0|            0|            0|  0.00%|    >>> out = vfunc([1, 2, 3, 4], 2)
  2197|         0|            0|            0|  0.00%|    >>> type(out[0])
  2198|         0|            0|            0|  0.00%|    <class 'numpy.int64'>
  2199|         0|            0|            0|  0.00%|    >>> vfunc = np.vectorize(myfunc, otypes=[float])
  2200|         0|            0|            0|  0.00%|    >>> out = vfunc([1, 2, 3, 4], 2)
  2201|         0|            0|            0|  0.00%|    >>> type(out[0])
  2202|         0|            0|            0|  0.00%|    <class 'numpy.float64'>
  2203|         0|            0|            0|  0.00%|
  2204|         0|            0|            0|  0.00%|    The `excluded` argument can be used to prevent vectorizing over certain
  2205|         0|            0|            0|  0.00%|    arguments.  This can be useful for array-like arguments of a fixed length
  2206|         0|            0|            0|  0.00%|    such as the coefficients for a polynomial as in `polyval`:
  2207|         0|            0|            0|  0.00%|
  2208|         0|            0|            0|  0.00%|    >>> def mypolyval(p, x):
  2209|         0|            0|            0|  0.00%|    ...     _p = list(p)
  2210|         0|            0|            0|  0.00%|    ...     res = _p.pop(0)
  2211|         0|            0|            0|  0.00%|    ...     while _p:
  2212|         0|            0|            0|  0.00%|    ...         res = res*x + _p.pop(0)
  2213|         0|            0|            0|  0.00%|    ...     return res
  2214|         0|            0|            0|  0.00%|    >>> vpolyval = np.vectorize(mypolyval, excluded=['p'])
  2215|         0|            0|            0|  0.00%|    >>> vpolyval(p=[1, 2, 3], x=[0, 1])
  2216|         0|            0|            0|  0.00%|    array([3, 6])
  2217|         0|            0|            0|  0.00%|
  2218|         0|            0|            0|  0.00%|    Positional arguments may also be excluded by specifying their position:
  2219|         0|            0|            0|  0.00%|
  2220|         0|            0|            0|  0.00%|    >>> vpolyval.excluded.add(0)
  2221|         0|            0|            0|  0.00%|    >>> vpolyval([1, 2, 3], x=[0, 1])
  2222|         0|            0|            0|  0.00%|    array([3, 6])
  2223|         0|            0|            0|  0.00%|
  2224|         0|            0|            0|  0.00%|    The `signature` argument allows for vectorizing functions that act on
  2225|         0|            0|            0|  0.00%|    non-scalar arrays of fixed length. For example, you can use it for a
  2226|         0|            0|            0|  0.00%|    vectorized calculation of Pearson correlation coefficient and its p-value:
  2227|         0|            0|            0|  0.00%|
  2228|         0|            0|            0|  0.00%|    >>> import scipy.stats
  2229|         0|            0|            0|  0.00%|    >>> pearsonr = np.vectorize(scipy.stats.pearsonr,
  2230|         0|            0|            0|  0.00%|    ...                 signature='(n),(n)->(),()')
  2231|         0|            0|            0|  0.00%|    >>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])
  2232|         0|            0|            0|  0.00%|    (array([ 1., -1.]), array([ 0.,  0.]))
  2233|         0|            0|            0|  0.00%|
  2234|         0|            0|            0|  0.00%|    Or for a vectorized convolution:
  2235|         0|            0|            0|  0.00%|
  2236|         0|            0|            0|  0.00%|    >>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')
  2237|         0|            0|            0|  0.00%|    >>> convolve(np.eye(4), [1, 2, 1])
  2238|         0|            0|            0|  0.00%|    array([[1., 2., 1., 0., 0., 0.],
  2239|         0|            0|            0|  0.00%|           [0., 1., 2., 1., 0., 0.],
  2240|         0|            0|            0|  0.00%|           [0., 0., 1., 2., 1., 0.],
  2241|         0|            0|            0|  0.00%|           [0., 0., 0., 1., 2., 1.]])
  2242|         0|            0|            0|  0.00%|
  2243|         0|            0|            0|  0.00%|    """
  2244|         0|            0|            0|  0.00%|    def __init__(self, pyfunc, otypes=None, doc=None, excluded=None,
  2245|         0|            0|            0|  0.00%|                 cache=False, signature=None):
  2246|         0|            0|            0|  0.00%|        self.pyfunc = pyfunc
  2247|         0|            0|            0|  0.00%|        self.cache = cache
  2248|         0|            0|            0|  0.00%|        self.signature = signature
  2249|         0|            0|            0|  0.00%|        self._ufunc = {}    # Caching to improve default performance
  2250|         0|            0|            0|  0.00%|
  2251|         0|            0|            0|  0.00%|        if doc is None:
  2252|         0|            0|            0|  0.00%|            self.__doc__ = pyfunc.__doc__
  2253|         0|            0|            0|  0.00%|        else:
  2254|         0|            0|            0|  0.00%|            self.__doc__ = doc
  2255|         0|            0|            0|  0.00%|
  2256|         0|            0|            0|  0.00%|        if isinstance(otypes, str):
  2257|         0|            0|            0|  0.00%|            for char in otypes:
  2258|         0|            0|            0|  0.00%|                if char not in typecodes['All']:
  2259|         0|            0|            0|  0.00%|                    raise ValueError("Invalid otype specified: %s" % (char,))
  2260|         0|            0|            0|  0.00%|        elif iterable(otypes):
  2261|         0|            0|            0|  0.00%|            otypes = ''.join([_nx.dtype(x).char for x in otypes])
  2262|         0|            0|            0|  0.00%|        elif otypes is not None:
  2263|         0|            0|            0|  0.00%|            raise ValueError("Invalid otype specification")
  2264|         0|            0|            0|  0.00%|        self.otypes = otypes
  2265|         0|            0|            0|  0.00%|
  2266|         0|            0|            0|  0.00%|        # Excluded variable support
  2267|         0|            0|            0|  0.00%|        if excluded is None:
  2268|         0|            0|            0|  0.00%|            excluded = set()
  2269|         0|            0|            0|  0.00%|        self.excluded = set(excluded)
  2270|         0|            0|            0|  0.00%|
  2271|         0|            0|            0|  0.00%|        if signature is not None:
  2272|         0|            0|            0|  0.00%|            self._in_and_out_core_dims = _parse_gufunc_signature(signature)
  2273|         0|            0|            0|  0.00%|        else:
  2274|         0|            0|            0|  0.00%|            self._in_and_out_core_dims = None
  2275|         0|            0|            0|  0.00%|
  2276|         0|            0|            0|  0.00%|    def __call__(self, *args, **kwargs):
  2277|         0|            0|            0|  0.00%|        """
  2278|         0|            0|            0|  0.00%|        Return arrays with the results of `pyfunc` broadcast (vectorized) over
  2279|         0|            0|            0|  0.00%|        `args` and `kwargs` not in `excluded`.
  2280|         0|            0|            0|  0.00%|        """
  2281|         0|            0|            0|  0.00%|        excluded = self.excluded
  2282|         0|            0|            0|  0.00%|        if not kwargs and not excluded:
  2283|         0|            0|            0|  0.00%|            func = self.pyfunc
  2284|         0|            0|            0|  0.00%|            vargs = args
  2285|         0|            0|            0|  0.00%|        else:
  2286|         0|            0|            0|  0.00%|            # The wrapper accepts only positional arguments: we use `names` and
  2287|         0|            0|            0|  0.00%|            # `inds` to mutate `the_args` and `kwargs` to pass to the original
  2288|         0|            0|            0|  0.00%|            # function.
  2289|         0|            0|            0|  0.00%|            nargs = len(args)
  2290|         0|            0|            0|  0.00%|
  2291|         0|            0|            0|  0.00%|            names = [_n for _n in kwargs if _n not in excluded]
  2292|         0|            0|            0|  0.00%|            inds = [_i for _i in range(nargs) if _i not in excluded]
  2293|         0|            0|            0|  0.00%|            the_args = list(args)
  2294|         0|            0|            0|  0.00%|
  2295|         0|            0|            0|  0.00%|            def func(*vargs):
  2296|         0|            0|            0|  0.00%|                for _n, _i in enumerate(inds):
  2297|         0|            0|            0|  0.00%|                    the_args[_i] = vargs[_n]
  2298|         0|            0|            0|  0.00%|                kwargs.update(zip(names, vargs[len(inds):]))
  2299|         0|            0|            0|  0.00%|                return self.pyfunc(*the_args, **kwargs)
  2300|         0|            0|            0|  0.00%|
  2301|         0|            0|            0|  0.00%|            vargs = [args[_i] for _i in inds]
  2302|         0|            0|            0|  0.00%|            vargs.extend([kwargs[_n] for _n in names])
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|        return self._vectorize_call(func=func, args=vargs)
  2305|         0|            0|            0|  0.00%|
  2306|         0|            0|            0|  0.00%|    def _get_ufunc_and_otypes(self, func, args):
  2307|         0|            0|            0|  0.00%|        """Return (ufunc, otypes)."""
  2308|         0|            0|            0|  0.00%|        # frompyfunc will fail if args is empty
  2309|         0|            0|            0|  0.00%|        if not args:
  2310|         0|            0|            0|  0.00%|            raise ValueError('args can not be empty')
  2311|         0|            0|            0|  0.00%|
  2312|         0|            0|            0|  0.00%|        if self.otypes is not None:
  2313|         0|            0|            0|  0.00%|            otypes = self.otypes
  2314|         0|            0|            0|  0.00%|
  2315|         0|            0|            0|  0.00%|            # self._ufunc is a dictionary whose keys are the number of
  2316|         0|            0|            0|  0.00%|            # arguments (i.e. len(args)) and whose values are ufuncs created
  2317|         0|            0|            0|  0.00%|            # by frompyfunc. len(args) can be different for different calls if
  2318|         0|            0|            0|  0.00%|            # self.pyfunc has parameters with default values.  We only use the
  2319|         0|            0|            0|  0.00%|            # cache when func is self.pyfunc, which occurs when the call uses
  2320|         0|            0|            0|  0.00%|            # only positional arguments and no arguments are excluded.
  2321|         0|            0|            0|  0.00%|
  2322|         0|            0|            0|  0.00%|            nin = len(args)
  2323|         0|            0|            0|  0.00%|            nout = len(self.otypes)
  2324|         0|            0|            0|  0.00%|            if func is not self.pyfunc or nin not in self._ufunc:
  2325|         0|            0|            0|  0.00%|                ufunc = frompyfunc(func, nin, nout)
  2326|         0|            0|            0|  0.00%|            else:
  2327|         0|            0|            0|  0.00%|                ufunc = None  # We'll get it from self._ufunc
  2328|         0|            0|            0|  0.00%|            if func is self.pyfunc:
  2329|         0|            0|            0|  0.00%|                ufunc = self._ufunc.setdefault(nin, ufunc)
  2330|         0|            0|            0|  0.00%|        else:
  2331|         0|            0|            0|  0.00%|            # Get number of outputs and output types by calling the function on
  2332|         0|            0|            0|  0.00%|            # the first entries of args.  We also cache the result to prevent
  2333|         0|            0|            0|  0.00%|            # the subsequent call when the ufunc is evaluated.
  2334|         0|            0|            0|  0.00%|            # Assumes that ufunc first evaluates the 0th elements in the input
  2335|         0|            0|            0|  0.00%|            # arrays (the input values are not checked to ensure this)
  2336|         0|            0|            0|  0.00%|            args = [asarray(arg) for arg in args]
  2337|         0|            0|            0|  0.00%|            if builtins.any(arg.size == 0 for arg in args):
  2338|         0|            0|            0|  0.00%|                raise ValueError('cannot call `vectorize` on size 0 inputs '
  2339|         0|            0|            0|  0.00%|                                 'unless `otypes` is set')
  2340|         0|            0|            0|  0.00%|
  2341|         0|            0|            0|  0.00%|            inputs = [arg.flat[0] for arg in args]
  2342|         0|            0|            0|  0.00%|            outputs = func(*inputs)
  2343|         0|            0|            0|  0.00%|
  2344|         0|            0|            0|  0.00%|            # Performance note: profiling indicates that -- for simple
  2345|         0|            0|            0|  0.00%|            # functions at least -- this wrapping can almost double the
  2346|         0|            0|            0|  0.00%|            # execution time.
  2347|         0|            0|            0|  0.00%|            # Hence we make it optional.
  2348|         0|            0|            0|  0.00%|            if self.cache:
  2349|         0|            0|            0|  0.00%|                _cache = [outputs]
  2350|         0|            0|            0|  0.00%|
  2351|         0|            0|            0|  0.00%|                def _func(*vargs):
  2352|         0|            0|            0|  0.00%|                    if _cache:
  2353|         0|            0|            0|  0.00%|                        return _cache.pop()
  2354|         0|            0|            0|  0.00%|                    else:
  2355|         0|            0|            0|  0.00%|                        return func(*vargs)
  2356|         0|            0|            0|  0.00%|            else:
  2357|         0|            0|            0|  0.00%|                _func = func
  2358|         0|            0|            0|  0.00%|
  2359|         0|            0|            0|  0.00%|            if isinstance(outputs, tuple):
  2360|         0|            0|            0|  0.00%|                nout = len(outputs)
  2361|         0|            0|            0|  0.00%|            else:
  2362|         0|            0|            0|  0.00%|                nout = 1
  2363|         0|            0|            0|  0.00%|                outputs = (outputs,)
  2364|         0|            0|            0|  0.00%|
  2365|         0|            0|            0|  0.00%|            otypes = ''.join([asarray(outputs[_k]).dtype.char
  2366|         0|            0|            0|  0.00%|                              for _k in range(nout)])
  2367|         0|            0|            0|  0.00%|
  2368|         0|            0|            0|  0.00%|            # Performance note: profiling indicates that creating the ufunc is
  2369|         0|            0|            0|  0.00%|            # not a significant cost compared with wrapping so it seems not
  2370|         0|            0|            0|  0.00%|            # worth trying to cache this.
  2371|         0|            0|            0|  0.00%|            ufunc = frompyfunc(_func, len(args), nout)
  2372|         0|            0|            0|  0.00%|
  2373|         0|            0|            0|  0.00%|        return ufunc, otypes
  2374|         0|            0|            0|  0.00%|
  2375|         0|            0|            0|  0.00%|    def _vectorize_call(self, func, args):
  2376|         0|            0|            0|  0.00%|        """Vectorized call to `func` over positional `args`."""
  2377|         0|            0|            0|  0.00%|        if self.signature is not None:
  2378|         0|            0|            0|  0.00%|            res = self._vectorize_call_with_signature(func, args)
  2379|         0|            0|            0|  0.00%|        elif not args:
  2380|         0|            0|            0|  0.00%|            res = func()
  2381|         0|            0|            0|  0.00%|        else:
  2382|         0|            0|            0|  0.00%|            ufunc, otypes = self._get_ufunc_and_otypes(func=func, args=args)
  2383|         0|            0|            0|  0.00%|
  2384|         0|            0|            0|  0.00%|            # Convert args to object arrays first
  2385|         0|            0|            0|  0.00%|            inputs = [asanyarray(a, dtype=object) for a in args]
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|            outputs = ufunc(*inputs)
  2388|         0|            0|            0|  0.00%|
  2389|         0|            0|            0|  0.00%|            if ufunc.nout == 1:
  2390|         0|            0|            0|  0.00%|                res = asanyarray(outputs, dtype=otypes[0])
  2391|         0|            0|            0|  0.00%|            else:
  2392|         0|            0|            0|  0.00%|                res = tuple([asanyarray(x, dtype=t)
  2393|         0|            0|            0|  0.00%|                             for x, t in zip(outputs, otypes)])
  2394|         0|            0|            0|  0.00%|        return res
  2395|         0|            0|            0|  0.00%|
  2396|         0|            0|            0|  0.00%|    def _vectorize_call_with_signature(self, func, args):
  2397|         0|            0|            0|  0.00%|        """Vectorized call over positional arguments with a signature."""
  2398|         0|            0|            0|  0.00%|        input_core_dims, output_core_dims = self._in_and_out_core_dims
  2399|         0|            0|            0|  0.00%|
  2400|         0|            0|            0|  0.00%|        if len(args) != len(input_core_dims):
  2401|         0|            0|            0|  0.00%|            raise TypeError('wrong number of positional arguments: '
  2402|         0|            0|            0|  0.00%|                            'expected %r, got %r'
  2403|         0|            0|            0|  0.00%|                            % (len(input_core_dims), len(args)))
  2404|         0|            0|            0|  0.00%|        args = tuple(asanyarray(arg) for arg in args)
  2405|         0|            0|            0|  0.00%|
  2406|         0|            0|            0|  0.00%|        broadcast_shape, dim_sizes = _parse_input_dimensions(
  2407|         0|            0|            0|  0.00%|            args, input_core_dims)
  2408|         0|            0|            0|  0.00%|        input_shapes = _calculate_shapes(broadcast_shape, dim_sizes,
  2409|         0|            0|            0|  0.00%|                                         input_core_dims)
  2410|         0|            0|            0|  0.00%|        args = [np.broadcast_to(arg, shape, subok=True)
  2411|         0|            0|            0|  0.00%|                for arg, shape in zip(args, input_shapes)]
  2412|         0|            0|            0|  0.00%|
  2413|         0|            0|            0|  0.00%|        outputs = None
  2414|         0|            0|            0|  0.00%|        otypes = self.otypes
  2415|         0|            0|            0|  0.00%|        nout = len(output_core_dims)
  2416|         0|            0|            0|  0.00%|
  2417|         0|            0|            0|  0.00%|        for index in np.ndindex(*broadcast_shape):
  2418|         0|            0|            0|  0.00%|            results = func(*(arg[index] for arg in args))
  2419|         0|            0|            0|  0.00%|
  2420|         0|            0|            0|  0.00%|            n_results = len(results) if isinstance(results, tuple) else 1
  2421|         0|            0|            0|  0.00%|
  2422|         0|            0|            0|  0.00%|            if nout != n_results:
  2423|         0|            0|            0|  0.00%|                raise ValueError(
  2424|         0|            0|            0|  0.00%|                    'wrong number of outputs from pyfunc: expected %r, got %r'
  2425|         0|            0|            0|  0.00%|                    % (nout, n_results))
  2426|         0|            0|            0|  0.00%|
  2427|         0|            0|            0|  0.00%|            if nout == 1:
  2428|         0|            0|            0|  0.00%|                results = (results,)
  2429|         0|            0|            0|  0.00%|
  2430|         0|            0|            0|  0.00%|            if outputs is None:
  2431|         0|            0|            0|  0.00%|                for result, core_dims in zip(results, output_core_dims):
  2432|         0|            0|            0|  0.00%|                    _update_dim_sizes(dim_sizes, result, core_dims)
  2433|         0|            0|            0|  0.00%|
  2434|         0|            0|            0|  0.00%|                outputs = _create_arrays(broadcast_shape, dim_sizes,
  2435|         0|            0|            0|  0.00%|                                         output_core_dims, otypes, results)
  2436|         0|            0|            0|  0.00%|
  2437|         0|            0|            0|  0.00%|            for output, result in zip(outputs, results):
  2438|         0|            0|            0|  0.00%|                output[index] = result
  2439|         0|            0|            0|  0.00%|
  2440|         0|            0|            0|  0.00%|        if outputs is None:
  2441|         0|            0|            0|  0.00%|            # did not call the function even once
  2442|         0|            0|            0|  0.00%|            if otypes is None:
  2443|         0|            0|            0|  0.00%|                raise ValueError('cannot call `vectorize` on size 0 inputs '
  2444|         0|            0|            0|  0.00%|                                 'unless `otypes` is set')
  2445|         0|            0|            0|  0.00%|            if builtins.any(dim not in dim_sizes
  2446|         0|            0|            0|  0.00%|                            for dims in output_core_dims
  2447|         0|            0|            0|  0.00%|                            for dim in dims):
  2448|         0|            0|            0|  0.00%|                raise ValueError('cannot call `vectorize` with a signature '
  2449|         0|            0|            0|  0.00%|                                 'including new output dimensions on size 0 '
  2450|         0|            0|            0|  0.00%|                                 'inputs')
  2451|         0|            0|            0|  0.00%|            outputs = _create_arrays(broadcast_shape, dim_sizes,
  2452|         0|            0|            0|  0.00%|                                     output_core_dims, otypes)
  2453|         0|            0|            0|  0.00%|
  2454|         0|            0|            0|  0.00%|        return outputs[0] if nout == 1 else outputs
  2455|         0|            0|            0|  0.00%|
  2456|         0|            0|            0|  0.00%|
  2457|         0|            0|            0|  0.00%|def _cov_dispatcher(m, y=None, rowvar=None, bias=None, ddof=None,
  2458|         0|            0|            0|  0.00%|                    fweights=None, aweights=None, *, dtype=None):
  2459|         0|            0|            0|  0.00%|    return (m, y, fweights, aweights)
  2460|         0|            0|            0|  0.00%|
  2461|         0|            0|            0|  0.00%|
  2462|         0|            0|            0|  0.00%|@array_function_dispatch(_cov_dispatcher)
  2463|         0|            0|            0|  0.00%|def cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None,
  2464|         0|            0|            0|  0.00%|        aweights=None, *, dtype=None):
  2465|         0|            0|            0|  0.00%|    """
  2466|         0|            0|            0|  0.00%|    Estimate a covariance matrix, given data and weights.
  2467|         0|            0|            0|  0.00%|
  2468|         0|            0|            0|  0.00%|    Covariance indicates the level to which two variables vary together.
  2469|         0|            0|            0|  0.00%|    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
  2470|         0|            0|            0|  0.00%|    then the covariance matrix element :math:`C_{ij}` is the covariance of
  2471|         0|            0|            0|  0.00%|    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
  2472|         0|            0|            0|  0.00%|    of :math:`x_i`.
  2473|         0|            0|            0|  0.00%|
  2474|         0|            0|            0|  0.00%|    See the notes for an outline of the algorithm.
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|    Parameters
  2477|         0|            0|            0|  0.00%|    ----------
  2478|         0|            0|            0|  0.00%|    m : array_like
  2479|         0|            0|            0|  0.00%|        A 1-D or 2-D array containing multiple variables and observations.
  2480|         0|            0|            0|  0.00%|        Each row of `m` represents a variable, and each column a single
  2481|         0|            0|            0|  0.00%|        observation of all those variables. Also see `rowvar` below.
  2482|         0|            0|            0|  0.00%|    y : array_like, optional
  2483|         0|            0|            0|  0.00%|        An additional set of variables and observations. `y` has the same form
  2484|         0|            0|            0|  0.00%|        as that of `m`.
  2485|         0|            0|            0|  0.00%|    rowvar : bool, optional
  2486|         0|            0|            0|  0.00%|        If `rowvar` is True (default), then each row represents a
  2487|         0|            0|            0|  0.00%|        variable, with observations in the columns. Otherwise, the relationship
  2488|         0|            0|            0|  0.00%|        is transposed: each column represents a variable, while the rows
  2489|         0|            0|            0|  0.00%|        contain observations.
  2490|         0|            0|            0|  0.00%|    bias : bool, optional
  2491|         0|            0|            0|  0.00%|        Default normalization (False) is by ``(N - 1)``, where ``N`` is the
  2492|         0|            0|            0|  0.00%|        number of observations given (unbiased estimate). If `bias` is True,
  2493|         0|            0|            0|  0.00%|        then normalization is by ``N``. These values can be overridden by using
  2494|         0|            0|            0|  0.00%|        the keyword ``ddof`` in numpy versions >= 1.5.
  2495|         0|            0|            0|  0.00%|    ddof : int, optional
  2496|         0|            0|            0|  0.00%|        If not ``None`` the default value implied by `bias` is overridden.
  2497|         0|            0|            0|  0.00%|        Note that ``ddof=1`` will return the unbiased estimate, even if both
  2498|         0|            0|            0|  0.00%|        `fweights` and `aweights` are specified, and ``ddof=0`` will return
  2499|         0|            0|            0|  0.00%|        the simple average. See the notes for the details. The default value
  2500|         0|            0|            0|  0.00%|        is ``None``.
  2501|         0|            0|            0|  0.00%|
  2502|         0|            0|            0|  0.00%|        .. versionadded:: 1.5
  2503|         0|            0|            0|  0.00%|    fweights : array_like, int, optional
  2504|         0|            0|            0|  0.00%|        1-D array of integer frequency weights; the number of times each
  2505|         0|            0|            0|  0.00%|        observation vector should be repeated.
  2506|         0|            0|            0|  0.00%|
  2507|         0|            0|            0|  0.00%|        .. versionadded:: 1.10
  2508|         0|            0|            0|  0.00%|    aweights : array_like, optional
  2509|         0|            0|            0|  0.00%|        1-D array of observation vector weights. These relative weights are
  2510|         0|            0|            0|  0.00%|        typically large for observations considered "important" and smaller for
  2511|         0|            0|            0|  0.00%|        observations considered less "important". If ``ddof=0`` the array of
  2512|         0|            0|            0|  0.00%|        weights can be used to assign probabilities to observation vectors.
  2513|         0|            0|            0|  0.00%|
  2514|         0|            0|            0|  0.00%|        .. versionadded:: 1.10
  2515|         0|            0|            0|  0.00%|    dtype : data-type, optional
  2516|         0|            0|            0|  0.00%|        Data-type of the result. By default, the return data-type will have
  2517|         0|            0|            0|  0.00%|        at least `numpy.float64` precision.
  2518|         0|            0|            0|  0.00%|
  2519|         0|            0|            0|  0.00%|        .. versionadded:: 1.20
  2520|         0|            0|            0|  0.00%|
  2521|         0|            0|            0|  0.00%|    Returns
  2522|         0|            0|            0|  0.00%|    -------
  2523|         0|            0|            0|  0.00%|    out : ndarray
  2524|         0|            0|            0|  0.00%|        The covariance matrix of the variables.
  2525|         0|            0|            0|  0.00%|
  2526|         0|            0|            0|  0.00%|    See Also
  2527|         0|            0|            0|  0.00%|    --------
  2528|         0|            0|            0|  0.00%|    corrcoef : Normalized covariance matrix
  2529|         0|            0|            0|  0.00%|
  2530|         0|            0|            0|  0.00%|    Notes
  2531|         0|            0|            0|  0.00%|    -----
  2532|         0|            0|            0|  0.00%|    Assume that the observations are in the columns of the observation
  2533|         0|            0|            0|  0.00%|    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
  2534|         0|            0|            0|  0.00%|    steps to compute the weighted covariance are as follows::
  2535|         0|            0|            0|  0.00%|
  2536|         0|            0|            0|  0.00%|        >>> m = np.arange(10, dtype=np.float64)
  2537|         0|            0|            0|  0.00%|        >>> f = np.arange(10) * 2
  2538|         0|            0|            0|  0.00%|        >>> a = np.arange(10) ** 2.
  2539|         0|            0|            0|  0.00%|        >>> ddof = 1
  2540|         0|            0|            0|  0.00%|        >>> w = f * a
  2541|         0|            0|            0|  0.00%|        >>> v1 = np.sum(w)
  2542|         0|            0|            0|  0.00%|        >>> v2 = np.sum(w * a)
  2543|         0|            0|            0|  0.00%|        >>> m -= np.sum(m * w, axis=None, keepdims=True) / v1
  2544|         0|            0|            0|  0.00%|        >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)
  2545|         0|            0|            0|  0.00%|
  2546|         0|            0|            0|  0.00%|    Note that when ``a == 1``, the normalization factor
  2547|         0|            0|            0|  0.00%|    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``
  2548|         0|            0|            0|  0.00%|    as it should.
  2549|         0|            0|            0|  0.00%|
  2550|         0|            0|            0|  0.00%|    Examples
  2551|         0|            0|            0|  0.00%|    --------
  2552|         0|            0|            0|  0.00%|    Consider two variables, :math:`x_0` and :math:`x_1`, which
  2553|         0|            0|            0|  0.00%|    correlate perfectly, but in opposite directions:
  2554|         0|            0|            0|  0.00%|
  2555|         0|            0|            0|  0.00%|    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T
  2556|         0|            0|            0|  0.00%|    >>> x
  2557|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  2558|         0|            0|            0|  0.00%|           [2, 1, 0]])
  2559|         0|            0|            0|  0.00%|
  2560|         0|            0|            0|  0.00%|    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
  2561|         0|            0|            0|  0.00%|    matrix shows this clearly:
  2562|         0|            0|            0|  0.00%|
  2563|         0|            0|            0|  0.00%|    >>> np.cov(x)
  2564|         0|            0|            0|  0.00%|    array([[ 1., -1.],
  2565|         0|            0|            0|  0.00%|           [-1.,  1.]])
  2566|         0|            0|            0|  0.00%|
  2567|         0|            0|            0|  0.00%|    Note that element :math:`C_{0,1}`, which shows the correlation between
  2568|         0|            0|            0|  0.00%|    :math:`x_0` and :math:`x_1`, is negative.
  2569|         0|            0|            0|  0.00%|
  2570|         0|            0|            0|  0.00%|    Further, note how `x` and `y` are combined:
  2571|         0|            0|            0|  0.00%|
  2572|         0|            0|            0|  0.00%|    >>> x = [-2.1, -1,  4.3]
  2573|         0|            0|            0|  0.00%|    >>> y = [3,  1.1,  0.12]
  2574|         0|            0|            0|  0.00%|    >>> X = np.stack((x, y), axis=0)
  2575|         0|            0|            0|  0.00%|    >>> np.cov(X)
  2576|         0|            0|            0|  0.00%|    array([[11.71      , -4.286     ], # may vary
  2577|         0|            0|            0|  0.00%|           [-4.286     ,  2.144133]])
  2578|         0|            0|            0|  0.00%|    >>> np.cov(x, y)
  2579|         0|            0|            0|  0.00%|    array([[11.71      , -4.286     ], # may vary
  2580|         0|            0|            0|  0.00%|           [-4.286     ,  2.144133]])
  2581|         0|            0|            0|  0.00%|    >>> np.cov(x)
  2582|         0|            0|            0|  0.00%|    array(11.71)
  2583|         0|            0|            0|  0.00%|
  2584|         0|            0|            0|  0.00%|    """
  2585|         0|            0|            0|  0.00%|    # Check inputs
  2586|         0|            0|            0|  0.00%|    if ddof is not None and ddof != int(ddof):
  2587|         0|            0|            0|  0.00%|        raise ValueError(
  2588|         0|            0|            0|  0.00%|            "ddof must be integer")
  2589|         0|            0|            0|  0.00%|
  2590|         0|            0|            0|  0.00%|    # Handles complex arrays too
  2591|         0|            0|            0|  0.00%|    m = np.asarray(m)
  2592|         0|            0|            0|  0.00%|    if m.ndim > 2:
  2593|         0|            0|            0|  0.00%|        raise ValueError("m has more than 2 dimensions")
  2594|         0|            0|            0|  0.00%|
  2595|         0|            0|            0|  0.00%|    if y is not None:
  2596|         0|            0|            0|  0.00%|        y = np.asarray(y)
  2597|         0|            0|            0|  0.00%|        if y.ndim > 2:
  2598|         0|            0|            0|  0.00%|            raise ValueError("y has more than 2 dimensions")
  2599|         0|            0|            0|  0.00%|
  2600|         0|            0|            0|  0.00%|    if dtype is None:
  2601|         0|            0|            0|  0.00%|        if y is None:
  2602|         0|            0|            0|  0.00%|            dtype = np.result_type(m, np.float64)
  2603|         0|            0|            0|  0.00%|        else:
  2604|         0|            0|            0|  0.00%|            dtype = np.result_type(m, y, np.float64)
  2605|         0|            0|            0|  0.00%|
  2606|         0|            0|            0|  0.00%|    X = array(m, ndmin=2, dtype=dtype)
  2607|         0|            0|            0|  0.00%|    if not rowvar and X.shape[0] != 1:
  2608|         0|            0|            0|  0.00%|        X = X.T
  2609|         0|            0|            0|  0.00%|    if X.shape[0] == 0:
  2610|         0|            0|            0|  0.00%|        return np.array([]).reshape(0, 0)
  2611|         0|            0|            0|  0.00%|    if y is not None:
  2612|         0|            0|            0|  0.00%|        y = array(y, copy=False, ndmin=2, dtype=dtype)
  2613|         0|            0|            0|  0.00%|        if not rowvar and y.shape[0] != 1:
  2614|         0|            0|            0|  0.00%|            y = y.T
  2615|         0|            0|            0|  0.00%|        X = np.concatenate((X, y), axis=0)
  2616|         0|            0|            0|  0.00%|
  2617|         0|            0|            0|  0.00%|    if ddof is None:
  2618|         0|            0|            0|  0.00%|        if bias == 0:
  2619|         0|            0|            0|  0.00%|            ddof = 1
  2620|         0|            0|            0|  0.00%|        else:
  2621|         0|            0|            0|  0.00%|            ddof = 0
  2622|         0|            0|            0|  0.00%|
  2623|         0|            0|            0|  0.00%|    # Get the product of frequencies and weights
  2624|         0|            0|            0|  0.00%|    w = None
  2625|         0|            0|            0|  0.00%|    if fweights is not None:
  2626|         0|            0|            0|  0.00%|        fweights = np.asarray(fweights, dtype=float)
  2627|         0|            0|            0|  0.00%|        if not np.all(fweights == np.around(fweights)):
  2628|         0|            0|            0|  0.00%|            raise TypeError(
  2629|         0|            0|            0|  0.00%|                "fweights must be integer")
  2630|         0|            0|            0|  0.00%|        if fweights.ndim > 1:
  2631|         0|            0|            0|  0.00%|            raise RuntimeError(
  2632|         0|            0|            0|  0.00%|                "cannot handle multidimensional fweights")
  2633|         0|            0|            0|  0.00%|        if fweights.shape[0] != X.shape[1]:
  2634|         0|            0|            0|  0.00%|            raise RuntimeError(
  2635|         0|            0|            0|  0.00%|                "incompatible numbers of samples and fweights")
  2636|         0|            0|            0|  0.00%|        if any(fweights < 0):
  2637|         0|            0|            0|  0.00%|            raise ValueError(
  2638|         0|            0|            0|  0.00%|                "fweights cannot be negative")
  2639|         0|            0|            0|  0.00%|        w = fweights
  2640|         0|            0|            0|  0.00%|    if aweights is not None:
  2641|         0|            0|            0|  0.00%|        aweights = np.asarray(aweights, dtype=float)
  2642|         0|            0|            0|  0.00%|        if aweights.ndim > 1:
  2643|         0|            0|            0|  0.00%|            raise RuntimeError(
  2644|         0|            0|            0|  0.00%|                "cannot handle multidimensional aweights")
  2645|         0|            0|            0|  0.00%|        if aweights.shape[0] != X.shape[1]:
  2646|         0|            0|            0|  0.00%|            raise RuntimeError(
  2647|         0|            0|            0|  0.00%|                "incompatible numbers of samples and aweights")
  2648|         0|            0|            0|  0.00%|        if any(aweights < 0):
  2649|         0|            0|            0|  0.00%|            raise ValueError(
  2650|         0|            0|            0|  0.00%|                "aweights cannot be negative")
  2651|         0|            0|            0|  0.00%|        if w is None:
  2652|         0|            0|            0|  0.00%|            w = aweights
  2653|         0|            0|            0|  0.00%|        else:
  2654|         0|            0|            0|  0.00%|            w *= aweights
  2655|         0|            0|            0|  0.00%|
  2656|         0|            0|            0|  0.00%|    avg, w_sum = average(X, axis=1, weights=w, returned=True)
  2657|         0|            0|            0|  0.00%|    w_sum = w_sum[0]
  2658|         0|            0|            0|  0.00%|
  2659|         0|            0|            0|  0.00%|    # Determine the normalization
  2660|         0|            0|            0|  0.00%|    if w is None:
  2661|         0|            0|            0|  0.00%|        fact = X.shape[1] - ddof
  2662|         0|            0|            0|  0.00%|    elif ddof == 0:
  2663|         0|            0|            0|  0.00%|        fact = w_sum
  2664|         0|            0|            0|  0.00%|    elif aweights is None:
  2665|         0|            0|            0|  0.00%|        fact = w_sum - ddof
  2666|         0|            0|            0|  0.00%|    else:
  2667|         0|            0|            0|  0.00%|        fact = w_sum - ddof*sum(w*aweights)/w_sum
  2668|         0|            0|            0|  0.00%|
  2669|         0|            0|            0|  0.00%|    if fact <= 0:
  2670|         0|            0|            0|  0.00%|        warnings.warn("Degrees of freedom <= 0 for slice",
  2671|         0|            0|            0|  0.00%|                      RuntimeWarning, stacklevel=3)
  2672|         0|            0|            0|  0.00%|        fact = 0.0
  2673|         0|            0|            0|  0.00%|
  2674|         0|            0|            0|  0.00%|    X -= avg[:, None]
  2675|         0|            0|            0|  0.00%|    if w is None:
  2676|         0|            0|            0|  0.00%|        X_T = X.T
  2677|         0|            0|            0|  0.00%|    else:
  2678|         0|            0|            0|  0.00%|        X_T = (X*w).T
  2679|         0|            0|            0|  0.00%|    c = dot(X, X_T.conj())
  2680|         0|            0|            0|  0.00%|    c *= np.true_divide(1, fact)
  2681|         0|            0|            0|  0.00%|    return c.squeeze()
  2682|         0|            0|            0|  0.00%|
  2683|         0|            0|            0|  0.00%|
  2684|         0|            0|            0|  0.00%|def _corrcoef_dispatcher(x, y=None, rowvar=None, bias=None, ddof=None, *,
  2685|         0|            0|            0|  0.00%|                         dtype=None):
  2686|         0|            0|            0|  0.00%|    return (x, y)
  2687|         0|            0|            0|  0.00%|
  2688|         0|            0|            0|  0.00%|
  2689|         0|            0|            0|  0.00%|@array_function_dispatch(_corrcoef_dispatcher)
  2690|         0|            0|            0|  0.00%|def corrcoef(x, y=None, rowvar=True, bias=np._NoValue, ddof=np._NoValue, *,
  2691|         0|            0|            0|  0.00%|             dtype=None):
  2692|         0|            0|            0|  0.00%|    """
  2693|         0|            0|            0|  0.00%|    Return Pearson product-moment correlation coefficients.
  2694|         0|            0|            0|  0.00%|
  2695|         0|            0|            0|  0.00%|    Please refer to the documentation for `cov` for more detail.  The
  2696|         0|            0|            0|  0.00%|    relationship between the correlation coefficient matrix, `R`, and the
  2697|         0|            0|            0|  0.00%|    covariance matrix, `C`, is
  2698|         0|            0|            0|  0.00%|
  2699|         0|            0|            0|  0.00%|    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }
  2700|         0|            0|            0|  0.00%|
  2701|         0|            0|            0|  0.00%|    The values of `R` are between -1 and 1, inclusive.
  2702|         0|            0|            0|  0.00%|
  2703|         0|            0|            0|  0.00%|    Parameters
  2704|         0|            0|            0|  0.00%|    ----------
  2705|         0|            0|            0|  0.00%|    x : array_like
  2706|         0|            0|            0|  0.00%|        A 1-D or 2-D array containing multiple variables and observations.
  2707|         0|            0|            0|  0.00%|        Each row of `x` represents a variable, and each column a single
  2708|         0|            0|            0|  0.00%|        observation of all those variables. Also see `rowvar` below.
  2709|         0|            0|            0|  0.00%|    y : array_like, optional
  2710|         0|            0|            0|  0.00%|        An additional set of variables and observations. `y` has the same
  2711|         0|            0|            0|  0.00%|        shape as `x`.
  2712|         0|            0|            0|  0.00%|    rowvar : bool, optional
  2713|         0|            0|            0|  0.00%|        If `rowvar` is True (default), then each row represents a
  2714|         0|            0|            0|  0.00%|        variable, with observations in the columns. Otherwise, the relationship
  2715|         0|            0|            0|  0.00%|        is transposed: each column represents a variable, while the rows
  2716|         0|            0|            0|  0.00%|        contain observations.
  2717|         0|            0|            0|  0.00%|    bias : _NoValue, optional
  2718|         0|            0|            0|  0.00%|        Has no effect, do not use.
  2719|         0|            0|            0|  0.00%|
  2720|         0|            0|            0|  0.00%|        .. deprecated:: 1.10.0
  2721|         0|            0|            0|  0.00%|    ddof : _NoValue, optional
  2722|         0|            0|            0|  0.00%|        Has no effect, do not use.
  2723|         0|            0|            0|  0.00%|
  2724|         0|            0|            0|  0.00%|        .. deprecated:: 1.10.0
  2725|         0|            0|            0|  0.00%|    dtype : data-type, optional
  2726|         0|            0|            0|  0.00%|        Data-type of the result. By default, the return data-type will have
  2727|         0|            0|            0|  0.00%|        at least `numpy.float64` precision.
  2728|         0|            0|            0|  0.00%|
  2729|         0|            0|            0|  0.00%|        .. versionadded:: 1.20
  2730|         0|            0|            0|  0.00%|
  2731|         0|            0|            0|  0.00%|    Returns
  2732|         0|            0|            0|  0.00%|    -------
  2733|         0|            0|            0|  0.00%|    R : ndarray
  2734|         0|            0|            0|  0.00%|        The correlation coefficient matrix of the variables.
  2735|         0|            0|            0|  0.00%|
  2736|         0|            0|            0|  0.00%|    See Also
  2737|         0|            0|            0|  0.00%|    --------
  2738|         0|            0|            0|  0.00%|    cov : Covariance matrix
  2739|         0|            0|            0|  0.00%|
  2740|         0|            0|            0|  0.00%|    Notes
  2741|         0|            0|            0|  0.00%|    -----
  2742|         0|            0|            0|  0.00%|    Due to floating point rounding the resulting array may not be Hermitian,
  2743|         0|            0|            0|  0.00%|    the diagonal elements may not be 1, and the elements may not satisfy the
  2744|         0|            0|            0|  0.00%|    inequality abs(a) <= 1. The real and imaginary parts are clipped to the
  2745|         0|            0|            0|  0.00%|    interval [-1,  1] in an attempt to improve on that situation but is not
  2746|         0|            0|            0|  0.00%|    much help in the complex case.
  2747|         0|            0|            0|  0.00%|
  2748|         0|            0|            0|  0.00%|    This function accepts but discards arguments `bias` and `ddof`.  This is
  2749|         0|            0|            0|  0.00%|    for backwards compatibility with previous versions of this function.  These
  2750|         0|            0|            0|  0.00%|    arguments had no effect on the return values of the function and can be
  2751|         0|            0|            0|  0.00%|    safely ignored in this and previous versions of numpy.
  2752|         0|            0|            0|  0.00%|
  2753|         0|            0|            0|  0.00%|    Examples
  2754|         0|            0|            0|  0.00%|    --------
  2755|         0|            0|            0|  0.00%|    In this example we generate two random arrays, ``xarr`` and ``yarr``, and
  2756|         0|            0|            0|  0.00%|    compute the row-wise and column-wise Pearson correlation coefficients,
  2757|         0|            0|            0|  0.00%|    ``R``. Since ``rowvar`` is  true by  default, we first find the row-wise
  2758|         0|            0|            0|  0.00%|    Pearson correlation coefficients between the variables of ``xarr``.
  2759|         0|            0|            0|  0.00%|
  2760|         0|            0|            0|  0.00%|    >>> import numpy as np
  2761|         0|            0|            0|  0.00%|    >>> rng = np.random.default_rng(seed=42)
  2762|         0|            0|            0|  0.00%|    >>> xarr = rng.random((3, 3))
  2763|         0|            0|            0|  0.00%|    >>> xarr
  2764|         0|            0|            0|  0.00%|    array([[0.77395605, 0.43887844, 0.85859792],
  2765|         0|            0|            0|  0.00%|           [0.69736803, 0.09417735, 0.97562235],
  2766|         0|            0|            0|  0.00%|           [0.7611397 , 0.78606431, 0.12811363]])
  2767|         0|            0|            0|  0.00%|    >>> R1 = np.corrcoef(xarr)
  2768|         0|            0|            0|  0.00%|    >>> R1
  2769|         0|            0|            0|  0.00%|    array([[ 1.        ,  0.99256089, -0.68080986],
  2770|         0|            0|            0|  0.00%|           [ 0.99256089,  1.        , -0.76492172],
  2771|         0|            0|            0|  0.00%|           [-0.68080986, -0.76492172,  1.        ]])
  2772|         0|            0|            0|  0.00%|
  2773|         0|            0|            0|  0.00%|    If we add another set of variables and observations ``yarr``, we can
  2774|         0|            0|            0|  0.00%|    compute the row-wise Pearson correlation coefficients between the
  2775|         0|            0|            0|  0.00%|    variables in ``xarr`` and ``yarr``.
  2776|         0|            0|            0|  0.00%|
  2777|         0|            0|            0|  0.00%|    >>> yarr = rng.random((3, 3))
  2778|         0|            0|            0|  0.00%|    >>> yarr
  2779|         0|            0|            0|  0.00%|    array([[0.45038594, 0.37079802, 0.92676499],
  2780|         0|            0|            0|  0.00%|           [0.64386512, 0.82276161, 0.4434142 ],
  2781|         0|            0|            0|  0.00%|           [0.22723872, 0.55458479, 0.06381726]])
  2782|         0|            0|            0|  0.00%|    >>> R2 = np.corrcoef(xarr, yarr)
  2783|         0|            0|            0|  0.00%|    >>> R2
  2784|         0|            0|            0|  0.00%|    array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,
  2785|         0|            0|            0|  0.00%|            -0.99004057],
  2786|         0|            0|            0|  0.00%|           [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,
  2787|         0|            0|            0|  0.00%|            -0.99981569],
  2788|         0|            0|            0|  0.00%|           [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,
  2789|         0|            0|            0|  0.00%|             0.77714685],
  2790|         0|            0|            0|  0.00%|           [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,
  2791|         0|            0|            0|  0.00%|            -0.83571711],
  2792|         0|            0|            0|  0.00%|           [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,
  2793|         0|            0|            0|  0.00%|             0.97517215],
  2794|         0|            0|            0|  0.00%|           [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,
  2795|         0|            0|            0|  0.00%|             1.        ]])
  2796|         0|            0|            0|  0.00%|
  2797|         0|            0|            0|  0.00%|    Finally if we use the option ``rowvar=False``, the columns are now
  2798|         0|            0|            0|  0.00%|    being treated as the variables and we will find the column-wise Pearson
  2799|         0|            0|            0|  0.00%|    correlation coefficients between variables in ``xarr`` and ``yarr``.
  2800|         0|            0|            0|  0.00%|
  2801|         0|            0|            0|  0.00%|    >>> R3 = np.corrcoef(xarr, yarr, rowvar=False)
  2802|         0|            0|            0|  0.00%|    >>> R3
  2803|         0|            0|            0|  0.00%|    array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,
  2804|         0|            0|            0|  0.00%|             0.22423734],
  2805|         0|            0|            0|  0.00%|           [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,
  2806|         0|            0|            0|  0.00%|            -0.44069024],
  2807|         0|            0|            0|  0.00%|           [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,
  2808|         0|            0|            0|  0.00%|             0.75137473],
  2809|         0|            0|            0|  0.00%|           [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,
  2810|         0|            0|            0|  0.00%|             0.47536961],
  2811|         0|            0|            0|  0.00%|           [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,
  2812|         0|            0|            0|  0.00%|            -0.46666491],
  2813|         0|            0|            0|  0.00%|           [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,
  2814|         0|            0|            0|  0.00%|             1.        ]])
  2815|         0|            0|            0|  0.00%|
  2816|         0|            0|            0|  0.00%|    """
  2817|         0|            0|            0|  0.00%|    if bias is not np._NoValue or ddof is not np._NoValue:
  2818|         0|            0|            0|  0.00%|        # 2015-03-15, 1.10
  2819|         0|            0|            0|  0.00%|        warnings.warn('bias and ddof have no effect and are deprecated',
  2820|         0|            0|            0|  0.00%|                      DeprecationWarning, stacklevel=3)
  2821|         0|            0|            0|  0.00%|    c = cov(x, y, rowvar, dtype=dtype)
  2822|         0|            0|            0|  0.00%|    try:
  2823|         0|            0|            0|  0.00%|        d = diag(c)
  2824|         0|            0|            0|  0.00%|    except ValueError:
  2825|         0|            0|            0|  0.00%|        # scalar covariance
  2826|         0|            0|            0|  0.00%|        # nan if incorrect value (nan, inf, 0), 1 otherwise
  2827|         0|            0|            0|  0.00%|        return c / c
  2828|         0|            0|            0|  0.00%|    stddev = sqrt(d.real)
  2829|         0|            0|            0|  0.00%|    c /= stddev[:, None]
  2830|         0|            0|            0|  0.00%|    c /= stddev[None, :]
  2831|         0|            0|            0|  0.00%|
  2832|         0|            0|            0|  0.00%|    # Clip real and imaginary parts to [-1, 1].  This does not guarantee
  2833|         0|            0|            0|  0.00%|    # abs(a[i,j]) <= 1 for complex arrays, but is the best we can do without
  2834|         0|            0|            0|  0.00%|    # excessive work.
  2835|         0|            0|            0|  0.00%|    np.clip(c.real, -1, 1, out=c.real)
  2836|         0|            0|            0|  0.00%|    if np.iscomplexobj(c):
  2837|         0|            0|            0|  0.00%|        np.clip(c.imag, -1, 1, out=c.imag)
  2838|         0|            0|            0|  0.00%|
  2839|         0|            0|            0|  0.00%|    return c
  2840|         0|            0|            0|  0.00%|
  2841|         0|            0|            0|  0.00%|
  2842|         0|            0|            0|  0.00%|@set_module('numpy')
  2843|         0|            0|            0|  0.00%|def blackman(M):
  2844|         0|            0|            0|  0.00%|    """
  2845|         0|            0|            0|  0.00%|    Return the Blackman window.
  2846|         0|            0|            0|  0.00%|
  2847|         0|            0|            0|  0.00%|    The Blackman window is a taper formed by using the first three
  2848|         0|            0|            0|  0.00%|    terms of a summation of cosines. It was designed to have close to the
  2849|         0|            0|            0|  0.00%|    minimal leakage possible.  It is close to optimal, only slightly worse
  2850|         0|            0|            0|  0.00%|    than a Kaiser window.
  2851|         0|            0|            0|  0.00%|
  2852|         0|            0|            0|  0.00%|    Parameters
  2853|         0|            0|            0|  0.00%|    ----------
  2854|         0|            0|            0|  0.00%|    M : int
  2855|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an empty
  2856|         0|            0|            0|  0.00%|        array is returned.
  2857|         0|            0|            0|  0.00%|
  2858|         0|            0|            0|  0.00%|    Returns
  2859|         0|            0|            0|  0.00%|    -------
  2860|         0|            0|            0|  0.00%|    out : ndarray
  2861|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value one
  2862|         0|            0|            0|  0.00%|        appears only if the number of samples is odd).
  2863|         0|            0|            0|  0.00%|
  2864|         0|            0|            0|  0.00%|    See Also
  2865|         0|            0|            0|  0.00%|    --------
  2866|         0|            0|            0|  0.00%|    bartlett, hamming, hanning, kaiser
  2867|         0|            0|            0|  0.00%|
  2868|         0|            0|            0|  0.00%|    Notes
  2869|         0|            0|            0|  0.00%|    -----
  2870|         0|            0|            0|  0.00%|    The Blackman window is defined as
  2871|         0|            0|            0|  0.00%|
  2872|         0|            0|            0|  0.00%|    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)
  2873|         0|            0|            0|  0.00%|
  2874|         0|            0|            0|  0.00%|    Most references to the Blackman window come from the signal processing
  2875|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  2876|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  2877|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  2878|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function. It is known as a
  2879|         0|            0|            0|  0.00%|    "near optimal" tapering function, almost as good (by some measures)
  2880|         0|            0|            0|  0.00%|    as the kaiser window.
  2881|         0|            0|            0|  0.00%|
  2882|         0|            0|            0|  0.00%|    References
  2883|         0|            0|            0|  0.00%|    ----------
  2884|         0|            0|            0|  0.00%|    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
  2885|         0|            0|            0|  0.00%|    Dover Publications, New York.
  2886|         0|            0|            0|  0.00%|
  2887|         0|            0|            0|  0.00%|    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
  2888|         0|            0|            0|  0.00%|    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.
  2889|         0|            0|            0|  0.00%|
  2890|         0|            0|            0|  0.00%|    Examples
  2891|         0|            0|            0|  0.00%|    --------
  2892|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  2893|         0|            0|            0|  0.00%|    >>> np.blackman(12)
  2894|         0|            0|            0|  0.00%|    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary
  2895|         0|            0|            0|  0.00%|            4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
  2896|         0|            0|            0|  0.00%|            9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
  2897|         0|            0|            0|  0.00%|            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])
  2898|         0|            0|            0|  0.00%|
  2899|         0|            0|            0|  0.00%|    Plot the window and the frequency response:
  2900|         0|            0|            0|  0.00%|
  2901|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  2902|         0|            0|            0|  0.00%|    >>> window = np.blackman(51)
  2903|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  2904|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2905|         0|            0|            0|  0.00%|    >>> plt.title("Blackman window")
  2906|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Blackman window')
  2907|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  2908|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  2909|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  2910|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  2911|         0|            0|            0|  0.00%|    >>> plt.show()
  2912|         0|            0|            0|  0.00%|
  2913|         0|            0|            0|  0.00%|    >>> plt.figure()
  2914|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  2915|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  2916|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  2917|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  2918|         0|            0|            0|  0.00%|    >>> with np.errstate(divide='ignore', invalid='ignore'):
  2919|         0|            0|            0|  0.00%|    ...     response = 20 * np.log10(mag)
  2920|         0|            0|            0|  0.00%|    ...
  2921|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  2922|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  2923|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2924|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Blackman window")
  2925|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Blackman window')
  2926|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  2927|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  2928|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  2929|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  2930|         0|            0|            0|  0.00%|    >>> _ = plt.axis('tight')
  2931|         0|            0|            0|  0.00%|    >>> plt.show()
  2932|         0|            0|            0|  0.00%|
  2933|         0|            0|            0|  0.00%|    """
  2934|         0|            0|            0|  0.00%|    if M < 1:
  2935|         0|            0|            0|  0.00%|        return array([], dtype=np.result_type(M, 0.0))
  2936|         0|            0|            0|  0.00%|    if M == 1:
  2937|         0|            0|            0|  0.00%|        return ones(1, dtype=np.result_type(M, 0.0))
  2938|         0|            0|            0|  0.00%|    n = arange(1-M, M, 2)
  2939|         0|            0|            0|  0.00%|    return 0.42 + 0.5*cos(pi*n/(M-1)) + 0.08*cos(2.0*pi*n/(M-1))
  2940|         0|            0|            0|  0.00%|
  2941|         0|            0|            0|  0.00%|
  2942|         0|            0|            0|  0.00%|@set_module('numpy')
  2943|         0|            0|            0|  0.00%|def bartlett(M):
  2944|         0|            0|            0|  0.00%|    """
  2945|         0|            0|            0|  0.00%|    Return the Bartlett window.
  2946|         0|            0|            0|  0.00%|
  2947|         0|            0|            0|  0.00%|    The Bartlett window is very similar to a triangular window, except
  2948|         0|            0|            0|  0.00%|    that the end points are at zero.  It is often used in signal
  2949|         0|            0|            0|  0.00%|    processing for tapering a signal, without generating too much
  2950|         0|            0|            0|  0.00%|    ripple in the frequency domain.
  2951|         0|            0|            0|  0.00%|
  2952|         0|            0|            0|  0.00%|    Parameters
  2953|         0|            0|            0|  0.00%|    ----------
  2954|         0|            0|            0|  0.00%|    M : int
  2955|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  2956|         0|            0|            0|  0.00%|        empty array is returned.
  2957|         0|            0|            0|  0.00%|
  2958|         0|            0|            0|  0.00%|    Returns
  2959|         0|            0|            0|  0.00%|    -------
  2960|         0|            0|            0|  0.00%|    out : array
  2961|         0|            0|            0|  0.00%|        The triangular window, with the maximum value normalized to one
  2962|         0|            0|            0|  0.00%|        (the value one appears only if the number of samples is odd), with
  2963|         0|            0|            0|  0.00%|        the first and last samples equal to zero.
  2964|         0|            0|            0|  0.00%|
  2965|         0|            0|            0|  0.00%|    See Also
  2966|         0|            0|            0|  0.00%|    --------
  2967|         0|            0|            0|  0.00%|    blackman, hamming, hanning, kaiser
  2968|         0|            0|            0|  0.00%|
  2969|         0|            0|            0|  0.00%|    Notes
  2970|         0|            0|            0|  0.00%|    -----
  2971|         0|            0|            0|  0.00%|    The Bartlett window is defined as
  2972|         0|            0|            0|  0.00%|
  2973|         0|            0|            0|  0.00%|    .. math:: w(n) = \\frac{2}{M-1} \\left(
  2974|         0|            0|            0|  0.00%|              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|
  2975|         0|            0|            0|  0.00%|              \\right)
  2976|         0|            0|            0|  0.00%|
  2977|         0|            0|            0|  0.00%|    Most references to the Bartlett window come from the signal
  2978|         0|            0|            0|  0.00%|    processing literature, where it is used as one of many windowing
  2979|         0|            0|            0|  0.00%|    functions for smoothing values.  Note that convolution with this
  2980|         0|            0|            0|  0.00%|    window produces linear interpolation.  It is also known as an
  2981|         0|            0|            0|  0.00%|    apodization (which means"removing the foot", i.e. smoothing
  2982|         0|            0|            0|  0.00%|    discontinuities at the beginning and end of the sampled signal) or
  2983|         0|            0|            0|  0.00%|    tapering function. The fourier transform of the Bartlett is the product
  2984|         0|            0|            0|  0.00%|    of two sinc functions.
  2985|         0|            0|            0|  0.00%|    Note the excellent discussion in Kanasewich.
  2986|         0|            0|            0|  0.00%|
  2987|         0|            0|            0|  0.00%|    References
  2988|         0|            0|            0|  0.00%|    ----------
  2989|         0|            0|            0|  0.00%|    .. [1] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
  2990|         0|            0|            0|  0.00%|           Biometrika 37, 1-16, 1950.
  2991|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
  2992|         0|            0|            0|  0.00%|           The University of Alberta Press, 1975, pp. 109-110.
  2993|         0|            0|            0|  0.00%|    .. [3] A.V. Oppenheim and R.W. Schafer, "Discrete-Time Signal
  2994|         0|            0|            0|  0.00%|           Processing", Prentice-Hall, 1999, pp. 468-471.
  2995|         0|            0|            0|  0.00%|    .. [4] Wikipedia, "Window function",
  2996|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  2997|         0|            0|            0|  0.00%|    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
  2998|         0|            0|            0|  0.00%|           "Numerical Recipes", Cambridge University Press, 1986, page 429.
  2999|         0|            0|            0|  0.00%|
  3000|         0|            0|            0|  0.00%|    Examples
  3001|         0|            0|            0|  0.00%|    --------
  3002|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  3003|         0|            0|            0|  0.00%|    >>> np.bartlett(12)
  3004|         0|            0|            0|  0.00%|    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary
  3005|         0|            0|            0|  0.00%|            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
  3006|         0|            0|            0|  0.00%|            0.18181818,  0.        ])
  3007|         0|            0|            0|  0.00%|
  3008|         0|            0|            0|  0.00%|    Plot the window and its frequency response (requires SciPy and matplotlib):
  3009|         0|            0|            0|  0.00%|
  3010|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  3011|         0|            0|            0|  0.00%|    >>> window = np.bartlett(51)
  3012|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  3013|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3014|         0|            0|            0|  0.00%|    >>> plt.title("Bartlett window")
  3015|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Bartlett window')
  3016|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  3017|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  3018|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  3019|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  3020|         0|            0|            0|  0.00%|    >>> plt.show()
  3021|         0|            0|            0|  0.00%|
  3022|         0|            0|            0|  0.00%|    >>> plt.figure()
  3023|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  3024|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  3025|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  3026|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  3027|         0|            0|            0|  0.00%|    >>> with np.errstate(divide='ignore', invalid='ignore'):
  3028|         0|            0|            0|  0.00%|    ...     response = 20 * np.log10(mag)
  3029|         0|            0|            0|  0.00%|    ...
  3030|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  3031|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  3032|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3033|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Bartlett window")
  3034|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Bartlett window')
  3035|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  3036|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  3037|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  3038|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  3039|         0|            0|            0|  0.00%|    >>> _ = plt.axis('tight')
  3040|         0|            0|            0|  0.00%|    >>> plt.show()
  3041|         0|            0|            0|  0.00%|
  3042|         0|            0|            0|  0.00%|    """
  3043|         0|            0|            0|  0.00%|    if M < 1:
  3044|         0|            0|            0|  0.00%|        return array([], dtype=np.result_type(M, 0.0))
  3045|         0|            0|            0|  0.00%|    if M == 1:
  3046|         0|            0|            0|  0.00%|        return ones(1, dtype=np.result_type(M, 0.0))
  3047|         0|            0|            0|  0.00%|    n = arange(1-M, M, 2)
  3048|         0|            0|            0|  0.00%|    return where(less_equal(n, 0), 1 + n/(M-1), 1 - n/(M-1))
  3049|         0|            0|            0|  0.00%|
  3050|         0|            0|            0|  0.00%|
  3051|         0|            0|            0|  0.00%|@set_module('numpy')
  3052|         0|            0|            0|  0.00%|def hanning(M):
  3053|         0|            0|            0|  0.00%|    """
  3054|         0|            0|            0|  0.00%|    Return the Hanning window.
  3055|         0|            0|            0|  0.00%|
  3056|         0|            0|            0|  0.00%|    The Hanning window is a taper formed by using a weighted cosine.
  3057|         0|            0|            0|  0.00%|
  3058|         0|            0|            0|  0.00%|    Parameters
  3059|         0|            0|            0|  0.00%|    ----------
  3060|         0|            0|            0|  0.00%|    M : int
  3061|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  3062|         0|            0|            0|  0.00%|        empty array is returned.
  3063|         0|            0|            0|  0.00%|
  3064|         0|            0|            0|  0.00%|    Returns
  3065|         0|            0|            0|  0.00%|    -------
  3066|         0|            0|            0|  0.00%|    out : ndarray, shape(M,)
  3067|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value
  3068|         0|            0|            0|  0.00%|        one appears only if `M` is odd).
  3069|         0|            0|            0|  0.00%|
  3070|         0|            0|            0|  0.00%|    See Also
  3071|         0|            0|            0|  0.00%|    --------
  3072|         0|            0|            0|  0.00%|    bartlett, blackman, hamming, kaiser
  3073|         0|            0|            0|  0.00%|
  3074|         0|            0|            0|  0.00%|    Notes
  3075|         0|            0|            0|  0.00%|    -----
  3076|         0|            0|            0|  0.00%|    The Hanning window is defined as
  3077|         0|            0|            0|  0.00%|
  3078|         0|            0|            0|  0.00%|    .. math::  w(n) = 0.5 - 0.5cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
  3079|         0|            0|            0|  0.00%|               \\qquad 0 \\leq n \\leq M-1
  3080|         0|            0|            0|  0.00%|
  3081|         0|            0|            0|  0.00%|    The Hanning was named for Julius von Hann, an Austrian meteorologist.
  3082|         0|            0|            0|  0.00%|    It is also known as the Cosine Bell. Some authors prefer that it be
  3083|         0|            0|            0|  0.00%|    called a Hann window, to help avoid confusion with the very similar
  3084|         0|            0|            0|  0.00%|    Hamming window.
  3085|         0|            0|            0|  0.00%|
  3086|         0|            0|            0|  0.00%|    Most references to the Hanning window come from the signal processing
  3087|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  3088|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  3089|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  3090|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function.
  3091|         0|            0|            0|  0.00%|
  3092|         0|            0|            0|  0.00%|    References
  3093|         0|            0|            0|  0.00%|    ----------
  3094|         0|            0|            0|  0.00%|    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
  3095|         0|            0|            0|  0.00%|           spectra, Dover Publications, New York.
  3096|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
  3097|         0|            0|            0|  0.00%|           The University of Alberta Press, 1975, pp. 106-108.
  3098|         0|            0|            0|  0.00%|    .. [3] Wikipedia, "Window function",
  3099|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  3100|         0|            0|            0|  0.00%|    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
  3101|         0|            0|            0|  0.00%|           "Numerical Recipes", Cambridge University Press, 1986, page 425.
  3102|         0|            0|            0|  0.00%|
  3103|         0|            0|            0|  0.00%|    Examples
  3104|         0|            0|            0|  0.00%|    --------
  3105|         0|            0|            0|  0.00%|    >>> np.hanning(12)
  3106|         0|            0|            0|  0.00%|    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,
  3107|         0|            0|            0|  0.00%|           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,
  3108|         0|            0|            0|  0.00%|           0.07937323, 0.        ])
  3109|         0|            0|            0|  0.00%|
  3110|         0|            0|            0|  0.00%|    Plot the window and its frequency response:
  3111|         0|            0|            0|  0.00%|
  3112|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  3113|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  3114|         0|            0|            0|  0.00%|    >>> window = np.hanning(51)
  3115|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  3116|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3117|         0|            0|            0|  0.00%|    >>> plt.title("Hann window")
  3118|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Hann window')
  3119|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  3120|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  3121|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  3122|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  3123|         0|            0|            0|  0.00%|    >>> plt.show()
  3124|         0|            0|            0|  0.00%|
  3125|         0|            0|            0|  0.00%|    >>> plt.figure()
  3126|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  3127|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  3128|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  3129|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  3130|         0|            0|            0|  0.00%|    >>> with np.errstate(divide='ignore', invalid='ignore'):
  3131|         0|            0|            0|  0.00%|    ...     response = 20 * np.log10(mag)
  3132|         0|            0|            0|  0.00%|    ...
  3133|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  3134|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  3135|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3136|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of the Hann window")
  3137|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of the Hann window')
  3138|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  3139|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  3140|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  3141|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  3142|         0|            0|            0|  0.00%|    >>> plt.axis('tight')
  3143|         0|            0|            0|  0.00%|    ...
  3144|         0|            0|            0|  0.00%|    >>> plt.show()
  3145|         0|            0|            0|  0.00%|
  3146|         0|            0|            0|  0.00%|    """
  3147|         0|            0|            0|  0.00%|    if M < 1:
  3148|         0|            0|            0|  0.00%|        return array([], dtype=np.result_type(M, 0.0))
  3149|         0|            0|            0|  0.00%|    if M == 1:
  3150|         0|            0|            0|  0.00%|        return ones(1, dtype=np.result_type(M, 0.0))
  3151|         0|            0|            0|  0.00%|    n = arange(1-M, M, 2)
  3152|         0|            0|            0|  0.00%|    return 0.5 + 0.5*cos(pi*n/(M-1))
  3153|         0|            0|            0|  0.00%|
  3154|         0|            0|            0|  0.00%|
  3155|         0|            0|            0|  0.00%|@set_module('numpy')
  3156|         0|            0|            0|  0.00%|def hamming(M):
  3157|         0|            0|            0|  0.00%|    """
  3158|         0|            0|            0|  0.00%|    Return the Hamming window.
  3159|         0|            0|            0|  0.00%|
  3160|         0|            0|            0|  0.00%|    The Hamming window is a taper formed by using a weighted cosine.
  3161|         0|            0|            0|  0.00%|
  3162|         0|            0|            0|  0.00%|    Parameters
  3163|         0|            0|            0|  0.00%|    ----------
  3164|         0|            0|            0|  0.00%|    M : int
  3165|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  3166|         0|            0|            0|  0.00%|        empty array is returned.
  3167|         0|            0|            0|  0.00%|
  3168|         0|            0|            0|  0.00%|    Returns
  3169|         0|            0|            0|  0.00%|    -------
  3170|         0|            0|            0|  0.00%|    out : ndarray
  3171|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value
  3172|         0|            0|            0|  0.00%|        one appears only if the number of samples is odd).
  3173|         0|            0|            0|  0.00%|
  3174|         0|            0|            0|  0.00%|    See Also
  3175|         0|            0|            0|  0.00%|    --------
  3176|         0|            0|            0|  0.00%|    bartlett, blackman, hanning, kaiser
  3177|         0|            0|            0|  0.00%|
  3178|         0|            0|            0|  0.00%|    Notes
  3179|         0|            0|            0|  0.00%|    -----
  3180|         0|            0|            0|  0.00%|    The Hamming window is defined as
  3181|         0|            0|            0|  0.00%|
  3182|         0|            0|            0|  0.00%|    .. math::  w(n) = 0.54 - 0.46cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
  3183|         0|            0|            0|  0.00%|               \\qquad 0 \\leq n \\leq M-1
  3184|         0|            0|            0|  0.00%|
  3185|         0|            0|            0|  0.00%|    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
  3186|         0|            0|            0|  0.00%|    and is described in Blackman and Tukey. It was recommended for
  3187|         0|            0|            0|  0.00%|    smoothing the truncated autocovariance function in the time domain.
  3188|         0|            0|            0|  0.00%|    Most references to the Hamming window come from the signal processing
  3189|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  3190|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  3191|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  3192|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function.
  3193|         0|            0|            0|  0.00%|
  3194|         0|            0|            0|  0.00%|    References
  3195|         0|            0|            0|  0.00%|    ----------
  3196|         0|            0|            0|  0.00%|    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
  3197|         0|            0|            0|  0.00%|           spectra, Dover Publications, New York.
  3198|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
  3199|         0|            0|            0|  0.00%|           University of Alberta Press, 1975, pp. 109-110.
  3200|         0|            0|            0|  0.00%|    .. [3] Wikipedia, "Window function",
  3201|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  3202|         0|            0|            0|  0.00%|    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
  3203|         0|            0|            0|  0.00%|           "Numerical Recipes", Cambridge University Press, 1986, page 425.
  3204|         0|            0|            0|  0.00%|
  3205|         0|            0|            0|  0.00%|    Examples
  3206|         0|            0|            0|  0.00%|    --------
  3207|         0|            0|            0|  0.00%|    >>> np.hamming(12)
  3208|         0|            0|            0|  0.00%|    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary
  3209|         0|            0|            0|  0.00%|            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
  3210|         0|            0|            0|  0.00%|            0.15302337,  0.08      ])
  3211|         0|            0|            0|  0.00%|
  3212|         0|            0|            0|  0.00%|    Plot the window and the frequency response:
  3213|         0|            0|            0|  0.00%|
  3214|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  3215|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  3216|         0|            0|            0|  0.00%|    >>> window = np.hamming(51)
  3217|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  3218|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3219|         0|            0|            0|  0.00%|    >>> plt.title("Hamming window")
  3220|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Hamming window')
  3221|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  3222|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  3223|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  3224|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  3225|         0|            0|            0|  0.00%|    >>> plt.show()
  3226|         0|            0|            0|  0.00%|
  3227|         0|            0|            0|  0.00%|    >>> plt.figure()
  3228|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  3229|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  3230|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  3231|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  3232|         0|            0|            0|  0.00%|    >>> response = 20 * np.log10(mag)
  3233|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  3234|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  3235|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3236|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Hamming window")
  3237|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Hamming window')
  3238|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  3239|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  3240|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  3241|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  3242|         0|            0|            0|  0.00%|    >>> plt.axis('tight')
  3243|         0|            0|            0|  0.00%|    ...
  3244|         0|            0|            0|  0.00%|    >>> plt.show()
  3245|         0|            0|            0|  0.00%|
  3246|         0|            0|            0|  0.00%|    """
  3247|         0|            0|            0|  0.00%|    if M < 1:
  3248|         0|            0|            0|  0.00%|        return array([], dtype=np.result_type(M, 0.0))
  3249|         0|            0|            0|  0.00%|    if M == 1:
  3250|         0|            0|            0|  0.00%|        return ones(1, dtype=np.result_type(M, 0.0))
  3251|         0|            0|            0|  0.00%|    n = arange(1-M, M, 2)
  3252|         0|            0|            0|  0.00%|    return 0.54 + 0.46*cos(pi*n/(M-1))
  3253|         0|            0|            0|  0.00%|
  3254|         0|            0|            0|  0.00%|
  3255|         0|            0|            0|  0.00%|## Code from cephes for i0
  3256|         0|            0|            0|  0.00%|
  3257|         0|            0|            0|  0.00%|_i0A = [
  3258|         0|            0|            0|  0.00%|    -4.41534164647933937950E-18,
  3259|         0|            0|            0|  0.00%|    3.33079451882223809783E-17,
  3260|         0|            0|            0|  0.00%|    -2.43127984654795469359E-16,
  3261|         0|            0|            0|  0.00%|    1.71539128555513303061E-15,
  3262|         0|            0|            0|  0.00%|    -1.16853328779934516808E-14,
  3263|         0|            0|            0|  0.00%|    7.67618549860493561688E-14,
  3264|         0|            0|            0|  0.00%|    -4.85644678311192946090E-13,
  3265|         0|            0|            0|  0.00%|    2.95505266312963983461E-12,
  3266|         0|            0|            0|  0.00%|    -1.72682629144155570723E-11,
  3267|         0|            0|            0|  0.00%|    9.67580903537323691224E-11,
  3268|         0|            0|            0|  0.00%|    -5.18979560163526290666E-10,
  3269|         0|            0|            0|  0.00%|    2.65982372468238665035E-9,
  3270|         0|            0|            0|  0.00%|    -1.30002500998624804212E-8,
  3271|         0|            0|            0|  0.00%|    6.04699502254191894932E-8,
  3272|         0|            0|            0|  0.00%|    -2.67079385394061173391E-7,
  3273|         0|            0|            0|  0.00%|    1.11738753912010371815E-6,
  3274|         0|            0|            0|  0.00%|    -4.41673835845875056359E-6,
  3275|         0|            0|            0|  0.00%|    1.64484480707288970893E-5,
  3276|         0|            0|            0|  0.00%|    -5.75419501008210370398E-5,
  3277|         0|            0|            0|  0.00%|    1.88502885095841655729E-4,
  3278|         0|            0|            0|  0.00%|    -5.76375574538582365885E-4,
  3279|         0|            0|            0|  0.00%|    1.63947561694133579842E-3,
  3280|         0|            0|            0|  0.00%|    -4.32430999505057594430E-3,
  3281|         0|            0|            0|  0.00%|    1.05464603945949983183E-2,
  3282|         0|            0|            0|  0.00%|    -2.37374148058994688156E-2,
  3283|         0|            0|            0|  0.00%|    4.93052842396707084878E-2,
  3284|         0|            0|            0|  0.00%|    -9.49010970480476444210E-2,
  3285|         0|            0|            0|  0.00%|    1.71620901522208775349E-1,
  3286|         0|            0|            0|  0.00%|    -3.04682672343198398683E-1,
  3287|         0|            0|            0|  0.00%|    6.76795274409476084995E-1
  3288|         0|            0|            0|  0.00%|    ]
  3289|         0|            0|            0|  0.00%|
  3290|         0|            0|            0|  0.00%|_i0B = [
  3291|         0|            0|            0|  0.00%|    -7.23318048787475395456E-18,
  3292|         0|            0|            0|  0.00%|    -4.83050448594418207126E-18,
  3293|         0|            0|            0|  0.00%|    4.46562142029675999901E-17,
  3294|         0|            0|            0|  0.00%|    3.46122286769746109310E-17,
  3295|         0|            0|            0|  0.00%|    -2.82762398051658348494E-16,
  3296|         0|            0|            0|  0.00%|    -3.42548561967721913462E-16,
  3297|         0|            0|            0|  0.00%|    1.77256013305652638360E-15,
  3298|         0|            0|            0|  0.00%|    3.81168066935262242075E-15,
  3299|         0|            0|            0|  0.00%|    -9.55484669882830764870E-15,
  3300|         0|            0|            0|  0.00%|    -4.15056934728722208663E-14,
  3301|         0|            0|            0|  0.00%|    1.54008621752140982691E-14,
  3302|         0|            0|            0|  0.00%|    3.85277838274214270114E-13,
  3303|         0|            0|            0|  0.00%|    7.18012445138366623367E-13,
  3304|         0|            0|            0|  0.00%|    -1.79417853150680611778E-12,
  3305|         0|            0|            0|  0.00%|    -1.32158118404477131188E-11,
  3306|         0|            0|            0|  0.00%|    -3.14991652796324136454E-11,
  3307|         0|            0|            0|  0.00%|    1.18891471078464383424E-11,
  3308|         0|            0|            0|  0.00%|    4.94060238822496958910E-10,
  3309|         0|            0|            0|  0.00%|    3.39623202570838634515E-9,
  3310|         0|            0|            0|  0.00%|    2.26666899049817806459E-8,
  3311|         0|            0|            0|  0.00%|    2.04891858946906374183E-7,
  3312|         0|            0|            0|  0.00%|    2.89137052083475648297E-6,
  3313|         0|            0|            0|  0.00%|    6.88975834691682398426E-5,
  3314|         0|            0|            0|  0.00%|    3.36911647825569408990E-3,
  3315|         0|            0|            0|  0.00%|    8.04490411014108831608E-1
  3316|         0|            0|            0|  0.00%|    ]
  3317|         0|            0|            0|  0.00%|
  3318|         0|            0|            0|  0.00%|
  3319|         0|            0|            0|  0.00%|def _chbevl(x, vals):
  3320|         0|            0|            0|  0.00%|    b0 = vals[0]
  3321|         0|            0|            0|  0.00%|    b1 = 0.0
  3322|         0|            0|            0|  0.00%|
  3323|         0|            0|            0|  0.00%|    for i in range(1, len(vals)):
  3324|         0|            0|            0|  0.00%|        b2 = b1
  3325|         0|            0|            0|  0.00%|        b1 = b0
  3326|         0|            0|            0|  0.00%|        b0 = x*b1 - b2 + vals[i]
  3327|         0|            0|            0|  0.00%|
  3328|         0|            0|            0|  0.00%|    return 0.5*(b0 - b2)
  3329|         0|            0|            0|  0.00%|
  3330|         0|            0|            0|  0.00%|
  3331|         0|            0|            0|  0.00%|def _i0_1(x):
  3332|         0|            0|            0|  0.00%|    return exp(x) * _chbevl(x/2.0-2, _i0A)
  3333|         0|            0|            0|  0.00%|
  3334|         0|            0|            0|  0.00%|
  3335|         0|            0|            0|  0.00%|def _i0_2(x):
  3336|         0|            0|            0|  0.00%|    return exp(x) * _chbevl(32.0/x - 2.0, _i0B) / sqrt(x)
  3337|         0|            0|            0|  0.00%|
  3338|         0|            0|            0|  0.00%|
  3339|         0|            0|            0|  0.00%|def _i0_dispatcher(x):
  3340|         0|            0|            0|  0.00%|    return (x,)
  3341|         0|            0|            0|  0.00%|
  3342|         0|            0|            0|  0.00%|
  3343|         0|            0|            0|  0.00%|@array_function_dispatch(_i0_dispatcher)
  3344|         0|            0|            0|  0.00%|def i0(x):
  3345|         0|            0|            0|  0.00%|    """
  3346|         0|            0|            0|  0.00%|    Modified Bessel function of the first kind, order 0.
  3347|         0|            0|            0|  0.00%|
  3348|         0|            0|            0|  0.00%|    Usually denoted :math:`I_0`.
  3349|         0|            0|            0|  0.00%|
  3350|         0|            0|            0|  0.00%|    Parameters
  3351|         0|            0|            0|  0.00%|    ----------
  3352|         0|            0|            0|  0.00%|    x : array_like of float
  3353|         0|            0|            0|  0.00%|        Argument of the Bessel function.
  3354|         0|            0|            0|  0.00%|
  3355|         0|            0|            0|  0.00%|    Returns
  3356|         0|            0|            0|  0.00%|    -------
  3357|         0|            0|            0|  0.00%|    out : ndarray, shape = x.shape, dtype = float
  3358|         0|            0|            0|  0.00%|        The modified Bessel function evaluated at each of the elements of `x`.
  3359|         0|            0|            0|  0.00%|
  3360|         0|            0|            0|  0.00%|    See Also
  3361|         0|            0|            0|  0.00%|    --------
  3362|         0|            0|            0|  0.00%|    scipy.special.i0, scipy.special.iv, scipy.special.ive
  3363|         0|            0|            0|  0.00%|
  3364|         0|            0|            0|  0.00%|    Notes
  3365|         0|            0|            0|  0.00%|    -----
  3366|         0|            0|            0|  0.00%|    The scipy implementation is recommended over this function: it is a
  3367|         0|            0|            0|  0.00%|    proper ufunc written in C, and more than an order of magnitude faster.
  3368|         0|            0|            0|  0.00%|
  3369|         0|            0|            0|  0.00%|    We use the algorithm published by Clenshaw [1]_ and referenced by
  3370|         0|            0|            0|  0.00%|    Abramowitz and Stegun [2]_, for which the function domain is
  3371|         0|            0|            0|  0.00%|    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
  3372|         0|            0|            0|  0.00%|    polynomial expansions are employed in each interval. Relative error on
  3373|         0|            0|            0|  0.00%|    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
  3374|         0|            0|            0|  0.00%|    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).
  3375|         0|            0|            0|  0.00%|
  3376|         0|            0|            0|  0.00%|    References
  3377|         0|            0|            0|  0.00%|    ----------
  3378|         0|            0|            0|  0.00%|    .. [1] C. W. Clenshaw, "Chebyshev series for mathematical functions", in
  3379|         0|            0|            0|  0.00%|           *National Physical Laboratory Mathematical Tables*, vol. 5, London:
  3380|         0|            0|            0|  0.00%|           Her Majesty's Stationery Office, 1962.
  3381|         0|            0|            0|  0.00%|    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
  3382|         0|            0|            0|  0.00%|           Functions*, 10th printing, New York: Dover, 1964, pp. 379.
  3383|         0|            0|            0|  0.00%|           https://personal.math.ubc.ca/~cbm/aands/page_379.htm
  3384|         0|            0|            0|  0.00%|    .. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero
  3385|         0|            0|            0|  0.00%|
  3386|         0|            0|            0|  0.00%|    Examples
  3387|         0|            0|            0|  0.00%|    --------
  3388|         0|            0|            0|  0.00%|    >>> np.i0(0.)
  3389|         0|            0|            0|  0.00%|    array(1.0)
  3390|         0|            0|            0|  0.00%|    >>> np.i0([0, 1, 2, 3])
  3391|         0|            0|            0|  0.00%|    array([1.        , 1.26606588, 2.2795853 , 4.88079259])
  3392|         0|            0|            0|  0.00%|
  3393|         0|            0|            0|  0.00%|    """
  3394|         0|            0|            0|  0.00%|    x = np.asanyarray(x)
  3395|         0|            0|            0|  0.00%|    if x.dtype.kind == 'c':
  3396|         0|            0|            0|  0.00%|        raise TypeError("i0 not supported for complex values")
  3397|         0|            0|            0|  0.00%|    if x.dtype.kind != 'f':
  3398|         0|            0|            0|  0.00%|        x = x.astype(float)
  3399|         0|            0|            0|  0.00%|    x = np.abs(x)
  3400|         0|            0|            0|  0.00%|    return piecewise(x, [x <= 8.0], [_i0_1, _i0_2])
  3401|         0|            0|            0|  0.00%|
  3402|         0|            0|            0|  0.00%|## End of cephes code for i0
  3403|         0|            0|            0|  0.00%|
  3404|         0|            0|            0|  0.00%|
  3405|         0|            0|            0|  0.00%|@set_module('numpy')
  3406|         0|            0|            0|  0.00%|def kaiser(M, beta):
  3407|         0|            0|            0|  0.00%|    """
  3408|         0|            0|            0|  0.00%|    Return the Kaiser window.
  3409|         0|            0|            0|  0.00%|
  3410|         0|            0|            0|  0.00%|    The Kaiser window is a taper formed by using a Bessel function.
  3411|         0|            0|            0|  0.00%|
  3412|         0|            0|            0|  0.00%|    Parameters
  3413|         0|            0|            0|  0.00%|    ----------
  3414|         0|            0|            0|  0.00%|    M : int
  3415|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  3416|         0|            0|            0|  0.00%|        empty array is returned.
  3417|         0|            0|            0|  0.00%|    beta : float
  3418|         0|            0|            0|  0.00%|        Shape parameter for window.
  3419|         0|            0|            0|  0.00%|
  3420|         0|            0|            0|  0.00%|    Returns
  3421|         0|            0|            0|  0.00%|    -------
  3422|         0|            0|            0|  0.00%|    out : array
  3423|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value
  3424|         0|            0|            0|  0.00%|        one appears only if the number of samples is odd).
  3425|         0|            0|            0|  0.00%|
  3426|         0|            0|            0|  0.00%|    See Also
  3427|         0|            0|            0|  0.00%|    --------
  3428|         0|            0|            0|  0.00%|    bartlett, blackman, hamming, hanning
  3429|         0|            0|            0|  0.00%|
  3430|         0|            0|            0|  0.00%|    Notes
  3431|         0|            0|            0|  0.00%|    -----
  3432|         0|            0|            0|  0.00%|    The Kaiser window is defined as
  3433|         0|            0|            0|  0.00%|
  3434|         0|            0|            0|  0.00%|    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}
  3435|         0|            0|            0|  0.00%|               \\right)/I_0(\\beta)
  3436|         0|            0|            0|  0.00%|
  3437|         0|            0|            0|  0.00%|    with
  3438|         0|            0|            0|  0.00%|
  3439|         0|            0|            0|  0.00%|    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},
  3440|         0|            0|            0|  0.00%|
  3441|         0|            0|            0|  0.00%|    where :math:`I_0` is the modified zeroth-order Bessel function.
  3442|         0|            0|            0|  0.00%|
  3443|         0|            0|            0|  0.00%|    The Kaiser was named for Jim Kaiser, who discovered a simple
  3444|         0|            0|            0|  0.00%|    approximation to the DPSS window based on Bessel functions.  The Kaiser
  3445|         0|            0|            0|  0.00%|    window is a very good approximation to the Digital Prolate Spheroidal
  3446|         0|            0|            0|  0.00%|    Sequence, or Slepian window, which is the transform which maximizes the
  3447|         0|            0|            0|  0.00%|    energy in the main lobe of the window relative to total energy.
  3448|         0|            0|            0|  0.00%|
  3449|         0|            0|            0|  0.00%|    The Kaiser can approximate many other windows by varying the beta
  3450|         0|            0|            0|  0.00%|    parameter.
  3451|         0|            0|            0|  0.00%|
  3452|         0|            0|            0|  0.00%|    ====  =======================
  3453|         0|            0|            0|  0.00%|    beta  Window shape
  3454|         0|            0|            0|  0.00%|    ====  =======================
  3455|         0|            0|            0|  0.00%|    0     Rectangular
  3456|         0|            0|            0|  0.00%|    5     Similar to a Hamming
  3457|         0|            0|            0|  0.00%|    6     Similar to a Hanning
  3458|         0|            0|            0|  0.00%|    8.6   Similar to a Blackman
  3459|         0|            0|            0|  0.00%|    ====  =======================
  3460|         0|            0|            0|  0.00%|
  3461|         0|            0|            0|  0.00%|    A beta value of 14 is probably a good starting point. Note that as beta
  3462|         0|            0|            0|  0.00%|    gets large, the window narrows, and so the number of samples needs to be
  3463|         0|            0|            0|  0.00%|    large enough to sample the increasingly narrow spike, otherwise NaNs will
  3464|         0|            0|            0|  0.00%|    get returned.
  3465|         0|            0|            0|  0.00%|
  3466|         0|            0|            0|  0.00%|    Most references to the Kaiser window come from the signal processing
  3467|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  3468|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  3469|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  3470|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function.
  3471|         0|            0|            0|  0.00%|
  3472|         0|            0|            0|  0.00%|    References
  3473|         0|            0|            0|  0.00%|    ----------
  3474|         0|            0|            0|  0.00%|    .. [1] J. F. Kaiser, "Digital Filters" - Ch 7 in "Systems analysis by
  3475|         0|            0|            0|  0.00%|           digital computer", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
  3476|         0|            0|            0|  0.00%|           John Wiley and Sons, New York, (1966).
  3477|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
  3478|         0|            0|            0|  0.00%|           University of Alberta Press, 1975, pp. 177-178.
  3479|         0|            0|            0|  0.00%|    .. [3] Wikipedia, "Window function",
  3480|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  3481|         0|            0|            0|  0.00%|
  3482|         0|            0|            0|  0.00%|    Examples
  3483|         0|            0|            0|  0.00%|    --------
  3484|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  3485|         0|            0|            0|  0.00%|    >>> np.kaiser(12, 14)
  3486|         0|            0|            0|  0.00%|     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary
  3487|         0|            0|            0|  0.00%|            2.29737120e-01, 5.99885316e-01, 9.45674898e-01,
  3488|         0|            0|            0|  0.00%|            9.45674898e-01, 5.99885316e-01, 2.29737120e-01,
  3489|         0|            0|            0|  0.00%|            4.65200189e-02, 3.46009194e-03, 7.72686684e-06])
  3490|         0|            0|            0|  0.00%|
  3491|         0|            0|            0|  0.00%|
  3492|         0|            0|            0|  0.00%|    Plot the window and the frequency response:
  3493|         0|            0|            0|  0.00%|
  3494|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  3495|         0|            0|            0|  0.00%|    >>> window = np.kaiser(51, 14)
  3496|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  3497|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3498|         0|            0|            0|  0.00%|    >>> plt.title("Kaiser window")
  3499|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Kaiser window')
  3500|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  3501|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  3502|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  3503|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  3504|         0|            0|            0|  0.00%|    >>> plt.show()
  3505|         0|            0|            0|  0.00%|
  3506|         0|            0|            0|  0.00%|    >>> plt.figure()
  3507|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  3508|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  3509|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  3510|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  3511|         0|            0|            0|  0.00%|    >>> response = 20 * np.log10(mag)
  3512|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  3513|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  3514|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3515|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Kaiser window")
  3516|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Kaiser window')
  3517|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  3518|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  3519|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  3520|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  3521|         0|            0|            0|  0.00%|    >>> plt.axis('tight')
  3522|         0|            0|            0|  0.00%|    (-0.5, 0.5, -100.0, ...) # may vary
  3523|         0|            0|            0|  0.00%|    >>> plt.show()
  3524|         0|            0|            0|  0.00%|
  3525|         0|            0|            0|  0.00%|    """
  3526|         0|            0|            0|  0.00%|    if M == 1:
  3527|         0|            0|            0|  0.00%|        return np.ones(1, dtype=np.result_type(M, 0.0))
  3528|         0|            0|            0|  0.00%|    n = arange(0, M)
  3529|         0|            0|            0|  0.00%|    alpha = (M-1)/2.0
  3530|         0|            0|            0|  0.00%|    return i0(beta * sqrt(1-((n-alpha)/alpha)**2.0))/i0(float(beta))
  3531|         0|            0|            0|  0.00%|
  3532|         0|            0|            0|  0.00%|
  3533|         0|            0|            0|  0.00%|def _sinc_dispatcher(x):
  3534|         0|            0|            0|  0.00%|    return (x,)
  3535|         0|            0|            0|  0.00%|
  3536|         0|            0|            0|  0.00%|
  3537|         0|            0|            0|  0.00%|@array_function_dispatch(_sinc_dispatcher)
  3538|         0|            0|            0|  0.00%|def sinc(x):
  3539|         0|            0|            0|  0.00%|    r"""
  3540|         0|            0|            0|  0.00%|    Return the normalized sinc function.
  3541|         0|            0|            0|  0.00%|
  3542|         0|            0|            0|  0.00%|    The sinc function is :math:`\sin(\pi x)/(\pi x)`.
  3543|         0|            0|            0|  0.00%|
  3544|         0|            0|            0|  0.00%|    .. note::
  3545|         0|            0|            0|  0.00%|
  3546|         0|            0|            0|  0.00%|        Note the normalization factor of ``pi`` used in the definition.
  3547|         0|            0|            0|  0.00%|        This is the most commonly used definition in signal processing.
  3548|         0|            0|            0|  0.00%|        Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function
  3549|         0|            0|            0|  0.00%|        :math:`\sin(x)/(x)` that is more common in mathematics.
  3550|         0|            0|            0|  0.00%|
  3551|         0|            0|            0|  0.00%|    Parameters
  3552|         0|            0|            0|  0.00%|    ----------
  3553|         0|            0|            0|  0.00%|    x : ndarray
  3554|         0|            0|            0|  0.00%|        Array (possibly multi-dimensional) of values for which to to
  3555|         0|            0|            0|  0.00%|        calculate ``sinc(x)``.
  3556|         0|            0|            0|  0.00%|
  3557|         0|            0|            0|  0.00%|    Returns
  3558|         0|            0|            0|  0.00%|    -------
  3559|         0|            0|            0|  0.00%|    out : ndarray
  3560|         0|            0|            0|  0.00%|        ``sinc(x)``, which has the same shape as the input.
  3561|         0|            0|            0|  0.00%|
  3562|         0|            0|            0|  0.00%|    Notes
  3563|         0|            0|            0|  0.00%|    -----
  3564|         0|            0|            0|  0.00%|    ``sinc(0)`` is the limit value 1.
  3565|         0|            0|            0|  0.00%|
  3566|         0|            0|            0|  0.00%|    The name sinc is short for "sine cardinal" or "sinus cardinalis".
  3567|         0|            0|            0|  0.00%|
  3568|         0|            0|            0|  0.00%|    The sinc function is used in various signal processing applications,
  3569|         0|            0|            0|  0.00%|    including in anti-aliasing, in the construction of a Lanczos resampling
  3570|         0|            0|            0|  0.00%|    filter, and in interpolation.
  3571|         0|            0|            0|  0.00%|
  3572|         0|            0|            0|  0.00%|    For bandlimited interpolation of discrete-time signals, the ideal
  3573|         0|            0|            0|  0.00%|    interpolation kernel is proportional to the sinc function.
  3574|         0|            0|            0|  0.00%|
  3575|         0|            0|            0|  0.00%|    References
  3576|         0|            0|            0|  0.00%|    ----------
  3577|         0|            0|            0|  0.00%|    .. [1] Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
  3578|         0|            0|            0|  0.00%|           Resource. http://mathworld.wolfram.com/SincFunction.html
  3579|         0|            0|            0|  0.00%|    .. [2] Wikipedia, "Sinc function",
  3580|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Sinc_function
  3581|         0|            0|            0|  0.00%|
  3582|         0|            0|            0|  0.00%|    Examples
  3583|         0|            0|            0|  0.00%|    --------
  3584|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  3585|         0|            0|            0|  0.00%|    >>> x = np.linspace(-4, 4, 41)
  3586|         0|            0|            0|  0.00%|    >>> np.sinc(x)
  3587|         0|            0|            0|  0.00%|     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
  3588|         0|            0|            0|  0.00%|            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
  3589|         0|            0|            0|  0.00%|            6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
  3590|         0|            0|            0|  0.00%|            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
  3591|         0|            0|            0|  0.00%|            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
  3592|         0|            0|            0|  0.00%|            3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
  3593|         0|            0|            0|  0.00%|            7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
  3594|         0|            0|            0|  0.00%|            9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
  3595|         0|            0|            0|  0.00%|            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
  3596|         0|            0|            0|  0.00%|           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
  3597|         0|            0|            0|  0.00%|           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
  3598|         0|            0|            0|  0.00%|            1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
  3599|         0|            0|            0|  0.00%|            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
  3600|         0|            0|            0|  0.00%|            -4.92362781e-02,  -3.89804309e-17])
  3601|         0|            0|            0|  0.00%|
  3602|         0|            0|            0|  0.00%|    >>> plt.plot(x, np.sinc(x))
  3603|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3604|         0|            0|            0|  0.00%|    >>> plt.title("Sinc Function")
  3605|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Sinc Function')
  3606|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  3607|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  3608|         0|            0|            0|  0.00%|    >>> plt.xlabel("X")
  3609|         0|            0|            0|  0.00%|    Text(0.5, 0, 'X')
  3610|         0|            0|            0|  0.00%|    >>> plt.show()
  3611|         0|            0|            0|  0.00%|
  3612|         0|            0|            0|  0.00%|    """
  3613|         0|            0|            0|  0.00%|    x = np.asanyarray(x)
  3614|         0|            0|            0|  0.00%|    y = pi * where(x == 0, 1.0e-20, x)
  3615|         0|            0|            0|  0.00%|    return sin(y)/y
  3616|         0|            0|            0|  0.00%|
  3617|         0|            0|            0|  0.00%|
  3618|         0|            0|            0|  0.00%|def _msort_dispatcher(a):
  3619|         0|            0|            0|  0.00%|    return (a,)
  3620|         0|            0|            0|  0.00%|
  3621|         0|            0|            0|  0.00%|
  3622|         0|            0|            0|  0.00%|@array_function_dispatch(_msort_dispatcher)
  3623|         0|            0|            0|  0.00%|def msort(a):
  3624|         0|            0|            0|  0.00%|    """
  3625|         0|            0|            0|  0.00%|    Return a copy of an array sorted along the first axis.
  3626|         0|            0|            0|  0.00%|
  3627|         0|            0|            0|  0.00%|    Parameters
  3628|         0|            0|            0|  0.00%|    ----------
  3629|         0|            0|            0|  0.00%|    a : array_like
  3630|         0|            0|            0|  0.00%|        Array to be sorted.
  3631|         0|            0|            0|  0.00%|
  3632|         0|            0|            0|  0.00%|    Returns
  3633|         0|            0|            0|  0.00%|    -------
  3634|         0|            0|            0|  0.00%|    sorted_array : ndarray
  3635|         0|            0|            0|  0.00%|        Array of the same type and shape as `a`.
  3636|         0|            0|            0|  0.00%|
  3637|         0|            0|            0|  0.00%|    See Also
  3638|         0|            0|            0|  0.00%|    --------
  3639|         0|            0|            0|  0.00%|    sort
  3640|         0|            0|            0|  0.00%|
  3641|         0|            0|            0|  0.00%|    Notes
  3642|         0|            0|            0|  0.00%|    -----
  3643|         0|            0|            0|  0.00%|    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.
  3644|         0|            0|            0|  0.00%|
  3645|         0|            0|            0|  0.00%|    """
  3646|         0|            0|            0|  0.00%|    b = array(a, subok=True, copy=True)
  3647|         0|            0|            0|  0.00%|    b.sort(0)
  3648|         0|            0|            0|  0.00%|    return b
  3649|         0|            0|            0|  0.00%|
  3650|         0|            0|            0|  0.00%|
  3651|         0|            0|            0|  0.00%|def _ureduce(a, func, **kwargs):
  3652|         0|            0|            0|  0.00%|    """
  3653|         0|            0|            0|  0.00%|    Internal Function.
  3654|         0|            0|            0|  0.00%|    Call `func` with `a` as first argument swapping the axes to use extended
  3655|         0|            0|            0|  0.00%|    axis on functions that don't support it natively.
  3656|         0|            0|            0|  0.00%|
  3657|         0|            0|            0|  0.00%|    Returns result and a.shape with axis dims set to 1.
  3658|         0|            0|            0|  0.00%|
  3659|         0|            0|            0|  0.00%|    Parameters
  3660|         0|            0|            0|  0.00%|    ----------
  3661|         0|            0|            0|  0.00%|    a : array_like
  3662|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  3663|         0|            0|            0|  0.00%|    func : callable
  3664|         0|            0|            0|  0.00%|        Reduction function capable of receiving a single axis argument.
  3665|         0|            0|            0|  0.00%|        It is called with `a` as first argument followed by `kwargs`.
  3666|         0|            0|            0|  0.00%|    kwargs : keyword arguments
  3667|         0|            0|            0|  0.00%|        additional keyword arguments to pass to `func`.
  3668|         0|            0|            0|  0.00%|
  3669|         0|            0|            0|  0.00%|    Returns
  3670|         0|            0|            0|  0.00%|    -------
  3671|         0|            0|            0|  0.00%|    result : tuple
  3672|         0|            0|            0|  0.00%|        Result of func(a, **kwargs) and a.shape with axis dims set to 1
  3673|         0|            0|            0|  0.00%|        which can be used to reshape the result to the same shape a ufunc with
  3674|         0|            0|            0|  0.00%|        keepdims=True would produce.
  3675|         0|            0|            0|  0.00%|
  3676|         0|            0|            0|  0.00%|    """
  3677|         0|            0|            0|  0.00%|    a = np.asanyarray(a)
  3678|         0|            0|            0|  0.00%|    axis = kwargs.get('axis', None)
  3679|         0|            0|            0|  0.00%|    if axis is not None:
  3680|         0|            0|            0|  0.00%|        keepdim = list(a.shape)
  3681|         0|            0|            0|  0.00%|        nd = a.ndim
  3682|         0|            0|            0|  0.00%|        axis = _nx.normalize_axis_tuple(axis, nd)
  3683|         0|            0|            0|  0.00%|
  3684|         0|            0|            0|  0.00%|        for ax in axis:
  3685|         0|            0|            0|  0.00%|            keepdim[ax] = 1
  3686|         0|            0|            0|  0.00%|
  3687|         0|            0|            0|  0.00%|        if len(axis) == 1:
  3688|         0|            0|            0|  0.00%|            kwargs['axis'] = axis[0]
  3689|         0|            0|            0|  0.00%|        else:
  3690|         0|            0|            0|  0.00%|            keep = set(range(nd)) - set(axis)
  3691|         0|            0|            0|  0.00%|            nkeep = len(keep)
  3692|         0|            0|            0|  0.00%|            # swap axis that should not be reduced to front
  3693|         0|            0|            0|  0.00%|            for i, s in enumerate(sorted(keep)):
  3694|         0|            0|            0|  0.00%|                a = a.swapaxes(i, s)
  3695|         0|            0|            0|  0.00%|            # merge reduced axis
  3696|         0|            0|            0|  0.00%|            a = a.reshape(a.shape[:nkeep] + (-1,))
  3697|         0|            0|            0|  0.00%|            kwargs['axis'] = -1
  3698|         0|            0|            0|  0.00%|        keepdim = tuple(keepdim)
  3699|         0|            0|            0|  0.00%|    else:
  3700|         0|            0|            0|  0.00%|        keepdim = (1,) * a.ndim
  3701|         0|            0|            0|  0.00%|
  3702|         0|            0|            0|  0.00%|    r = func(a, **kwargs)
  3703|         0|            0|            0|  0.00%|    return r, keepdim
  3704|         0|            0|            0|  0.00%|
  3705|         0|            0|            0|  0.00%|
  3706|         0|            0|            0|  0.00%|def _median_dispatcher(
  3707|         0|            0|            0|  0.00%|        a, axis=None, out=None, overwrite_input=None, keepdims=None):
  3708|         0|            0|            0|  0.00%|    return (a, out)
  3709|         0|            0|            0|  0.00%|
  3710|         0|            0|            0|  0.00%|
  3711|         0|            0|            0|  0.00%|@array_function_dispatch(_median_dispatcher)
  3712|         0|            0|            0|  0.00%|def median(a, axis=None, out=None, overwrite_input=False, keepdims=False):
  3713|         0|            0|            0|  0.00%|    """
  3714|         0|            0|            0|  0.00%|    Compute the median along the specified axis.
  3715|         0|            0|            0|  0.00%|
  3716|         0|            0|            0|  0.00%|    Returns the median of the array elements.
  3717|         0|            0|            0|  0.00%|
  3718|         0|            0|            0|  0.00%|    Parameters
  3719|         0|            0|            0|  0.00%|    ----------
  3720|         0|            0|            0|  0.00%|    a : array_like
  3721|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  3722|         0|            0|            0|  0.00%|    axis : {int, sequence of int, None}, optional
  3723|         0|            0|            0|  0.00%|        Axis or axes along which the medians are computed. The default
  3724|         0|            0|            0|  0.00%|        is to compute the median along a flattened version of the array.
  3725|         0|            0|            0|  0.00%|        A sequence of axes is supported since version 1.9.0.
  3726|         0|            0|            0|  0.00%|    out : ndarray, optional
  3727|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  3728|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output,
  3729|         0|            0|            0|  0.00%|        but the type (of the output) will be cast if necessary.
  3730|         0|            0|            0|  0.00%|    overwrite_input : bool, optional
  3731|         0|            0|            0|  0.00%|       If True, then allow use of memory of input array `a` for
  3732|         0|            0|            0|  0.00%|       calculations. The input array will be modified by the call to
  3733|         0|            0|            0|  0.00%|       `median`. This will save memory when you do not need to preserve
  3734|         0|            0|            0|  0.00%|       the contents of the input array. Treat the input as undefined,
  3735|         0|            0|            0|  0.00%|       but it will probably be fully or partially sorted. Default is
  3736|         0|            0|            0|  0.00%|       False. If `overwrite_input` is ``True`` and `a` is not already an
  3737|         0|            0|            0|  0.00%|       `ndarray`, an error will be raised.
  3738|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3739|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3740|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3741|         0|            0|            0|  0.00%|        the result will broadcast correctly against the original `arr`.
  3742|         0|            0|            0|  0.00%|
  3743|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
  3744|         0|            0|            0|  0.00%|
  3745|         0|            0|            0|  0.00%|    Returns
  3746|         0|            0|            0|  0.00%|    -------
  3747|         0|            0|            0|  0.00%|    median : ndarray
  3748|         0|            0|            0|  0.00%|        A new array holding the result. If the input contains integers
  3749|         0|            0|            0|  0.00%|        or floats smaller than ``float64``, then the output data-type is
  3750|         0|            0|            0|  0.00%|        ``np.float64``.  Otherwise, the data-type of the output is the
  3751|         0|            0|            0|  0.00%|        same as that of the input. If `out` is specified, that array is
  3752|         0|            0|            0|  0.00%|        returned instead.
  3753|         0|            0|            0|  0.00%|
  3754|         0|            0|            0|  0.00%|    See Also
  3755|         0|            0|            0|  0.00%|    --------
  3756|         0|            0|            0|  0.00%|    mean, percentile
  3757|         0|            0|            0|  0.00%|
  3758|         0|            0|            0|  0.00%|    Notes
  3759|         0|            0|            0|  0.00%|    -----
  3760|         0|            0|            0|  0.00%|    Given a vector ``V`` of length ``N``, the median of ``V`` is the
  3761|         0|            0|            0|  0.00%|    middle value of a sorted copy of ``V``, ``V_sorted`` - i
  3762|         0|            0|            0|  0.00%|    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the
  3763|         0|            0|            0|  0.00%|    two middle values of ``V_sorted`` when ``N`` is even.
  3764|         0|            0|            0|  0.00%|
  3765|         0|            0|            0|  0.00%|    Examples
  3766|         0|            0|            0|  0.00%|    --------
  3767|         0|            0|            0|  0.00%|    >>> a = np.array([[10, 7, 4], [3, 2, 1]])
  3768|         0|            0|            0|  0.00%|    >>> a
  3769|         0|            0|            0|  0.00%|    array([[10,  7,  4],
  3770|         0|            0|            0|  0.00%|           [ 3,  2,  1]])
  3771|         0|            0|            0|  0.00%|    >>> np.median(a)
  3772|         0|            0|            0|  0.00%|    3.5
  3773|         0|            0|            0|  0.00%|    >>> np.median(a, axis=0)
  3774|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3775|         0|            0|            0|  0.00%|    >>> np.median(a, axis=1)
  3776|         0|            0|            0|  0.00%|    array([7.,  2.])
  3777|         0|            0|            0|  0.00%|    >>> m = np.median(a, axis=0)
  3778|         0|            0|            0|  0.00%|    >>> out = np.zeros_like(m)
  3779|         0|            0|            0|  0.00%|    >>> np.median(a, axis=0, out=m)
  3780|         0|            0|            0|  0.00%|    array([6.5,  4.5,  2.5])
  3781|         0|            0|            0|  0.00%|    >>> m
  3782|         0|            0|            0|  0.00%|    array([6.5,  4.5,  2.5])
  3783|         0|            0|            0|  0.00%|    >>> b = a.copy()
  3784|         0|            0|            0|  0.00%|    >>> np.median(b, axis=1, overwrite_input=True)
  3785|         0|            0|            0|  0.00%|    array([7.,  2.])
  3786|         0|            0|            0|  0.00%|    >>> assert not np.all(a==b)
  3787|         0|            0|            0|  0.00%|    >>> b = a.copy()
  3788|         0|            0|            0|  0.00%|    >>> np.median(b, axis=None, overwrite_input=True)
  3789|         0|            0|            0|  0.00%|    3.5
  3790|         0|            0|            0|  0.00%|    >>> assert not np.all(a==b)
  3791|         0|            0|            0|  0.00%|
  3792|         0|            0|            0|  0.00%|    """
  3793|         0|            0|            0|  0.00%|    r, k = _ureduce(a, func=_median, axis=axis, out=out,
  3794|         0|            0|            0|  0.00%|                    overwrite_input=overwrite_input)
  3795|         0|            0|            0|  0.00%|    if keepdims:
  3796|         0|            0|            0|  0.00%|        return r.reshape(k)
  3797|         0|            0|            0|  0.00%|    else:
  3798|         0|            0|            0|  0.00%|        return r
  3799|         0|            0|            0|  0.00%|
  3800|         0|            0|            0|  0.00%|
  3801|         0|            0|            0|  0.00%|def _median(a, axis=None, out=None, overwrite_input=False):
  3802|         0|            0|            0|  0.00%|    # can't be reasonably be implemented in terms of percentile as we have to
  3803|         0|            0|            0|  0.00%|    # call mean to not break astropy
  3804|         0|            0|            0|  0.00%|    a = np.asanyarray(a)
  3805|         0|            0|            0|  0.00%|
  3806|         0|            0|            0|  0.00%|    # Set the partition indexes
  3807|         0|            0|            0|  0.00%|    if axis is None:
  3808|         0|            0|            0|  0.00%|        sz = a.size
  3809|         0|            0|            0|  0.00%|    else:
  3810|         0|            0|            0|  0.00%|        sz = a.shape[axis]
  3811|         0|            0|            0|  0.00%|    if sz % 2 == 0:
  3812|         0|            0|            0|  0.00%|        szh = sz // 2
  3813|         0|            0|            0|  0.00%|        kth = [szh - 1, szh]
  3814|         0|            0|            0|  0.00%|    else:
  3815|         0|            0|            0|  0.00%|        kth = [(sz - 1) // 2]
  3816|         0|            0|            0|  0.00%|    # Check if the array contains any nan's
  3817|         0|            0|            0|  0.00%|    if np.issubdtype(a.dtype, np.inexact):
  3818|         0|            0|            0|  0.00%|        kth.append(-1)
  3819|         0|            0|            0|  0.00%|
  3820|         0|            0|            0|  0.00%|    if overwrite_input:
  3821|         0|            0|            0|  0.00%|        if axis is None:
  3822|         0|            0|            0|  0.00%|            part = a.ravel()
  3823|         0|            0|            0|  0.00%|            part.partition(kth)
  3824|         0|            0|            0|  0.00%|        else:
  3825|         0|            0|            0|  0.00%|            a.partition(kth, axis=axis)
  3826|         0|            0|            0|  0.00%|            part = a
  3827|         0|            0|            0|  0.00%|    else:
  3828|         0|            0|            0|  0.00%|        part = partition(a, kth, axis=axis)
  3829|         0|            0|            0|  0.00%|
  3830|         0|            0|            0|  0.00%|    if part.shape == ():
  3831|         0|            0|            0|  0.00%|        # make 0-D arrays work
  3832|         0|            0|            0|  0.00%|        return part.item()
  3833|         0|            0|            0|  0.00%|    if axis is None:
  3834|         0|            0|            0|  0.00%|        axis = 0
  3835|         0|            0|            0|  0.00%|
  3836|         0|            0|            0|  0.00%|    indexer = [slice(None)] * part.ndim
  3837|         0|            0|            0|  0.00%|    index = part.shape[axis] // 2
  3838|         0|            0|            0|  0.00%|    if part.shape[axis] % 2 == 1:
  3839|         0|            0|            0|  0.00%|        # index with slice to allow mean (below) to work
  3840|         0|            0|            0|  0.00%|        indexer[axis] = slice(index, index+1)
  3841|         0|            0|            0|  0.00%|    else:
  3842|         0|            0|            0|  0.00%|        indexer[axis] = slice(index-1, index+1)
  3843|         0|            0|            0|  0.00%|    indexer = tuple(indexer)
  3844|         0|            0|            0|  0.00%|
  3845|         0|            0|            0|  0.00%|    # Use mean in both odd and even case to coerce data type,
  3846|         0|            0|            0|  0.00%|    # using out array if needed.
  3847|         0|            0|            0|  0.00%|    rout = mean(part[indexer], axis=axis, out=out)
  3848|         0|            0|            0|  0.00%|    # Check if the array contains any nan's
  3849|         0|            0|            0|  0.00%|    if np.issubdtype(a.dtype, np.inexact) and sz > 0:
  3850|         0|            0|            0|  0.00%|        # If nans are possible, warn and replace by nans like mean would.
  3851|         0|            0|            0|  0.00%|        rout = np.lib.utils._median_nancheck(part, rout, axis)
  3852|         0|            0|            0|  0.00%|
  3853|         0|            0|            0|  0.00%|    return rout
  3854|         0|            0|            0|  0.00%|
  3855|         0|            0|            0|  0.00%|
  3856|         0|            0|            0|  0.00%|def _percentile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,
  3857|         0|            0|            0|  0.00%|                           method=None, keepdims=None, *, interpolation=None):
  3858|         0|            0|            0|  0.00%|    return (a, q, out)
  3859|         0|            0|            0|  0.00%|
  3860|         0|            0|            0|  0.00%|
  3861|         0|            0|            0|  0.00%|@array_function_dispatch(_percentile_dispatcher)
  3862|         0|            0|            0|  0.00%|def percentile(a,
  3863|         0|            0|            0|  0.00%|               q,
  3864|         0|            0|            0|  0.00%|               axis=None,
  3865|         0|            0|            0|  0.00%|               out=None,
  3866|         0|            0|            0|  0.00%|               overwrite_input=False,
  3867|         0|            0|            0|  0.00%|               method="linear",
  3868|         0|            0|            0|  0.00%|               keepdims=False,
  3869|         0|            0|            0|  0.00%|               *,
  3870|         0|            0|            0|  0.00%|               interpolation=None):
  3871|         0|            0|            0|  0.00%|    """
  3872|         0|            0|            0|  0.00%|    Compute the q-th percentile of the data along the specified axis.
  3873|         0|            0|            0|  0.00%|
  3874|         0|            0|            0|  0.00%|    Returns the q-th percentile(s) of the array elements.
  3875|         0|            0|            0|  0.00%|
  3876|         0|            0|            0|  0.00%|    Parameters
  3877|         0|            0|            0|  0.00%|    ----------
  3878|         0|            0|            0|  0.00%|    a : array_like
  3879|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  3880|         0|            0|            0|  0.00%|    q : array_like of float
  3881|         0|            0|            0|  0.00%|        Percentile or sequence of percentiles to compute, which must be between
  3882|         0|            0|            0|  0.00%|        0 and 100 inclusive.
  3883|         0|            0|            0|  0.00%|    axis : {int, tuple of int, None}, optional
  3884|         0|            0|            0|  0.00%|        Axis or axes along which the percentiles are computed. The
  3885|         0|            0|            0|  0.00%|        default is to compute the percentile(s) along a flattened
  3886|         0|            0|            0|  0.00%|        version of the array.
  3887|         0|            0|            0|  0.00%|
  3888|         0|            0|            0|  0.00%|        .. versionchanged:: 1.9.0
  3889|         0|            0|            0|  0.00%|            A tuple of axes is supported
  3890|         0|            0|            0|  0.00%|    out : ndarray, optional
  3891|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  3892|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output,
  3893|         0|            0|            0|  0.00%|        but the type (of the output) will be cast if necessary.
  3894|         0|            0|            0|  0.00%|    overwrite_input : bool, optional
  3895|         0|            0|            0|  0.00%|        If True, then allow the input array `a` to be modified by intermediate
  3896|         0|            0|            0|  0.00%|        calculations, to save memory. In this case, the contents of the input
  3897|         0|            0|            0|  0.00%|        `a` after this function completes is undefined.
  3898|         0|            0|            0|  0.00%|    method : str, optional
  3899|         0|            0|            0|  0.00%|        This parameter specifies the method to use for estimating the
  3900|         0|            0|            0|  0.00%|        percentile.  There are many different methods, some unique to NumPy.
  3901|         0|            0|            0|  0.00%|        See the notes for explanation.  The options sorted by their R type
  3902|         0|            0|            0|  0.00%|        as summarized in the H&F paper [1]_ are:
  3903|         0|            0|            0|  0.00%|
  3904|         0|            0|            0|  0.00%|        1. 'inverted_cdf'
  3905|         0|            0|            0|  0.00%|        2. 'averaged_inverted_cdf'
  3906|         0|            0|            0|  0.00%|        3. 'closest_observation'
  3907|         0|            0|            0|  0.00%|        4. 'interpolated_inverted_cdf'
  3908|         0|            0|            0|  0.00%|        5. 'hazen'
  3909|         0|            0|            0|  0.00%|        6. 'weibull'
  3910|         0|            0|            0|  0.00%|        7. 'linear'  (default)
  3911|         0|            0|            0|  0.00%|        8. 'median_unbiased'
  3912|         0|            0|            0|  0.00%|        9. 'normal_unbiased'
  3913|         0|            0|            0|  0.00%|
  3914|         0|            0|            0|  0.00%|        The first three methods are discontiuous.  NumPy further defines the
  3915|         0|            0|            0|  0.00%|        following discontinuous variations of the default 'linear' (7.) option:
  3916|         0|            0|            0|  0.00%|
  3917|         0|            0|            0|  0.00%|        * 'lower'
  3918|         0|            0|            0|  0.00%|        * 'higher',
  3919|         0|            0|            0|  0.00%|        * 'midpoint'
  3920|         0|            0|            0|  0.00%|        * 'nearest'
  3921|         0|            0|            0|  0.00%|
  3922|         0|            0|            0|  0.00%|        .. versionchanged:: 1.22.0
  3923|         0|            0|            0|  0.00%|            This argument was previously called "interpolation" and only
  3924|         0|            0|            0|  0.00%|            offered the "linear" default and last four options.
  3925|         0|            0|            0|  0.00%|
  3926|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3927|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left in
  3928|         0|            0|            0|  0.00%|        the result as dimensions with size one. With this option, the
  3929|         0|            0|            0|  0.00%|        result will broadcast correctly against the original array `a`.
  3930|         0|            0|            0|  0.00%|
  3931|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
  3932|         0|            0|            0|  0.00%|
  3933|         0|            0|            0|  0.00%|    interpolation : str, optional
  3934|         0|            0|            0|  0.00%|        Deprecated name for the method keyword argument.
  3935|         0|            0|            0|  0.00%|
  3936|         0|            0|            0|  0.00%|        .. deprecated:: 1.22.0
  3937|         0|            0|            0|  0.00%|
  3938|         0|            0|            0|  0.00%|    Returns
  3939|         0|            0|            0|  0.00%|    -------
  3940|         0|            0|            0|  0.00%|    percentile : scalar or ndarray
  3941|         0|            0|            0|  0.00%|        If `q` is a single percentile and `axis=None`, then the result
  3942|         0|            0|            0|  0.00%|        is a scalar. If multiple percentiles are given, first axis of
  3943|         0|            0|            0|  0.00%|        the result corresponds to the percentiles. The other axes are
  3944|         0|            0|            0|  0.00%|        the axes that remain after the reduction of `a`. If the input
  3945|         0|            0|            0|  0.00%|        contains integers or floats smaller than ``float64``, the output
  3946|         0|            0|            0|  0.00%|        data-type is ``float64``. Otherwise, the output data-type is the
  3947|         0|            0|            0|  0.00%|        same as that of the input. If `out` is specified, that array is
  3948|         0|            0|            0|  0.00%|        returned instead.
  3949|         0|            0|            0|  0.00%|
  3950|         0|            0|            0|  0.00%|    See Also
  3951|         0|            0|            0|  0.00%|    --------
  3952|         0|            0|            0|  0.00%|    mean
  3953|         0|            0|            0|  0.00%|    median : equivalent to ``percentile(..., 50)``
  3954|         0|            0|            0|  0.00%|    nanpercentile
  3955|         0|            0|            0|  0.00%|    quantile : equivalent to percentile, except q in the range [0, 1].
  3956|         0|            0|            0|  0.00%|
  3957|         0|            0|            0|  0.00%|    Notes
  3958|         0|            0|            0|  0.00%|    -----
  3959|         0|            0|            0|  0.00%|    Given a vector ``V`` of length ``N``, the q-th percentile of ``V`` is
  3960|         0|            0|            0|  0.00%|    the value ``q/100`` of the way from the minimum to the maximum in a
  3961|         0|            0|            0|  0.00%|    sorted copy of ``V``. The values and distances of the two nearest
  3962|         0|            0|            0|  0.00%|    neighbors as well as the `method` parameter will determine the
  3963|         0|            0|            0|  0.00%|    percentile if the normalized ranking does not match the location of
  3964|         0|            0|            0|  0.00%|    ``q`` exactly. This function is the same as the median if ``q=50``, the
  3965|         0|            0|            0|  0.00%|    same as the minimum if ``q=0`` and the same as the maximum if
  3966|         0|            0|            0|  0.00%|    ``q=100``.
  3967|         0|            0|            0|  0.00%|
  3968|         0|            0|            0|  0.00%|    This optional `method` parameter specifies the method to use when the
  3969|         0|            0|            0|  0.00%|    desired quantile lies between two data points ``i < j``.
  3970|         0|            0|            0|  0.00%|    If ``g`` is the fractional part of the index surrounded by ``i`` and
  3971|         0|            0|            0|  0.00%|    alpha and beta are correction constants modifying i and j.
  3972|         0|            0|            0|  0.00%|
  3973|         0|            0|            0|  0.00%|    Below, 'q' is the quantile value, 'n' is the sample size and
  3974|         0|            0|            0|  0.00%|    alpha and beta are constants.
  3975|         0|            0|            0|  0.00%|    The following formula gives an interpolation "i + g" of where the quantile
  3976|         0|            0|            0|  0.00%|    would be in the sorted sample.
  3977|         0|            0|            0|  0.00%|    With 'i' being the floor and 'g' the fractional part of the result.
  3978|         0|            0|            0|  0.00%|
  3979|         0|            0|            0|  0.00%|    .. math::
  3980|         0|            0|            0|  0.00%|        i + g = (q - alpha) / ( n - alpha - beta + 1 )
  3981|         0|            0|            0|  0.00%|
  3982|         0|            0|            0|  0.00%|    The different methods then work as follows
  3983|         0|            0|            0|  0.00%|
  3984|         0|            0|            0|  0.00%|    inverted_cdf:
  3985|         0|            0|            0|  0.00%|        method 1 of H&F [1]_.
  3986|         0|            0|            0|  0.00%|        This method gives discontinuous results:
  3987|         0|            0|            0|  0.00%|        * if g > 0 ; then take j
  3988|         0|            0|            0|  0.00%|        * if g = 0 ; then take i
  3989|         0|            0|            0|  0.00%|
  3990|         0|            0|            0|  0.00%|    averaged_inverted_cdf:
  3991|         0|            0|            0|  0.00%|        method 2 of H&F [1]_.
  3992|         0|            0|            0|  0.00%|        This method give discontinuous results:
  3993|         0|            0|            0|  0.00%|        * if g > 0 ; then take j
  3994|         0|            0|            0|  0.00%|        * if g = 0 ; then average between bounds
  3995|         0|            0|            0|  0.00%|
  3996|         0|            0|            0|  0.00%|    closest_observation:
  3997|         0|            0|            0|  0.00%|        method 3 of H&F [1]_.
  3998|         0|            0|            0|  0.00%|        This method give discontinuous results:
  3999|         0|            0|            0|  0.00%|        * if g > 0 ; then take j
  4000|         0|            0|            0|  0.00%|        * if g = 0 and index is odd ; then take j
  4001|         0|            0|            0|  0.00%|        * if g = 0 and index is even ; then take i
  4002|         0|            0|            0|  0.00%|
  4003|         0|            0|            0|  0.00%|    interpolated_inverted_cdf:
  4004|         0|            0|            0|  0.00%|        method 4 of H&F [1]_.
  4005|         0|            0|            0|  0.00%|        This method give continuous results using:
  4006|         0|            0|            0|  0.00%|        * alpha = 0
  4007|         0|            0|            0|  0.00%|        * beta = 1
  4008|         0|            0|            0|  0.00%|
  4009|         0|            0|            0|  0.00%|    hazen:
  4010|         0|            0|            0|  0.00%|        method 5 of H&F [1]_.
  4011|         0|            0|            0|  0.00%|        This method give continuous results using:
  4012|         0|            0|            0|  0.00%|        * alpha = 1/2
  4013|         0|            0|            0|  0.00%|        * beta = 1/2
  4014|         0|            0|            0|  0.00%|
  4015|         0|            0|            0|  0.00%|    weibull:
  4016|         0|            0|            0|  0.00%|        method 6 of H&F [1]_.
  4017|         0|            0|            0|  0.00%|        This method give continuous results using:
  4018|         0|            0|            0|  0.00%|        * alpha = 0
  4019|         0|            0|            0|  0.00%|        * beta = 0
  4020|         0|            0|            0|  0.00%|
  4021|         0|            0|            0|  0.00%|    linear:
  4022|         0|            0|            0|  0.00%|        method 7 of H&F [1]_.
  4023|         0|            0|            0|  0.00%|        This method give continuous results using:
  4024|         0|            0|            0|  0.00%|        * alpha = 1
  4025|         0|            0|            0|  0.00%|        * beta = 1
  4026|         0|            0|            0|  0.00%|
  4027|         0|            0|            0|  0.00%|    median_unbiased:
  4028|         0|            0|            0|  0.00%|        method 8 of H&F [1]_.
  4029|         0|            0|            0|  0.00%|        This method is probably the best method if the sample
  4030|         0|            0|            0|  0.00%|        distribution function is unknown (see reference).
  4031|         0|            0|            0|  0.00%|        This method give continuous results using:
  4032|         0|            0|            0|  0.00%|        * alpha = 1/3
  4033|         0|            0|            0|  0.00%|        * beta = 1/3
  4034|         0|            0|            0|  0.00%|
  4035|         0|            0|            0|  0.00%|    normal_unbiased:
  4036|         0|            0|            0|  0.00%|        method 9 of H&F [1]_.
  4037|         0|            0|            0|  0.00%|        This method is probably the best method if the sample
  4038|         0|            0|            0|  0.00%|        distribution function is known to be normal.
  4039|         0|            0|            0|  0.00%|        This method give continuous results using:
  4040|         0|            0|            0|  0.00%|        * alpha = 3/8
  4041|         0|            0|            0|  0.00%|        * beta = 3/8
  4042|         0|            0|            0|  0.00%|
  4043|         0|            0|            0|  0.00%|    lower:
  4044|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4045|         0|            0|            0|  0.00%|        Takes ``i`` as the interpolation point.
  4046|         0|            0|            0|  0.00%|
  4047|         0|            0|            0|  0.00%|    higher:
  4048|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4049|         0|            0|            0|  0.00%|        Takes ``j`` as the interpolation point.
  4050|         0|            0|            0|  0.00%|
  4051|         0|            0|            0|  0.00%|    nearest:
  4052|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4053|         0|            0|            0|  0.00%|        Takes ``i`` or ``j``, whichever is nearest.
  4054|         0|            0|            0|  0.00%|
  4055|         0|            0|            0|  0.00%|    midpoint:
  4056|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4057|         0|            0|            0|  0.00%|        Uses ``(i + j) / 2``.
  4058|         0|            0|            0|  0.00%|
  4059|         0|            0|            0|  0.00%|    Examples
  4060|         0|            0|            0|  0.00%|    --------
  4061|         0|            0|            0|  0.00%|    >>> a = np.array([[10, 7, 4], [3, 2, 1]])
  4062|         0|            0|            0|  0.00%|    >>> a
  4063|         0|            0|            0|  0.00%|    array([[10,  7,  4],
  4064|         0|            0|            0|  0.00%|           [ 3,  2,  1]])
  4065|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50)
  4066|         0|            0|            0|  0.00%|    3.5
  4067|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=0)
  4068|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  4069|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=1)
  4070|         0|            0|            0|  0.00%|    array([7.,  2.])
  4071|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=1, keepdims=True)
  4072|         0|            0|            0|  0.00%|    array([[7.],
  4073|         0|            0|            0|  0.00%|           [2.]])
  4074|         0|            0|            0|  0.00%|
  4075|         0|            0|            0|  0.00%|    >>> m = np.percentile(a, 50, axis=0)
  4076|         0|            0|            0|  0.00%|    >>> out = np.zeros_like(m)
  4077|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=0, out=out)
  4078|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  4079|         0|            0|            0|  0.00%|    >>> m
  4080|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  4081|         0|            0|            0|  0.00%|
  4082|         0|            0|            0|  0.00%|    >>> b = a.copy()
  4083|         0|            0|            0|  0.00%|    >>> np.percentile(b, 50, axis=1, overwrite_input=True)
  4084|         0|            0|            0|  0.00%|    array([7.,  2.])
  4085|         0|            0|            0|  0.00%|    >>> assert not np.all(a == b)
  4086|         0|            0|            0|  0.00%|
  4087|         0|            0|            0|  0.00%|    The different methods can be visualized graphically:
  4088|         0|            0|            0|  0.00%|
  4089|         0|            0|            0|  0.00%|    .. plot::
  4090|         0|            0|            0|  0.00%|
  4091|         0|            0|            0|  0.00%|        import matplotlib.pyplot as plt
  4092|         0|            0|            0|  0.00%|
  4093|         0|            0|            0|  0.00%|        a = np.arange(4)
  4094|         0|            0|            0|  0.00%|        p = np.linspace(0, 100, 6001)
  4095|         0|            0|            0|  0.00%|        ax = plt.gca()
  4096|         0|            0|            0|  0.00%|        lines = [
  4097|         0|            0|            0|  0.00%|            ('linear', '-', 'C0'),
  4098|         0|            0|            0|  0.00%|            ('inverted_cdf', ':', 'C1'),
  4099|         0|            0|            0|  0.00%|            # Almost the same as `inverted_cdf`:
  4100|         0|            0|            0|  0.00%|            ('averaged_inverted_cdf', '-.', 'C1'),
  4101|         0|            0|            0|  0.00%|            ('closest_observation', ':', 'C2'),
  4102|         0|            0|            0|  0.00%|            ('interpolated_inverted_cdf', '--', 'C1'),
  4103|         0|            0|            0|  0.00%|            ('hazen', '--', 'C3'),
  4104|         0|            0|            0|  0.00%|            ('weibull', '-.', 'C4'),
  4105|         0|            0|            0|  0.00%|            ('median_unbiased', '--', 'C5'),
  4106|         0|            0|            0|  0.00%|            ('normal_unbiased', '-.', 'C6'),
  4107|         0|            0|            0|  0.00%|            ]
  4108|         0|            0|            0|  0.00%|        for method, style, color in lines:
  4109|         0|            0|            0|  0.00%|            ax.plot(
  4110|         0|            0|            0|  0.00%|                p, np.percentile(a, p, method=method),
  4111|         0|            0|            0|  0.00%|                label=method, linestyle=style, color=color)
  4112|         0|            0|            0|  0.00%|        ax.set(
  4113|         0|            0|            0|  0.00%|            title='Percentiles for different methods and data: ' + str(a),
  4114|         0|            0|            0|  0.00%|            xlabel='Percentile',
  4115|         0|            0|            0|  0.00%|            ylabel='Estimated percentile value',
  4116|         0|            0|            0|  0.00%|            yticks=a)
  4117|         0|            0|            0|  0.00%|        ax.legend()
  4118|         0|            0|            0|  0.00%|        plt.show()
  4119|         0|            0|            0|  0.00%|
  4120|         0|            0|            0|  0.00%|    References
  4121|         0|            0|            0|  0.00%|    ----------
  4122|         0|            0|            0|  0.00%|    .. [1] R. J. Hyndman and Y. Fan,
  4123|         0|            0|            0|  0.00%|       "Sample quantiles in statistical packages,"
  4124|         0|            0|            0|  0.00%|       The American Statistician, 50(4), pp. 361-365, 1996
  4125|         0|            0|            0|  0.00%|
  4126|         0|            0|            0|  0.00%|    """
  4127|         0|            0|            0|  0.00%|    if interpolation is not None:
  4128|         0|            0|            0|  0.00%|        method = _check_interpolation_as_method(
  4129|         0|            0|            0|  0.00%|            method, interpolation, "percentile")
  4130|         0|            0|            0|  0.00%|    q = np.true_divide(q, 100)
  4131|         0|            0|            0|  0.00%|    q = asanyarray(q)  # undo any decay that the ufunc performed (see gh-13105)
  4132|         0|            0|            0|  0.00%|    if not _quantile_is_valid(q):
  4133|         0|            0|            0|  0.00%|        raise ValueError("Percentiles must be in the range [0, 100]")
  4134|         0|            0|            0|  0.00%|    return _quantile_unchecked(
  4135|         0|            0|            0|  0.00%|        a, q, axis, out, overwrite_input, method, keepdims)
  4136|         0|            0|            0|  0.00%|
  4137|         0|            0|            0|  0.00%|
  4138|         0|            0|            0|  0.00%|def _quantile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,
  4139|         0|            0|            0|  0.00%|                         method=None, keepdims=None, *, interpolation=None):
  4140|         0|            0|            0|  0.00%|    return (a, q, out)
  4141|         0|            0|            0|  0.00%|
  4142|         0|            0|            0|  0.00%|
  4143|         0|            0|            0|  0.00%|@array_function_dispatch(_quantile_dispatcher)
  4144|         0|            0|            0|  0.00%|def quantile(a,
  4145|         0|            0|            0|  0.00%|             q,
  4146|         0|            0|            0|  0.00%|             axis=None,
  4147|         0|            0|            0|  0.00%|             out=None,
  4148|         0|            0|            0|  0.00%|             overwrite_input=False,
  4149|         0|            0|            0|  0.00%|             method="linear",
  4150|         0|            0|            0|  0.00%|             keepdims=False,
  4151|         0|            0|            0|  0.00%|             *,
  4152|         0|            0|            0|  0.00%|             interpolation=None):
  4153|         0|            0|            0|  0.00%|    """
  4154|         0|            0|            0|  0.00%|    Compute the q-th quantile of the data along the specified axis.
  4155|         0|            0|            0|  0.00%|
  4156|         0|            0|            0|  0.00%|    .. versionadded:: 1.15.0
  4157|         0|            0|            0|  0.00%|
  4158|         0|            0|            0|  0.00%|    Parameters
  4159|         0|            0|            0|  0.00%|    ----------
  4160|         0|            0|            0|  0.00%|    a : array_like
  4161|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  4162|         0|            0|            0|  0.00%|    q : array_like of float
  4163|         0|            0|            0|  0.00%|        Quantile or sequence of quantiles to compute, which must be between
  4164|         0|            0|            0|  0.00%|        0 and 1 inclusive.
  4165|         0|            0|            0|  0.00%|    axis : {int, tuple of int, None}, optional
  4166|         0|            0|            0|  0.00%|        Axis or axes along which the quantiles are computed. The default is
  4167|         0|            0|            0|  0.00%|        to compute the quantile(s) along a flattened version of the array.
  4168|         0|            0|            0|  0.00%|    out : ndarray, optional
  4169|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  4170|         0|            0|            0|  0.00%|        the same shape and buffer length as the expected output, but the
  4171|         0|            0|            0|  0.00%|        type (of the output) will be cast if necessary.
  4172|         0|            0|            0|  0.00%|    overwrite_input : bool, optional
  4173|         0|            0|            0|  0.00%|        If True, then allow the input array `a` to be modified by
  4174|         0|            0|            0|  0.00%|        intermediate calculations, to save memory. In this case, the
  4175|         0|            0|            0|  0.00%|        contents of the input `a` after this function completes is
  4176|         0|            0|            0|  0.00%|        undefined.
  4177|         0|            0|            0|  0.00%|    method : str, optional
  4178|         0|            0|            0|  0.00%|        This parameter specifies the method to use for estimating the
  4179|         0|            0|            0|  0.00%|        quantile.  There are many different methods, some unique to NumPy.
  4180|         0|            0|            0|  0.00%|        See the notes for explanation.  The options sorted by their R type
  4181|         0|            0|            0|  0.00%|        as summarized in the H&F paper [1]_ are:
  4182|         0|            0|            0|  0.00%|
  4183|         0|            0|            0|  0.00%|        1. 'inverted_cdf'
  4184|         0|            0|            0|  0.00%|        2. 'averaged_inverted_cdf'
  4185|         0|            0|            0|  0.00%|        3. 'closest_observation'
  4186|         0|            0|            0|  0.00%|        4. 'interpolated_inverted_cdf'
  4187|         0|            0|            0|  0.00%|        5. 'hazen'
  4188|         0|            0|            0|  0.00%|        6. 'weibull'
  4189|         0|            0|            0|  0.00%|        7. 'linear'  (default)
  4190|         0|            0|            0|  0.00%|        8. 'median_unbiased'
  4191|         0|            0|            0|  0.00%|        9. 'normal_unbiased'
  4192|         0|            0|            0|  0.00%|
  4193|         0|            0|            0|  0.00%|        The first three methods are discontiuous.  NumPy further defines the
  4194|         0|            0|            0|  0.00%|        following discontinuous variations of the default 'linear' (7.) option:
  4195|         0|            0|            0|  0.00%|
  4196|         0|            0|            0|  0.00%|        * 'lower'
  4197|         0|            0|            0|  0.00%|        * 'higher',
  4198|         0|            0|            0|  0.00%|        * 'midpoint'
  4199|         0|            0|            0|  0.00%|        * 'nearest'
  4200|         0|            0|            0|  0.00%|
  4201|         0|            0|            0|  0.00%|        .. versionchanged:: 1.22.0
  4202|         0|            0|            0|  0.00%|            This argument was previously called "interpolation" and only
  4203|         0|            0|            0|  0.00%|            offered the "linear" default and last four options.
  4204|         0|            0|            0|  0.00%|
  4205|         0|            0|            0|  0.00%|    keepdims : bool, optional
  4206|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left in
  4207|         0|            0|            0|  0.00%|        the result as dimensions with size one. With this option, the
  4208|         0|            0|            0|  0.00%|        result will broadcast correctly against the original array `a`.
  4209|         0|            0|            0|  0.00%|
  4210|         0|            0|            0|  0.00%|    interpolation : str, optional
  4211|         0|            0|            0|  0.00%|        Deprecated name for the method keyword argument.
  4212|         0|            0|            0|  0.00%|
  4213|         0|            0|            0|  0.00%|        .. deprecated:: 1.22.0
  4214|         0|            0|            0|  0.00%|
  4215|         0|            0|            0|  0.00%|    Returns
  4216|         0|            0|            0|  0.00%|    -------
  4217|         0|            0|            0|  0.00%|    quantile : scalar or ndarray
  4218|         0|            0|            0|  0.00%|        If `q` is a single quantile and `axis=None`, then the result
  4219|         0|            0|            0|  0.00%|        is a scalar. If multiple quantiles are given, first axis of
  4220|         0|            0|            0|  0.00%|        the result corresponds to the quantiles. The other axes are
  4221|         0|            0|            0|  0.00%|        the axes that remain after the reduction of `a`. If the input
  4222|         0|            0|            0|  0.00%|        contains integers or floats smaller than ``float64``, the output
  4223|         0|            0|            0|  0.00%|        data-type is ``float64``. Otherwise, the output data-type is the
  4224|         0|            0|            0|  0.00%|        same as that of the input. If `out` is specified, that array is
  4225|         0|            0|            0|  0.00%|        returned instead.
  4226|         0|            0|            0|  0.00%|
  4227|         0|            0|            0|  0.00%|    See Also
  4228|         0|            0|            0|  0.00%|    --------
  4229|         0|            0|            0|  0.00%|    mean
  4230|         0|            0|            0|  0.00%|    percentile : equivalent to quantile, but with q in the range [0, 100].
  4231|         0|            0|            0|  0.00%|    median : equivalent to ``quantile(..., 0.5)``
  4232|         0|            0|            0|  0.00%|    nanquantile
  4233|         0|            0|            0|  0.00%|
  4234|         0|            0|            0|  0.00%|    Notes
  4235|         0|            0|            0|  0.00%|    -----
  4236|         0|            0|            0|  0.00%|    Given a vector ``V`` of length ``N``, the q-th quantile of ``V`` is the
  4237|         0|            0|            0|  0.00%|    value ``q`` of the way from the minimum to the maximum in a sorted copy of
  4238|         0|            0|            0|  0.00%|    ``V``. The values and distances of the two nearest neighbors as well as the
  4239|         0|            0|            0|  0.00%|    `method` parameter will determine the quantile if the normalized
  4240|         0|            0|            0|  0.00%|    ranking does not match the location of ``q`` exactly. This function is the
  4241|         0|            0|            0|  0.00%|    same as the median if ``q=0.5``, the same as the minimum if ``q=0.0`` and
  4242|         0|            0|            0|  0.00%|    the same as the maximum if ``q=1.0``.
  4243|         0|            0|            0|  0.00%|
  4244|         0|            0|            0|  0.00%|    This optional `method` parameter specifies the method to use when the
  4245|         0|            0|            0|  0.00%|    desired quantile lies between two data points ``i < j``.
  4246|         0|            0|            0|  0.00%|    If ``g`` is the fractional part of the index surrounded by ``i`` and
  4247|         0|            0|            0|  0.00%|    alpha and beta are correction constants modifying i and j.
  4248|         0|            0|            0|  0.00%|
  4249|         0|            0|            0|  0.00%|    .. math::
  4250|         0|            0|            0|  0.00%|        i + g = (q - alpha) / ( n - alpha - beta + 1 )
  4251|         0|            0|            0|  0.00%|
  4252|         0|            0|            0|  0.00%|    The different methods then work as follows
  4253|         0|            0|            0|  0.00%|
  4254|         0|            0|            0|  0.00%|    inverted_cdf:
  4255|         0|            0|            0|  0.00%|        method 1 of H&F [1]_.
  4256|         0|            0|            0|  0.00%|        This method gives discontinuous results:
  4257|         0|            0|            0|  0.00%|        * if g > 0 ; then take j
  4258|         0|            0|            0|  0.00%|        * if g = 0 ; then take i
  4259|         0|            0|            0|  0.00%|
  4260|         0|            0|            0|  0.00%|    averaged_inverted_cdf:
  4261|         0|            0|            0|  0.00%|        method 2 of H&F [1]_.
  4262|         0|            0|            0|  0.00%|        This method give discontinuous results:
  4263|         0|            0|            0|  0.00%|        * if g > 0 ; then take j
  4264|         0|            0|            0|  0.00%|        * if g = 0 ; then average between bounds
  4265|         0|            0|            0|  0.00%|
  4266|         0|            0|            0|  0.00%|    closest_observation:
  4267|         0|            0|            0|  0.00%|        method 3 of H&F [1]_.
  4268|         0|            0|            0|  0.00%|        This method give discontinuous results:
  4269|         0|            0|            0|  0.00%|        * if g > 0 ; then take j
  4270|         0|            0|            0|  0.00%|        * if g = 0 and index is odd ; then take j
  4271|         0|            0|            0|  0.00%|        * if g = 0 and index is even ; then take i
  4272|         0|            0|            0|  0.00%|
  4273|         0|            0|            0|  0.00%|    interpolated_inverted_cdf:
  4274|         0|            0|            0|  0.00%|        method 4 of H&F [1]_.
  4275|         0|            0|            0|  0.00%|        This method give continuous results using:
  4276|         0|            0|            0|  0.00%|        * alpha = 0
  4277|         0|            0|            0|  0.00%|        * beta = 1
  4278|         0|            0|            0|  0.00%|
  4279|         0|            0|            0|  0.00%|    hazen:
  4280|         0|            0|            0|  0.00%|        method 5 of H&F [1]_.
  4281|         0|            0|            0|  0.00%|        This method give continuous results using:
  4282|         0|            0|            0|  0.00%|        * alpha = 1/2
  4283|         0|            0|            0|  0.00%|        * beta = 1/2
  4284|         0|            0|            0|  0.00%|
  4285|         0|            0|            0|  0.00%|    weibull:
  4286|         0|            0|            0|  0.00%|        method 6 of H&F [1]_.
  4287|         0|            0|            0|  0.00%|        This method give continuous results using:
  4288|         0|            0|            0|  0.00%|        * alpha = 0
  4289|         0|            0|            0|  0.00%|        * beta = 0
  4290|         0|            0|            0|  0.00%|
  4291|         0|            0|            0|  0.00%|    linear:
  4292|         0|            0|            0|  0.00%|        method 7 of H&F [1]_.
  4293|         0|            0|            0|  0.00%|        This method give continuous results using:
  4294|         0|            0|            0|  0.00%|        * alpha = 1
  4295|         0|            0|            0|  0.00%|        * beta = 1
  4296|         0|            0|            0|  0.00%|
  4297|         0|            0|            0|  0.00%|    median_unbiased:
  4298|         0|            0|            0|  0.00%|        method 8 of H&F [1]_.
  4299|         0|            0|            0|  0.00%|        This method is probably the best method if the sample
  4300|         0|            0|            0|  0.00%|        distribution function is unknown (see reference).
  4301|         0|            0|            0|  0.00%|        This method give continuous results using:
  4302|         0|            0|            0|  0.00%|        * alpha = 1/3
  4303|         0|            0|            0|  0.00%|        * beta = 1/3
  4304|         0|            0|            0|  0.00%|
  4305|         0|            0|            0|  0.00%|    normal_unbiased:
  4306|         0|            0|            0|  0.00%|        method 9 of H&F [1]_.
  4307|         0|            0|            0|  0.00%|        This method is probably the best method if the sample
  4308|         0|            0|            0|  0.00%|        distribution function is known to be normal.
  4309|         0|            0|            0|  0.00%|        This method give continuous results using:
  4310|         0|            0|            0|  0.00%|        * alpha = 3/8
  4311|         0|            0|            0|  0.00%|        * beta = 3/8
  4312|         0|            0|            0|  0.00%|
  4313|         0|            0|            0|  0.00%|    lower:
  4314|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4315|         0|            0|            0|  0.00%|        Takes ``i`` as the interpolation point.
  4316|         0|            0|            0|  0.00%|
  4317|         0|            0|            0|  0.00%|    higher:
  4318|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4319|         0|            0|            0|  0.00%|        Takes ``j`` as the interpolation point.
  4320|         0|            0|            0|  0.00%|
  4321|         0|            0|            0|  0.00%|    nearest:
  4322|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4323|         0|            0|            0|  0.00%|        Takes ``i`` or ``j``, whichever is nearest.
  4324|         0|            0|            0|  0.00%|
  4325|         0|            0|            0|  0.00%|    midpoint:
  4326|         0|            0|            0|  0.00%|        NumPy method kept for backwards compatibility.
  4327|         0|            0|            0|  0.00%|        Uses ``(i + j) / 2``.
  4328|         0|            0|            0|  0.00%|
  4329|         0|            0|            0|  0.00%|    Examples
  4330|         0|            0|            0|  0.00%|    --------
  4331|         0|            0|            0|  0.00%|    >>> a = np.array([[10, 7, 4], [3, 2, 1]])
  4332|         0|            0|            0|  0.00%|    >>> a
  4333|         0|            0|            0|  0.00%|    array([[10,  7,  4],
  4334|         0|            0|            0|  0.00%|           [ 3,  2,  1]])
  4335|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5)
  4336|         0|            0|            0|  0.00%|    3.5
  4337|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=0)
  4338|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  4339|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=1)
  4340|         0|            0|            0|  0.00%|    array([7.,  2.])
  4341|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=1, keepdims=True)
  4342|         0|            0|            0|  0.00%|    array([[7.],
  4343|         0|            0|            0|  0.00%|           [2.]])
  4344|         0|            0|            0|  0.00%|    >>> m = np.quantile(a, 0.5, axis=0)
  4345|         0|            0|            0|  0.00%|    >>> out = np.zeros_like(m)
  4346|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=0, out=out)
  4347|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  4348|         0|            0|            0|  0.00%|    >>> m
  4349|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  4350|         0|            0|            0|  0.00%|    >>> b = a.copy()
  4351|         0|            0|            0|  0.00%|    >>> np.quantile(b, 0.5, axis=1, overwrite_input=True)
  4352|         0|            0|            0|  0.00%|    array([7.,  2.])
  4353|         0|            0|            0|  0.00%|    >>> assert not np.all(a == b)
  4354|         0|            0|            0|  0.00%|
  4355|         0|            0|            0|  0.00%|    See also `numpy.percentile` for a visualization of most methods.
  4356|         0|            0|            0|  0.00%|
  4357|         0|            0|            0|  0.00%|    References
  4358|         0|            0|            0|  0.00%|    ----------
  4359|         0|            0|            0|  0.00%|    .. [1] R. J. Hyndman and Y. Fan,
  4360|         0|            0|            0|  0.00%|       "Sample quantiles in statistical packages,"
  4361|         0|            0|            0|  0.00%|       The American Statistician, 50(4), pp. 361-365, 1996
  4362|         0|            0|            0|  0.00%|
  4363|         0|            0|            0|  0.00%|    """
  4364|         0|            0|            0|  0.00%|    if interpolation is not None:
  4365|         0|            0|            0|  0.00%|        method = _check_interpolation_as_method(
  4366|         0|            0|            0|  0.00%|            method, interpolation, "quantile")
  4367|         0|            0|            0|  0.00%|
  4368|         0|            0|            0|  0.00%|    q = np.asanyarray(q)
  4369|         0|            0|            0|  0.00%|    if not _quantile_is_valid(q):
  4370|         0|            0|            0|  0.00%|        raise ValueError("Quantiles must be in the range [0, 1]")
  4371|         0|            0|            0|  0.00%|    return _quantile_unchecked(
  4372|         0|            0|            0|  0.00%|        a, q, axis, out, overwrite_input, method, keepdims)
  4373|         0|            0|            0|  0.00%|
  4374|         0|            0|            0|  0.00%|
  4375|         0|            0|            0|  0.00%|def _quantile_unchecked(a,
  4376|         0|            0|            0|  0.00%|                        q,
  4377|         0|            0|            0|  0.00%|                        axis=None,
  4378|         0|            0|            0|  0.00%|                        out=None,
  4379|         0|            0|            0|  0.00%|                        overwrite_input=False,
  4380|         0|            0|            0|  0.00%|                        method="linear",
  4381|         0|            0|            0|  0.00%|                        keepdims=False):
  4382|         0|            0|            0|  0.00%|    """Assumes that q is in [0, 1], and is an ndarray"""
  4383|         0|            0|            0|  0.00%|    r, k = _ureduce(a,
  4384|         0|            0|            0|  0.00%|                    func=_quantile_ureduce_func,
  4385|         0|            0|            0|  0.00%|                    q=q,
  4386|         0|            0|            0|  0.00%|                    axis=axis,
  4387|         0|            0|            0|  0.00%|                    out=out,
  4388|         0|            0|            0|  0.00%|                    overwrite_input=overwrite_input,
  4389|         0|            0|            0|  0.00%|                    method=method)
  4390|         0|            0|            0|  0.00%|    if keepdims:
  4391|         0|            0|            0|  0.00%|        return r.reshape(q.shape + k)
  4392|         0|            0|            0|  0.00%|    else:
  4393|         0|            0|            0|  0.00%|        return r
  4394|         0|            0|            0|  0.00%|
  4395|         0|            0|            0|  0.00%|
  4396|         0|            0|            0|  0.00%|def _quantile_is_valid(q):
  4397|         0|            0|            0|  0.00%|    # avoid expensive reductions, relevant for arrays with < O(1000) elements
  4398|         0|            0|            0|  0.00%|    if q.ndim == 1 and q.size < 10:
  4399|         0|            0|            0|  0.00%|        for i in range(q.size):
  4400|         0|            0|            0|  0.00%|            if not (0.0 <= q[i] <= 1.0):
  4401|         0|            0|            0|  0.00%|                return False
  4402|         0|            0|            0|  0.00%|    else:
  4403|         0|            0|            0|  0.00%|        if not (np.all(0 <= q) and np.all(q <= 1)):
  4404|         0|            0|            0|  0.00%|            return False
  4405|         0|            0|            0|  0.00%|    return True
  4406|         0|            0|            0|  0.00%|
  4407|         0|            0|            0|  0.00%|
  4408|         0|            0|            0|  0.00%|def _check_interpolation_as_method(method, interpolation, fname):
  4409|         0|            0|            0|  0.00%|    # Deprecated NumPy 1.22, 2021-11-08
  4410|         0|            0|            0|  0.00%|    warnings.warn(
  4411|         0|            0|            0|  0.00%|        f"the `interpolation=` argument to {fname} was renamed to "
  4412|         0|            0|            0|  0.00%|        "`method=`, which has additional options.\n"
  4413|         0|            0|            0|  0.00%|        "Users of the modes 'nearest', 'lower', 'higher', or "
  4414|         0|            0|            0|  0.00%|        "'midpoint' are encouraged to review the method they. "
  4415|         0|            0|            0|  0.00%|        "(Deprecated NumPy 1.22)",
  4416|         0|            0|            0|  0.00%|        DeprecationWarning, stacklevel=4)
  4417|         0|            0|            0|  0.00%|    if method != "linear":
  4418|         0|            0|            0|  0.00%|        # sanity check, we assume this basically never happens
  4419|         0|            0|            0|  0.00%|        raise TypeError(
  4420|         0|            0|            0|  0.00%|            "You shall not pass both `method` and `interpolation`!\n"
  4421|         0|            0|            0|  0.00%|            "(`interpolation` is Deprecated in favor of `method`)")
  4422|         0|            0|            0|  0.00%|    return interpolation
  4423|         0|            0|            0|  0.00%|
  4424|         0|            0|            0|  0.00%|
  4425|         0|            0|            0|  0.00%|def _compute_virtual_index(n, quantiles, alpha: float, beta: float):
  4426|         0|            0|            0|  0.00%|    """
  4427|         0|            0|            0|  0.00%|    Compute the floating point indexes of an array for the linear
  4428|         0|            0|            0|  0.00%|    interpolation of quantiles.
  4429|         0|            0|            0|  0.00%|    n : array_like
  4430|         0|            0|            0|  0.00%|        The sample sizes.
  4431|         0|            0|            0|  0.00%|    quantiles : array_like
  4432|         0|            0|            0|  0.00%|        The quantiles values.
  4433|         0|            0|            0|  0.00%|    alpha : float
  4434|         0|            0|            0|  0.00%|        A constant used to correct the index computed.
  4435|         0|            0|            0|  0.00%|    beta : float
  4436|         0|            0|            0|  0.00%|        A constant used to correct the index computed.
  4437|         0|            0|            0|  0.00%|
  4438|         0|            0|            0|  0.00%|    alpha and beta values depend on the chosen method
  4439|         0|            0|            0|  0.00%|    (see quantile documentation)
  4440|         0|            0|            0|  0.00%|
  4441|         0|            0|            0|  0.00%|    Reference:
  4442|         0|            0|            0|  0.00%|    Hyndman&Fan paper "Sample Quantiles in Statistical Packages",
  4443|         0|            0|            0|  0.00%|    DOI: 10.1080/00031305.1996.10473566
  4444|         0|            0|            0|  0.00%|    """
  4445|         0|            0|            0|  0.00%|    return n * quantiles + (
  4446|         0|            0|            0|  0.00%|            alpha + quantiles * (1 - alpha - beta)
  4447|         0|            0|            0|  0.00%|    ) - 1
  4448|         0|            0|            0|  0.00%|
  4449|         0|            0|            0|  0.00%|
  4450|         0|            0|            0|  0.00%|def _get_gamma(virtual_indexes, previous_indexes, method):
  4451|         0|            0|            0|  0.00%|    """
  4452|         0|            0|            0|  0.00%|    Compute gamma (a.k.a 'm' or 'weight') for the linear interpolation
  4453|         0|            0|            0|  0.00%|    of quantiles.
  4454|         0|            0|            0|  0.00%|
  4455|         0|            0|            0|  0.00%|    virtual_indexes : array_like
  4456|         0|            0|            0|  0.00%|        The indexes where the percentile is supposed to be found in the sorted
  4457|         0|            0|            0|  0.00%|        sample.
  4458|         0|            0|            0|  0.00%|    previous_indexes : array_like
  4459|         0|            0|            0|  0.00%|        The floor values of virtual_indexes.
  4460|         0|            0|            0|  0.00%|    interpolation : dict
  4461|         0|            0|            0|  0.00%|        The interpolation method chosen, which may have a specific rule
  4462|         0|            0|            0|  0.00%|        modifying gamma.
  4463|         0|            0|            0|  0.00%|
  4464|         0|            0|            0|  0.00%|    gamma is usually the fractional part of virtual_indexes but can be modified
  4465|         0|            0|            0|  0.00%|    by the interpolation method.
  4466|         0|            0|            0|  0.00%|    """
  4467|         0|            0|            0|  0.00%|    gamma = np.asanyarray(virtual_indexes - previous_indexes)
  4468|         0|            0|            0|  0.00%|    gamma = method["fix_gamma"](gamma, virtual_indexes)
  4469|         0|            0|            0|  0.00%|    return np.asanyarray(gamma)
  4470|         0|            0|            0|  0.00%|
  4471|         0|            0|            0|  0.00%|
  4472|         0|            0|            0|  0.00%|def _lerp(a, b, t, out=None):
  4473|         0|            0|            0|  0.00%|    """
  4474|         0|            0|            0|  0.00%|    Compute the linear interpolation weighted by gamma on each point of
  4475|         0|            0|            0|  0.00%|    two same shape array.
  4476|         0|            0|            0|  0.00%|
  4477|         0|            0|            0|  0.00%|    a : array_like
  4478|         0|            0|            0|  0.00%|        Left bound.
  4479|         0|            0|            0|  0.00%|    b : array_like
  4480|         0|            0|            0|  0.00%|        Right bound.
  4481|         0|            0|            0|  0.00%|    t : array_like
  4482|         0|            0|            0|  0.00%|        The interpolation weight.
  4483|         0|            0|            0|  0.00%|    out : array_like
  4484|         0|            0|            0|  0.00%|        Output array.
  4485|         0|            0|            0|  0.00%|    """
  4486|         0|            0|            0|  0.00%|    diff_b_a = subtract(b, a)
  4487|         0|            0|            0|  0.00%|    # asanyarray is a stop-gap until gh-13105
  4488|         0|            0|            0|  0.00%|    lerp_interpolation = asanyarray(add(a, diff_b_a * t, out=out))
  4489|         0|            0|            0|  0.00%|    subtract(b, diff_b_a * (1 - t), out=lerp_interpolation, where=t >= 0.5)
  4490|         0|            0|            0|  0.00%|    if lerp_interpolation.ndim == 0 and out is None:
  4491|         0|            0|            0|  0.00%|        lerp_interpolation = lerp_interpolation[()]  # unpack 0d arrays
  4492|         0|            0|            0|  0.00%|    return lerp_interpolation
  4493|         0|            0|            0|  0.00%|
  4494|         0|            0|            0|  0.00%|
  4495|         0|            0|            0|  0.00%|def _get_gamma_mask(shape, default_value, conditioned_value, where):
  4496|         0|            0|            0|  0.00%|    out = np.full(shape, default_value)
  4497|         0|            0|            0|  0.00%|    np.copyto(out, conditioned_value, where=where, casting="unsafe")
  4498|         0|            0|            0|  0.00%|    return out
  4499|         0|            0|            0|  0.00%|
  4500|         0|            0|            0|  0.00%|
  4501|         0|            0|            0|  0.00%|def _discret_interpolation_to_boundaries(index, gamma_condition_fun):
  4502|         0|            0|            0|  0.00%|    previous = np.floor(index)
  4503|         0|            0|            0|  0.00%|    next = previous + 1
  4504|         0|            0|            0|  0.00%|    gamma = index - previous
  4505|         0|            0|            0|  0.00%|    res = _get_gamma_mask(shape=index.shape,
  4506|         0|            0|            0|  0.00%|                          default_value=next,
  4507|         0|            0|            0|  0.00%|                          conditioned_value=previous,
  4508|         0|            0|            0|  0.00%|                          where=gamma_condition_fun(gamma, index)
  4509|         0|            0|            0|  0.00%|                          ).astype(np.intp)
  4510|         0|            0|            0|  0.00%|    # Some methods can lead to out-of-bound integers, clip them:
  4511|         0|            0|            0|  0.00%|    res[res < 0] = 0
  4512|         0|            0|            0|  0.00%|    return res
  4513|         0|            0|            0|  0.00%|
  4514|         0|            0|            0|  0.00%|
  4515|         0|            0|            0|  0.00%|def _closest_observation(n, quantiles):
  4516|         0|            0|            0|  0.00%|    gamma_fun = lambda gamma, index: (gamma == 0) & (np.floor(index) % 2 == 0)
  4517|         0|            0|            0|  0.00%|    return _discret_interpolation_to_boundaries((n * quantiles) - 1 - 0.5,
  4518|         0|            0|            0|  0.00%|                                                gamma_fun)
  4519|         0|            0|            0|  0.00%|
  4520|         0|            0|            0|  0.00%|
  4521|         0|            0|            0|  0.00%|def _inverted_cdf(n, quantiles):
  4522|         0|            0|            0|  0.00%|    gamma_fun = lambda gamma, _: (gamma == 0)
  4523|         0|            0|            0|  0.00%|    return _discret_interpolation_to_boundaries((n * quantiles) - 1,
  4524|         0|            0|            0|  0.00%|                                                gamma_fun)
  4525|         0|            0|            0|  0.00%|
  4526|         0|            0|            0|  0.00%|
  4527|         0|            0|            0|  0.00%|def _quantile_ureduce_func(
  4528|         0|            0|            0|  0.00%|        a: np.array,
  4529|         0|            0|            0|  0.00%|        q: np.array,
  4530|         0|            0|            0|  0.00%|        axis: int = None,
  4531|         0|            0|            0|  0.00%|        out=None,
  4532|         0|            0|            0|  0.00%|        overwrite_input: bool = False,
  4533|         0|            0|            0|  0.00%|        method="linear",
  4534|         0|            0|            0|  0.00%|) -> np.array:
  4535|         0|            0|            0|  0.00%|    if q.ndim > 2:
  4536|         0|            0|            0|  0.00%|        # The code below works fine for nd, but it might not have useful
  4537|         0|            0|            0|  0.00%|        # semantics. For now, keep the supported dimensions the same as it was
  4538|         0|            0|            0|  0.00%|        # before.
  4539|         0|            0|            0|  0.00%|        raise ValueError("q must be a scalar or 1d")
  4540|         0|            0|            0|  0.00%|    if overwrite_input:
  4541|         0|            0|            0|  0.00%|        if axis is None:
  4542|         0|            0|            0|  0.00%|            axis = 0
  4543|         0|            0|            0|  0.00%|            arr = a.ravel()
  4544|         0|            0|            0|  0.00%|        else:
  4545|         0|            0|            0|  0.00%|            arr = a
  4546|         0|            0|            0|  0.00%|    else:
  4547|         0|            0|            0|  0.00%|        if axis is None:
  4548|         0|            0|            0|  0.00%|            axis = 0
  4549|         0|            0|            0|  0.00%|            arr = a.flatten()
  4550|         0|            0|            0|  0.00%|        else:
  4551|         0|            0|            0|  0.00%|            arr = a.copy()
  4552|         0|            0|            0|  0.00%|    result = _quantile(arr,
  4553|         0|            0|            0|  0.00%|                       quantiles=q,
  4554|         0|            0|            0|  0.00%|                       axis=axis,
  4555|         0|            0|            0|  0.00%|                       method=method,
  4556|         0|            0|            0|  0.00%|                       out=out)
  4557|         0|            0|            0|  0.00%|    return result
  4558|         0|            0|            0|  0.00%|
  4559|         0|            0|            0|  0.00%|
  4560|         0|            0|            0|  0.00%|def _get_indexes(arr, virtual_indexes, valid_values_count):
  4561|         0|            0|            0|  0.00%|    """
  4562|         0|            0|            0|  0.00%|    Get the valid indexes of arr neighbouring virtual_indexes.
  4563|         0|            0|            0|  0.00%|    Note
  4564|         0|            0|            0|  0.00%|    This is a companion function to linear interpolation of
  4565|         0|            0|            0|  0.00%|    Quantiles
  4566|         0|            0|            0|  0.00%|
  4567|         0|            0|            0|  0.00%|    Returns
  4568|         0|            0|            0|  0.00%|    -------
  4569|         0|            0|            0|  0.00%|    (previous_indexes, next_indexes): Tuple
  4570|         0|            0|            0|  0.00%|        A Tuple of virtual_indexes neighbouring indexes
  4571|         0|            0|            0|  0.00%|    """
  4572|         0|            0|            0|  0.00%|    previous_indexes = np.asanyarray(np.floor(virtual_indexes))
  4573|         0|            0|            0|  0.00%|    next_indexes = np.asanyarray(previous_indexes + 1)
  4574|         0|            0|            0|  0.00%|    indexes_above_bounds = virtual_indexes >= valid_values_count - 1
  4575|         0|            0|            0|  0.00%|    # When indexes is above max index, take the max value of the array
  4576|         0|            0|            0|  0.00%|    if indexes_above_bounds.any():
  4577|         0|            0|            0|  0.00%|        previous_indexes[indexes_above_bounds] = -1
  4578|         0|            0|            0|  0.00%|        next_indexes[indexes_above_bounds] = -1
  4579|         0|            0|            0|  0.00%|    # When indexes is below min index, take the min value of the array
  4580|         0|            0|            0|  0.00%|    indexes_below_bounds = virtual_indexes < 0
  4581|         0|            0|            0|  0.00%|    if indexes_below_bounds.any():
  4582|         0|            0|            0|  0.00%|        previous_indexes[indexes_below_bounds] = 0
  4583|         0|            0|            0|  0.00%|        next_indexes[indexes_below_bounds] = 0
  4584|         0|            0|            0|  0.00%|    if np.issubdtype(arr.dtype, np.inexact):
  4585|         0|            0|            0|  0.00%|        # After the sort, slices having NaNs will have for last element a NaN
  4586|         0|            0|            0|  0.00%|        virtual_indexes_nans = np.isnan(virtual_indexes)
  4587|         0|            0|            0|  0.00%|        if virtual_indexes_nans.any():
  4588|         0|            0|            0|  0.00%|            previous_indexes[virtual_indexes_nans] = -1
  4589|         0|            0|            0|  0.00%|            next_indexes[virtual_indexes_nans] = -1
  4590|         0|            0|            0|  0.00%|    previous_indexes = previous_indexes.astype(np.intp)
  4591|         0|            0|            0|  0.00%|    next_indexes = next_indexes.astype(np.intp)
  4592|         0|            0|            0|  0.00%|    return previous_indexes, next_indexes
  4593|         0|            0|            0|  0.00%|
  4594|         0|            0|            0|  0.00%|
  4595|         0|            0|            0|  0.00%|def _quantile(
  4596|         0|            0|            0|  0.00%|        arr: np.array,
  4597|         0|            0|            0|  0.00%|        quantiles: np.array,
  4598|         0|            0|            0|  0.00%|        axis: int = -1,
  4599|         0|            0|            0|  0.00%|        method="linear",
  4600|         0|            0|            0|  0.00%|        out=None,
  4601|         0|            0|            0|  0.00%|):
  4602|         0|            0|            0|  0.00%|    """
  4603|         0|            0|            0|  0.00%|    Private function that doesn't support extended axis or keepdims.
  4604|         0|            0|            0|  0.00%|    These methods are extended to this function using _ureduce
  4605|         0|            0|            0|  0.00%|    See nanpercentile for parameter usage
  4606|         0|            0|            0|  0.00%|    It computes the quantiles of the array for the given axis.
  4607|         0|            0|            0|  0.00%|    A linear interpolation is performed based on the `interpolation`.
  4608|         0|            0|            0|  0.00%|
  4609|         0|            0|            0|  0.00%|    By default, the method is "linear" where alpha == beta == 1 which
  4610|         0|            0|            0|  0.00%|    performs the 7th method of Hyndman&Fan.
  4611|         0|            0|            0|  0.00%|    With "median_unbiased" we get alpha == beta == 1/3
  4612|         0|            0|            0|  0.00%|    thus the 8th method of Hyndman&Fan.
  4613|         0|            0|            0|  0.00%|    """
  4614|         0|            0|            0|  0.00%|    # --- Setup
  4615|         0|            0|            0|  0.00%|    arr = np.asanyarray(arr)
  4616|         0|            0|            0|  0.00%|    values_count = arr.shape[axis]
  4617|         0|            0|            0|  0.00%|    # The dimensions of `q` are prepended to the output shape, so we need the
  4618|         0|            0|            0|  0.00%|    # axis being sampled from `arr` to be last.
  4619|         0|            0|            0|  0.00%|    DATA_AXIS = 0
  4620|         0|            0|            0|  0.00%|    if axis != DATA_AXIS:  # But moveaxis is slow, so only call it if axis!=0.
  4621|         0|            0|            0|  0.00%|        arr = np.moveaxis(arr, axis, destination=DATA_AXIS)
  4622|         0|            0|            0|  0.00%|    # --- Computation of indexes
  4623|         0|            0|            0|  0.00%|    # Index where to find the value in the sorted array.
  4624|         0|            0|            0|  0.00%|    # Virtual because it is a floating point value, not an valid index.
  4625|         0|            0|            0|  0.00%|    # The nearest neighbours are used for interpolation
  4626|         0|            0|            0|  0.00%|    try:
  4627|         0|            0|            0|  0.00%|        method = _QuantileMethods[method]
  4628|         0|            0|            0|  0.00%|    except KeyError:
  4629|         0|            0|            0|  0.00%|        raise ValueError(
  4630|         0|            0|            0|  0.00%|            f"{method!r} is not a valid method. Use one of: "
  4631|         0|            0|            0|  0.00%|            f"{_QuantileMethods.keys()}") from None
  4632|         0|            0|            0|  0.00%|    virtual_indexes = method["get_virtual_index"](values_count, quantiles)
  4633|         0|            0|            0|  0.00%|    virtual_indexes = np.asanyarray(virtual_indexes)
  4634|         0|            0|            0|  0.00%|    if np.issubdtype(virtual_indexes.dtype, np.integer):
  4635|         0|            0|            0|  0.00%|        # No interpolation needed, take the points along axis
  4636|         0|            0|            0|  0.00%|        if np.issubdtype(arr.dtype, np.inexact):
  4637|         0|            0|            0|  0.00%|            # may contain nan, which would sort to the end
  4638|         0|            0|            0|  0.00%|            arr.partition(concatenate((virtual_indexes.ravel(), [-1])), axis=0)
  4639|         0|            0|            0|  0.00%|            slices_having_nans = np.isnan(arr[-1])
  4640|         0|            0|            0|  0.00%|        else:
  4641|         0|            0|            0|  0.00%|            # cannot contain nan
  4642|         0|            0|            0|  0.00%|            arr.partition(virtual_indexes.ravel(), axis=0)
  4643|         0|            0|            0|  0.00%|            slices_having_nans = np.array(False, dtype=bool)
  4644|         0|            0|            0|  0.00%|        result = take(arr, virtual_indexes, axis=0, out=out)
  4645|         0|            0|            0|  0.00%|    else:
  4646|         0|            0|            0|  0.00%|        previous_indexes, next_indexes = _get_indexes(arr,
  4647|         0|            0|            0|  0.00%|                                                      virtual_indexes,
  4648|         0|            0|            0|  0.00%|                                                      values_count)
  4649|         0|            0|            0|  0.00%|        # --- Sorting
  4650|         0|            0|            0|  0.00%|        arr.partition(
  4651|         0|            0|            0|  0.00%|            np.unique(np.concatenate(([0, -1],
  4652|         0|            0|            0|  0.00%|                                      previous_indexes.ravel(),
  4653|         0|            0|            0|  0.00%|                                      next_indexes.ravel(),
  4654|         0|            0|            0|  0.00%|                                      ))),
  4655|         0|            0|            0|  0.00%|            axis=DATA_AXIS)
  4656|         0|            0|            0|  0.00%|        if np.issubdtype(arr.dtype, np.inexact):
  4657|         0|            0|            0|  0.00%|            slices_having_nans = np.isnan(
  4658|         0|            0|            0|  0.00%|                take(arr, indices=-1, axis=DATA_AXIS)
  4659|         0|            0|            0|  0.00%|            )
  4660|         0|            0|            0|  0.00%|        else:
  4661|         0|            0|            0|  0.00%|            slices_having_nans = None
  4662|         0|            0|            0|  0.00%|        # --- Get values from indexes
  4663|         0|            0|            0|  0.00%|        previous = np.take(arr, previous_indexes, axis=DATA_AXIS)
  4664|         0|            0|            0|  0.00%|        next = np.take(arr, next_indexes, axis=DATA_AXIS)
  4665|         0|            0|            0|  0.00%|        # --- Linear interpolation
  4666|         0|            0|            0|  0.00%|        gamma = _get_gamma(virtual_indexes, previous_indexes, method)
  4667|         0|            0|            0|  0.00%|        result_shape = virtual_indexes.shape + (1,) * (arr.ndim - 1)
  4668|         0|            0|            0|  0.00%|        gamma = gamma.reshape(result_shape)
  4669|         0|            0|            0|  0.00%|        result = _lerp(previous,
  4670|         0|            0|            0|  0.00%|                       next,
  4671|         0|            0|            0|  0.00%|                       gamma,
  4672|         0|            0|            0|  0.00%|                       out=out)
  4673|         0|            0|            0|  0.00%|    if np.any(slices_having_nans):
  4674|         0|            0|            0|  0.00%|        if result.ndim == 0 and out is None:
  4675|         0|            0|            0|  0.00%|            # can't write to a scalar
  4676|         0|            0|            0|  0.00%|            result = arr.dtype.type(np.nan)
  4677|         0|            0|            0|  0.00%|        else:
  4678|         0|            0|            0|  0.00%|            result[..., slices_having_nans] = np.nan
  4679|         0|            0|            0|  0.00%|    return result
  4680|         0|            0|            0|  0.00%|
  4681|         0|            0|            0|  0.00%|
  4682|         0|            0|            0|  0.00%|def _trapz_dispatcher(y, x=None, dx=None, axis=None):
  4683|         0|            0|            0|  0.00%|    return (y, x)
  4684|         0|            0|            0|  0.00%|
  4685|         0|            0|            0|  0.00%|
  4686|         0|            0|            0|  0.00%|@array_function_dispatch(_trapz_dispatcher)
  4687|         0|            0|            0|  0.00%|def trapz(y, x=None, dx=1.0, axis=-1):
  4688|         0|            0|            0|  0.00%|    r"""
  4689|         0|            0|            0|  0.00%|    Integrate along the given axis using the composite trapezoidal rule.
  4690|         0|            0|            0|  0.00%|
  4691|         0|            0|            0|  0.00%|    If `x` is provided, the integration happens in sequence along its
  4692|         0|            0|            0|  0.00%|    elements - they are not sorted.
  4693|         0|            0|            0|  0.00%|
  4694|         0|            0|            0|  0.00%|    Integrate `y` (`x`) along each 1d slice on the given axis, compute
  4695|         0|            0|            0|  0.00%|    :math:`\int y(x) dx`.
  4696|         0|            0|            0|  0.00%|    When `x` is specified, this integrates along the parametric curve,
  4697|         0|            0|            0|  0.00%|    computing :math:`\int_t y(t) dt =
  4698|         0|            0|            0|  0.00%|    \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`.
  4699|         0|            0|            0|  0.00%|
  4700|         0|            0|            0|  0.00%|    Parameters
  4701|         0|            0|            0|  0.00%|    ----------
  4702|         0|            0|            0|  0.00%|    y : array_like
  4703|         0|            0|            0|  0.00%|        Input array to integrate.
  4704|         0|            0|            0|  0.00%|    x : array_like, optional
  4705|         0|            0|            0|  0.00%|        The sample points corresponding to the `y` values. If `x` is None,
  4706|         0|            0|            0|  0.00%|        the sample points are assumed to be evenly spaced `dx` apart. The
  4707|         0|            0|            0|  0.00%|        default is None.
  4708|         0|            0|            0|  0.00%|    dx : scalar, optional
  4709|         0|            0|            0|  0.00%|        The spacing between sample points when `x` is None. The default is 1.
  4710|         0|            0|            0|  0.00%|    axis : int, optional
  4711|         0|            0|            0|  0.00%|        The axis along which to integrate.
  4712|         0|            0|            0|  0.00%|
  4713|         0|            0|            0|  0.00%|    Returns
  4714|         0|            0|            0|  0.00%|    -------
  4715|         0|            0|            0|  0.00%|    trapz : float or ndarray
  4716|         0|            0|            0|  0.00%|        Definite integral of 'y' = n-dimensional array as approximated along
  4717|         0|            0|            0|  0.00%|        a single axis by the trapezoidal rule. If 'y' is a 1-dimensional array,
  4718|         0|            0|            0|  0.00%|        then the result is a float. If 'n' is greater than 1, then the result
  4719|         0|            0|            0|  0.00%|        is an 'n-1' dimensional array.
  4720|         0|            0|            0|  0.00%|
  4721|         0|            0|            0|  0.00%|    See Also
  4722|         0|            0|            0|  0.00%|    --------
  4723|         0|            0|            0|  0.00%|    sum, cumsum
  4724|         0|            0|            0|  0.00%|
  4725|         0|            0|            0|  0.00%|    Notes
  4726|         0|            0|            0|  0.00%|    -----
  4727|         0|            0|            0|  0.00%|    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
  4728|         0|            0|            0|  0.00%|    will be taken from `y` array, by default x-axis distances between
  4729|         0|            0|            0|  0.00%|    points will be 1.0, alternatively they can be provided with `x` array
  4730|         0|            0|            0|  0.00%|    or with `dx` scalar.  Return value will be equal to combined area under
  4731|         0|            0|            0|  0.00%|    the red lines.
  4732|         0|            0|            0|  0.00%|
  4733|         0|            0|            0|  0.00%|
  4734|         0|            0|            0|  0.00%|    References
  4735|         0|            0|            0|  0.00%|    ----------
  4736|         0|            0|            0|  0.00%|    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule
  4737|         0|            0|            0|  0.00%|
  4738|         0|            0|            0|  0.00%|    .. [2] Illustration image:
  4739|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png
  4740|         0|            0|            0|  0.00%|
  4741|         0|            0|            0|  0.00%|    Examples
  4742|         0|            0|            0|  0.00%|    --------
  4743|         0|            0|            0|  0.00%|    >>> np.trapz([1,2,3])
  4744|         0|            0|            0|  0.00%|    4.0
  4745|         0|            0|            0|  0.00%|    >>> np.trapz([1,2,3], x=[4,6,8])
  4746|         0|            0|            0|  0.00%|    8.0
  4747|         0|            0|            0|  0.00%|    >>> np.trapz([1,2,3], dx=2)
  4748|         0|            0|            0|  0.00%|    8.0
  4749|         0|            0|            0|  0.00%|
  4750|         0|            0|            0|  0.00%|    Using a decreasing `x` corresponds to integrating in reverse:
  4751|         0|            0|            0|  0.00%|
  4752|         0|            0|            0|  0.00%|    >>> np.trapz([1,2,3], x=[8,6,4])
  4753|         0|            0|            0|  0.00%|    -8.0
  4754|         0|            0|            0|  0.00%|
  4755|         0|            0|            0|  0.00%|    More generally `x` is used to integrate along a parametric curve.
  4756|         0|            0|            0|  0.00%|    This finds the area of a circle, noting we repeat the sample which closes
  4757|         0|            0|            0|  0.00%|    the curve:
  4758|         0|            0|            0|  0.00%|
  4759|         0|            0|            0|  0.00%|    >>> theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)
  4760|         0|            0|            0|  0.00%|    >>> np.trapz(np.cos(theta), x=np.sin(theta))
  4761|         0|            0|            0|  0.00%|    3.141571941375841
  4762|         0|            0|            0|  0.00%|
  4763|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape(2, 3)
  4764|         0|            0|            0|  0.00%|    >>> a
  4765|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  4766|         0|            0|            0|  0.00%|           [3, 4, 5]])
  4767|         0|            0|            0|  0.00%|    >>> np.trapz(a, axis=0)
  4768|         0|            0|            0|  0.00%|    array([1.5, 2.5, 3.5])
  4769|         0|            0|            0|  0.00%|    >>> np.trapz(a, axis=1)
  4770|         0|            0|            0|  0.00%|    array([2.,  8.])
  4771|         0|            0|            0|  0.00%|    """
  4772|         0|            0|            0|  0.00%|    y = asanyarray(y)
  4773|         0|            0|            0|  0.00%|    if x is None:
  4774|         0|            0|            0|  0.00%|        d = dx
  4775|         0|            0|            0|  0.00%|    else:
  4776|         0|            0|            0|  0.00%|        x = asanyarray(x)
  4777|         0|            0|            0|  0.00%|        if x.ndim == 1:
  4778|         0|            0|            0|  0.00%|            d = diff(x)
  4779|         0|            0|            0|  0.00%|            # reshape to correct shape
  4780|         0|            0|            0|  0.00%|            shape = [1]*y.ndim
  4781|         0|            0|            0|  0.00%|            shape[axis] = d.shape[0]
  4782|         0|            0|            0|  0.00%|            d = d.reshape(shape)
  4783|         0|            0|            0|  0.00%|        else:
  4784|         0|            0|            0|  0.00%|            d = diff(x, axis=axis)
  4785|         0|            0|            0|  0.00%|    nd = y.ndim
  4786|         0|            0|            0|  0.00%|    slice1 = [slice(None)]*nd
  4787|         0|            0|            0|  0.00%|    slice2 = [slice(None)]*nd
  4788|         0|            0|            0|  0.00%|    slice1[axis] = slice(1, None)
  4789|         0|            0|            0|  0.00%|    slice2[axis] = slice(None, -1)
  4790|         0|            0|            0|  0.00%|    try:
  4791|         0|            0|            0|  0.00%|        ret = (d * (y[tuple(slice1)] + y[tuple(slice2)]) / 2.0).sum(axis)
  4792|         0|            0|            0|  0.00%|    except ValueError:
  4793|         0|            0|            0|  0.00%|        # Operations didn't work, cast to ndarray
  4794|         0|            0|            0|  0.00%|        d = np.asarray(d)
  4795|         0|            0|            0|  0.00%|        y = np.asarray(y)
  4796|         0|            0|            0|  0.00%|        ret = add.reduce(d * (y[tuple(slice1)]+y[tuple(slice2)])/2.0, axis)
  4797|         0|            0|            0|  0.00%|    return ret
  4798|         0|            0|            0|  0.00%|
  4799|         0|            0|            0|  0.00%|
  4800|         0|            0|            0|  0.00%|def _meshgrid_dispatcher(*xi, copy=None, sparse=None, indexing=None):
  4801|         0|            0|            0|  0.00%|    return xi
  4802|         0|            0|            0|  0.00%|
  4803|         0|            0|            0|  0.00%|
  4804|         0|            0|            0|  0.00%|# Based on scitools meshgrid
  4805|         0|            0|            0|  0.00%|@array_function_dispatch(_meshgrid_dispatcher)
  4806|         0|            0|            0|  0.00%|def meshgrid(*xi, copy=True, sparse=False, indexing='xy'):
  4807|         0|            0|            0|  0.00%|    """
  4808|         0|            0|            0|  0.00%|    Return coordinate matrices from coordinate vectors.
  4809|         0|            0|            0|  0.00%|
  4810|         0|            0|            0|  0.00%|    Make N-D coordinate arrays for vectorized evaluations of
  4811|         0|            0|            0|  0.00%|    N-D scalar/vector fields over N-D grids, given
  4812|         0|            0|            0|  0.00%|    one-dimensional coordinate arrays x1, x2,..., xn.
  4813|         0|            0|            0|  0.00%|
  4814|         0|            0|            0|  0.00%|    .. versionchanged:: 1.9
  4815|         0|            0|            0|  0.00%|       1-D and 0-D cases are allowed.
  4816|         0|            0|            0|  0.00%|
  4817|         0|            0|            0|  0.00%|    Parameters
  4818|         0|            0|            0|  0.00%|    ----------
  4819|         0|            0|            0|  0.00%|    x1, x2,..., xn : array_like
  4820|         0|            0|            0|  0.00%|        1-D arrays representing the coordinates of a grid.
  4821|         0|            0|            0|  0.00%|    indexing : {'xy', 'ij'}, optional
  4822|         0|            0|            0|  0.00%|        Cartesian ('xy', default) or matrix ('ij') indexing of output.
  4823|         0|            0|            0|  0.00%|        See Notes for more details.
  4824|         0|            0|            0|  0.00%|
  4825|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  4826|         0|            0|            0|  0.00%|    sparse : bool, optional
  4827|         0|            0|            0|  0.00%|        If True the shape of the returned coordinate array for dimension *i*
  4828|         0|            0|            0|  0.00%|        is reduced from ``(N1, ..., Ni, ... Nn)`` to
  4829|         0|            0|            0|  0.00%|        ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are
  4830|         0|            0|            0|  0.00%|        intended to be use with :ref:`basics.broadcasting`.  When all
  4831|         0|            0|            0|  0.00%|        coordinates are used in an expression, broadcasting still leads to a
  4832|         0|            0|            0|  0.00%|        fully-dimensonal result array.
  4833|         0|            0|            0|  0.00%|
  4834|         0|            0|            0|  0.00%|        Default is False.
  4835|         0|            0|            0|  0.00%|
  4836|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  4837|         0|            0|            0|  0.00%|    copy : bool, optional
  4838|         0|            0|            0|  0.00%|        If False, a view into the original arrays are returned in order to
  4839|         0|            0|            0|  0.00%|        conserve memory.  Default is True.  Please note that
  4840|         0|            0|            0|  0.00%|        ``sparse=False, copy=False`` will likely return non-contiguous
  4841|         0|            0|            0|  0.00%|        arrays.  Furthermore, more than one element of a broadcast array
  4842|         0|            0|            0|  0.00%|        may refer to a single memory location.  If you need to write to the
  4843|         0|            0|            0|  0.00%|        arrays, make copies first.
  4844|         0|            0|            0|  0.00%|
  4845|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  4846|         0|            0|            0|  0.00%|
  4847|         0|            0|            0|  0.00%|    Returns
  4848|         0|            0|            0|  0.00%|    -------
  4849|         0|            0|            0|  0.00%|    X1, X2,..., XN : ndarray
  4850|         0|            0|            0|  0.00%|        For vectors `x1`, `x2`,..., 'xn' with lengths ``Ni=len(xi)`` ,
  4851|         0|            0|            0|  0.00%|        return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing='ij'
  4852|         0|            0|            0|  0.00%|        or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing='xy'
  4853|         0|            0|            0|  0.00%|        with the elements of `xi` repeated to fill the matrix along
  4854|         0|            0|            0|  0.00%|        the first dimension for `x1`, the second for `x2` and so on.
  4855|         0|            0|            0|  0.00%|
  4856|         0|            0|            0|  0.00%|    Notes
  4857|         0|            0|            0|  0.00%|    -----
  4858|         0|            0|            0|  0.00%|    This function supports both indexing conventions through the indexing
  4859|         0|            0|            0|  0.00%|    keyword argument.  Giving the string 'ij' returns a meshgrid with
  4860|         0|            0|            0|  0.00%|    matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.
  4861|         0|            0|            0|  0.00%|    In the 2-D case with inputs of length M and N, the outputs are of shape
  4862|         0|            0|            0|  0.00%|    (N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case
  4863|         0|            0|            0|  0.00%|    with inputs of length M, N and P, outputs are of shape (N, M, P) for
  4864|         0|            0|            0|  0.00%|    'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is
  4865|         0|            0|            0|  0.00%|    illustrated by the following code snippet::
  4866|         0|            0|            0|  0.00%|
  4867|         0|            0|            0|  0.00%|        xv, yv = np.meshgrid(x, y, indexing='ij')
  4868|         0|            0|            0|  0.00%|        for i in range(nx):
  4869|         0|            0|            0|  0.00%|            for j in range(ny):
  4870|         0|            0|            0|  0.00%|                # treat xv[i,j], yv[i,j]
  4871|         0|            0|            0|  0.00%|
  4872|         0|            0|            0|  0.00%|        xv, yv = np.meshgrid(x, y, indexing='xy')
  4873|         0|            0|            0|  0.00%|        for i in range(nx):
  4874|         0|            0|            0|  0.00%|            for j in range(ny):
  4875|         0|            0|            0|  0.00%|                # treat xv[j,i], yv[j,i]
  4876|         0|            0|            0|  0.00%|
  4877|         0|            0|            0|  0.00%|    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.
  4878|         0|            0|            0|  0.00%|
  4879|         0|            0|            0|  0.00%|    See Also
  4880|         0|            0|            0|  0.00%|    --------
  4881|         0|            0|            0|  0.00%|    mgrid : Construct a multi-dimensional "meshgrid" using indexing notation.
  4882|         0|            0|            0|  0.00%|    ogrid : Construct an open multi-dimensional "meshgrid" using indexing
  4883|         0|            0|            0|  0.00%|            notation.
  4884|         0|            0|            0|  0.00%|
  4885|         0|            0|            0|  0.00%|    Examples
  4886|         0|            0|            0|  0.00%|    --------
  4887|         0|            0|            0|  0.00%|    >>> nx, ny = (3, 2)
  4888|         0|            0|            0|  0.00%|    >>> x = np.linspace(0, 1, nx)
  4889|         0|            0|            0|  0.00%|    >>> y = np.linspace(0, 1, ny)
  4890|         0|            0|            0|  0.00%|    >>> xv, yv = np.meshgrid(x, y)
  4891|         0|            0|            0|  0.00%|    >>> xv
  4892|         0|            0|            0|  0.00%|    array([[0. , 0.5, 1. ],
  4893|         0|            0|            0|  0.00%|           [0. , 0.5, 1. ]])
  4894|         0|            0|            0|  0.00%|    >>> yv
  4895|         0|            0|            0|  0.00%|    array([[0.,  0.,  0.],
  4896|         0|            0|            0|  0.00%|           [1.,  1.,  1.]])
  4897|         0|            0|            0|  0.00%|    >>> xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays
  4898|         0|            0|            0|  0.00%|    >>> xv
  4899|         0|            0|            0|  0.00%|    array([[0. ,  0.5,  1. ]])
  4900|         0|            0|            0|  0.00%|    >>> yv
  4901|         0|            0|            0|  0.00%|    array([[0.],
  4902|         0|            0|            0|  0.00%|           [1.]])
  4903|         0|            0|            0|  0.00%|
  4904|         0|            0|            0|  0.00%|    `meshgrid` is very useful to evaluate functions on a grid.  If the
  4905|         0|            0|            0|  0.00%|    function depends on all coordinates, you can use the parameter
  4906|         0|            0|            0|  0.00%|    ``sparse=True`` to save memory and computation time.
  4907|         0|            0|            0|  0.00%|
  4908|         0|            0|            0|  0.00%|    >>> x = np.linspace(-5, 5, 101)
  4909|         0|            0|            0|  0.00%|    >>> y = np.linspace(-5, 5, 101)
  4910|         0|            0|            0|  0.00%|    >>> # full coorindate arrays
  4911|         0|            0|            0|  0.00%|    >>> xx, yy = np.meshgrid(x, y)
  4912|         0|            0|            0|  0.00%|    >>> zz = np.sqrt(xx**2 + yy**2)
  4913|         0|            0|            0|  0.00%|    >>> xx.shape, yy.shape, zz.shape
  4914|         0|            0|            0|  0.00%|    ((101, 101), (101, 101), (101, 101))
  4915|         0|            0|            0|  0.00%|    >>> # sparse coordinate arrays
  4916|         0|            0|            0|  0.00%|    >>> xs, ys = np.meshgrid(x, y, sparse=True)
  4917|         0|            0|            0|  0.00%|    >>> zs = np.sqrt(xs**2 + ys**2)
  4918|         0|            0|            0|  0.00%|    >>> xs.shape, ys.shape, zs.shape
  4919|         0|            0|            0|  0.00%|    ((1, 101), (101, 1), (101, 101))
  4920|         0|            0|            0|  0.00%|    >>> np.array_equal(zz, zs)
  4921|         0|            0|            0|  0.00%|    True
  4922|         0|            0|            0|  0.00%|
  4923|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  4924|         0|            0|            0|  0.00%|    >>> h = plt.contourf(x, y, zs)
  4925|         0|            0|            0|  0.00%|    >>> plt.axis('scaled')
  4926|         0|            0|            0|  0.00%|    >>> plt.colorbar()
  4927|         0|            0|            0|  0.00%|    >>> plt.show()
  4928|         0|            0|            0|  0.00%|    """
  4929|         0|            0|            0|  0.00%|    ndim = len(xi)
  4930|         0|            0|            0|  0.00%|
  4931|         0|            0|            0|  0.00%|    if indexing not in ['xy', 'ij']:
  4932|         0|            0|            0|  0.00%|        raise ValueError(
  4933|         0|            0|            0|  0.00%|            "Valid values for `indexing` are 'xy' and 'ij'.")
  4934|         0|            0|            0|  0.00%|
  4935|         0|            0|            0|  0.00%|    s0 = (1,) * ndim
  4936|         0|            0|            0|  0.00%|    output = [np.asanyarray(x).reshape(s0[:i] + (-1,) + s0[i + 1:])
  4937|         0|            0|            0|  0.00%|              for i, x in enumerate(xi)]
  4938|         0|            0|            0|  0.00%|
  4939|         0|            0|            0|  0.00%|    if indexing == 'xy' and ndim > 1:
  4940|         0|            0|            0|  0.00%|        # switch first and second axis
  4941|         0|            0|            0|  0.00%|        output[0].shape = (1, -1) + s0[2:]
  4942|         0|            0|            0|  0.00%|        output[1].shape = (-1, 1) + s0[2:]
  4943|         0|            0|            0|  0.00%|
  4944|         0|            0|            0|  0.00%|    if not sparse:
  4945|         0|            0|            0|  0.00%|        # Return the full N-D matrix (not only the 1-D vector)
  4946|         0|            0|            0|  0.00%|        output = np.broadcast_arrays(*output, subok=True)
  4947|         0|            0|            0|  0.00%|
  4948|         0|            0|            0|  0.00%|    if copy:
  4949|         0|            0|            0|  0.00%|        output = [x.copy() for x in output]
  4950|         0|            0|            0|  0.00%|
  4951|         0|            0|            0|  0.00%|    return output
  4952|         0|            0|            0|  0.00%|
  4953|         0|            0|            0|  0.00%|
  4954|       337|            0|            0|  0.00%|def _delete_dispatcher(arr, obj, axis=None):
  4955|       337|            0|            0|  0.00%|    return (arr, obj)
  4956|         0|            0|            0|  0.00%|
  4957|         0|            0|            0|  0.00%|
  4958|       337|  0.000124454|  3.69301e-07|  0.00%|@array_function_dispatch(_delete_dispatcher)
  4959|         0|            0|            0|  0.00%|def delete(arr, obj, axis=None):
  4960|         0|            0|            0|  0.00%|    """
  4961|         0|            0|            0|  0.00%|    Return a new array with sub-arrays along an axis deleted. For a one
  4962|         0|            0|            0|  0.00%|    dimensional array, this returns those entries not returned by
  4963|         0|            0|            0|  0.00%|    `arr[obj]`.
  4964|         0|            0|            0|  0.00%|
  4965|         0|            0|            0|  0.00%|    Parameters
  4966|         0|            0|            0|  0.00%|    ----------
  4967|         0|            0|            0|  0.00%|    arr : array_like
  4968|         0|            0|            0|  0.00%|        Input array.
  4969|         0|            0|            0|  0.00%|    obj : slice, int or array of ints
  4970|         0|            0|            0|  0.00%|        Indicate indices of sub-arrays to remove along the specified axis.
  4971|         0|            0|            0|  0.00%|
  4972|         0|            0|            0|  0.00%|        .. versionchanged:: 1.19.0
  4973|         0|            0|            0|  0.00%|            Boolean indices are now treated as a mask of elements to remove,
  4974|         0|            0|            0|  0.00%|            rather than being cast to the integers 0 and 1.
  4975|         0|            0|            0|  0.00%|
  4976|         0|            0|            0|  0.00%|    axis : int, optional
  4977|         0|            0|            0|  0.00%|        The axis along which to delete the subarray defined by `obj`.
  4978|         0|            0|            0|  0.00%|        If `axis` is None, `obj` is applied to the flattened array.
  4979|         0|            0|            0|  0.00%|
  4980|         0|            0|            0|  0.00%|    Returns
  4981|         0|            0|            0|  0.00%|    -------
  4982|         0|            0|            0|  0.00%|    out : ndarray
  4983|         0|            0|            0|  0.00%|        A copy of `arr` with the elements specified by `obj` removed. Note
  4984|         0|            0|            0|  0.00%|        that `delete` does not occur in-place. If `axis` is None, `out` is
  4985|         0|            0|            0|  0.00%|        a flattened array.
  4986|         0|            0|            0|  0.00%|
  4987|         0|            0|            0|  0.00%|    See Also
  4988|         0|            0|            0|  0.00%|    --------
  4989|         0|            0|            0|  0.00%|    insert : Insert elements into an array.
  4990|         0|            0|            0|  0.00%|    append : Append elements at the end of an array.
  4991|         0|            0|            0|  0.00%|
  4992|         0|            0|            0|  0.00%|    Notes
  4993|         0|            0|            0|  0.00%|    -----
  4994|         0|            0|            0|  0.00%|    Often it is preferable to use a boolean mask. For example:
  4995|         0|            0|            0|  0.00%|
  4996|         0|            0|            0|  0.00%|    >>> arr = np.arange(12) + 1
  4997|         0|            0|            0|  0.00%|    >>> mask = np.ones(len(arr), dtype=bool)
  4998|         0|            0|            0|  0.00%|    >>> mask[[0,2,4]] = False
  4999|         0|            0|            0|  0.00%|    >>> result = arr[mask,...]
  5000|         0|            0|            0|  0.00%|
  5001|         0|            0|            0|  0.00%|    Is equivalent to `np.delete(arr, [0,2,4], axis=0)`, but allows further
  5002|         0|            0|            0|  0.00%|    use of `mask`.
  5003|         0|            0|            0|  0.00%|
  5004|         0|            0|            0|  0.00%|    Examples
  5005|         0|            0|            0|  0.00%|    --------
  5006|         0|            0|            0|  0.00%|    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
  5007|         0|            0|            0|  0.00%|    >>> arr
  5008|         0|            0|            0|  0.00%|    array([[ 1,  2,  3,  4],
  5009|         0|            0|            0|  0.00%|           [ 5,  6,  7,  8],
  5010|         0|            0|            0|  0.00%|           [ 9, 10, 11, 12]])
  5011|         0|            0|            0|  0.00%|    >>> np.delete(arr, 1, 0)
  5012|         0|            0|            0|  0.00%|    array([[ 1,  2,  3,  4],
  5013|         0|            0|            0|  0.00%|           [ 9, 10, 11, 12]])
  5014|         0|            0|            0|  0.00%|
  5015|         0|            0|            0|  0.00%|    >>> np.delete(arr, np.s_[::2], 1)
  5016|         0|            0|            0|  0.00%|    array([[ 2,  4],
  5017|         0|            0|            0|  0.00%|           [ 6,  8],
  5018|         0|            0|            0|  0.00%|           [10, 12]])
  5019|         0|            0|            0|  0.00%|    >>> np.delete(arr, [1,3,5], None)
  5020|         0|            0|            0|  0.00%|    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])
  5021|         0|            0|            0|  0.00%|
  5022|         0|            0|            0|  0.00%|    """
  5023|       337|   0.00199866|  5.93075e-06|  0.01%|    wrap = None
  5024|       337|            0|            0|  0.00%|    if type(arr) is not ndarray:
  5025|         0|            0|            0|  0.00%|        try:
  5026|         0|            0|            0|  0.00%|            wrap = arr.__array_wrap__
  5027|         0|            0|            0|  0.00%|        except AttributeError:
  5028|         0|            0|            0|  0.00%|            pass
  5029|         0|            0|            0|  0.00%|
  5030|       337|            0|            0|  0.00%|    arr = asarray(arr)
  5031|       337|   0.00101066|  2.99898e-06|  0.00%|    ndim = arr.ndim
  5032|       337|    0.0029943|  8.88516e-06|  0.01%|    arrorder = 'F' if arr.flags.fnc else 'C'
  5033|       337|   0.00107789|  3.19849e-06|  0.00%|    if axis is None:
  5034|         0|            0|            0|  0.00%|        if ndim != 1:
  5035|         0|            0|            0|  0.00%|            arr = arr.ravel()
  5036|         0|            0|            0|  0.00%|        # needed for np.matrix, which is still not 1d after being ravelled
  5037|         0|            0|            0|  0.00%|        ndim = arr.ndim
  5038|         0|            0|            0|  0.00%|        axis = ndim - 1
  5039|         0|            0|            0|  0.00%|    else:
  5040|       337|            0|            0|  0.00%|        axis = normalize_axis_index(axis, ndim)
  5041|         0|            0|            0|  0.00%|
  5042|       337|   0.00199246|  5.91236e-06|  0.01%|    slobj = [slice(None)]*ndim
  5043|       337|            0|            0|  0.00%|    N = arr.shape[axis]
  5044|       337|   0.00300336|  8.91204e-06|  0.01%|    newshape = list(arr.shape)
  5045|         0|            0|            0|  0.00%|
  5046|       337|            0|            0|  0.00%|    if isinstance(obj, slice):
  5047|         0|            0|            0|  0.00%|        start, stop, step = obj.indices(N)
  5048|         0|            0|            0|  0.00%|        xr = range(start, stop, step)
  5049|         0|            0|            0|  0.00%|        numtodel = len(xr)
  5050|         0|            0|            0|  0.00%|
  5051|         0|            0|            0|  0.00%|        if numtodel <= 0:
  5052|         0|            0|            0|  0.00%|            if wrap:
  5053|         0|            0|            0|  0.00%|                return wrap(arr.copy(order=arrorder))
  5054|         0|            0|            0|  0.00%|            else:
  5055|         0|            0|            0|  0.00%|                return arr.copy(order=arrorder)
  5056|         0|            0|            0|  0.00%|
  5057|         0|            0|            0|  0.00%|        # Invert if step is negative:
  5058|         0|            0|            0|  0.00%|        if step < 0:
  5059|         0|            0|            0|  0.00%|            step = -step
  5060|         0|            0|            0|  0.00%|            start = xr[-1]
  5061|         0|            0|            0|  0.00%|            stop = xr[0] + 1
  5062|         0|            0|            0|  0.00%|
  5063|         0|            0|            0|  0.00%|        newshape[axis] -= numtodel
  5064|         0|            0|            0|  0.00%|        new = empty(newshape, arr.dtype, arrorder)
  5065|         0|            0|            0|  0.00%|        # copy initial chunk
  5066|         0|            0|            0|  0.00%|        if start == 0:
  5067|         0|            0|            0|  0.00%|            pass
  5068|         0|            0|            0|  0.00%|        else:
  5069|         0|            0|            0|  0.00%|            slobj[axis] = slice(None, start)
  5070|         0|            0|            0|  0.00%|            new[tuple(slobj)] = arr[tuple(slobj)]
  5071|         0|            0|            0|  0.00%|        # copy end chunk
  5072|         0|            0|            0|  0.00%|        if stop == N:
  5073|         0|            0|            0|  0.00%|            pass
  5074|         0|            0|            0|  0.00%|        else:
  5075|         0|            0|            0|  0.00%|            slobj[axis] = slice(stop-numtodel, None)
  5076|         0|            0|            0|  0.00%|            slobj2 = [slice(None)]*ndim
  5077|         0|            0|            0|  0.00%|            slobj2[axis] = slice(stop, None)
  5078|         0|            0|            0|  0.00%|            new[tuple(slobj)] = arr[tuple(slobj2)]
  5079|         0|            0|            0|  0.00%|        # copy middle pieces
  5080|         0|            0|            0|  0.00%|        if step == 1:
  5081|         0|            0|            0|  0.00%|            pass
  5082|         0|            0|            0|  0.00%|        else:  # use array indexing.
  5083|         0|            0|            0|  0.00%|            keep = ones(stop-start, dtype=bool)
  5084|         0|            0|            0|  0.00%|            keep[:stop-start:step] = False
  5085|         0|            0|            0|  0.00%|            slobj[axis] = slice(start, stop-numtodel)
  5086|         0|            0|            0|  0.00%|            slobj2 = [slice(None)]*ndim
  5087|         0|            0|            0|  0.00%|            slobj2[axis] = slice(start, stop)
  5088|         0|            0|            0|  0.00%|            arr = arr[tuple(slobj2)]
  5089|         0|            0|            0|  0.00%|            slobj2[axis] = keep
  5090|         0|            0|            0|  0.00%|            new[tuple(slobj)] = arr[tuple(slobj2)]
  5091|         0|            0|            0|  0.00%|        if wrap:
  5092|         0|            0|            0|  0.00%|            return wrap(new)
  5093|         0|            0|            0|  0.00%|        else:
  5094|         0|            0|            0|  0.00%|            return new
  5095|         0|            0|            0|  0.00%|
  5096|       337|            0|            0|  0.00%|    if isinstance(obj, (int, integer)) and not isinstance(obj, bool):
  5097|         0|            0|            0|  0.00%|        # optimization for a single value
  5098|       337|  0.000997305|  2.95936e-06|  0.00%|        if (obj < -N or obj >= N):
  5099|         0|            0|            0|  0.00%|            raise IndexError(
  5100|         0|            0|            0|  0.00%|                "index %i is out of bounds for axis %i with "
  5101|         0|            0|            0|  0.00%|                "size %i" % (obj, axis, N))
  5102|       337|   0.00303459|  9.00472e-06|  0.01%|        if (obj < 0):
  5103|         0|            0|            0|  0.00%|            obj += N
  5104|       337|   0.00199389|   5.9166e-06|  0.01%|        newshape[axis] -= 1
  5105|       337|            0|            0|  0.00%|        new = empty(newshape, arr.dtype, arrorder)
  5106|       337|            0|            0|  0.00%|        slobj[axis] = slice(None, obj)
  5107|       337|    0.0030303|  8.99199e-06|  0.01%|        new[tuple(slobj)] = arr[tuple(slobj)]
  5108|       337|  0.000996113|  2.95582e-06|  0.00%|        slobj[axis] = slice(obj, None)
  5109|       337|   0.00199461|  5.91872e-06|  0.01%|        slobj2 = [slice(None)]*ndim
  5110|       337|   0.00204873|  6.07932e-06|  0.01%|        slobj2[axis] = slice(obj+1, None)
  5111|       337|            0|            0|  0.00%|        new[tuple(slobj)] = arr[tuple(slobj2)]
  5112|         0|            0|            0|  0.00%|    else:
  5113|         0|            0|            0|  0.00%|        _obj = obj
  5114|         0|            0|            0|  0.00%|        obj = np.asarray(obj)
  5115|         0|            0|            0|  0.00%|        if obj.size == 0 and not isinstance(_obj, np.ndarray):
  5116|         0|            0|            0|  0.00%|            obj = obj.astype(intp)
  5117|         0|            0|            0|  0.00%|
  5118|         0|            0|            0|  0.00%|        if obj.dtype == bool:
  5119|         0|            0|            0|  0.00%|            if obj.shape != (N,):
  5120|         0|            0|            0|  0.00%|                raise ValueError('boolean array argument obj to delete '
  5121|         0|            0|            0|  0.00%|                                 'must be one dimensional and match the axis '
  5122|         0|            0|            0|  0.00%|                                 'length of {}'.format(N))
  5123|         0|            0|            0|  0.00%|
  5124|         0|            0|            0|  0.00%|            # optimization, the other branch is slower
  5125|         0|            0|            0|  0.00%|            keep = ~obj
  5126|         0|            0|            0|  0.00%|        else:
  5127|         0|            0|            0|  0.00%|            keep = ones(N, dtype=bool)
  5128|         0|            0|            0|  0.00%|            keep[obj,] = False
  5129|         0|            0|            0|  0.00%|
  5130|         0|            0|            0|  0.00%|        slobj[axis] = keep
  5131|         0|            0|            0|  0.00%|        new = arr[tuple(slobj)]
  5132|         0|            0|            0|  0.00%|
  5133|       337|   0.00102305|  3.03577e-06|  0.00%|    if wrap:
  5134|         0|            0|            0|  0.00%|        return wrap(new)
  5135|         0|            0|            0|  0.00%|    else:
  5136|       337|            0|            0|  0.00%|        return new
  5137|         0|            0|            0|  0.00%|
  5138|         0|            0|            0|  0.00%|
  5139|         0|            0|            0|  0.00%|def _insert_dispatcher(arr, obj, values, axis=None):
  5140|         0|            0|            0|  0.00%|    return (arr, obj, values)
  5141|         0|            0|            0|  0.00%|
  5142|         0|            0|            0|  0.00%|
  5143|         0|            0|            0|  0.00%|@array_function_dispatch(_insert_dispatcher)
  5144|         0|            0|            0|  0.00%|def insert(arr, obj, values, axis=None):
  5145|         0|            0|            0|  0.00%|    """
  5146|         0|            0|            0|  0.00%|    Insert values along the given axis before the given indices.
  5147|         0|            0|            0|  0.00%|
  5148|         0|            0|            0|  0.00%|    Parameters
  5149|         0|            0|            0|  0.00%|    ----------
  5150|         0|            0|            0|  0.00%|    arr : array_like
  5151|         0|            0|            0|  0.00%|        Input array.
  5152|         0|            0|            0|  0.00%|    obj : int, slice or sequence of ints
  5153|         0|            0|            0|  0.00%|        Object that defines the index or indices before which `values` is
  5154|         0|            0|            0|  0.00%|        inserted.
  5155|         0|            0|            0|  0.00%|
  5156|         0|            0|            0|  0.00%|        .. versionadded:: 1.8.0
  5157|         0|            0|            0|  0.00%|
  5158|         0|            0|            0|  0.00%|        Support for multiple insertions when `obj` is a single scalar or a
  5159|         0|            0|            0|  0.00%|        sequence with one element (similar to calling insert multiple
  5160|         0|            0|            0|  0.00%|        times).
  5161|         0|            0|            0|  0.00%|    values : array_like
  5162|         0|            0|            0|  0.00%|        Values to insert into `arr`. If the type of `values` is different
  5163|         0|            0|            0|  0.00%|        from that of `arr`, `values` is converted to the type of `arr`.
  5164|         0|            0|            0|  0.00%|        `values` should be shaped so that ``arr[...,obj,...] = values``
  5165|         0|            0|            0|  0.00%|        is legal.
  5166|         0|            0|            0|  0.00%|    axis : int, optional
  5167|         0|            0|            0|  0.00%|        Axis along which to insert `values`.  If `axis` is None then `arr`
  5168|         0|            0|            0|  0.00%|        is flattened first.
  5169|         0|            0|            0|  0.00%|
  5170|         0|            0|            0|  0.00%|    Returns
  5171|         0|            0|            0|  0.00%|    -------
  5172|         0|            0|            0|  0.00%|    out : ndarray
  5173|         0|            0|            0|  0.00%|        A copy of `arr` with `values` inserted.  Note that `insert`
  5174|         0|            0|            0|  0.00%|        does not occur in-place: a new array is returned. If
  5175|         0|            0|            0|  0.00%|        `axis` is None, `out` is a flattened array.
  5176|         0|            0|            0|  0.00%|
  5177|         0|            0|            0|  0.00%|    See Also
  5178|         0|            0|            0|  0.00%|    --------
  5179|         0|            0|            0|  0.00%|    append : Append elements at the end of an array.
  5180|         0|            0|            0|  0.00%|    concatenate : Join a sequence of arrays along an existing axis.
  5181|         0|            0|            0|  0.00%|    delete : Delete elements from an array.
  5182|         0|            0|            0|  0.00%|
  5183|         0|            0|            0|  0.00%|    Notes
  5184|         0|            0|            0|  0.00%|    -----
  5185|         0|            0|            0|  0.00%|    Note that for higher dimensional inserts `obj=0` behaves very different
  5186|         0|            0|            0|  0.00%|    from `obj=[0]` just like `arr[:,0,:] = values` is different from
  5187|         0|            0|            0|  0.00%|    `arr[:,[0],:] = values`.
  5188|         0|            0|            0|  0.00%|
  5189|         0|            0|            0|  0.00%|    Examples
  5190|         0|            0|            0|  0.00%|    --------
  5191|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 1], [2, 2], [3, 3]])
  5192|         0|            0|            0|  0.00%|    >>> a
  5193|         0|            0|            0|  0.00%|    array([[1, 1],
  5194|         0|            0|            0|  0.00%|           [2, 2],
  5195|         0|            0|            0|  0.00%|           [3, 3]])
  5196|         0|            0|            0|  0.00%|    >>> np.insert(a, 1, 5)
  5197|         0|            0|            0|  0.00%|    array([1, 5, 1, ..., 2, 3, 3])
  5198|         0|            0|            0|  0.00%|    >>> np.insert(a, 1, 5, axis=1)
  5199|         0|            0|            0|  0.00%|    array([[1, 5, 1],
  5200|         0|            0|            0|  0.00%|           [2, 5, 2],
  5201|         0|            0|            0|  0.00%|           [3, 5, 3]])
  5202|         0|            0|            0|  0.00%|
  5203|         0|            0|            0|  0.00%|    Difference between sequence and scalars:
  5204|         0|            0|            0|  0.00%|
  5205|         0|            0|            0|  0.00%|    >>> np.insert(a, [1], [[1],[2],[3]], axis=1)
  5206|         0|            0|            0|  0.00%|    array([[1, 1, 1],
  5207|         0|            0|            0|  0.00%|           [2, 2, 2],
  5208|         0|            0|            0|  0.00%|           [3, 3, 3]])
  5209|         0|            0|            0|  0.00%|    >>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
  5210|         0|            0|            0|  0.00%|    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))
  5211|         0|            0|            0|  0.00%|    True
  5212|         0|            0|            0|  0.00%|
  5213|         0|            0|            0|  0.00%|    >>> b = a.flatten()
  5214|         0|            0|            0|  0.00%|    >>> b
  5215|         0|            0|            0|  0.00%|    array([1, 1, 2, 2, 3, 3])
  5216|         0|            0|            0|  0.00%|    >>> np.insert(b, [2, 2], [5, 6])
  5217|         0|            0|            0|  0.00%|    array([1, 1, 5, ..., 2, 3, 3])
  5218|         0|            0|            0|  0.00%|
  5219|         0|            0|            0|  0.00%|    >>> np.insert(b, slice(2, 4), [5, 6])
  5220|         0|            0|            0|  0.00%|    array([1, 1, 5, ..., 2, 3, 3])
  5221|         0|            0|            0|  0.00%|
  5222|         0|            0|            0|  0.00%|    >>> np.insert(b, [2, 2], [7.13, False]) # type casting
  5223|         0|            0|            0|  0.00%|    array([1, 1, 7, ..., 2, 3, 3])
  5224|         0|            0|            0|  0.00%|
  5225|         0|            0|            0|  0.00%|    >>> x = np.arange(8).reshape(2, 4)
  5226|         0|            0|            0|  0.00%|    >>> idx = (1, 3)
  5227|         0|            0|            0|  0.00%|    >>> np.insert(x, idx, 999, axis=1)
  5228|         0|            0|            0|  0.00%|    array([[  0, 999,   1,   2, 999,   3],
  5229|         0|            0|            0|  0.00%|           [  4, 999,   5,   6, 999,   7]])
  5230|         0|            0|            0|  0.00%|
  5231|         0|            0|            0|  0.00%|    """
  5232|         0|            0|            0|  0.00%|    wrap = None
  5233|         0|            0|            0|  0.00%|    if type(arr) is not ndarray:
  5234|         0|            0|            0|  0.00%|        try:
  5235|         0|            0|            0|  0.00%|            wrap = arr.__array_wrap__
  5236|         0|            0|            0|  0.00%|        except AttributeError:
  5237|         0|            0|            0|  0.00%|            pass
  5238|         0|            0|            0|  0.00%|
  5239|         0|            0|            0|  0.00%|    arr = asarray(arr)
  5240|         0|            0|            0|  0.00%|    ndim = arr.ndim
  5241|         0|            0|            0|  0.00%|    arrorder = 'F' if arr.flags.fnc else 'C'
  5242|         0|            0|            0|  0.00%|    if axis is None:
  5243|         0|            0|            0|  0.00%|        if ndim != 1:
  5244|         0|            0|            0|  0.00%|            arr = arr.ravel()
  5245|         0|            0|            0|  0.00%|        # needed for np.matrix, which is still not 1d after being ravelled
  5246|         0|            0|            0|  0.00%|        ndim = arr.ndim
  5247|         0|            0|            0|  0.00%|        axis = ndim - 1
  5248|         0|            0|            0|  0.00%|    else:
  5249|         0|            0|            0|  0.00%|        axis = normalize_axis_index(axis, ndim)
  5250|         0|            0|            0|  0.00%|    slobj = [slice(None)]*ndim
  5251|         0|            0|            0|  0.00%|    N = arr.shape[axis]
  5252|         0|            0|            0|  0.00%|    newshape = list(arr.shape)
  5253|         0|            0|            0|  0.00%|
  5254|         0|            0|            0|  0.00%|    if isinstance(obj, slice):
  5255|         0|            0|            0|  0.00%|        # turn it into a range object
  5256|         0|            0|            0|  0.00%|        indices = arange(*obj.indices(N), dtype=intp)
  5257|         0|            0|            0|  0.00%|    else:
  5258|         0|            0|            0|  0.00%|        # need to copy obj, because indices will be changed in-place
  5259|         0|            0|            0|  0.00%|        indices = np.array(obj)
  5260|         0|            0|            0|  0.00%|        if indices.dtype == bool:
  5261|         0|            0|            0|  0.00%|            # See also delete
  5262|         0|            0|            0|  0.00%|            # 2012-10-11, NumPy 1.8
  5263|         0|            0|            0|  0.00%|            warnings.warn(
  5264|         0|            0|            0|  0.00%|                "in the future insert will treat boolean arrays and "
  5265|         0|            0|            0|  0.00%|                "array-likes as a boolean index instead of casting it to "
  5266|         0|            0|            0|  0.00%|                "integer", FutureWarning, stacklevel=3)
  5267|         0|            0|            0|  0.00%|            indices = indices.astype(intp)
  5268|         0|            0|            0|  0.00%|            # Code after warning period:
  5269|         0|            0|            0|  0.00%|            #if obj.ndim != 1:
  5270|         0|            0|            0|  0.00%|            #    raise ValueError('boolean array argument obj to insert '
  5271|         0|            0|            0|  0.00%|            #                     'must be one dimensional')
  5272|         0|            0|            0|  0.00%|            #indices = np.flatnonzero(obj)
  5273|         0|            0|            0|  0.00%|        elif indices.ndim > 1:
  5274|         0|            0|            0|  0.00%|            raise ValueError(
  5275|         0|            0|            0|  0.00%|                "index array argument obj to insert must be one dimensional "
  5276|         0|            0|            0|  0.00%|                "or scalar")
  5277|         0|            0|            0|  0.00%|    if indices.size == 1:
  5278|         0|            0|            0|  0.00%|        index = indices.item()
  5279|         0|            0|            0|  0.00%|        if index < -N or index > N:
  5280|         0|            0|            0|  0.00%|            raise IndexError(f"index {obj} is out of bounds for axis {axis} "
  5281|         0|            0|            0|  0.00%|                             f"with size {N}")
  5282|         0|            0|            0|  0.00%|        if (index < 0):
  5283|         0|            0|            0|  0.00%|            index += N
  5284|         0|            0|            0|  0.00%|
  5285|         0|            0|            0|  0.00%|        # There are some object array corner cases here, but we cannot avoid
  5286|         0|            0|            0|  0.00%|        # that:
  5287|         0|            0|            0|  0.00%|        values = array(values, copy=False, ndmin=arr.ndim, dtype=arr.dtype)
  5288|         0|            0|            0|  0.00%|        if indices.ndim == 0:
  5289|         0|            0|            0|  0.00%|            # broadcasting is very different here, since a[:,0,:] = ... behaves
  5290|         0|            0|            0|  0.00%|            # very different from a[:,[0],:] = ...! This changes values so that
  5291|         0|            0|            0|  0.00%|            # it works likes the second case. (here a[:,0:1,:])
  5292|         0|            0|            0|  0.00%|            values = np.moveaxis(values, 0, axis)
  5293|         0|            0|            0|  0.00%|        numnew = values.shape[axis]
  5294|         0|            0|            0|  0.00%|        newshape[axis] += numnew
  5295|         0|            0|            0|  0.00%|        new = empty(newshape, arr.dtype, arrorder)
  5296|         0|            0|            0|  0.00%|        slobj[axis] = slice(None, index)
  5297|         0|            0|            0|  0.00%|        new[tuple(slobj)] = arr[tuple(slobj)]
  5298|         0|            0|            0|  0.00%|        slobj[axis] = slice(index, index+numnew)
  5299|         0|            0|            0|  0.00%|        new[tuple(slobj)] = values
  5300|         0|            0|            0|  0.00%|        slobj[axis] = slice(index+numnew, None)
  5301|         0|            0|            0|  0.00%|        slobj2 = [slice(None)] * ndim
  5302|         0|            0|            0|  0.00%|        slobj2[axis] = slice(index, None)
  5303|         0|            0|            0|  0.00%|        new[tuple(slobj)] = arr[tuple(slobj2)]
  5304|         0|            0|            0|  0.00%|        if wrap:
  5305|         0|            0|            0|  0.00%|            return wrap(new)
  5306|         0|            0|            0|  0.00%|        return new
  5307|         0|            0|            0|  0.00%|    elif indices.size == 0 and not isinstance(obj, np.ndarray):
  5308|         0|            0|            0|  0.00%|        # Can safely cast the empty list to intp
  5309|         0|            0|            0|  0.00%|        indices = indices.astype(intp)
  5310|         0|            0|            0|  0.00%|
  5311|         0|            0|            0|  0.00%|    indices[indices < 0] += N
  5312|         0|            0|            0|  0.00%|
  5313|         0|            0|            0|  0.00%|    numnew = len(indices)
  5314|         0|            0|            0|  0.00%|    order = indices.argsort(kind='mergesort')   # stable sort
  5315|         0|            0|            0|  0.00%|    indices[order] += np.arange(numnew)
  5316|         0|            0|            0|  0.00%|
  5317|         0|            0|            0|  0.00%|    newshape[axis] += numnew
  5318|         0|            0|            0|  0.00%|    old_mask = ones(newshape[axis], dtype=bool)
  5319|         0|            0|            0|  0.00%|    old_mask[indices] = False
  5320|         0|            0|            0|  0.00%|
  5321|         0|            0|            0|  0.00%|    new = empty(newshape, arr.dtype, arrorder)
  5322|         0|            0|            0|  0.00%|    slobj2 = [slice(None)]*ndim
  5323|         0|            0|            0|  0.00%|    slobj[axis] = indices
  5324|         0|            0|            0|  0.00%|    slobj2[axis] = old_mask
  5325|         0|            0|            0|  0.00%|    new[tuple(slobj)] = values
  5326|         0|            0|            0|  0.00%|    new[tuple(slobj2)] = arr
  5327|         0|            0|            0|  0.00%|
  5328|         0|            0|            0|  0.00%|    if wrap:
  5329|         0|            0|            0|  0.00%|        return wrap(new)
  5330|         0|            0|            0|  0.00%|    return new
  5331|         0|            0|            0|  0.00%|
  5332|         0|            0|            0|  0.00%|
  5333|         4|            0|            0|  0.00%|def _append_dispatcher(arr, values, axis=None):
  5334|         4|            0|            0|  0.00%|    return (arr, values)
  5335|         0|            0|            0|  0.00%|
  5336|         0|            0|            0|  0.00%|
  5337|         4|            0|            0|  0.00%|@array_function_dispatch(_append_dispatcher)
  5338|         0|            0|            0|  0.00%|def append(arr, values, axis=None):
  5339|         0|            0|            0|  0.00%|    """
  5340|         0|            0|            0|  0.00%|    Append values to the end of an array.
  5341|         0|            0|            0|  0.00%|
  5342|         0|            0|            0|  0.00%|    Parameters
  5343|         0|            0|            0|  0.00%|    ----------
  5344|         0|            0|            0|  0.00%|    arr : array_like
  5345|         0|            0|            0|  0.00%|        Values are appended to a copy of this array.
  5346|         0|            0|            0|  0.00%|    values : array_like
  5347|         0|            0|            0|  0.00%|        These values are appended to a copy of `arr`.  It must be of the
  5348|         0|            0|            0|  0.00%|        correct shape (the same shape as `arr`, excluding `axis`).  If
  5349|         0|            0|            0|  0.00%|        `axis` is not specified, `values` can be any shape and will be
  5350|         0|            0|            0|  0.00%|        flattened before use.
  5351|         0|            0|            0|  0.00%|    axis : int, optional
  5352|         0|            0|            0|  0.00%|        The axis along which `values` are appended.  If `axis` is not
  5353|         0|            0|            0|  0.00%|        given, both `arr` and `values` are flattened before use.
  5354|         0|            0|            0|  0.00%|
  5355|         0|            0|            0|  0.00%|    Returns
  5356|         0|            0|            0|  0.00%|    -------
  5357|         0|            0|            0|  0.00%|    append : ndarray
  5358|         0|            0|            0|  0.00%|        A copy of `arr` with `values` appended to `axis`.  Note that
  5359|         0|            0|            0|  0.00%|        `append` does not occur in-place: a new array is allocated and
  5360|         0|            0|            0|  0.00%|        filled.  If `axis` is None, `out` is a flattened array.
  5361|         0|            0|            0|  0.00%|
  5362|         0|            0|            0|  0.00%|    See Also
  5363|         0|            0|            0|  0.00%|    --------
  5364|         0|            0|            0|  0.00%|    insert : Insert elements into an array.
  5365|         0|            0|            0|  0.00%|    delete : Delete elements from an array.
  5366|         0|            0|            0|  0.00%|
  5367|         0|            0|            0|  0.00%|    Examples
  5368|         0|            0|            0|  0.00%|    --------
  5369|         0|            0|            0|  0.00%|    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
  5370|         0|            0|            0|  0.00%|    array([1, 2, 3, ..., 7, 8, 9])
  5371|         0|            0|            0|  0.00%|
  5372|         0|            0|            0|  0.00%|    When `axis` is specified, `values` must have the correct shape.
  5373|         0|            0|            0|  0.00%|
  5374|         0|            0|            0|  0.00%|    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
  5375|         0|            0|            0|  0.00%|    array([[1, 2, 3],
  5376|         0|            0|            0|  0.00%|           [4, 5, 6],
  5377|         0|            0|            0|  0.00%|           [7, 8, 9]])
  5378|         0|            0|            0|  0.00%|    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
  5379|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  5380|         0|            0|            0|  0.00%|        ...
  5381|         0|            0|            0|  0.00%|    ValueError: all the input arrays must have same number of dimensions, but
  5382|         0|            0|            0|  0.00%|    the array at index 0 has 2 dimension(s) and the array at index 1 has 1
  5383|         0|            0|            0|  0.00%|    dimension(s)
  5384|         0|            0|            0|  0.00%|
  5385|         0|            0|            0|  0.00%|    """
  5386|         4|            0|            0|  0.00%|    arr = asanyarray(arr)
  5387|         4|            0|            0|  0.00%|    if axis is None:
  5388|         4|            0|            0|  0.00%|        if arr.ndim != 1:
  5389|         4|            0|            0|  0.00%|            arr = arr.ravel()
  5390|         4|            0|            0|  0.00%|        values = ravel(values)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 ravel
  5391|         4|            0|            0|  0.00%|        axis = arr.ndim-1
  5392|         4|            0|            0|  0.00%|    return concatenate((arr, values), axis=axis)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 concatenate
  5393|         0|            0|            0|  0.00%|
  5394|         0|            0|            0|  0.00%|
  5395|         0|            0|            0|  0.00%|def _digitize_dispatcher(x, bins, right=None):
  5396|         0|            0|            0|  0.00%|    return (x, bins)
  5397|         0|            0|            0|  0.00%|
  5398|         0|            0|            0|  0.00%|
  5399|         0|            0|            0|  0.00%|@array_function_dispatch(_digitize_dispatcher)
  5400|         0|            0|            0|  0.00%|def digitize(x, bins, right=False):
  5401|         0|            0|            0|  0.00%|    """
  5402|         0|            0|            0|  0.00%|    Return the indices of the bins to which each value in input array belongs.
  5403|         0|            0|            0|  0.00%|
  5404|         0|            0|            0|  0.00%|    =========  =============  ============================
  5405|         0|            0|            0|  0.00%|    `right`    order of bins  returned index `i` satisfies
  5406|         0|            0|            0|  0.00%|    =========  =============  ============================
  5407|         0|            0|            0|  0.00%|    ``False``  increasing     ``bins[i-1] <= x < bins[i]``
  5408|         0|            0|            0|  0.00%|    ``True``   increasing     ``bins[i-1] < x <= bins[i]``
  5409|         0|            0|            0|  0.00%|    ``False``  decreasing     ``bins[i-1] > x >= bins[i]``
  5410|         0|            0|            0|  0.00%|    ``True``   decreasing     ``bins[i-1] >= x > bins[i]``
  5411|         0|            0|            0|  0.00%|    =========  =============  ============================
  5412|         0|            0|            0|  0.00%|
  5413|         0|            0|            0|  0.00%|    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is
  5414|         0|            0|            0|  0.00%|    returned as appropriate.
  5415|         0|            0|            0|  0.00%|
  5416|         0|            0|            0|  0.00%|    Parameters
  5417|         0|            0|            0|  0.00%|    ----------
  5418|         0|            0|            0|  0.00%|    x : array_like
  5419|         0|            0|            0|  0.00%|        Input array to be binned. Prior to NumPy 1.10.0, this array had to
  5420|         0|            0|            0|  0.00%|        be 1-dimensional, but can now have any shape.
  5421|         0|            0|            0|  0.00%|    bins : array_like
  5422|         0|            0|            0|  0.00%|        Array of bins. It has to be 1-dimensional and monotonic.
  5423|         0|            0|            0|  0.00%|    right : bool, optional
  5424|         0|            0|            0|  0.00%|        Indicating whether the intervals include the right or the left bin
  5425|         0|            0|            0|  0.00%|        edge. Default behavior is (right==False) indicating that the interval
  5426|         0|            0|            0|  0.00%|        does not include the right edge. The left bin end is open in this
  5427|         0|            0|            0|  0.00%|        case, i.e., bins[i-1] <= x < bins[i] is the default behavior for
  5428|         0|            0|            0|  0.00%|        monotonically increasing bins.
  5429|         0|            0|            0|  0.00%|
  5430|         0|            0|            0|  0.00%|    Returns
  5431|         0|            0|            0|  0.00%|    -------
  5432|         0|            0|            0|  0.00%|    indices : ndarray of ints
  5433|         0|            0|            0|  0.00%|        Output array of indices, of same shape as `x`.
  5434|         0|            0|            0|  0.00%|
  5435|         0|            0|            0|  0.00%|    Raises
  5436|         0|            0|            0|  0.00%|    ------
  5437|         0|            0|            0|  0.00%|    ValueError
  5438|         0|            0|            0|  0.00%|        If `bins` is not monotonic.
  5439|         0|            0|            0|  0.00%|    TypeError
  5440|         0|            0|            0|  0.00%|        If the type of the input is complex.
  5441|         0|            0|            0|  0.00%|
  5442|         0|            0|            0|  0.00%|    See Also
  5443|         0|            0|            0|  0.00%|    --------
  5444|         0|            0|            0|  0.00%|    bincount, histogram, unique, searchsorted
  5445|         0|            0|            0|  0.00%|
  5446|         0|            0|            0|  0.00%|    Notes
  5447|         0|            0|            0|  0.00%|    -----
  5448|         0|            0|            0|  0.00%|    If values in `x` are such that they fall outside the bin range,
  5449|         0|            0|            0|  0.00%|    attempting to index `bins` with the indices that `digitize` returns
  5450|         0|            0|            0|  0.00%|    will result in an IndexError.
  5451|         0|            0|            0|  0.00%|
  5452|         0|            0|            0|  0.00%|    .. versionadded:: 1.10.0
  5453|         0|            0|            0|  0.00%|
  5454|         0|            0|            0|  0.00%|    `np.digitize` is  implemented in terms of `np.searchsorted`. This means
  5455|         0|            0|            0|  0.00%|    that a binary search is used to bin the values, which scales much better
  5456|         0|            0|            0|  0.00%|    for larger number of bins than the previous linear search. It also removes
  5457|         0|            0|            0|  0.00%|    the requirement for the input array to be 1-dimensional.
  5458|         0|            0|            0|  0.00%|
  5459|         0|            0|            0|  0.00%|    For monotonically _increasing_ `bins`, the following are equivalent::
  5460|         0|            0|            0|  0.00%|
  5461|         0|            0|            0|  0.00%|        np.digitize(x, bins, right=True)
  5462|         0|            0|            0|  0.00%|        np.searchsorted(bins, x, side='left')
  5463|         0|            0|            0|  0.00%|
  5464|         0|            0|            0|  0.00%|    Note that as the order of the arguments are reversed, the side must be too.
  5465|         0|            0|            0|  0.00%|    The `searchsorted` call is marginally faster, as it does not do any
  5466|         0|            0|            0|  0.00%|    monotonicity checks. Perhaps more importantly, it supports all dtypes.
  5467|         0|            0|            0|  0.00%|
  5468|         0|            0|            0|  0.00%|    Examples
  5469|         0|            0|            0|  0.00%|    --------
  5470|         0|            0|            0|  0.00%|    >>> x = np.array([0.2, 6.4, 3.0, 1.6])
  5471|         0|            0|            0|  0.00%|    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
  5472|         0|            0|            0|  0.00%|    >>> inds = np.digitize(x, bins)
  5473|         0|            0|            0|  0.00%|    >>> inds
  5474|         0|            0|            0|  0.00%|    array([1, 4, 3, 2])
  5475|         0|            0|            0|  0.00%|    >>> for n in range(x.size):
  5476|         0|            0|            0|  0.00%|    ...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])
  5477|         0|            0|            0|  0.00%|    ...
  5478|         0|            0|            0|  0.00%|    0.0 <= 0.2 < 1.0
  5479|         0|            0|            0|  0.00%|    4.0 <= 6.4 < 10.0
  5480|         0|            0|            0|  0.00%|    2.5 <= 3.0 < 4.0
  5481|         0|            0|            0|  0.00%|    1.0 <= 1.6 < 2.5
  5482|         0|            0|            0|  0.00%|
  5483|         0|            0|            0|  0.00%|    >>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
  5484|         0|            0|            0|  0.00%|    >>> bins = np.array([0, 5, 10, 15, 20])
  5485|         0|            0|            0|  0.00%|    >>> np.digitize(x,bins,right=True)
  5486|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 4])
  5487|         0|            0|            0|  0.00%|    >>> np.digitize(x,bins,right=False)
  5488|         0|            0|            0|  0.00%|    array([1, 3, 3, 4, 5])
  5489|         0|            0|            0|  0.00%|    """
  5490|         0|            0|            0|  0.00%|    x = _nx.asarray(x)
  5491|         0|            0|            0|  0.00%|    bins = _nx.asarray(bins)
  5492|         0|            0|            0|  0.00%|
  5493|         0|            0|            0|  0.00%|    # here for compatibility, searchsorted below is happy to take this
  5494|         0|            0|            0|  0.00%|    if np.issubdtype(x.dtype, _nx.complexfloating):
  5495|         0|            0|            0|  0.00%|        raise TypeError("x may not be complex")
  5496|         0|            0|            0|  0.00%|
  5497|         0|            0|            0|  0.00%|    mono = _monotonicity(bins)
  5498|         0|            0|            0|  0.00%|    if mono == 0:
  5499|         0|            0|            0|  0.00%|        raise ValueError("bins must be monotonically increasing or decreasing")
  5500|         0|            0|            0|  0.00%|
  5501|         0|            0|            0|  0.00%|    # this is backwards because the arguments below are swapped
  5502|         0|            0|            0|  0.00%|    side = 'left' if right else 'right'
  5503|         0|            0|            0|  0.00%|    if mono == -1:
  5504|         0|            0|            0|  0.00%|        # reverse the bins, and invert the results
  5505|         0|            0|            0|  0.00%|        return len(bins) - _nx.searchsorted(bins[::-1], x, side=side)
  5506|         0|            0|            0|  0.00%|    else:
  5507|         0|            0|            0|  0.00%|        return _nx.searchsorted(bins, x, side=side)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py
File duration: 0.0080843s (0.02%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Base class for sparse matrix formats using compressed storage."""
     2|         0|            0|            0|  0.00%|__all__ = []
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|from warnings import warn
     5|         0|            0|            0|  0.00%|import operator
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|import numpy as np
     8|         0|            0|            0|  0.00%|from scipy._lib._util import _prune_array
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|from .base import spmatrix, isspmatrix, SparseEfficiencyWarning
    11|         0|            0|            0|  0.00%|from .data import _data_matrix, _minmax_mixin
    12|         0|            0|            0|  0.00%|from .dia import dia_matrix
    13|         0|            0|            0|  0.00%|from . import _sparsetools
    14|         0|            0|            0|  0.00%|from ._sparsetools import (get_csr_submatrix, csr_sample_offsets, csr_todense,
    15|         0|            0|            0|  0.00%|                           csr_sample_values, csr_row_index, csr_row_slice,
    16|         0|            0|            0|  0.00%|                           csr_column_index1, csr_column_index2)
    17|         0|            0|            0|  0.00%|from ._index import IndexMixin
    18|         0|            0|            0|  0.00%|from .sputils import (upcast, upcast_char, to_native, isdense, isshape,
    19|         0|            0|            0|  0.00%|                      getdtype, isscalarlike, isintlike, get_index_dtype,
    20|         0|            0|            0|  0.00%|                      downcast_intp_index, get_sum_dtype, check_shape,
    21|         0|            0|            0|  0.00%|                      matrix, asmatrix, is_pydata_spmatrix)
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|class _cs_matrix(_data_matrix, _minmax_mixin, IndexMixin):
    25|         0|            0|            0|  0.00%|    """base matrix class for compressed row- and column-oriented matrices"""
    26|         0|            0|            0|  0.00%|
    27|        16|   0.00100398|  6.27488e-05|  0.00%|    def __init__(self, arg1, shape=None, dtype=None, copy=False):
    28|        16|  0.000998974|  6.24359e-05|  0.00%|        _data_matrix.__init__(self)
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:20 __init__
    29|         0|            0|            0|  0.00%|
    30|        16|            0|            0|  0.00%|        if isspmatrix(arg1):
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:1205 isspmatrix
    31|         0|            0|            0|  0.00%|            if arg1.format == self.format and copy:
    32|         0|            0|            0|  0.00%|                arg1 = arg1.copy()
    33|         0|            0|            0|  0.00%|            else:
    34|         0|            0|            0|  0.00%|                arg1 = arg1.asformat(self.format)
    35|         0|            0|            0|  0.00%|            self._set_self(arg1)
    36|         0|            0|            0|  0.00%|
    37|        16|            0|            0|  0.00%|        elif isinstance(arg1, tuple):
    38|        16|            0|            0|  0.00%|            if isshape(arg1):
(call)|        16|  0.000997066|  6.23167e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:220 isshape
    39|         0|            0|            0|  0.00%|                # It's a tuple of matrix dimensions (M, N)
    40|         0|            0|            0|  0.00%|                # create empty matrix
    41|         0|            0|            0|  0.00%|                self._shape = check_shape(arg1)
    42|         0|            0|            0|  0.00%|                M, N = self.shape
    43|         0|            0|            0|  0.00%|                # Select index dtype large enough to pass array and
    44|         0|            0|            0|  0.00%|                # scalar parameters to sparsetools
    45|         0|            0|            0|  0.00%|                idx_dtype = get_index_dtype(maxval=max(M, N))
    46|         0|            0|            0|  0.00%|                self.data = np.zeros(0, getdtype(dtype, default=float))
    47|         0|            0|            0|  0.00%|                self.indices = np.zeros(0, idx_dtype)
    48|         0|            0|            0|  0.00%|                self.indptr = np.zeros(self._swap((M, N))[0] + 1,
    49|         0|            0|            0|  0.00%|                                       dtype=idx_dtype)
    50|         0|            0|            0|  0.00%|            else:
    51|        16|            0|            0|  0.00%|                if len(arg1) == 2:
    52|         0|            0|            0|  0.00%|                    # (data, ij) format
    53|         0|            0|            0|  0.00%|                    from .coo import coo_matrix
    54|         0|            0|            0|  0.00%|                    other = self.__class__(coo_matrix(arg1, shape=shape,
    55|         0|            0|            0|  0.00%|                                                      dtype=dtype))
    56|         0|            0|            0|  0.00%|                    self._set_self(other)
    57|        16|            0|            0|  0.00%|                elif len(arg1) == 3:
    58|         0|            0|            0|  0.00%|                    # (data, indices, indptr) format
    59|        16|            0|            0|  0.00%|                    (data, indices, indptr) = arg1
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|                    # Select index dtype large enough to pass array and
    62|         0|            0|            0|  0.00%|                    # scalar parameters to sparsetools
    63|        16|            0|            0|  0.00%|                    maxval = None
    64|        16|            0|            0|  0.00%|                    if shape is not None:
    65|        16|            0|            0|  0.00%|                        maxval = max(shape)
    66|        32|            0|            0|  0.00%|                    idx_dtype = get_index_dtype((indices, indptr),
(call)|        16|  0.000997066|  6.23167e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:131 get_index_dtype
    67|        16|            0|            0|  0.00%|                                                maxval=maxval,
    68|        16|            0|            0|  0.00%|                                                check_contents=True)
    69|         0|            0|            0|  0.00%|
    70|        32|            0|            0|  0.00%|                    self.indices = np.array(indices, copy=copy,
    71|        16|            0|            0|  0.00%|                                            dtype=idx_dtype)
    72|        16|            0|            0|  0.00%|                    self.indptr = np.array(indptr, copy=copy, dtype=idx_dtype)
    73|        16|            0|            0|  0.00%|                    self.data = np.array(data, copy=copy, dtype=dtype)
    74|         0|            0|            0|  0.00%|                else:
    75|         0|            0|            0|  0.00%|                    raise ValueError("unrecognized {}_matrix "
    76|         0|            0|            0|  0.00%|                                     "constructor usage".format(self.format))
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|        else:
    79|         0|            0|            0|  0.00%|            # must be dense
    80|         0|            0|            0|  0.00%|            try:
    81|         0|            0|            0|  0.00%|                arg1 = np.asarray(arg1)
    82|         0|            0|            0|  0.00%|            except Exception as e:
    83|         0|            0|            0|  0.00%|                raise ValueError("unrecognized {}_matrix constructor usage"
    84|         0|            0|            0|  0.00%|                                 "".format(self.format)) from e
    85|         0|            0|            0|  0.00%|            from .coo import coo_matrix
    86|         0|            0|            0|  0.00%|            self._set_self(self.__class__(coo_matrix(arg1, dtype=dtype)))
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|        # Read matrix dimensions given, if any
    89|        16|  0.000997782|  6.23614e-05|  0.00%|        if shape is not None:
    90|        16|   0.00102282|   6.3926e-05|  0.00%|            self._shape = check_shape(shape)
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:277 check_shape
    91|         0|            0|            0|  0.00%|        else:
    92|         0|            0|            0|  0.00%|            if self.shape is None:
    93|         0|            0|            0|  0.00%|                # shape not already set, try to infer dimensions
    94|         0|            0|            0|  0.00%|                try:
    95|         0|            0|            0|  0.00%|                    major_dim = len(self.indptr) - 1
    96|         0|            0|            0|  0.00%|                    minor_dim = self.indices.max() + 1
    97|         0|            0|            0|  0.00%|                except Exception as e:
    98|         0|            0|            0|  0.00%|                    raise ValueError('unable to infer matrix dimensions') from e
    99|         0|            0|            0|  0.00%|                else:
   100|         0|            0|            0|  0.00%|                    self._shape = check_shape(self._swap((major_dim,
   101|         0|            0|            0|  0.00%|                                                          minor_dim)))
   102|         0|            0|            0|  0.00%|
   103|        16|            0|            0|  0.00%|        if dtype is not None:
   104|         8|            0|            0|  0.00%|            self.data = self.data.astype(dtype, copy=False)
   105|         0|            0|            0|  0.00%|
   106|        16|            0|            0|  0.00%|        self.check_format(full_check=False)
(call)|        16|   0.00700402|  0.000437751|  0.02%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:136 check_format
   107|         0|            0|            0|  0.00%|
   108|        72|            0|            0|  0.00%|    def getnnz(self, axis=None):
   109|        72|            0|            0|  0.00%|        if axis is None:
   110|        72|  0.000992298|  1.37819e-05|  0.00%|            return int(self.indptr[-1])
   111|         0|            0|            0|  0.00%|        else:
   112|         0|            0|            0|  0.00%|            if axis < 0:
   113|         0|            0|            0|  0.00%|                axis += 2
   114|         0|            0|            0|  0.00%|            axis, _ = self._swap((axis, 1 - axis))
   115|         0|            0|            0|  0.00%|            _, N = self._swap(self.shape)
   116|         0|            0|            0|  0.00%|            if axis == 0:
   117|         0|            0|            0|  0.00%|                return np.bincount(downcast_intp_index(self.indices),
   118|         0|            0|            0|  0.00%|                                   minlength=N)
   119|         0|            0|            0|  0.00%|            elif axis == 1:
   120|         0|            0|            0|  0.00%|                return np.diff(self.indptr)
   121|         0|            0|            0|  0.00%|            raise ValueError('axis out of bounds')
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    getnnz.__doc__ = spmatrix.getnnz.__doc__
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    def _set_self(self, other, copy=False):
   126|         0|            0|            0|  0.00%|        """take the member variables of other and assign them to self"""
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|        if copy:
   129|         0|            0|            0|  0.00%|            other = other.copy()
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|        self.data = other.data
   132|         0|            0|            0|  0.00%|        self.indices = other.indices
   133|         0|            0|            0|  0.00%|        self.indptr = other.indptr
   134|         0|            0|            0|  0.00%|        self._shape = check_shape(other.shape)
   135|         0|            0|            0|  0.00%|
   136|        16|            0|            0|  0.00%|    def check_format(self, full_check=True):
   137|         0|            0|            0|  0.00%|        """check whether the matrix format is valid
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|        Parameters
   140|         0|            0|            0|  0.00%|        ----------
   141|         0|            0|            0|  0.00%|        full_check : bool, optional
   142|         0|            0|            0|  0.00%|            If `True`, rigorous check, O(N) operations. Otherwise
   143|         0|            0|            0|  0.00%|            basic check, O(1) operations (default True).
   144|         0|            0|            0|  0.00%|        """
   145|         0|            0|            0|  0.00%|        # use _swap to determine proper bounds
   146|        16|            0|            0|  0.00%|        major_name, minor_name = self._swap(('row', 'column'))
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:235 _swap
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csc.py:229 _swap
   147|        16|            0|            0|  0.00%|        major_dim, minor_dim = self._swap(self.shape)
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|        12|  0.000997543|  8.31286e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:235 _swap
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csc.py:229 _swap
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|        # index arrays should have integer data types
   150|        16|            0|            0|  0.00%|        if self.indptr.dtype.kind != 'i':
   151|         0|            0|            0|  0.00%|            warn("indptr array has non-integer dtype ({})"
   152|         0|            0|            0|  0.00%|                 "".format(self.indptr.dtype.name), stacklevel=3)
   153|        16|            0|            0|  0.00%|        if self.indices.dtype.kind != 'i':
   154|         0|            0|            0|  0.00%|            warn("indices array has non-integer dtype ({})"
   155|         0|            0|            0|  0.00%|                 "".format(self.indices.dtype.name), stacklevel=3)
   156|         0|            0|            0|  0.00%|
   157|        16|            0|            0|  0.00%|        idx_dtype = get_index_dtype((self.indptr, self.indices))
(call)|        16|  0.000997782|  6.23614e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:131 get_index_dtype
   158|        16|            0|            0|  0.00%|        self.indptr = np.asarray(self.indptr, dtype=idx_dtype)
   159|        16|            0|            0|  0.00%|        self.indices = np.asarray(self.indices, dtype=idx_dtype)
   160|        16|            0|            0|  0.00%|        self.data = to_native(self.data)
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:91 to_native
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|        # check array shapes
   163|        64|            0|            0|  0.00%|        for x in [self.data.ndim, self.indices.ndim, self.indptr.ndim]:
   164|        48|            0|            0|  0.00%|            if x != 1:
   165|         0|            0|            0|  0.00%|                raise ValueError('data, indices, and indptr should be 1-D')
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|        # check index pointer
   168|        16|            0|            0|  0.00%|        if (len(self.indptr) != major_dim + 1):
   169|         0|            0|            0|  0.00%|            raise ValueError("index pointer size ({}) should be ({})"
   170|         0|            0|            0|  0.00%|                             "".format(len(self.indptr), major_dim + 1))
   171|        16|            0|            0|  0.00%|        if (self.indptr[0] != 0):
   172|         0|            0|            0|  0.00%|            raise ValueError("index pointer should start with 0")
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|        # check index and data arrays
   175|        16|            0|            0|  0.00%|        if (len(self.indices) != len(self.data)):
   176|         0|            0|            0|  0.00%|            raise ValueError("indices and data should have the same size")
   177|        16|            0|            0|  0.00%|        if (self.indptr[-1] > len(self.indices)):
   178|         0|            0|            0|  0.00%|            raise ValueError("Last value of index pointer should be less than "
   179|         0|            0|            0|  0.00%|                             "the size of index and data arrays")
   180|         0|            0|            0|  0.00%|
   181|        16|  7.27177e-05|  4.54485e-06|  0.00%|        self.prune()
(call)|        16|   0.00493598|  0.000308499|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1156 prune
   182|         0|            0|            0|  0.00%|
   183|        16|            0|            0|  0.00%|        if full_check:
   184|         0|            0|            0|  0.00%|            # check format validity (more expensive)
   185|         0|            0|            0|  0.00%|            if self.nnz > 0:
   186|         0|            0|            0|  0.00%|                if self.indices.max() >= minor_dim:
   187|         0|            0|            0|  0.00%|                    raise ValueError("{} index values must be < {}"
   188|         0|            0|            0|  0.00%|                                     "".format(minor_name, minor_dim))
   189|         0|            0|            0|  0.00%|                if self.indices.min() < 0:
   190|         0|            0|            0|  0.00%|                    raise ValueError("{} index values must be >= 0"
   191|         0|            0|            0|  0.00%|                                     "".format(minor_name))
   192|         0|            0|            0|  0.00%|                if np.diff(self.indptr).min() < 0:
   193|         0|            0|            0|  0.00%|                    raise ValueError("index pointer values must form a "
   194|         0|            0|            0|  0.00%|                                     "non-decreasing sequence")
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|        # if not self.has_sorted_indices():
   197|         0|            0|            0|  0.00%|        #    warn('Indices were not in sorted order.  Sorting indices.')
   198|         0|            0|            0|  0.00%|        #    self.sort_indices()
   199|         0|            0|            0|  0.00%|        #    assert(self.has_sorted_indices())
   200|         0|            0|            0|  0.00%|        # TODO check for duplicates?
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    #######################
   203|         0|            0|            0|  0.00%|    # Boolean comparisons #
   204|         0|            0|            0|  0.00%|    #######################
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|    def _scalar_binopt(self, other, op):
   207|         0|            0|            0|  0.00%|        """Scalar version of self._binopt, for cases in which no new nonzeros
   208|         0|            0|            0|  0.00%|        are added. Produces a new spmatrix in canonical form.
   209|         0|            0|            0|  0.00%|        """
   210|         0|            0|            0|  0.00%|        self.sum_duplicates()
   211|         0|            0|            0|  0.00%|        res = self._with_data(op(self.data, other), copy=True)
   212|         0|            0|            0|  0.00%|        res.eliminate_zeros()
   213|         0|            0|            0|  0.00%|        return res
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    def __eq__(self, other):
   216|         0|            0|            0|  0.00%|        # Scalar other.
   217|         0|            0|            0|  0.00%|        if isscalarlike(other):
   218|         0|            0|            0|  0.00%|            if np.isnan(other):
   219|         0|            0|            0|  0.00%|                return self.__class__(self.shape, dtype=np.bool_)
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|            if other == 0:
   222|         0|            0|            0|  0.00%|                warn("Comparing a sparse matrix with 0 using == is inefficient"
   223|         0|            0|            0|  0.00%|                     ", try using != instead.", SparseEfficiencyWarning,
   224|         0|            0|            0|  0.00%|                     stacklevel=3)
   225|         0|            0|            0|  0.00%|                all_true = self.__class__(np.ones(self.shape, dtype=np.bool_))
   226|         0|            0|            0|  0.00%|                inv = self._scalar_binopt(other, operator.ne)
   227|         0|            0|            0|  0.00%|                return all_true - inv
   228|         0|            0|            0|  0.00%|            else:
   229|         0|            0|            0|  0.00%|                return self._scalar_binopt(other, operator.eq)
   230|         0|            0|            0|  0.00%|        # Dense other.
   231|         0|            0|            0|  0.00%|        elif isdense(other):
   232|         0|            0|            0|  0.00%|            return self.todense() == other
   233|         0|            0|            0|  0.00%|        # Pydata sparse other.
   234|         0|            0|            0|  0.00%|        elif is_pydata_spmatrix(other):
   235|         0|            0|            0|  0.00%|            return NotImplemented
   236|         0|            0|            0|  0.00%|        # Sparse other.
   237|         0|            0|            0|  0.00%|        elif isspmatrix(other):
   238|         0|            0|            0|  0.00%|            warn("Comparing sparse matrices using == is inefficient, try using"
   239|         0|            0|            0|  0.00%|                 " != instead.", SparseEfficiencyWarning, stacklevel=3)
   240|         0|            0|            0|  0.00%|            # TODO sparse broadcasting
   241|         0|            0|            0|  0.00%|            if self.shape != other.shape:
   242|         0|            0|            0|  0.00%|                return False
   243|         0|            0|            0|  0.00%|            elif self.format != other.format:
   244|         0|            0|            0|  0.00%|                other = other.asformat(self.format)
   245|         0|            0|            0|  0.00%|            res = self._binopt(other, '_ne_')
   246|         0|            0|            0|  0.00%|            all_true = self.__class__(np.ones(self.shape, dtype=np.bool_))
   247|         0|            0|            0|  0.00%|            return all_true - res
   248|         0|            0|            0|  0.00%|        else:
   249|         0|            0|            0|  0.00%|            return False
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    def __ne__(self, other):
   252|         0|            0|            0|  0.00%|        # Scalar other.
   253|         0|            0|            0|  0.00%|        if isscalarlike(other):
   254|         0|            0|            0|  0.00%|            if np.isnan(other):
   255|         0|            0|            0|  0.00%|                warn("Comparing a sparse matrix with nan using != is"
   256|         0|            0|            0|  0.00%|                     " inefficient", SparseEfficiencyWarning, stacklevel=3)
   257|         0|            0|            0|  0.00%|                all_true = self.__class__(np.ones(self.shape, dtype=np.bool_))
   258|         0|            0|            0|  0.00%|                return all_true
   259|         0|            0|            0|  0.00%|            elif other != 0:
   260|         0|            0|            0|  0.00%|                warn("Comparing a sparse matrix with a nonzero scalar using !="
   261|         0|            0|            0|  0.00%|                     " is inefficient, try using == instead.",
   262|         0|            0|            0|  0.00%|                     SparseEfficiencyWarning, stacklevel=3)
   263|         0|            0|            0|  0.00%|                all_true = self.__class__(np.ones(self.shape), dtype=np.bool_)
   264|         0|            0|            0|  0.00%|                inv = self._scalar_binopt(other, operator.eq)
   265|         0|            0|            0|  0.00%|                return all_true - inv
   266|         0|            0|            0|  0.00%|            else:
   267|         0|            0|            0|  0.00%|                return self._scalar_binopt(other, operator.ne)
   268|         0|            0|            0|  0.00%|        # Dense other.
   269|         0|            0|            0|  0.00%|        elif isdense(other):
   270|         0|            0|            0|  0.00%|            return self.todense() != other
   271|         0|            0|            0|  0.00%|        # Pydata sparse other.
   272|         0|            0|            0|  0.00%|        elif is_pydata_spmatrix(other):
   273|         0|            0|            0|  0.00%|            return NotImplemented
   274|         0|            0|            0|  0.00%|        # Sparse other.
   275|         0|            0|            0|  0.00%|        elif isspmatrix(other):
   276|         0|            0|            0|  0.00%|            # TODO sparse broadcasting
   277|         0|            0|            0|  0.00%|            if self.shape != other.shape:
   278|         0|            0|            0|  0.00%|                return True
   279|         0|            0|            0|  0.00%|            elif self.format != other.format:
   280|         0|            0|            0|  0.00%|                other = other.asformat(self.format)
   281|         0|            0|            0|  0.00%|            return self._binopt(other, '_ne_')
   282|         0|            0|            0|  0.00%|        else:
   283|         0|            0|            0|  0.00%|            return True
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    def _inequality(self, other, op, op_name, bad_scalar_msg):
   286|         0|            0|            0|  0.00%|        # Scalar other.
   287|         0|            0|            0|  0.00%|        if isscalarlike(other):
   288|         0|            0|            0|  0.00%|            if 0 == other and op_name in ('_le_', '_ge_'):
   289|         0|            0|            0|  0.00%|                raise NotImplementedError(" >= and <= don't work with 0.")
   290|         0|            0|            0|  0.00%|            elif op(0, other):
   291|         0|            0|            0|  0.00%|                warn(bad_scalar_msg, SparseEfficiencyWarning)
   292|         0|            0|            0|  0.00%|                other_arr = np.empty(self.shape, dtype=np.result_type(other))
   293|         0|            0|            0|  0.00%|                other_arr.fill(other)
   294|         0|            0|            0|  0.00%|                other_arr = self.__class__(other_arr)
   295|         0|            0|            0|  0.00%|                return self._binopt(other_arr, op_name)
   296|         0|            0|            0|  0.00%|            else:
   297|         0|            0|            0|  0.00%|                return self._scalar_binopt(other, op)
   298|         0|            0|            0|  0.00%|        # Dense other.
   299|         0|            0|            0|  0.00%|        elif isdense(other):
   300|         0|            0|            0|  0.00%|            return op(self.todense(), other)
   301|         0|            0|            0|  0.00%|        # Sparse other.
   302|         0|            0|            0|  0.00%|        elif isspmatrix(other):
   303|         0|            0|            0|  0.00%|            # TODO sparse broadcasting
   304|         0|            0|            0|  0.00%|            if self.shape != other.shape:
   305|         0|            0|            0|  0.00%|                raise ValueError("inconsistent shapes")
   306|         0|            0|            0|  0.00%|            elif self.format != other.format:
   307|         0|            0|            0|  0.00%|                other = other.asformat(self.format)
   308|         0|            0|            0|  0.00%|            if op_name not in ('_ge_', '_le_'):
   309|         0|            0|            0|  0.00%|                return self._binopt(other, op_name)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|            warn("Comparing sparse matrices using >= and <= is inefficient, "
   312|         0|            0|            0|  0.00%|                 "using <, >, or !=, instead.", SparseEfficiencyWarning)
   313|         0|            0|            0|  0.00%|            all_true = self.__class__(np.ones(self.shape, dtype=np.bool_))
   314|         0|            0|            0|  0.00%|            res = self._binopt(other, '_gt_' if op_name == '_le_' else '_lt_')
   315|         0|            0|            0|  0.00%|            return all_true - res
   316|         0|            0|            0|  0.00%|        else:
   317|         0|            0|            0|  0.00%|            raise ValueError("Operands could not be compared.")
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|    def __lt__(self, other):
   320|         0|            0|            0|  0.00%|        return self._inequality(other, operator.lt, '_lt_',
   321|         0|            0|            0|  0.00%|                                "Comparing a sparse matrix with a scalar "
   322|         0|            0|            0|  0.00%|                                "greater than zero using < is inefficient, "
   323|         0|            0|            0|  0.00%|                                "try using >= instead.")
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|    def __gt__(self, other):
   326|         0|            0|            0|  0.00%|        return self._inequality(other, operator.gt, '_gt_',
   327|         0|            0|            0|  0.00%|                                "Comparing a sparse matrix with a scalar "
   328|         0|            0|            0|  0.00%|                                "less than zero using > is inefficient, "
   329|         0|            0|            0|  0.00%|                                "try using <= instead.")
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    def __le__(self, other):
   332|         0|            0|            0|  0.00%|        return self._inequality(other, operator.le, '_le_',
   333|         0|            0|            0|  0.00%|                                "Comparing a sparse matrix with a scalar "
   334|         0|            0|            0|  0.00%|                                "greater than zero using <= is inefficient, "
   335|         0|            0|            0|  0.00%|                                "try using > instead.")
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|    def __ge__(self, other):
   338|         0|            0|            0|  0.00%|        return self._inequality(other, operator.ge, '_ge_',
   339|         0|            0|            0|  0.00%|                                "Comparing a sparse matrix with a scalar "
   340|         0|            0|            0|  0.00%|                                "less than zero using >= is inefficient, "
   341|         0|            0|            0|  0.00%|                                "try using < instead.")
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    #################################
   344|         0|            0|            0|  0.00%|    # Arithmetic operator overrides #
   345|         0|            0|            0|  0.00%|    #################################
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|    def _add_dense(self, other):
   348|         0|            0|            0|  0.00%|        if other.shape != self.shape:
   349|         0|            0|            0|  0.00%|            raise ValueError('Incompatible shapes ({} and {})'
   350|         0|            0|            0|  0.00%|                             .format(self.shape, other.shape))
   351|         0|            0|            0|  0.00%|        dtype = upcast_char(self.dtype.char, other.dtype.char)
   352|         0|            0|            0|  0.00%|        order = self._swap('CF')[0]
   353|         0|            0|            0|  0.00%|        result = np.array(other, dtype=dtype, order=order, copy=True)
   354|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   355|         0|            0|            0|  0.00%|        y = result if result.flags.c_contiguous else result.T
   356|         0|            0|            0|  0.00%|        csr_todense(M, N, self.indptr, self.indices, self.data, y)
   357|         0|            0|            0|  0.00%|        return matrix(result, copy=False)
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|    def _add_sparse(self, other):
   360|         0|            0|            0|  0.00%|        return self._binopt(other, '_plus_')
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    def _sub_sparse(self, other):
   363|         0|            0|            0|  0.00%|        return self._binopt(other, '_minus_')
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|    def multiply(self, other):
   366|         0|            0|            0|  0.00%|        """Point-wise multiplication by another matrix, vector, or
   367|         0|            0|            0|  0.00%|        scalar.
   368|         0|            0|            0|  0.00%|        """
   369|         0|            0|            0|  0.00%|        # Scalar multiplication.
   370|         0|            0|            0|  0.00%|        if isscalarlike(other):
   371|         0|            0|            0|  0.00%|            return self._mul_scalar(other)
   372|         0|            0|            0|  0.00%|        # Sparse matrix or vector.
   373|         0|            0|            0|  0.00%|        if isspmatrix(other):
   374|         0|            0|            0|  0.00%|            if self.shape == other.shape:
   375|         0|            0|            0|  0.00%|                other = self.__class__(other)
   376|         0|            0|            0|  0.00%|                return self._binopt(other, '_elmul_')
   377|         0|            0|            0|  0.00%|            # Single element.
   378|         0|            0|            0|  0.00%|            elif other.shape == (1, 1):
   379|         0|            0|            0|  0.00%|                return self._mul_scalar(other.toarray()[0, 0])
   380|         0|            0|            0|  0.00%|            elif self.shape == (1, 1):
   381|         0|            0|            0|  0.00%|                return other._mul_scalar(self.toarray()[0, 0])
   382|         0|            0|            0|  0.00%|            # A row times a column.
   383|         0|            0|            0|  0.00%|            elif self.shape[1] == 1 and other.shape[0] == 1:
   384|         0|            0|            0|  0.00%|                return self._mul_sparse_matrix(other.tocsc())
   385|         0|            0|            0|  0.00%|            elif self.shape[0] == 1 and other.shape[1] == 1:
   386|         0|            0|            0|  0.00%|                return other._mul_sparse_matrix(self.tocsc())
   387|         0|            0|            0|  0.00%|            # Row vector times matrix. other is a row.
   388|         0|            0|            0|  0.00%|            elif other.shape[0] == 1 and self.shape[1] == other.shape[1]:
   389|         0|            0|            0|  0.00%|                other = dia_matrix((other.toarray().ravel(), [0]),
   390|         0|            0|            0|  0.00%|                                   shape=(other.shape[1], other.shape[1]))
   391|         0|            0|            0|  0.00%|                return self._mul_sparse_matrix(other)
   392|         0|            0|            0|  0.00%|            # self is a row.
   393|         0|            0|            0|  0.00%|            elif self.shape[0] == 1 and self.shape[1] == other.shape[1]:
   394|         0|            0|            0|  0.00%|                copy = dia_matrix((self.toarray().ravel(), [0]),
   395|         0|            0|            0|  0.00%|                                  shape=(self.shape[1], self.shape[1]))
   396|         0|            0|            0|  0.00%|                return other._mul_sparse_matrix(copy)
   397|         0|            0|            0|  0.00%|            # Column vector times matrix. other is a column.
   398|         0|            0|            0|  0.00%|            elif other.shape[1] == 1 and self.shape[0] == other.shape[0]:
   399|         0|            0|            0|  0.00%|                other = dia_matrix((other.toarray().ravel(), [0]),
   400|         0|            0|            0|  0.00%|                                   shape=(other.shape[0], other.shape[0]))
   401|         0|            0|            0|  0.00%|                return other._mul_sparse_matrix(self)
   402|         0|            0|            0|  0.00%|            # self is a column.
   403|         0|            0|            0|  0.00%|            elif self.shape[1] == 1 and self.shape[0] == other.shape[0]:
   404|         0|            0|            0|  0.00%|                copy = dia_matrix((self.toarray().ravel(), [0]),
   405|         0|            0|            0|  0.00%|                                  shape=(self.shape[0], self.shape[0]))
   406|         0|            0|            0|  0.00%|                return copy._mul_sparse_matrix(other)
   407|         0|            0|            0|  0.00%|            else:
   408|         0|            0|            0|  0.00%|                raise ValueError("inconsistent shapes")
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|        # Assume other is a dense matrix/array, which produces a single-item
   411|         0|            0|            0|  0.00%|        # object array if other isn't convertible to ndarray.
   412|         0|            0|            0|  0.00%|        other = np.atleast_2d(other)
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|        if other.ndim != 2:
   415|         0|            0|            0|  0.00%|            return np.multiply(self.toarray(), other)
   416|         0|            0|            0|  0.00%|        # Single element / wrapped object.
   417|         0|            0|            0|  0.00%|        if other.size == 1:
   418|         0|            0|            0|  0.00%|            return self._mul_scalar(other.flat[0])
   419|         0|            0|            0|  0.00%|        # Fast case for trivial sparse matrix.
   420|         0|            0|            0|  0.00%|        elif self.shape == (1, 1):
   421|         0|            0|            0|  0.00%|            return np.multiply(self.toarray()[0, 0], other)
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|        from .coo import coo_matrix
   424|         0|            0|            0|  0.00%|        ret = self.tocoo()
   425|         0|            0|            0|  0.00%|        # Matching shapes.
   426|         0|            0|            0|  0.00%|        if self.shape == other.shape:
   427|         0|            0|            0|  0.00%|            data = np.multiply(ret.data, other[ret.row, ret.col])
   428|         0|            0|            0|  0.00%|        # Sparse row vector times...
   429|         0|            0|            0|  0.00%|        elif self.shape[0] == 1:
   430|         0|            0|            0|  0.00%|            if other.shape[1] == 1:  # Dense column vector.
   431|         0|            0|            0|  0.00%|                data = np.multiply(ret.data, other)
   432|         0|            0|            0|  0.00%|            elif other.shape[1] == self.shape[1]:  # Dense matrix.
   433|         0|            0|            0|  0.00%|                data = np.multiply(ret.data, other[:, ret.col])
   434|         0|            0|            0|  0.00%|            else:
   435|         0|            0|            0|  0.00%|                raise ValueError("inconsistent shapes")
   436|         0|            0|            0|  0.00%|            row = np.repeat(np.arange(other.shape[0]), len(ret.row))
   437|         0|            0|            0|  0.00%|            col = np.tile(ret.col, other.shape[0])
   438|         0|            0|            0|  0.00%|            return coo_matrix((data.view(np.ndarray).ravel(), (row, col)),
   439|         0|            0|            0|  0.00%|                              shape=(other.shape[0], self.shape[1]),
   440|         0|            0|            0|  0.00%|                              copy=False)
   441|         0|            0|            0|  0.00%|        # Sparse column vector times...
   442|         0|            0|            0|  0.00%|        elif self.shape[1] == 1:
   443|         0|            0|            0|  0.00%|            if other.shape[0] == 1:  # Dense row vector.
   444|         0|            0|            0|  0.00%|                data = np.multiply(ret.data[:, None], other)
   445|         0|            0|            0|  0.00%|            elif other.shape[0] == self.shape[0]:  # Dense matrix.
   446|         0|            0|            0|  0.00%|                data = np.multiply(ret.data[:, None], other[ret.row])
   447|         0|            0|            0|  0.00%|            else:
   448|         0|            0|            0|  0.00%|                raise ValueError("inconsistent shapes")
   449|         0|            0|            0|  0.00%|            row = np.repeat(ret.row, other.shape[1])
   450|         0|            0|            0|  0.00%|            col = np.tile(np.arange(other.shape[1]), len(ret.col))
   451|         0|            0|            0|  0.00%|            return coo_matrix((data.view(np.ndarray).ravel(), (row, col)),
   452|         0|            0|            0|  0.00%|                              shape=(self.shape[0], other.shape[1]),
   453|         0|            0|            0|  0.00%|                              copy=False)
   454|         0|            0|            0|  0.00%|        # Sparse matrix times dense row vector.
   455|         0|            0|            0|  0.00%|        elif other.shape[0] == 1 and self.shape[1] == other.shape[1]:
   456|         0|            0|            0|  0.00%|            data = np.multiply(ret.data, other[:, ret.col].ravel())
   457|         0|            0|            0|  0.00%|        # Sparse matrix times dense column vector.
   458|         0|            0|            0|  0.00%|        elif other.shape[1] == 1 and self.shape[0] == other.shape[0]:
   459|         0|            0|            0|  0.00%|            data = np.multiply(ret.data, other[ret.row].ravel())
   460|         0|            0|            0|  0.00%|        else:
   461|         0|            0|            0|  0.00%|            raise ValueError("inconsistent shapes")
   462|         0|            0|            0|  0.00%|        ret.data = data.view(np.ndarray).ravel()
   463|         0|            0|            0|  0.00%|        return ret
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    ###########################
   466|         0|            0|            0|  0.00%|    # Multiplication handlers #
   467|         0|            0|            0|  0.00%|    ###########################
   468|         0|            0|            0|  0.00%|
   469|         8|            0|            0|  0.00%|    def _mul_vector(self, other):
   470|         8|            0|            0|  0.00%|        M, N = self.shape
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|        # output array
   473|        16|            0|            0|  0.00%|        result = np.zeros(M, dtype=upcast_char(self.dtype.char,
(call)|         8|  0.000968695|  0.000121087|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:54 upcast_char
   474|         8|            0|            0|  0.00%|                                               other.dtype.char))
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|        # csr_matvec or csc_matvec
   477|         8|            0|            0|  0.00%|        fn = getattr(_sparsetools, self.format + '_matvec')
   478|         8|            0|            0|  0.00%|        fn(M, N, self.indptr, self.indices, self.data, other, result)
   479|         0|            0|            0|  0.00%|
   480|         8|            0|            0|  0.00%|        return result
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    def _mul_multivector(self, other):
   483|         0|            0|            0|  0.00%|        M, N = self.shape
   484|         0|            0|            0|  0.00%|        n_vecs = other.shape[1]  # number of column vectors
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|        result = np.zeros((M, n_vecs),
   487|         0|            0|            0|  0.00%|                          dtype=upcast_char(self.dtype.char, other.dtype.char))
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|        # csr_matvecs or csc_matvecs
   490|         0|            0|            0|  0.00%|        fn = getattr(_sparsetools, self.format + '_matvecs')
   491|         0|            0|            0|  0.00%|        fn(M, N, n_vecs, self.indptr, self.indices, self.data,
   492|         0|            0|            0|  0.00%|           other.ravel(), result.ravel())
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|        return result
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    def _mul_sparse_matrix(self, other):
   497|         0|            0|            0|  0.00%|        M, K1 = self.shape
   498|         0|            0|            0|  0.00%|        K2, N = other.shape
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|        major_axis = self._swap((M, N))[0]
   501|         0|            0|            0|  0.00%|        other = self.__class__(other)  # convert to this format
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|        idx_dtype = get_index_dtype((self.indptr, self.indices,
   504|         0|            0|            0|  0.00%|                                     other.indptr, other.indices))
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|        fn = getattr(_sparsetools, self.format + '_matmat_maxnnz')
   507|         0|            0|            0|  0.00%|        nnz = fn(M, N,
   508|         0|            0|            0|  0.00%|                 np.asarray(self.indptr, dtype=idx_dtype),
   509|         0|            0|            0|  0.00%|                 np.asarray(self.indices, dtype=idx_dtype),
   510|         0|            0|            0|  0.00%|                 np.asarray(other.indptr, dtype=idx_dtype),
   511|         0|            0|            0|  0.00%|                 np.asarray(other.indices, dtype=idx_dtype))
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|        idx_dtype = get_index_dtype((self.indptr, self.indices,
   514|         0|            0|            0|  0.00%|                                     other.indptr, other.indices),
   515|         0|            0|            0|  0.00%|                                    maxval=nnz)
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|        indptr = np.empty(major_axis + 1, dtype=idx_dtype)
   518|         0|            0|            0|  0.00%|        indices = np.empty(nnz, dtype=idx_dtype)
   519|         0|            0|            0|  0.00%|        data = np.empty(nnz, dtype=upcast(self.dtype, other.dtype))
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|        fn = getattr(_sparsetools, self.format + '_matmat')
   522|         0|            0|            0|  0.00%|        fn(M, N, np.asarray(self.indptr, dtype=idx_dtype),
   523|         0|            0|            0|  0.00%|           np.asarray(self.indices, dtype=idx_dtype),
   524|         0|            0|            0|  0.00%|           self.data,
   525|         0|            0|            0|  0.00%|           np.asarray(other.indptr, dtype=idx_dtype),
   526|         0|            0|            0|  0.00%|           np.asarray(other.indices, dtype=idx_dtype),
   527|         0|            0|            0|  0.00%|           other.data,
   528|         0|            0|            0|  0.00%|           indptr, indices, data)
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|        return self.__class__((data, indices, indptr), shape=(M, N))
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|    def diagonal(self, k=0):
   533|         0|            0|            0|  0.00%|        rows, cols = self.shape
   534|         0|            0|            0|  0.00%|        if k <= -rows or k >= cols:
   535|         0|            0|            0|  0.00%|            return np.empty(0, dtype=self.data.dtype)
   536|         0|            0|            0|  0.00%|        fn = getattr(_sparsetools, self.format + "_diagonal")
   537|         0|            0|            0|  0.00%|        y = np.empty(min(rows + min(k, 0), cols - max(k, 0)),
   538|         0|            0|            0|  0.00%|                     dtype=upcast(self.dtype))
   539|         0|            0|            0|  0.00%|        fn(k, self.shape[0], self.shape[1], self.indptr, self.indices,
   540|         0|            0|            0|  0.00%|           self.data, y)
   541|         0|            0|            0|  0.00%|        return y
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    diagonal.__doc__ = spmatrix.diagonal.__doc__
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|    #####################
   546|         0|            0|            0|  0.00%|    # Other binary ops  #
   547|         0|            0|            0|  0.00%|    #####################
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|    def _maximum_minimum(self, other, npop, op_name, dense_check):
   550|         0|            0|            0|  0.00%|        if isscalarlike(other):
   551|         0|            0|            0|  0.00%|            if dense_check(other):
   552|         0|            0|            0|  0.00%|                warn("Taking maximum (minimum) with > 0 (< 0) number results"
   553|         0|            0|            0|  0.00%|                     " to a dense matrix.", SparseEfficiencyWarning,
   554|         0|            0|            0|  0.00%|                     stacklevel=3)
   555|         0|            0|            0|  0.00%|                other_arr = np.empty(self.shape, dtype=np.asarray(other).dtype)
   556|         0|            0|            0|  0.00%|                other_arr.fill(other)
   557|         0|            0|            0|  0.00%|                other_arr = self.__class__(other_arr)
   558|         0|            0|            0|  0.00%|                return self._binopt(other_arr, op_name)
   559|         0|            0|            0|  0.00%|            else:
   560|         0|            0|            0|  0.00%|                self.sum_duplicates()
   561|         0|            0|            0|  0.00%|                new_data = npop(self.data, np.asarray(other))
   562|         0|            0|            0|  0.00%|                mat = self.__class__((new_data, self.indices, self.indptr),
   563|         0|            0|            0|  0.00%|                                     dtype=new_data.dtype, shape=self.shape)
   564|         0|            0|            0|  0.00%|                return mat
   565|         0|            0|            0|  0.00%|        elif isdense(other):
   566|         0|            0|            0|  0.00%|            return npop(self.todense(), other)
   567|         0|            0|            0|  0.00%|        elif isspmatrix(other):
   568|         0|            0|            0|  0.00%|            return self._binopt(other, op_name)
   569|         0|            0|            0|  0.00%|        else:
   570|         0|            0|            0|  0.00%|            raise ValueError("Operands not compatible.")
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    def maximum(self, other):
   573|         0|            0|            0|  0.00%|        return self._maximum_minimum(other, np.maximum,
   574|         0|            0|            0|  0.00%|                                     '_maximum_', lambda x: np.asarray(x) > 0)
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|    maximum.__doc__ = spmatrix.maximum.__doc__
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    def minimum(self, other):
   579|         0|            0|            0|  0.00%|        return self._maximum_minimum(other, np.minimum,
   580|         0|            0|            0|  0.00%|                                     '_minimum_', lambda x: np.asarray(x) < 0)
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|    minimum.__doc__ = spmatrix.minimum.__doc__
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|    #####################
   585|         0|            0|            0|  0.00%|    # Reduce operations #
   586|         0|            0|            0|  0.00%|    #####################
   587|         0|            0|            0|  0.00%|
   588|        12|            0|            0|  0.00%|    def sum(self, axis=None, dtype=None, out=None):
   589|         0|            0|            0|  0.00%|        """Sum the matrix over the given axis.  If the axis is None, sum
   590|         0|            0|            0|  0.00%|        over both rows and columns, returning a scalar.
   591|         0|            0|            0|  0.00%|        """
   592|         0|            0|            0|  0.00%|        # The spmatrix base class already does axis=0 and axis=1 efficiently
   593|         0|            0|            0|  0.00%|        # so we only do the case axis=None here
   594|        12|            0|            0|  0.00%|        if (not hasattr(self, 'blocksize') and
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:673 __getattr__
   595|        12|            0|            0|  0.00%|                axis in self._swap(((1, -1), (0, 2)))[0]):
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:235 _swap
   596|         0|            0|            0|  0.00%|            # faster than multiplication for large minor axis in CSC/CSR
   597|         4|            0|            0|  0.00%|            res_dtype = get_sum_dtype(self.dtype)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:184 get_sum_dtype
   598|         4|            0|            0|  0.00%|            ret = np.zeros(len(self.indptr) - 1, dtype=res_dtype)
   599|         0|            0|            0|  0.00%|
   600|         4|            0|            0|  0.00%|            major_index, value = self._minor_reduce(np.add)
(call)|         4|    0.0011971|  0.000299275|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:617 _minor_reduce
   601|         4|            0|            0|  0.00%|            ret[major_index] = value
   602|         4|            0|            0|  0.00%|            ret = asmatrix(ret)
(call)|         4|  0.000997782|  0.000249445|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:363 asmatrix
   603|         4|            0|            0|  0.00%|            if axis % 2 == 1:
   604|         4|            0|            0|  0.00%|                ret = ret.T
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:935 T
   605|         0|            0|            0|  0.00%|
   606|         4|            0|            0|  0.00%|            if out is not None and out.shape != ret.shape:
   607|         0|            0|            0|  0.00%|                raise ValueError('dimensions do not match')
   608|         0|            0|            0|  0.00%|
   609|         4|            0|            0|  0.00%|            return ret.sum(axis=(), dtype=dtype, out=out)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:287 sum
   610|         0|            0|            0|  0.00%|        # spmatrix will handle the remaining situations when axis
   611|         0|            0|            0|  0.00%|        # is in {None, -1, 0, 1}
   612|         0|            0|            0|  0.00%|        else:
   613|         8|            0|            0|  0.00%|            return spmatrix.sum(self, axis=axis, dtype=dtype, out=out)
(call)|         8|   0.00806236|    0.0010078|  0.02%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:968 sum
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    sum.__doc__ = spmatrix.sum.__doc__
   616|         0|            0|            0|  0.00%|
   617|         4|            0|            0|  0.00%|    def _minor_reduce(self, ufunc, data=None):
   618|         0|            0|            0|  0.00%|        """Reduce nonzeros with a ufunc over the minor axis when non-empty
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|        Can be applied to a function of self.data by supplying data parameter.
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|        Warning: this does not call sum_duplicates()
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|        Returns
   625|         0|            0|            0|  0.00%|        -------
   626|         0|            0|            0|  0.00%|        major_index : array of ints
   627|         0|            0|            0|  0.00%|            Major indices where nonzero
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|        value : array of self.dtype
   630|         0|            0|            0|  0.00%|            Reduce result for nonzeros in each major_index
   631|         0|            0|            0|  0.00%|        """
   632|         4|            0|            0|  0.00%|        if data is None:
   633|         4|            0|            0|  0.00%|            data = self.data
   634|         4|            0|            0|  0.00%|        major_index = np.flatnonzero(np.diff(self.indptr))
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 diff
(call)|         4|    0.0011971|  0.000299275|  0.00%|# <__array_function__ internals>:177 flatnonzero
   635|         8|            0|            0|  0.00%|        value = ufunc.reduceat(data,
   636|         4|            0|            0|  0.00%|                               downcast_intp_index(self.indptr[major_index]))
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:71 downcast_intp_index
   637|         4|            0|            0|  0.00%|        return major_index, value
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|    #######################
   640|         0|            0|            0|  0.00%|    # Getting and Setting #
   641|         0|            0|            0|  0.00%|    #######################
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    def _get_intXint(self, row, col):
   644|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   645|         0|            0|            0|  0.00%|        major, minor = self._swap((row, col))
   646|         0|            0|            0|  0.00%|        indptr, indices, data = get_csr_submatrix(
   647|         0|            0|            0|  0.00%|            M, N, self.indptr, self.indices, self.data,
   648|         0|            0|            0|  0.00%|            major, major + 1, minor, minor + 1)
   649|         0|            0|            0|  0.00%|        return data.sum(dtype=self.dtype)
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|    def _get_sliceXslice(self, row, col):
   652|         0|            0|            0|  0.00%|        major, minor = self._swap((row, col))
   653|         0|            0|            0|  0.00%|        if major.step in (1, None) and minor.step in (1, None):
   654|         0|            0|            0|  0.00%|            return self._get_submatrix(major, minor, copy=True)
   655|         0|            0|            0|  0.00%|        return self._major_slice(major)._minor_slice(minor)
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|    def _get_arrayXarray(self, row, col):
   658|         0|            0|            0|  0.00%|        # inner indexing
   659|         0|            0|            0|  0.00%|        idx_dtype = self.indices.dtype
   660|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   661|         0|            0|            0|  0.00%|        major, minor = self._swap((row, col))
   662|         0|            0|            0|  0.00%|        major = np.asarray(major, dtype=idx_dtype)
   663|         0|            0|            0|  0.00%|        minor = np.asarray(minor, dtype=idx_dtype)
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|        val = np.empty(major.size, dtype=self.dtype)
   666|         0|            0|            0|  0.00%|        csr_sample_values(M, N, self.indptr, self.indices, self.data,
   667|         0|            0|            0|  0.00%|                          major.size, major.ravel(), minor.ravel(), val)
   668|         0|            0|            0|  0.00%|        if major.ndim == 1:
   669|         0|            0|            0|  0.00%|            return asmatrix(val)
   670|         0|            0|            0|  0.00%|        return self.__class__(val.reshape(major.shape))
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    def _get_columnXarray(self, row, col):
   673|         0|            0|            0|  0.00%|        # outer indexing
   674|         0|            0|            0|  0.00%|        major, minor = self._swap((row, col))
   675|         0|            0|            0|  0.00%|        return self._major_index_fancy(major)._minor_index_fancy(minor)
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|    def _major_index_fancy(self, idx):
   678|         0|            0|            0|  0.00%|        """Index along the major axis where idx is an array of ints.
   679|         0|            0|            0|  0.00%|        """
   680|         0|            0|            0|  0.00%|        idx_dtype = self.indices.dtype
   681|         0|            0|            0|  0.00%|        indices = np.asarray(idx, dtype=idx_dtype).ravel()
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|        _, N = self._swap(self.shape)
   684|         0|            0|            0|  0.00%|        M = len(indices)
   685|         0|            0|            0|  0.00%|        new_shape = self._swap((M, N))
   686|         0|            0|            0|  0.00%|        if M == 0:
   687|         0|            0|            0|  0.00%|            return self.__class__(new_shape)
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|        row_nnz = self.indptr[indices + 1] - self.indptr[indices]
   690|         0|            0|            0|  0.00%|        idx_dtype = self.indices.dtype
   691|         0|            0|            0|  0.00%|        res_indptr = np.zeros(M+1, dtype=idx_dtype)
   692|         0|            0|            0|  0.00%|        np.cumsum(row_nnz, out=res_indptr[1:])
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|        nnz = res_indptr[-1]
   695|         0|            0|            0|  0.00%|        res_indices = np.empty(nnz, dtype=idx_dtype)
   696|         0|            0|            0|  0.00%|        res_data = np.empty(nnz, dtype=self.dtype)
   697|         0|            0|            0|  0.00%|        csr_row_index(M, indices, self.indptr, self.indices, self.data,
   698|         0|            0|            0|  0.00%|                      res_indices, res_data)
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|        return self.__class__((res_data, res_indices, res_indptr),
   701|         0|            0|            0|  0.00%|                              shape=new_shape, copy=False)
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    def _major_slice(self, idx, copy=False):
   704|         0|            0|            0|  0.00%|        """Index along the major axis where idx is a slice object.
   705|         0|            0|            0|  0.00%|        """
   706|         0|            0|            0|  0.00%|        if idx == slice(None):
   707|         0|            0|            0|  0.00%|            return self.copy() if copy else self
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   710|         0|            0|            0|  0.00%|        start, stop, step = idx.indices(M)
   711|         0|            0|            0|  0.00%|        M = len(range(start, stop, step))
   712|         0|            0|            0|  0.00%|        new_shape = self._swap((M, N))
   713|         0|            0|            0|  0.00%|        if M == 0:
   714|         0|            0|            0|  0.00%|            return self.__class__(new_shape)
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|        # Work out what slices are needed for `row_nnz`
   717|         0|            0|            0|  0.00%|        # start,stop can be -1, only if step is negative
   718|         0|            0|            0|  0.00%|        start0, stop0 = start, stop
   719|         0|            0|            0|  0.00%|        if stop == -1 and start >= 0:
   720|         0|            0|            0|  0.00%|            stop0 = None
   721|         0|            0|            0|  0.00%|        start1, stop1 = start + 1, stop + 1
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|        row_nnz = self.indptr[start1:stop1:step] - \
   724|         0|            0|            0|  0.00%|            self.indptr[start0:stop0:step]
   725|         0|            0|            0|  0.00%|        idx_dtype = self.indices.dtype
   726|         0|            0|            0|  0.00%|        res_indptr = np.zeros(M+1, dtype=idx_dtype)
   727|         0|            0|            0|  0.00%|        np.cumsum(row_nnz, out=res_indptr[1:])
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|        if step == 1:
   730|         0|            0|            0|  0.00%|            all_idx = slice(self.indptr[start], self.indptr[stop])
   731|         0|            0|            0|  0.00%|            res_indices = np.array(self.indices[all_idx], copy=copy)
   732|         0|            0|            0|  0.00%|            res_data = np.array(self.data[all_idx], copy=copy)
   733|         0|            0|            0|  0.00%|        else:
   734|         0|            0|            0|  0.00%|            nnz = res_indptr[-1]
   735|         0|            0|            0|  0.00%|            res_indices = np.empty(nnz, dtype=idx_dtype)
   736|         0|            0|            0|  0.00%|            res_data = np.empty(nnz, dtype=self.dtype)
   737|         0|            0|            0|  0.00%|            csr_row_slice(start, stop, step, self.indptr, self.indices,
   738|         0|            0|            0|  0.00%|                          self.data, res_indices, res_data)
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|        return self.__class__((res_data, res_indices, res_indptr),
   741|         0|            0|            0|  0.00%|                              shape=new_shape, copy=False)
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|    def _minor_index_fancy(self, idx):
   744|         0|            0|            0|  0.00%|        """Index along the minor axis where idx is an array of ints.
   745|         0|            0|            0|  0.00%|        """
   746|         0|            0|            0|  0.00%|        idx_dtype = self.indices.dtype
   747|         0|            0|            0|  0.00%|        idx = np.asarray(idx, dtype=idx_dtype).ravel()
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   750|         0|            0|            0|  0.00%|        k = len(idx)
   751|         0|            0|            0|  0.00%|        new_shape = self._swap((M, k))
   752|         0|            0|            0|  0.00%|        if k == 0:
   753|         0|            0|            0|  0.00%|            return self.__class__(new_shape)
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|        # pass 1: count idx entries and compute new indptr
   756|         0|            0|            0|  0.00%|        col_offsets = np.zeros(N, dtype=idx_dtype)
   757|         0|            0|            0|  0.00%|        res_indptr = np.empty_like(self.indptr)
   758|         0|            0|            0|  0.00%|        csr_column_index1(k, idx, M, N, self.indptr, self.indices,
   759|         0|            0|            0|  0.00%|                          col_offsets, res_indptr)
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|        # pass 2: copy indices/data for selected idxs
   762|         0|            0|            0|  0.00%|        col_order = np.argsort(idx).astype(idx_dtype, copy=False)
   763|         0|            0|            0|  0.00%|        nnz = res_indptr[-1]
   764|         0|            0|            0|  0.00%|        res_indices = np.empty(nnz, dtype=idx_dtype)
   765|         0|            0|            0|  0.00%|        res_data = np.empty(nnz, dtype=self.dtype)
   766|         0|            0|            0|  0.00%|        csr_column_index2(col_order, col_offsets, len(self.indices),
   767|         0|            0|            0|  0.00%|                          self.indices, self.data, res_indices, res_data)
   768|         0|            0|            0|  0.00%|        return self.__class__((res_data, res_indices, res_indptr),
   769|         0|            0|            0|  0.00%|                              shape=new_shape, copy=False)
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|    def _minor_slice(self, idx, copy=False):
   772|         0|            0|            0|  0.00%|        """Index along the minor axis where idx is a slice object.
   773|         0|            0|            0|  0.00%|        """
   774|         0|            0|            0|  0.00%|        if idx == slice(None):
   775|         0|            0|            0|  0.00%|            return self.copy() if copy else self
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   778|         0|            0|            0|  0.00%|        start, stop, step = idx.indices(N)
   779|         0|            0|            0|  0.00%|        N = len(range(start, stop, step))
   780|         0|            0|            0|  0.00%|        if N == 0:
   781|         0|            0|            0|  0.00%|            return self.__class__(self._swap((M, N)))
   782|         0|            0|            0|  0.00%|        if step == 1:
   783|         0|            0|            0|  0.00%|            return self._get_submatrix(minor=idx, copy=copy)
   784|         0|            0|            0|  0.00%|        # TODO: don't fall back to fancy indexing here
   785|         0|            0|            0|  0.00%|        return self._minor_index_fancy(np.arange(start, stop, step))
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|    def _get_submatrix(self, major=None, minor=None, copy=False):
   788|         0|            0|            0|  0.00%|        """Return a submatrix of this matrix.
   789|         0|            0|            0|  0.00%|
   790|         0|            0|            0|  0.00%|        major, minor: None, int, or slice with step 1
   791|         0|            0|            0|  0.00%|        """
   792|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   793|         0|            0|            0|  0.00%|        i0, i1 = _process_slice(major, M)
   794|         0|            0|            0|  0.00%|        j0, j1 = _process_slice(minor, N)
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|        if i0 == 0 and j0 == 0 and i1 == M and j1 == N:
   797|         0|            0|            0|  0.00%|            return self.copy() if copy else self
   798|         0|            0|            0|  0.00%|
   799|         0|            0|            0|  0.00%|        indptr, indices, data = get_csr_submatrix(
   800|         0|            0|            0|  0.00%|            M, N, self.indptr, self.indices, self.data, i0, i1, j0, j1)
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|        shape = self._swap((i1 - i0, j1 - j0))
   803|         0|            0|            0|  0.00%|        return self.__class__((data, indices, indptr), shape=shape,
   804|         0|            0|            0|  0.00%|                              dtype=self.dtype, copy=False)
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    def _set_intXint(self, row, col, x):
   807|         0|            0|            0|  0.00%|        i, j = self._swap((row, col))
   808|         0|            0|            0|  0.00%|        self._set_many(i, j, x)
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|    def _set_arrayXarray(self, row, col, x):
   811|         0|            0|            0|  0.00%|        i, j = self._swap((row, col))
   812|         0|            0|            0|  0.00%|        self._set_many(i, j, x)
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|    def _set_arrayXarray_sparse(self, row, col, x):
   815|         0|            0|            0|  0.00%|        # clear entries that will be overwritten
   816|         0|            0|            0|  0.00%|        self._zero_many(*self._swap((row, col)))
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|        M, N = row.shape  # matches col.shape
   819|         0|            0|            0|  0.00%|        broadcast_row = M != 1 and x.shape[0] == 1
   820|         0|            0|            0|  0.00%|        broadcast_col = N != 1 and x.shape[1] == 1
   821|         0|            0|            0|  0.00%|        r, c = x.row, x.col
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|        x = np.asarray(x.data, dtype=self.dtype)
   824|         0|            0|            0|  0.00%|        if x.size == 0:
   825|         0|            0|            0|  0.00%|            return
   826|         0|            0|            0|  0.00%|
   827|         0|            0|            0|  0.00%|        if broadcast_row:
   828|         0|            0|            0|  0.00%|            r = np.repeat(np.arange(M), len(r))
   829|         0|            0|            0|  0.00%|            c = np.tile(c, M)
   830|         0|            0|            0|  0.00%|            x = np.tile(x, M)
   831|         0|            0|            0|  0.00%|        if broadcast_col:
   832|         0|            0|            0|  0.00%|            r = np.repeat(r, N)
   833|         0|            0|            0|  0.00%|            c = np.tile(np.arange(N), len(c))
   834|         0|            0|            0|  0.00%|            x = np.repeat(x, N)
   835|         0|            0|            0|  0.00%|        # only assign entries in the new sparsity structure
   836|         0|            0|            0|  0.00%|        i, j = self._swap((row[r, c], col[r, c]))
   837|         0|            0|            0|  0.00%|        self._set_many(i, j, x)
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|    def _setdiag(self, values, k):
   840|         0|            0|            0|  0.00%|        if 0 in self.shape:
   841|         0|            0|            0|  0.00%|            return
   842|         0|            0|            0|  0.00%|
   843|         0|            0|            0|  0.00%|        M, N = self.shape
   844|         0|            0|            0|  0.00%|        broadcast = (values.ndim == 0)
   845|         0|            0|            0|  0.00%|
   846|         0|            0|            0|  0.00%|        if k < 0:
   847|         0|            0|            0|  0.00%|            if broadcast:
   848|         0|            0|            0|  0.00%|                max_index = min(M + k, N)
   849|         0|            0|            0|  0.00%|            else:
   850|         0|            0|            0|  0.00%|                max_index = min(M + k, N, len(values))
   851|         0|            0|            0|  0.00%|            i = np.arange(max_index, dtype=self.indices.dtype)
   852|         0|            0|            0|  0.00%|            j = np.arange(max_index, dtype=self.indices.dtype)
   853|         0|            0|            0|  0.00%|            i -= k
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|        else:
   856|         0|            0|            0|  0.00%|            if broadcast:
   857|         0|            0|            0|  0.00%|                max_index = min(M, N - k)
   858|         0|            0|            0|  0.00%|            else:
   859|         0|            0|            0|  0.00%|                max_index = min(M, N - k, len(values))
   860|         0|            0|            0|  0.00%|            i = np.arange(max_index, dtype=self.indices.dtype)
   861|         0|            0|            0|  0.00%|            j = np.arange(max_index, dtype=self.indices.dtype)
   862|         0|            0|            0|  0.00%|            j += k
   863|         0|            0|            0|  0.00%|
   864|         0|            0|            0|  0.00%|        if not broadcast:
   865|         0|            0|            0|  0.00%|            values = values[:len(i)]
   866|         0|            0|            0|  0.00%|
   867|         0|            0|            0|  0.00%|        self[i, j] = values
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|    def _prepare_indices(self, i, j):
   870|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|        def check_bounds(indices, bound):
   873|         0|            0|            0|  0.00%|            idx = indices.max()
   874|         0|            0|            0|  0.00%|            if idx >= bound:
   875|         0|            0|            0|  0.00%|                raise IndexError('index (%d) out of range (>= %d)' %
   876|         0|            0|            0|  0.00%|                                 (idx, bound))
   877|         0|            0|            0|  0.00%|            idx = indices.min()
   878|         0|            0|            0|  0.00%|            if idx < -bound:
   879|         0|            0|            0|  0.00%|                raise IndexError('index (%d) out of range (< -%d)' %
   880|         0|            0|            0|  0.00%|                                 (idx, bound))
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|        i = np.array(i, dtype=self.indices.dtype, copy=False, ndmin=1).ravel()
   883|         0|            0|            0|  0.00%|        j = np.array(j, dtype=self.indices.dtype, copy=False, ndmin=1).ravel()
   884|         0|            0|            0|  0.00%|        check_bounds(i, M)
   885|         0|            0|            0|  0.00%|        check_bounds(j, N)
   886|         0|            0|            0|  0.00%|        return i, j, M, N
   887|         0|            0|            0|  0.00%|
   888|         0|            0|            0|  0.00%|    def _set_many(self, i, j, x):
   889|         0|            0|            0|  0.00%|        """Sets value at each (i, j) to x
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|        Here (i,j) index major and minor respectively, and must not contain
   892|         0|            0|            0|  0.00%|        duplicate entries.
   893|         0|            0|            0|  0.00%|        """
   894|         0|            0|            0|  0.00%|        i, j, M, N = self._prepare_indices(i, j)
   895|         0|            0|            0|  0.00%|        x = np.array(x, dtype=self.dtype, copy=False, ndmin=1).ravel()
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|        n_samples = x.size
   898|         0|            0|            0|  0.00%|        offsets = np.empty(n_samples, dtype=self.indices.dtype)
   899|         0|            0|            0|  0.00%|        ret = csr_sample_offsets(M, N, self.indptr, self.indices, n_samples,
   900|         0|            0|            0|  0.00%|                                 i, j, offsets)
   901|         0|            0|            0|  0.00%|        if ret == 1:
   902|         0|            0|            0|  0.00%|            # rinse and repeat
   903|         0|            0|            0|  0.00%|            self.sum_duplicates()
   904|         0|            0|            0|  0.00%|            csr_sample_offsets(M, N, self.indptr, self.indices, n_samples,
   905|         0|            0|            0|  0.00%|                               i, j, offsets)
   906|         0|            0|            0|  0.00%|
   907|         0|            0|            0|  0.00%|        if -1 not in offsets:
   908|         0|            0|            0|  0.00%|            # only affects existing non-zero cells
   909|         0|            0|            0|  0.00%|            self.data[offsets] = x
   910|         0|            0|            0|  0.00%|            return
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|        else:
   913|         0|            0|            0|  0.00%|            warn("Changing the sparsity structure of a {}_matrix is expensive."
   914|         0|            0|            0|  0.00%|                 " lil_matrix is more efficient.".format(self.format),
   915|         0|            0|            0|  0.00%|                 SparseEfficiencyWarning, stacklevel=3)
   916|         0|            0|            0|  0.00%|            # replace where possible
   917|         0|            0|            0|  0.00%|            mask = offsets > -1
   918|         0|            0|            0|  0.00%|            self.data[offsets[mask]] = x[mask]
   919|         0|            0|            0|  0.00%|            # only insertions remain
   920|         0|            0|            0|  0.00%|            mask = ~mask
   921|         0|            0|            0|  0.00%|            i = i[mask]
   922|         0|            0|            0|  0.00%|            i[i < 0] += M
   923|         0|            0|            0|  0.00%|            j = j[mask]
   924|         0|            0|            0|  0.00%|            j[j < 0] += N
   925|         0|            0|            0|  0.00%|            self._insert_many(i, j, x[mask])
   926|         0|            0|            0|  0.00%|
   927|         0|            0|            0|  0.00%|    def _zero_many(self, i, j):
   928|         0|            0|            0|  0.00%|        """Sets value at each (i, j) to zero, preserving sparsity structure.
   929|         0|            0|            0|  0.00%|
   930|         0|            0|            0|  0.00%|        Here (i,j) index major and minor respectively.
   931|         0|            0|            0|  0.00%|        """
   932|         0|            0|            0|  0.00%|        i, j, M, N = self._prepare_indices(i, j)
   933|         0|            0|            0|  0.00%|
   934|         0|            0|            0|  0.00%|        n_samples = len(i)
   935|         0|            0|            0|  0.00%|        offsets = np.empty(n_samples, dtype=self.indices.dtype)
   936|         0|            0|            0|  0.00%|        ret = csr_sample_offsets(M, N, self.indptr, self.indices, n_samples,
   937|         0|            0|            0|  0.00%|                                 i, j, offsets)
   938|         0|            0|            0|  0.00%|        if ret == 1:
   939|         0|            0|            0|  0.00%|            # rinse and repeat
   940|         0|            0|            0|  0.00%|            self.sum_duplicates()
   941|         0|            0|            0|  0.00%|            csr_sample_offsets(M, N, self.indptr, self.indices, n_samples,
   942|         0|            0|            0|  0.00%|                               i, j, offsets)
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|        # only assign zeros to the existing sparsity structure
   945|         0|            0|            0|  0.00%|        self.data[offsets[offsets > -1]] = 0
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|    def _insert_many(self, i, j, x):
   948|         0|            0|            0|  0.00%|        """Inserts new nonzero at each (i, j) with value x
   949|         0|            0|            0|  0.00%|
   950|         0|            0|            0|  0.00%|        Here (i,j) index major and minor respectively.
   951|         0|            0|            0|  0.00%|        i, j and x must be non-empty, 1d arrays.
   952|         0|            0|            0|  0.00%|        Inserts each major group (e.g. all entries per row) at a time.
   953|         0|            0|            0|  0.00%|        Maintains has_sorted_indices property.
   954|         0|            0|            0|  0.00%|        Modifies i, j, x in place.
   955|         0|            0|            0|  0.00%|        """
   956|         0|            0|            0|  0.00%|        order = np.argsort(i, kind='mergesort')  # stable for duplicates
   957|         0|            0|            0|  0.00%|        i = i.take(order, mode='clip')
   958|         0|            0|            0|  0.00%|        j = j.take(order, mode='clip')
   959|         0|            0|            0|  0.00%|        x = x.take(order, mode='clip')
   960|         0|            0|            0|  0.00%|
   961|         0|            0|            0|  0.00%|        do_sort = self.has_sorted_indices
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|        # Update index data type
   964|         0|            0|            0|  0.00%|        idx_dtype = get_index_dtype((self.indices, self.indptr),
   965|         0|            0|            0|  0.00%|                                    maxval=(self.indptr[-1] + x.size))
   966|         0|            0|            0|  0.00%|        self.indptr = np.asarray(self.indptr, dtype=idx_dtype)
   967|         0|            0|            0|  0.00%|        self.indices = np.asarray(self.indices, dtype=idx_dtype)
   968|         0|            0|            0|  0.00%|        i = np.asarray(i, dtype=idx_dtype)
   969|         0|            0|            0|  0.00%|        j = np.asarray(j, dtype=idx_dtype)
   970|         0|            0|            0|  0.00%|
   971|         0|            0|            0|  0.00%|        # Collate old and new in chunks by major index
   972|         0|            0|            0|  0.00%|        indices_parts = []
   973|         0|            0|            0|  0.00%|        data_parts = []
   974|         0|            0|            0|  0.00%|        ui, ui_indptr = np.unique(i, return_index=True)
   975|         0|            0|            0|  0.00%|        ui_indptr = np.append(ui_indptr, len(j))
   976|         0|            0|            0|  0.00%|        new_nnzs = np.diff(ui_indptr)
   977|         0|            0|            0|  0.00%|        prev = 0
   978|         0|            0|            0|  0.00%|        for c, (ii, js, je) in enumerate(zip(ui, ui_indptr, ui_indptr[1:])):
   979|         0|            0|            0|  0.00%|            # old entries
   980|         0|            0|            0|  0.00%|            start = self.indptr[prev]
   981|         0|            0|            0|  0.00%|            stop = self.indptr[ii]
   982|         0|            0|            0|  0.00%|            indices_parts.append(self.indices[start:stop])
   983|         0|            0|            0|  0.00%|            data_parts.append(self.data[start:stop])
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|            # handle duplicate j: keep last setting
   986|         0|            0|            0|  0.00%|            uj, uj_indptr = np.unique(j[js:je][::-1], return_index=True)
   987|         0|            0|            0|  0.00%|            if len(uj) == je - js:
   988|         0|            0|            0|  0.00%|                indices_parts.append(j[js:je])
   989|         0|            0|            0|  0.00%|                data_parts.append(x[js:je])
   990|         0|            0|            0|  0.00%|            else:
   991|         0|            0|            0|  0.00%|                indices_parts.append(j[js:je][::-1][uj_indptr])
   992|         0|            0|            0|  0.00%|                data_parts.append(x[js:je][::-1][uj_indptr])
   993|         0|            0|            0|  0.00%|                new_nnzs[c] = len(uj)
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|            prev = ii
   996|         0|            0|            0|  0.00%|
   997|         0|            0|            0|  0.00%|        # remaining old entries
   998|         0|            0|            0|  0.00%|        start = self.indptr[ii]
   999|         0|            0|            0|  0.00%|        indices_parts.append(self.indices[start:])
  1000|         0|            0|            0|  0.00%|        data_parts.append(self.data[start:])
  1001|         0|            0|            0|  0.00%|
  1002|         0|            0|            0|  0.00%|        # update attributes
  1003|         0|            0|            0|  0.00%|        self.indices = np.concatenate(indices_parts)
  1004|         0|            0|            0|  0.00%|        self.data = np.concatenate(data_parts)
  1005|         0|            0|            0|  0.00%|        nnzs = np.empty(self.indptr.shape, dtype=idx_dtype)
  1006|         0|            0|            0|  0.00%|        nnzs[0] = idx_dtype(0)
  1007|         0|            0|            0|  0.00%|        indptr_diff = np.diff(self.indptr)
  1008|         0|            0|            0|  0.00%|        indptr_diff[ui] += new_nnzs
  1009|         0|            0|            0|  0.00%|        nnzs[1:] = indptr_diff
  1010|         0|            0|            0|  0.00%|        self.indptr = np.cumsum(nnzs, out=nnzs)
  1011|         0|            0|            0|  0.00%|
  1012|         0|            0|            0|  0.00%|        if do_sort:
  1013|         0|            0|            0|  0.00%|            # TODO: only sort where necessary
  1014|         0|            0|            0|  0.00%|            self.has_sorted_indices = False
  1015|         0|            0|            0|  0.00%|            self.sort_indices()
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|        self.check_format(full_check=False)
  1018|         0|            0|            0|  0.00%|
  1019|         0|            0|            0|  0.00%|    ######################
  1020|         0|            0|            0|  0.00%|    # Conversion methods #
  1021|         0|            0|            0|  0.00%|    ######################
  1022|         0|            0|            0|  0.00%|
  1023|         4|            0|            0|  0.00%|    def tocoo(self, copy=True):
  1024|         4|            0|            0|  0.00%|        major_dim, minor_dim = self._swap(self.shape)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:235 _swap
  1025|         4|            0|            0|  0.00%|        minor_indices = self.indices
  1026|         4|            0|            0|  0.00%|        major_indices = np.empty(len(minor_indices), dtype=self.indices.dtype)
  1027|         4|            0|            0|  0.00%|        _sparsetools.expandptr(major_dim, self.indptr, major_indices)
  1028|         4|            0|            0|  0.00%|        row, col = self._swap((major_indices, minor_indices))
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:235 _swap
  1029|         0|            0|            0|  0.00%|
  1030|         4|            0|            0|  0.00%|        from .coo import coo_matrix
(call)|         4|            0|            0|  0.00%|# <frozen importlib._bootstrap>:389 parent
  1031|         8|            0|            0|  0.00%|        return coo_matrix((self.data, (row, col)), self.shape, copy=copy,
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|         4|  0.000996351|  0.000249088|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:126 __init__
  1032|         4|            0|            0|  0.00%|                          dtype=self.dtype)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|    tocoo.__doc__ = spmatrix.tocoo.__doc__
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|    def toarray(self, order=None, out=None):
  1037|         0|            0|            0|  0.00%|        if out is None and order is None:
  1038|         0|            0|            0|  0.00%|            order = self._swap('cf')[0]
  1039|         0|            0|            0|  0.00%|        out = self._process_toarray_args(order, out)
  1040|         0|            0|            0|  0.00%|        if not (out.flags.c_contiguous or out.flags.f_contiguous):
  1041|         0|            0|            0|  0.00%|            raise ValueError('Output array must be C or F contiguous')
  1042|         0|            0|            0|  0.00%|        # align ideal order with output array order
  1043|         0|            0|            0|  0.00%|        if out.flags.c_contiguous:
  1044|         0|            0|            0|  0.00%|            x = self.tocsr()
  1045|         0|            0|            0|  0.00%|            y = out
  1046|         0|            0|            0|  0.00%|        else:
  1047|         0|            0|            0|  0.00%|            x = self.tocsc()
  1048|         0|            0|            0|  0.00%|            y = out.T
  1049|         0|            0|            0|  0.00%|        M, N = x._swap(x.shape)
  1050|         0|            0|            0|  0.00%|        csr_todense(M, N, x.indptr, x.indices, x.data, y)
  1051|         0|            0|            0|  0.00%|        return out
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|    toarray.__doc__ = spmatrix.toarray.__doc__
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|    ##############################################################
  1056|         0|            0|            0|  0.00%|    # methods that examine or modify the internal data structure #
  1057|         0|            0|            0|  0.00%|    ##############################################################
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|    def eliminate_zeros(self):
  1060|         0|            0|            0|  0.00%|        """Remove zero entries from the matrix
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|        This is an *in place* operation.
  1063|         0|            0|            0|  0.00%|        """
  1064|         0|            0|            0|  0.00%|        M, N = self._swap(self.shape)
  1065|         0|            0|            0|  0.00%|        _sparsetools.csr_eliminate_zeros(M, N, self.indptr, self.indices,
  1066|         0|            0|            0|  0.00%|                                         self.data)
  1067|         0|            0|            0|  0.00%|        self.prune()  # nnz may have changed
  1068|         0|            0|            0|  0.00%|
  1069|        16|            0|            0|  0.00%|    def __get_has_canonical_format(self):
  1070|         0|            0|            0|  0.00%|        """Determine whether the matrix has sorted indices and no duplicates
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|        Returns
  1073|         0|            0|            0|  0.00%|            - True: if the above applies
  1074|         0|            0|            0|  0.00%|            - False: otherwise
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|        has_canonical_format implies has_sorted_indices, so if the latter flag
  1077|         0|            0|            0|  0.00%|        is False, so will the former be; if the former is found True, the
  1078|         0|            0|            0|  0.00%|        latter flag is also set.
  1079|         0|            0|            0|  0.00%|        """
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|        # first check to see if result was cached
  1082|        16|            0|            0|  0.00%|        if not getattr(self, '_has_sorted_indices', True):
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:673 __getattr__
  1083|         0|            0|            0|  0.00%|            # not sorted => not canonical
  1084|         0|            0|            0|  0.00%|            self._has_canonical_format = False
  1085|        16|            0|            0|  0.00%|        elif not hasattr(self, '_has_canonical_format'):
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:673 __getattr__
  1086|        16|            0|            0|  0.00%|            self.has_canonical_format = bool(
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1091 __set_has_canonical_format
  1087|        16|            0|            0|  0.00%|                _sparsetools.csr_has_canonical_format(
  1088|         8|            0|            0|  0.00%|                    len(self.indptr) - 1, self.indptr, self.indices))
  1089|        16|            0|            0|  0.00%|        return self._has_canonical_format
  1090|         0|            0|            0|  0.00%|
  1091|        10|            0|            0|  0.00%|    def __set_has_canonical_format(self, val):
  1092|        10|            0|            0|  0.00%|        self._has_canonical_format = bool(val)
  1093|        10|            0|            0|  0.00%|        if val:
  1094|         8|            0|            0|  0.00%|            self.has_sorted_indices = True
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1131 __set_sorted
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|    has_canonical_format = property(fget=__get_has_canonical_format,
  1097|         0|            0|            0|  0.00%|                                    fset=__set_has_canonical_format)
  1098|         0|            0|            0|  0.00%|
  1099|        16|            0|            0|  0.00%|    def sum_duplicates(self):
  1100|         0|            0|            0|  0.00%|        """Eliminate duplicate matrix entries by adding them together
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|        This is an *in place* operation.
  1103|         0|            0|            0|  0.00%|        """
  1104|        16|            0|            0|  0.00%|        if self.has_canonical_format:
(call)|        16|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1069 __get_has_canonical_format
  1105|        14|            0|            0|  0.00%|            return
  1106|         2|            0|            0|  0.00%|        self.sort_indices()
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1147 sort_indices
  1107|         0|            0|            0|  0.00%|
  1108|         2|            0|            0|  0.00%|        M, N = self._swap(self.shape)
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:235 _swap
  1109|         4|            0|            0|  0.00%|        _sparsetools.csr_sum_duplicates(M, N, self.indptr, self.indices,
  1110|         2|            0|            0|  0.00%|                                        self.data)
  1111|         0|            0|            0|  0.00%|
  1112|         2|            0|            0|  0.00%|        self.prune()  # nnz may have changed
(call)|         2|  0.000992298|  0.000496149|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1156 prune
  1113|         2|            0|            0|  0.00%|        self.has_canonical_format = True
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1091 __set_has_canonical_format
  1114|         0|            0|            0|  0.00%|
  1115|         2|            0|            0|  0.00%|    def __get_sorted(self):
  1116|         0|            0|            0|  0.00%|        """Determine whether the matrix has sorted indices
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|        Returns
  1119|         0|            0|            0|  0.00%|            - True: if the indices of the matrix are in sorted order
  1120|         0|            0|            0|  0.00%|            - False: otherwise
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|        """
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|        # first check to see if result was cached
  1125|         2|            0|            0|  0.00%|        if not hasattr(self, '_has_sorted_indices'):
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:673 __getattr__
  1126|         4|            0|            0|  0.00%|            self._has_sorted_indices = bool(
  1127|         4|            0|            0|  0.00%|                _sparsetools.csr_has_sorted_indices(
  1128|         2|            0|            0|  0.00%|                    len(self.indptr) - 1, self.indptr, self.indices))
  1129|         2|            0|            0|  0.00%|        return self._has_sorted_indices
  1130|         0|            0|            0|  0.00%|
  1131|        10|            0|            0|  0.00%|    def __set_sorted(self, val):
  1132|        10|            0|            0|  0.00%|        self._has_sorted_indices = bool(val)
  1133|         0|            0|            0|  0.00%|
  1134|         0|            0|            0|  0.00%|    has_sorted_indices = property(fget=__get_sorted, fset=__set_sorted)
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|    def sorted_indices(self):
  1137|         0|            0|            0|  0.00%|        """Return a copy of this matrix with sorted indices
  1138|         0|            0|            0|  0.00%|        """
  1139|         0|            0|            0|  0.00%|        A = self.copy()
  1140|         0|            0|            0|  0.00%|        A.sort_indices()
  1141|         0|            0|            0|  0.00%|        return A
  1142|         0|            0|            0|  0.00%|
  1143|         0|            0|            0|  0.00%|        # an alternative that has linear complexity is the following
  1144|         0|            0|            0|  0.00%|        # although the previous option is typically faster
  1145|         0|            0|            0|  0.00%|        # return self.toother().toother()
  1146|         0|            0|            0|  0.00%|
  1147|         2|            0|            0|  0.00%|    def sort_indices(self):
  1148|         0|            0|            0|  0.00%|        """Sort the indices of this matrix *in place*
  1149|         0|            0|            0|  0.00%|        """
  1150|         0|            0|            0|  0.00%|
  1151|         2|            0|            0|  0.00%|        if not self.has_sorted_indices:
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1115 __get_sorted
  1152|         4|            0|            0|  0.00%|            _sparsetools.csr_sort_indices(len(self.indptr) - 1, self.indptr,
  1153|         2|            0|            0|  0.00%|                                          self.indices, self.data)
  1154|         2|            0|            0|  0.00%|            self.has_sorted_indices = True
(call)|         2|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1131 __set_sorted
  1155|         0|            0|            0|  0.00%|
  1156|        18|            0|            0|  0.00%|    def prune(self):
  1157|         0|            0|            0|  0.00%|        """Remove empty space after all non-zero elements.
  1158|         0|            0|            0|  0.00%|        """
  1159|        18|            0|            0|  0.00%|        major_dim = self._swap(self.shape)[0]
(call)|        18|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|        14|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:235 _swap
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csc.py:229 _swap
  1160|         0|            0|            0|  0.00%|
  1161|        18|            0|            0|  0.00%|        if len(self.indptr) != major_dim + 1:
  1162|         0|            0|            0|  0.00%|            raise ValueError('index pointer has invalid length')
  1163|        18|   0.00100112|  5.56178e-05|  0.00%|        if len(self.indices) < self.nnz:
(call)|        18|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
  1164|         0|            0|            0|  0.00%|            raise ValueError('indices array has fewer than nnz elements')
  1165|        18|  0.000958443|  5.32468e-05|  0.00%|        if len(self.data) < self.nnz:
(call)|        18|   0.00197268|  0.000109593|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
  1166|         0|            0|            0|  0.00%|            raise ValueError('data array has fewer than nnz elements')
  1167|         0|            0|            0|  0.00%|
  1168|        18|  0.000998497|  5.54721e-05|  0.00%|        self.indices = _prune_array(self.indices[:self.nnz])
(call)|        18|  0.000997543|  5.54191e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
(call)|        18|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\_lib\_util.py:143 _prune_array
  1169|        18|            0|            0|  0.00%|        self.data = _prune_array(self.data[:self.nnz])
(call)|        18|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
(call)|        18|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\_lib\_util.py:143 _prune_array
  1170|         0|            0|            0|  0.00%|
  1171|         0|            0|            0|  0.00%|    def resize(self, *shape):
  1172|         0|            0|            0|  0.00%|        shape = check_shape(shape)
  1173|         0|            0|            0|  0.00%|        if hasattr(self, 'blocksize'):
  1174|         0|            0|            0|  0.00%|            bm, bn = self.blocksize
  1175|         0|            0|            0|  0.00%|            new_M, rm = divmod(shape[0], bm)
  1176|         0|            0|            0|  0.00%|            new_N, rn = divmod(shape[1], bn)
  1177|         0|            0|            0|  0.00%|            if rm or rn:
  1178|         0|            0|            0|  0.00%|                raise ValueError("shape must be divisible into %s blocks. "
  1179|         0|            0|            0|  0.00%|                                 "Got %s" % (self.blocksize, shape))
  1180|         0|            0|            0|  0.00%|            M, N = self.shape[0] // bm, self.shape[1] // bn
  1181|         0|            0|            0|  0.00%|        else:
  1182|         0|            0|            0|  0.00%|            new_M, new_N = self._swap(shape)
  1183|         0|            0|            0|  0.00%|            M, N = self._swap(self.shape)
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|        if new_M < M:
  1186|         0|            0|            0|  0.00%|            self.indices = self.indices[:self.indptr[new_M]]
  1187|         0|            0|            0|  0.00%|            self.data = self.data[:self.indptr[new_M]]
  1188|         0|            0|            0|  0.00%|            self.indptr = self.indptr[:new_M + 1]
  1189|         0|            0|            0|  0.00%|        elif new_M > M:
  1190|         0|            0|            0|  0.00%|            self.indptr = np.resize(self.indptr, new_M + 1)
  1191|         0|            0|            0|  0.00%|            self.indptr[M + 1:].fill(self.indptr[M])
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|        if new_N < N:
  1194|         0|            0|            0|  0.00%|            mask = self.indices < new_N
  1195|         0|            0|            0|  0.00%|            if not np.all(mask):
  1196|         0|            0|            0|  0.00%|                self.indices = self.indices[mask]
  1197|         0|            0|            0|  0.00%|                self.data = self.data[mask]
  1198|         0|            0|            0|  0.00%|                major_index, val = self._minor_reduce(np.add, mask)
  1199|         0|            0|            0|  0.00%|                self.indptr.fill(0)
  1200|         0|            0|            0|  0.00%|                self.indptr[1:][major_index] = val
  1201|         0|            0|            0|  0.00%|                np.cumsum(self.indptr, out=self.indptr)
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|        self._shape = shape
  1204|         0|            0|            0|  0.00%|
  1205|         0|            0|            0|  0.00%|    resize.__doc__ = spmatrix.resize.__doc__
  1206|         0|            0|            0|  0.00%|
  1207|         0|            0|            0|  0.00%|    ###################
  1208|         0|            0|            0|  0.00%|    # utility methods #
  1209|         0|            0|            0|  0.00%|    ###################
  1210|         0|            0|            0|  0.00%|
  1211|         0|            0|            0|  0.00%|    # needed by _data_matrix
  1212|         8|            0|            0|  0.00%|    def _with_data(self, data, copy=True):
  1213|         0|            0|            0|  0.00%|        """Returns a matrix with the same sparsity structure as self,
  1214|         0|            0|            0|  0.00%|        but with different data.  By default the structure arrays
  1215|         0|            0|            0|  0.00%|        (i.e. .indptr and .indices) are copied.
  1216|         0|            0|            0|  0.00%|        """
  1217|         8|            0|            0|  0.00%|        if copy:
  1218|        12|            0|            0|  0.00%|            return self.__class__((data, self.indices.copy(),
(call)|         4|   0.00199604|   0.00049901|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:27 __init__
  1219|         4|            0|            0|  0.00%|                                   self.indptr.copy()),
  1220|         4|            0|            0|  0.00%|                                  shape=self.shape,
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
  1221|         4|            0|            0|  0.00%|                                  dtype=data.dtype)
  1222|         0|            0|            0|  0.00%|        else:
  1223|         8|  3.76701e-05|  4.70877e-06|  0.00%|            return self.__class__((data, self.indices, self.indptr),
(call)|         4|   0.00306582|  0.000766456|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:27 __init__
  1224|         4|            0|            0|  0.00%|                                  shape=self.shape, dtype=data.dtype)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
  1225|         0|            0|            0|  0.00%|
  1226|         0|            0|            0|  0.00%|    def _binopt(self, other, op):
  1227|         0|            0|            0|  0.00%|        """apply the binary operation fn to two sparse matrices."""
  1228|         0|            0|            0|  0.00%|        other = self.__class__(other)
  1229|         0|            0|            0|  0.00%|
  1230|         0|            0|            0|  0.00%|        # e.g. csr_plus_csr, csr_minus_csr, etc.
  1231|         0|            0|            0|  0.00%|        fn = getattr(_sparsetools, self.format + op + self.format)
  1232|         0|            0|            0|  0.00%|
  1233|         0|            0|            0|  0.00%|        maxnnz = self.nnz + other.nnz
  1234|         0|            0|            0|  0.00%|        idx_dtype = get_index_dtype((self.indptr, self.indices,
  1235|         0|            0|            0|  0.00%|                                     other.indptr, other.indices),
  1236|         0|            0|            0|  0.00%|                                    maxval=maxnnz)
  1237|         0|            0|            0|  0.00%|        indptr = np.empty(self.indptr.shape, dtype=idx_dtype)
  1238|         0|            0|            0|  0.00%|        indices = np.empty(maxnnz, dtype=idx_dtype)
  1239|         0|            0|            0|  0.00%|
  1240|         0|            0|            0|  0.00%|        bool_ops = ['_ne_', '_lt_', '_gt_', '_le_', '_ge_']
  1241|         0|            0|            0|  0.00%|        if op in bool_ops:
  1242|         0|            0|            0|  0.00%|            data = np.empty(maxnnz, dtype=np.bool_)
  1243|         0|            0|            0|  0.00%|        else:
  1244|         0|            0|            0|  0.00%|            data = np.empty(maxnnz, dtype=upcast(self.dtype, other.dtype))
  1245|         0|            0|            0|  0.00%|
  1246|         0|            0|            0|  0.00%|        fn(self.shape[0], self.shape[1],
  1247|         0|            0|            0|  0.00%|           np.asarray(self.indptr, dtype=idx_dtype),
  1248|         0|            0|            0|  0.00%|           np.asarray(self.indices, dtype=idx_dtype),
  1249|         0|            0|            0|  0.00%|           self.data,
  1250|         0|            0|            0|  0.00%|           np.asarray(other.indptr, dtype=idx_dtype),
  1251|         0|            0|            0|  0.00%|           np.asarray(other.indices, dtype=idx_dtype),
  1252|         0|            0|            0|  0.00%|           other.data,
  1253|         0|            0|            0|  0.00%|           indptr, indices, data)
  1254|         0|            0|            0|  0.00%|
  1255|         0|            0|            0|  0.00%|        A = self.__class__((data, indices, indptr), shape=self.shape)
  1256|         0|            0|            0|  0.00%|        A.prune()
  1257|         0|            0|            0|  0.00%|
  1258|         0|            0|            0|  0.00%|        return A
  1259|         0|            0|            0|  0.00%|
  1260|         0|            0|            0|  0.00%|    def _divide_sparse(self, other):
  1261|         0|            0|            0|  0.00%|        """
  1262|         0|            0|            0|  0.00%|        Divide this matrix by a second sparse matrix.
  1263|         0|            0|            0|  0.00%|        """
  1264|         0|            0|            0|  0.00%|        if other.shape != self.shape:
  1265|         0|            0|            0|  0.00%|            raise ValueError('inconsistent shapes')
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|        r = self._binopt(other, '_eldiv_')
  1268|         0|            0|            0|  0.00%|
  1269|         0|            0|            0|  0.00%|        if np.issubdtype(r.dtype, np.inexact):
  1270|         0|            0|            0|  0.00%|            # Eldiv leaves entries outside the combined sparsity
  1271|         0|            0|            0|  0.00%|            # pattern empty, so they must be filled manually.
  1272|         0|            0|            0|  0.00%|            # Everything outside of other's sparsity is NaN, and everything
  1273|         0|            0|            0|  0.00%|            # inside it is either zero or defined by eldiv.
  1274|         0|            0|            0|  0.00%|            out = np.empty(self.shape, dtype=self.dtype)
  1275|         0|            0|            0|  0.00%|            out.fill(np.nan)
  1276|         0|            0|            0|  0.00%|            row, col = other.nonzero()
  1277|         0|            0|            0|  0.00%|            out[row, col] = 0
  1278|         0|            0|            0|  0.00%|            r = r.tocoo()
  1279|         0|            0|            0|  0.00%|            out[r.row, r.col] = r.data
  1280|         0|            0|            0|  0.00%|            out = matrix(out)
  1281|         0|            0|            0|  0.00%|        else:
  1282|         0|            0|            0|  0.00%|            # integers types go with nan <-> 0
  1283|         0|            0|            0|  0.00%|            out = r
  1284|         0|            0|            0|  0.00%|
  1285|         0|            0|            0|  0.00%|        return out
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|
  1288|         0|            0|            0|  0.00%|def _process_slice(sl, num):
  1289|         0|            0|            0|  0.00%|    if sl is None:
  1290|         0|            0|            0|  0.00%|        i0, i1 = 0, num
  1291|         0|            0|            0|  0.00%|    elif isinstance(sl, slice):
  1292|         0|            0|            0|  0.00%|        i0, i1, stride = sl.indices(num)
  1293|         0|            0|            0|  0.00%|        if stride != 1:
  1294|         0|            0|            0|  0.00%|            raise ValueError('slicing with step != 1 not supported')
  1295|         0|            0|            0|  0.00%|        i0 = min(i0, i1)  # give an empty slice when i0 > i1
  1296|         0|            0|            0|  0.00%|    elif isintlike(sl):
  1297|         0|            0|            0|  0.00%|        if sl < 0:
  1298|         0|            0|            0|  0.00%|            sl += num
  1299|         0|            0|            0|  0.00%|        i0, i1 = sl, sl + 1
  1300|         0|            0|            0|  0.00%|        if i0 < 0 or i1 > num:
  1301|         0|            0|            0|  0.00%|            raise IndexError('index out of bounds: 0 <= %d < %d <= %d' %
  1302|         0|            0|            0|  0.00%|                             (i0, i1, num))
  1303|         0|            0|            0|  0.00%|    else:
  1304|         0|            0|            0|  0.00%|        raise TypeError('expected slice or scalar')
  1305|         0|            0|            0|  0.00%|
  1306|         0|            0|            0|  0.00%|    return i0, i1
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py
File duration: 0.00598431s (0.02%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|""" Utility functions for sparse matrix module
     2|         0|            0|            0|  0.00%|"""
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|import sys
     5|         0|            0|            0|  0.00%|import operator
     6|         0|            0|            0|  0.00%|import warnings
     7|         0|            0|            0|  0.00%|import numpy as np
     8|         0|            0|            0|  0.00%|from scipy._lib._util import prod
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|__all__ = ['upcast', 'getdtype', 'getdata', 'isscalarlike', 'isintlike',
    11|         0|            0|            0|  0.00%|           'isshape', 'issequence', 'isdense', 'ismatrix', 'get_sum_dtype']
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|supported_dtypes = [np.bool_, np.byte, np.ubyte, np.short, np.ushort, np.intc,
    14|         0|            0|            0|  0.00%|                    np.uintc, np.int_, np.uint, np.longlong, np.ulonglong, np.single, np.double,
    15|         0|            0|            0|  0.00%|                    np.longdouble, np.csingle, np.cdouble, np.clongdouble]
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|_upcast_memo = {}
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         5|            0|            0|  0.00%|def upcast(*args):
    21|         0|            0|            0|  0.00%|    """Returns the nearest supported sparse dtype for the
    22|         0|            0|            0|  0.00%|    combination of one or more types.
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|    upcast(t0, t1, ..., tn) -> T  where T is a supported dtype
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|    Examples
    27|         0|            0|            0|  0.00%|    --------
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|    >>> upcast('int32')
    30|         0|            0|            0|  0.00%|    <type 'numpy.int32'>
    31|         0|            0|            0|  0.00%|    >>> upcast('bool')
    32|         0|            0|            0|  0.00%|    <type 'numpy.bool_'>
    33|         0|            0|            0|  0.00%|    >>> upcast('int32','float32')
    34|         0|            0|            0|  0.00%|    <type 'numpy.float64'>
    35|         0|            0|            0|  0.00%|    >>> upcast('bool',complex,float)
    36|         0|            0|            0|  0.00%|    <type 'numpy.complex128'>
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|    """
    39|         0|            0|            0|  0.00%|
    40|         5|            0|            0|  0.00%|    t = _upcast_memo.get(hash(args))
    41|         5|            0|            0|  0.00%|    if t is not None:
    42|         3|            0|            0|  0.00%|        return t
    43|         0|            0|            0|  0.00%|
    44|         2|            0|            0|  0.00%|    upcast = np.find_common_type(args, [])
(call)|         2|   0.00100112|   0.00050056|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:597 find_common_type
    45|         0|            0|            0|  0.00%|
    46|        16|            0|            0|  0.00%|    for t in supported_dtypes:
    47|        16|            0|            0|  0.00%|        if np.can_cast(upcast, t):
(call)|        16|            0|            0|  0.00%|# <__array_function__ internals>:177 can_cast
    48|         2|            0|            0|  0.00%|            _upcast_memo[hash(args)] = t
    49|         2|            0|            0|  0.00%|            return t
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    raise TypeError('no supported conversion for types: %r' % (args,))
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         8|            0|            0|  0.00%|def upcast_char(*args):
    55|         0|            0|            0|  0.00%|    """Same as `upcast` but taking dtype.char as input (faster)."""
    56|         8|            0|            0|  0.00%|    t = _upcast_memo.get(args)
    57|         8|            0|            0|  0.00%|    if t is not None:
    58|         7|            0|            0|  0.00%|        return t
    59|         1|            0|            0|  0.00%|    t = upcast(*map(np.dtype, args))
(call)|         1|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:20 upcast
    60|         1|            0|            0|  0.00%|    _upcast_memo[args] = t
    61|         1|            0|            0|  0.00%|    return t
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|def upcast_scalar(dtype, scalar):
    65|         0|            0|            0|  0.00%|    """Determine data type for binary operation between an array of
    66|         0|            0|            0|  0.00%|    type `dtype` and a scalar.
    67|         0|            0|            0|  0.00%|    """
    68|         0|            0|            0|  0.00%|    return (np.array([0], dtype=dtype) * scalar).dtype
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         4|            0|            0|  0.00%|def downcast_intp_index(arr):
    72|         0|            0|            0|  0.00%|    """
    73|         0|            0|            0|  0.00%|    Down-cast index array to np.intp dtype if it is of a larger dtype.
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    Raise an error if the array contains a value that is too large for
    76|         0|            0|            0|  0.00%|    intp.
    77|         0|            0|            0|  0.00%|    """
    78|         4|            0|            0|  0.00%|    if arr.dtype.itemsize > np.dtype(np.intp).itemsize:
    79|         0|            0|            0|  0.00%|        if arr.size == 0:
    80|         0|            0|            0|  0.00%|            return arr.astype(np.intp)
    81|         0|            0|            0|  0.00%|        maxval = arr.max()
    82|         0|            0|            0|  0.00%|        minval = arr.min()
    83|         0|            0|            0|  0.00%|        if maxval > np.iinfo(np.intp).max or minval < np.iinfo(np.intp).min:
    84|         0|            0|            0|  0.00%|            raise ValueError("Cannot deal with arrays with indices larger "
    85|         0|            0|            0|  0.00%|                             "than the machine maximum address size "
    86|         0|            0|            0|  0.00%|                             "(e.g. 64-bit indices on 32-bit machine).")
    87|         0|            0|            0|  0.00%|        return arr.astype(np.intp)
    88|         4|            0|            0|  0.00%|    return arr
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|        28|            0|            0|  0.00%|def to_native(A):
    92|        28|            0|            0|  0.00%|    return np.asarray(A, dtype=A.dtype.newbyteorder('native'))
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         8|            0|            0|  0.00%|def getdtype(dtype, a=None, default=None):
    96|         0|            0|            0|  0.00%|    """Function used to simplify argument processing. If 'dtype' is not
    97|         0|            0|            0|  0.00%|    specified (is None), returns a.dtype; otherwise returns a np.dtype
    98|         0|            0|            0|  0.00%|    object created from the specified dtype argument. If 'dtype' and 'a'
    99|         0|            0|            0|  0.00%|    are both None, construct a data type out of the 'default' parameter.
   100|         0|            0|            0|  0.00%|    Furthermore, 'dtype' must be in 'allowed' set.
   101|         0|            0|            0|  0.00%|    """
   102|         0|            0|            0|  0.00%|    # TODO is this really what we want?
   103|         8|            0|            0|  0.00%|    if dtype is None:
   104|         0|            0|            0|  0.00%|        try:
   105|         0|            0|            0|  0.00%|            newdtype = a.dtype
   106|         0|            0|            0|  0.00%|        except AttributeError as e:
   107|         0|            0|            0|  0.00%|            if default is not None:
   108|         0|            0|            0|  0.00%|                newdtype = np.dtype(default)
   109|         0|            0|            0|  0.00%|            else:
   110|         0|            0|            0|  0.00%|                raise TypeError("could not interpret data type") from e
   111|         0|            0|            0|  0.00%|    else:
   112|         8|            0|            0|  0.00%|        newdtype = np.dtype(dtype)
   113|         8|            0|            0|  0.00%|        if newdtype == np.object_:
   114|         0|            0|            0|  0.00%|            warnings.warn("object dtype is not supported by sparse matrices")
   115|         0|            0|            0|  0.00%|
   116|         8|            0|            0|  0.00%|    return newdtype
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         8|            0|            0|  0.00%|def getdata(obj, dtype=None, copy=False):
   120|         0|            0|            0|  0.00%|    """
   121|         0|            0|            0|  0.00%|    This is a wrapper of `np.array(obj, dtype=dtype, copy=copy)`
   122|         0|            0|            0|  0.00%|    that will generate a warning if the result is an object array.
   123|         0|            0|            0|  0.00%|    """
   124|         8|            0|            0|  0.00%|    data = np.array(obj, dtype=dtype, copy=copy)
   125|         0|            0|            0|  0.00%|    # Defer to getdtype for checking that the dtype is OK.
   126|         0|            0|            0|  0.00%|    # This is called for the validation only; we don't need the return value.
   127|         8|            0|            0|  0.00%|    getdtype(data.dtype)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:95 getdtype
   128|         8|            0|            0|  0.00%|    return data
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|
   131|        56|            0|            0|  0.00%|def get_index_dtype(arrays=(), maxval=None, check_contents=False):
   132|         0|            0|            0|  0.00%|    """
   133|         0|            0|            0|  0.00%|    Based on input (integer) arrays `a`, determine a suitable index data
   134|         0|            0|            0|  0.00%|    type that can hold the data in the arrays.
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|    Parameters
   137|         0|            0|            0|  0.00%|    ----------
   138|         0|            0|            0|  0.00%|    arrays : tuple of array_like
   139|         0|            0|            0|  0.00%|        Input arrays whose types/contents to check
   140|         0|            0|            0|  0.00%|    maxval : float, optional
   141|         0|            0|            0|  0.00%|        Maximum value needed
   142|         0|            0|            0|  0.00%|    check_contents : bool, optional
   143|         0|            0|            0|  0.00%|        Whether to check the values in the arrays and not just their types.
   144|         0|            0|            0|  0.00%|        Default: False (check only the types)
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    Returns
   147|         0|            0|            0|  0.00%|    -------
   148|         0|            0|            0|  0.00%|    dtype : dtype
   149|         0|            0|            0|  0.00%|        Suitable index data type (int32 or int64)
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|    """
   152|         0|            0|            0|  0.00%|
   153|        56|            0|            0|  0.00%|    int32min = np.iinfo(np.int32).min
(call)|        56|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:647 __init__
(call)|        56|  0.000996351|   1.7792e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:658 min
   154|        56|   0.00199628|  3.56478e-05|  0.01%|    int32max = np.iinfo(np.int32).max
(call)|        56|  0.000997066|  1.78048e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:647 __init__
(call)|        56|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:671 max
   155|         0|            0|            0|  0.00%|
   156|        56|  0.000995636|  1.77792e-05|  0.00%|    dtype = np.intc
   157|        56|            0|            0|  0.00%|    if maxval is not None:
   158|        40|            0|            0|  0.00%|        if maxval > int32max:
   159|         0|            0|            0|  0.00%|            dtype = np.int64
   160|         0|            0|            0|  0.00%|
   161|        56|            0|            0|  0.00%|    if isinstance(arrays, np.ndarray):
   162|         0|            0|            0|  0.00%|        arrays = (arrays,)
   163|         0|            0|            0|  0.00%|
   164|       128|            0|            0|  0.00%|    for arr in arrays:
   165|        72|            0|            0|  0.00%|        arr = np.asarray(arr)
   166|        72|            0|            0|  0.00%|        if not np.can_cast(arr.dtype, np.int32):
(call)|        72|            0|            0|  0.00%|# <__array_function__ internals>:177 can_cast
   167|         0|            0|            0|  0.00%|            if check_contents:
   168|         0|            0|            0|  0.00%|                if arr.size == 0:
   169|         0|            0|            0|  0.00%|                    # a bigger type not needed
   170|         0|            0|            0|  0.00%|                    continue
   171|         0|            0|            0|  0.00%|                elif np.issubdtype(arr.dtype, np.integer):
   172|         0|            0|            0|  0.00%|                    maxval = arr.max()
   173|         0|            0|            0|  0.00%|                    minval = arr.min()
   174|         0|            0|            0|  0.00%|                    if minval >= int32min and maxval <= int32max:
   175|         0|            0|            0|  0.00%|                        # a bigger type not needed
   176|         0|            0|            0|  0.00%|                        continue
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|            dtype = np.int64
   179|         0|            0|            0|  0.00%|            break
   180|         0|            0|            0|  0.00%|
   181|        56|            0|            0|  0.00%|    return dtype
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|
   184|        12|            0|            0|  0.00%|def get_sum_dtype(dtype):
   185|         0|            0|            0|  0.00%|    """Mimic numpy's casting for np.sum"""
   186|        12|            0|            0|  0.00%|    if dtype.kind == 'u' and np.can_cast(dtype, np.uint):
   187|         0|            0|            0|  0.00%|        return np.uint
   188|        12|            0|            0|  0.00%|    if np.can_cast(dtype, np.int_):
(call)|        12|            0|            0|  0.00%|# <__array_function__ internals>:177 can_cast
   189|        12|            0|            0|  0.00%|        return np.int_
   190|         0|            0|            0|  0.00%|    return dtype
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|        12|            0|            0|  0.00%|def isscalarlike(x):
   194|         0|            0|            0|  0.00%|    """Is x either a scalar, an array scalar, or a 0-dim array?"""
   195|        12|            0|            0|  0.00%|    return np.isscalar(x) or (isdense(x) and x.ndim == 0)
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1859 isscalar
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:250 isdense
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|
   198|         8|            0|            0|  0.00%|def isintlike(x):
   199|         0|            0|            0|  0.00%|    """Is x appropriate as an index into a sparse matrix? Returns True
   200|         0|            0|            0|  0.00%|    if it can be cast safely to a machine int.
   201|         0|            0|            0|  0.00%|    """
   202|         0|            0|            0|  0.00%|    # Fast-path check to eliminate non-scalar values. operator.index would
   203|         0|            0|            0|  0.00%|    # catch this case too, but the exception catching is slow.
   204|         8|  0.000997782|  0.000124723|  0.00%|    if np.ndim(x) != 0:
(call)|         8|            0|            0|  0.00%|# <__array_function__ internals>:177 ndim
   205|         8|            0|            0|  0.00%|        return False
   206|         0|            0|            0|  0.00%|    try:
   207|         0|            0|            0|  0.00%|        operator.index(x)
   208|         0|            0|            0|  0.00%|    except (TypeError, ValueError):
   209|         0|            0|            0|  0.00%|        try:
   210|         0|            0|            0|  0.00%|            loose_int = bool(int(x) == x)
   211|         0|            0|            0|  0.00%|        except (TypeError, ValueError):
   212|         0|            0|            0|  0.00%|            return False
   213|         0|            0|            0|  0.00%|        if loose_int:
   214|         0|            0|            0|  0.00%|            warnings.warn("Inexact indices into sparse matrices are deprecated",
   215|         0|            0|            0|  0.00%|                          DeprecationWarning)
   216|         0|            0|            0|  0.00%|        return loose_int
   217|         0|            0|            0|  0.00%|    return True
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|
   220|        24|            0|            0|  0.00%|def isshape(x, nonneg=False):
   221|         0|            0|            0|  0.00%|    """Is x a valid 2-tuple of dimensions?
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    If nonneg, also checks that the dimensions are non-negative.
   224|         0|            0|            0|  0.00%|    """
   225|        24|  0.000997066|  4.15444e-05|  0.00%|    try:
   226|         0|            0|            0|  0.00%|        # Assume it's a tuple of matrix dimensions (M, N)
   227|        24|            0|            0|  0.00%|        (M, N) = x
   228|        16|            0|            0|  0.00%|    except Exception:
   229|        16|            0|            0|  0.00%|        return False
   230|         0|            0|            0|  0.00%|    else:
   231|         8|            0|            0|  0.00%|        if isintlike(M) and isintlike(N):
(call)|         8|  0.000997782|  0.000124723|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:198 isintlike
   232|         0|            0|            0|  0.00%|            if np.ndim(M) == 0 and np.ndim(N) == 0:
   233|         0|            0|            0|  0.00%|                if not nonneg or (M >= 0 and N >= 0):
   234|         0|            0|            0|  0.00%|                    return True
   235|         8|            0|            0|  0.00%|        return False
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|def issequence(t):
   239|         0|            0|            0|  0.00%|    return ((isinstance(t, (list, tuple)) and
   240|         0|            0|            0|  0.00%|            (len(t) == 0 or np.isscalar(t[0]))) or
   241|         0|            0|            0|  0.00%|            (isinstance(t, np.ndarray) and (t.ndim == 1)))
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|def ismatrix(t):
   245|         0|            0|            0|  0.00%|    return ((isinstance(t, (list, tuple)) and
   246|         0|            0|            0|  0.00%|             len(t) > 0 and issequence(t[0])) or
   247|         0|            0|            0|  0.00%|            (isinstance(t, np.ndarray) and t.ndim == 2))
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|
   250|        12|            0|            0|  0.00%|def isdense(x):
   251|        12|            0|            0|  0.00%|    return isinstance(x, np.ndarray)
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|
   254|         8|            0|            0|  0.00%|def validateaxis(axis):
   255|         8|            0|            0|  0.00%|    if axis is not None:
   256|         4|            0|            0|  0.00%|        axis_type = type(axis)
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|        # In NumPy, you can pass in tuples for 'axis', but they are
   259|         0|            0|            0|  0.00%|        # not very useful for sparse matrices given their limited
   260|         0|            0|            0|  0.00%|        # dimensions, so let's make it explicit that they are not
   261|         0|            0|            0|  0.00%|        # allowed to be passed in
   262|         4|            0|            0|  0.00%|        if axis_type == tuple:
   263|         0|            0|            0|  0.00%|            raise TypeError(("Tuples are not accepted for the 'axis' "
   264|         0|            0|            0|  0.00%|                             "parameter. Please pass in one of the "
   265|         0|            0|            0|  0.00%|                             "following: {-2, -1, 0, 1, None}."))
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|        # If not a tuple, check that the provided axis is actually
   268|         0|            0|            0|  0.00%|        # an integer and raise a TypeError similar to NumPy's
   269|         4|            0|            0|  0.00%|        if not np.issubdtype(np.dtype(axis_type), np.integer):
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numerictypes.py:356 issubdtype
   270|         0|            0|            0|  0.00%|            raise TypeError("axis must be an integer, not {name}"
   271|         0|            0|            0|  0.00%|                            .format(name=axis_type.__name__))
   272|         0|            0|            0|  0.00%|
   273|         4|            0|            0|  0.00%|        if not (-2 <= axis <= 1):
   274|         0|            0|            0|  0.00%|            raise ValueError("axis out of range")
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|
   277|        28|            0|            0|  0.00%|def check_shape(args, current_shape=None):
   278|         0|            0|            0|  0.00%|    """Imitate numpy.matrix handling of shape arguments"""
   279|        28|            0|            0|  0.00%|    if len(args) == 0:
   280|         0|            0|            0|  0.00%|        raise TypeError("function missing 1 required positional argument: "
   281|         0|            0|            0|  0.00%|                        "'shape'")
   282|        28|            0|            0|  0.00%|    elif len(args) == 1:
   283|         0|            0|            0|  0.00%|        try:
   284|         0|            0|            0|  0.00%|            shape_iter = iter(args[0])
   285|         0|            0|            0|  0.00%|        except TypeError:
   286|         0|            0|            0|  0.00%|            new_shape = (operator.index(args[0]), )
   287|         0|            0|            0|  0.00%|        else:
   288|         0|            0|            0|  0.00%|            new_shape = tuple(operator.index(arg) for arg in shape_iter)
   289|         0|            0|            0|  0.00%|    else:
   290|       196|  0.000997543|  5.08951e-06|  0.00%|        new_shape = tuple(operator.index(arg) for arg in args)
(call)|        84|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:290 <genexpr>
   291|         0|            0|            0|  0.00%|
   292|        28|            0|            0|  0.00%|    if current_shape is None:
   293|        28|            0|            0|  0.00%|        if len(new_shape) != 2:
   294|         0|            0|            0|  0.00%|            raise ValueError('shape must be a 2-tuple of positive integers')
   295|        28|            0|            0|  0.00%|        elif new_shape[0] < 0 or new_shape[1] < 0:
   296|         0|            0|            0|  0.00%|            raise ValueError("'shape' elements cannot be negative")
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    else:
   299|         0|            0|            0|  0.00%|        # Check the current size only if needed
   300|         0|            0|            0|  0.00%|        current_size = prod(current_shape)
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|        # Check for negatives
   303|         0|            0|            0|  0.00%|        negative_indexes = [i for i, x in enumerate(new_shape) if x < 0]
   304|         0|            0|            0|  0.00%|        if len(negative_indexes) == 0:
   305|         0|            0|            0|  0.00%|            new_size = prod(new_shape)
   306|         0|            0|            0|  0.00%|            if new_size != current_size:
   307|         0|            0|            0|  0.00%|                raise ValueError('cannot reshape array of size {} into shape {}'
   308|         0|            0|            0|  0.00%|                                 .format(current_size, new_shape))
   309|         0|            0|            0|  0.00%|        elif len(negative_indexes) == 1:
   310|         0|            0|            0|  0.00%|            skip = negative_indexes[0]
   311|         0|            0|            0|  0.00%|            specified = prod(new_shape[0:skip] + new_shape[skip+1:])
   312|         0|            0|            0|  0.00%|            unspecified, remainder = divmod(current_size, specified)
   313|         0|            0|            0|  0.00%|            if remainder != 0:
   314|         0|            0|            0|  0.00%|                err_shape = tuple('newshape' if x < 0 else x for x in new_shape)
   315|         0|            0|            0|  0.00%|                raise ValueError('cannot reshape array of size {} into shape {}'
   316|         0|            0|            0|  0.00%|                                 ''.format(current_size, err_shape))
   317|         0|            0|            0|  0.00%|            new_shape = new_shape[0:skip] + (unspecified,) + new_shape[skip+1:]
   318|         0|            0|            0|  0.00%|        else:
   319|         0|            0|            0|  0.00%|            raise ValueError('can only specify one unknown dimension')
   320|         0|            0|            0|  0.00%|
   321|        28|            0|            0|  0.00%|    if len(new_shape) != 2:
   322|         0|            0|            0|  0.00%|        raise ValueError('matrix shape must be two-dimensional')
   323|         0|            0|            0|  0.00%|
   324|        28|            0|            0|  0.00%|    return new_shape
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|def check_reshape_kwargs(kwargs):
   328|         0|            0|            0|  0.00%|    """Unpack keyword arguments for reshape function.
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|    This is useful because keyword arguments after star arguments are not
   331|         0|            0|            0|  0.00%|    allowed in Python 2, but star keyword arguments are. This function unpacks
   332|         0|            0|            0|  0.00%|    'order' and 'copy' from the star keyword arguments (with defaults) and
   333|         0|            0|            0|  0.00%|    throws an error for any remaining.
   334|         0|            0|            0|  0.00%|    """
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|    order = kwargs.pop('order', 'C')
   337|         0|            0|            0|  0.00%|    copy = kwargs.pop('copy', False)
   338|         0|            0|            0|  0.00%|    if kwargs:  # Some unused kwargs remain
   339|         0|            0|            0|  0.00%|        raise TypeError('reshape() got unexpected keywords arguments: {}'
   340|         0|            0|            0|  0.00%|                        .format(', '.join(kwargs.keys())))
   341|         0|            0|            0|  0.00%|    return order, copy
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|def is_pydata_spmatrix(m):
   345|         0|            0|            0|  0.00%|    """
   346|         0|            0|            0|  0.00%|    Check whether object is pydata/sparse matrix, avoiding importing the module.
   347|         0|            0|            0|  0.00%|    """
   348|         0|            0|            0|  0.00%|    base_cls = getattr(sys.modules.get('sparse'), 'SparseArray', None)
   349|         0|            0|            0|  0.00%|    return base_cls is not None and isinstance(m, base_cls)
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|###############################################################################
   353|         0|            0|            0|  0.00%|# Wrappers for NumPy types that are deprecated
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|# Numpy versions of these functions raise deprecation warnings, the
   356|         0|            0|            0|  0.00%|# ones below do not.
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|def matrix(*args, **kwargs):
   360|         0|            0|            0|  0.00%|    return np.array(*args, **kwargs).view(np.matrix)
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|        20|            0|            0|  0.00%|def asmatrix(data, dtype=None):
   364|        20|            0|            0|  0.00%|    if isinstance(data, np.matrix) and (dtype is None or data.dtype == dtype):
   365|         0|            0|            0|  0.00%|        return data
   366|        20|            0|            0|  0.00%|    return np.asarray(data, dtype=dtype).view(np.matrix)
(call)|        20|  0.000997782|  4.98891e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:167 __array_finalize__
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py
File duration: 0.00526285s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Utilities for input validation"""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|# Authors: Olivier Grisel
     4|         0|            0|            0|  0.00%|#          Gael Varoquaux
     5|         0|            0|            0|  0.00%|#          Andreas Mueller
     6|         0|            0|            0|  0.00%|#          Lars Buitinck
     7|         0|            0|            0|  0.00%|#          Alexandre Gramfort
     8|         0|            0|            0|  0.00%|#          Nicolas Tresegnie
     9|         0|            0|            0|  0.00%|#          Sylvain Marie
    10|         0|            0|            0|  0.00%|# License: BSD 3 clause
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|from functools import wraps
    13|         0|            0|            0|  0.00%|import warnings
    14|         0|            0|            0|  0.00%|import numbers
    15|         0|            0|            0|  0.00%|import operator
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|import numpy as np
    18|         0|            0|            0|  0.00%|import scipy.sparse as sp
    19|         0|            0|            0|  0.00%|from inspect import signature, isclass, Parameter
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|# mypy error: Module 'numpy.core.numeric' has no attribute 'ComplexWarning'
    22|         0|            0|            0|  0.00%|from numpy.core.numeric import ComplexWarning  # type: ignore
    23|         0|            0|            0|  0.00%|import joblib
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|from contextlib import suppress
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|from .fixes import _object_dtype_isnan, parse_version
    28|         0|            0|            0|  0.00%|from .. import get_config as _get_config
    29|         0|            0|            0|  0.00%|from ..exceptions import PositiveSpectrumWarning
    30|         0|            0|            0|  0.00%|from ..exceptions import NotFittedError
    31|         0|            0|            0|  0.00%|from ..exceptions import DataConversionWarning
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|FLOAT_DTYPES = (np.float64, np.float32, np.float16)
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|def _deprecate_positional_args(func=None, *, version="1.1 (renaming of 0.26)"):
    37|         0|            0|            0|  0.00%|    """Decorator for methods that issues warnings for positional arguments.
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    Using the keyword-only argument syntax in pep 3102, arguments after the
    40|         0|            0|            0|  0.00%|    * will issue a warning when passed as a positional argument.
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    Parameters
    43|         0|            0|            0|  0.00%|    ----------
    44|         0|            0|            0|  0.00%|    func : callable, default=None
    45|         0|            0|            0|  0.00%|        Function to check arguments on.
    46|         0|            0|            0|  0.00%|    version : callable, default="1.1 (renaming of 0.26)"
    47|         0|            0|            0|  0.00%|        The version when positional arguments will result in error.
    48|         0|            0|            0|  0.00%|    """
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|    def _inner_deprecate_positional_args(f):
    51|         0|            0|            0|  0.00%|        sig = signature(f)
    52|         0|            0|            0|  0.00%|        kwonly_args = []
    53|         0|            0|            0|  0.00%|        all_args = []
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|        for name, param in sig.parameters.items():
    56|         0|            0|            0|  0.00%|            if param.kind == Parameter.POSITIONAL_OR_KEYWORD:
    57|         0|            0|            0|  0.00%|                all_args.append(name)
    58|         0|            0|            0|  0.00%|            elif param.kind == Parameter.KEYWORD_ONLY:
    59|         0|            0|            0|  0.00%|                kwonly_args.append(name)
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|        @wraps(f)
    62|         0|            0|            0|  0.00%|        def inner_f(*args, **kwargs):
    63|         0|            0|            0|  0.00%|            extra_args = len(args) - len(all_args)
    64|         0|            0|            0|  0.00%|            if extra_args <= 0:
    65|         0|            0|            0|  0.00%|                return f(*args, **kwargs)
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|            # extra_args > 0
    68|         0|            0|            0|  0.00%|            args_msg = [
    69|         0|            0|            0|  0.00%|                "{}={}".format(name, arg)
    70|         0|            0|            0|  0.00%|                for name, arg in zip(kwonly_args[:extra_args], args[-extra_args:])
    71|         0|            0|            0|  0.00%|            ]
    72|         0|            0|            0|  0.00%|            args_msg = ", ".join(args_msg)
    73|         0|            0|            0|  0.00%|            warnings.warn(
    74|         0|            0|            0|  0.00%|                f"Pass {args_msg} as keyword args. From version "
    75|         0|            0|            0|  0.00%|                f"{version} passing these as positional arguments "
    76|         0|            0|            0|  0.00%|                "will result in an error",
    77|         0|            0|            0|  0.00%|                FutureWarning,
    78|         0|            0|            0|  0.00%|            )
    79|         0|            0|            0|  0.00%|            kwargs.update(zip(sig.parameters, args))
    80|         0|            0|            0|  0.00%|            return f(**kwargs)
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|        return inner_f
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    if func is not None:
    85|         0|            0|            0|  0.00%|        return _inner_deprecate_positional_args(func)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|    return _inner_deprecate_positional_args
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|        12|            0|            0|  0.00%|def _assert_all_finite(X, allow_nan=False, msg_dtype=None):
    91|         0|            0|            0|  0.00%|    """Like assert_all_finite, but only for ndarray."""
    92|         0|            0|            0|  0.00%|    # validation is also imported in extmath
    93|        12|            0|            0|  0.00%|    from .extmath import _safe_accumulator_op
(call)|        12|            0|            0|  0.00%|# <frozen importlib._bootstrap>:389 parent
    94|         0|            0|            0|  0.00%|
    95|        12|  0.000997066|  8.30889e-05|  0.00%|    if _get_config()["assume_finite"]:
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\_config.py:24 get_config
    96|         0|            0|            0|  0.00%|        return
    97|        12|            0|            0|  0.00%|    X = np.asanyarray(X)
    98|         0|            0|            0|  0.00%|    # First try an O(n) time, O(1) space solution for the common case that
    99|         0|            0|            0|  0.00%|    # everything is finite; fall back to O(n) space np.isfinite to prevent
   100|         0|            0|            0|  0.00%|    # false positives from overflow in sum method. The sum is also calculated
   101|         0|            0|            0|  0.00%|    # safely to reduce dtype induced overflows.
   102|        12|            0|            0|  0.00%|    is_float = X.dtype.kind in "fc"
   103|        12|            0|            0|  0.00%|    if is_float and (np.isfinite(_safe_accumulator_op(np.sum, X))):
   104|         0|            0|            0|  0.00%|        pass
   105|        12|            0|            0|  0.00%|    elif is_float:
   106|         0|            0|            0|  0.00%|        msg_err = "Input contains {} or a value too large for {!r}."
   107|         0|            0|            0|  0.00%|        if (
   108|         0|            0|            0|  0.00%|            allow_nan
   109|         0|            0|            0|  0.00%|            and np.isinf(X).any()
   110|         0|            0|            0|  0.00%|            or not allow_nan
   111|         0|            0|            0|  0.00%|            and not np.isfinite(X).all()
   112|         0|            0|            0|  0.00%|        ):
   113|         0|            0|            0|  0.00%|            type_err = "infinity" if allow_nan else "NaN, infinity"
   114|         0|            0|            0|  0.00%|            raise ValueError(
   115|         0|            0|            0|  0.00%|                msg_err.format(
   116|         0|            0|            0|  0.00%|                    type_err, msg_dtype if msg_dtype is not None else X.dtype
   117|         0|            0|            0|  0.00%|                )
   118|         0|            0|            0|  0.00%|            )
   119|         0|            0|            0|  0.00%|    # for object dtype data, we only check for NaNs (GH-13254)
   120|        12|            0|            0|  0.00%|    elif X.dtype == np.dtype("object") and not allow_nan:
   121|         0|            0|            0|  0.00%|        if _object_dtype_isnan(X).any():
   122|         0|            0|            0|  0.00%|            raise ValueError("Input contains NaN")
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|def assert_all_finite(X, *, allow_nan=False):
   126|         0|            0|            0|  0.00%|    """Throw a ValueError if X contains NaN or infinity.
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|    Parameters
   129|         0|            0|            0|  0.00%|    ----------
   130|         0|            0|            0|  0.00%|    X : {ndarray, sparse matrix}
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|    allow_nan : bool, default=False
   133|         0|            0|            0|  0.00%|    """
   134|         0|            0|            0|  0.00%|    _assert_all_finite(X.data if sp.issparse(X) else X, allow_nan)
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|def as_float_array(X, *, copy=True, force_all_finite=True):
   138|         0|            0|            0|  0.00%|    """Converts an array-like to an array of floats.
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    The new dtype will be np.float32 or np.float64, depending on the original
   141|         0|            0|            0|  0.00%|    type. The function can create a copy or modify the argument depending
   142|         0|            0|            0|  0.00%|    on the argument copy.
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    Parameters
   145|         0|            0|            0|  0.00%|    ----------
   146|         0|            0|            0|  0.00%|    X : {array-like, sparse matrix}
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    copy : bool, default=True
   149|         0|            0|            0|  0.00%|        If True, a copy of X will be created. If False, a copy may still be
   150|         0|            0|            0|  0.00%|        returned if X's dtype is not a floating point type.
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    force_all_finite : bool or 'allow-nan', default=True
   153|         0|            0|            0|  0.00%|        Whether to raise an error on np.inf, np.nan, pd.NA in X. The
   154|         0|            0|            0|  0.00%|        possibilities are:
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|        - True: Force all values of X to be finite.
   157|         0|            0|            0|  0.00%|        - False: accepts np.inf, np.nan, pd.NA in X.
   158|         0|            0|            0|  0.00%|        - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot
   159|         0|            0|            0|  0.00%|          be infinite.
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   162|         0|            0|            0|  0.00%|           ``force_all_finite`` accepts the string ``'allow-nan'``.
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|        .. versionchanged:: 0.23
   165|         0|            0|            0|  0.00%|           Accepts `pd.NA` and converts it into `np.nan`
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|    Returns
   168|         0|            0|            0|  0.00%|    -------
   169|         0|            0|            0|  0.00%|    XT : {ndarray, sparse matrix}
   170|         0|            0|            0|  0.00%|        An array of type float.
   171|         0|            0|            0|  0.00%|    """
   172|         0|            0|            0|  0.00%|    if isinstance(X, np.matrix) or (
   173|         0|            0|            0|  0.00%|        not isinstance(X, np.ndarray) and not sp.issparse(X)
   174|         0|            0|            0|  0.00%|    ):
   175|         0|            0|            0|  0.00%|        return check_array(
   176|         0|            0|            0|  0.00%|            X,
   177|         0|            0|            0|  0.00%|            accept_sparse=["csr", "csc", "coo"],
   178|         0|            0|            0|  0.00%|            dtype=np.float64,
   179|         0|            0|            0|  0.00%|            copy=copy,
   180|         0|            0|            0|  0.00%|            force_all_finite=force_all_finite,
   181|         0|            0|            0|  0.00%|            ensure_2d=False,
   182|         0|            0|            0|  0.00%|        )
   183|         0|            0|            0|  0.00%|    elif sp.issparse(X) and X.dtype in [np.float32, np.float64]:
   184|         0|            0|            0|  0.00%|        return X.copy() if copy else X
   185|         0|            0|            0|  0.00%|    elif X.dtype in [np.float32, np.float64]:  # is numpy array
   186|         0|            0|            0|  0.00%|        return X.copy("F" if X.flags["F_CONTIGUOUS"] else "C") if copy else X
   187|         0|            0|            0|  0.00%|    else:
   188|         0|            0|            0|  0.00%|        if X.dtype.kind in "uib" and X.dtype.itemsize <= 4:
   189|         0|            0|            0|  0.00%|            return_dtype = np.float32
   190|         0|            0|            0|  0.00%|        else:
   191|         0|            0|            0|  0.00%|            return_dtype = np.float64
   192|         0|            0|            0|  0.00%|        return X.astype(return_dtype)
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|def _is_arraylike(x):
   196|         0|            0|            0|  0.00%|    """Returns whether the input is array-like."""
   197|         0|            0|            0|  0.00%|    return hasattr(x, "__len__") or hasattr(x, "shape") or hasattr(x, "__array__")
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|def _num_features(X):
   201|         0|            0|            0|  0.00%|    """Return the number of features in an array-like X.
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    This helper function tries hard to avoid to materialize an array version
   204|         0|            0|            0|  0.00%|    of X unless necessary. For instance, if X is a list of lists,
   205|         0|            0|            0|  0.00%|    this function will return the length of the first element, assuming
   206|         0|            0|            0|  0.00%|    that subsequent elements are all lists of the same length without
   207|         0|            0|            0|  0.00%|    checking.
   208|         0|            0|            0|  0.00%|    Parameters
   209|         0|            0|            0|  0.00%|    ----------
   210|         0|            0|            0|  0.00%|    X : array-like
   211|         0|            0|            0|  0.00%|        array-like to get the number of features.
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    Returns
   214|         0|            0|            0|  0.00%|    -------
   215|         0|            0|            0|  0.00%|    features : int
   216|         0|            0|            0|  0.00%|        Number of features
   217|         0|            0|            0|  0.00%|    """
   218|         0|            0|            0|  0.00%|    type_ = type(X)
   219|         0|            0|            0|  0.00%|    if type_.__module__ == "builtins":
   220|         0|            0|            0|  0.00%|        type_name = type_.__qualname__
   221|         0|            0|            0|  0.00%|    else:
   222|         0|            0|            0|  0.00%|        type_name = f"{type_.__module__}.{type_.__qualname__}"
   223|         0|            0|            0|  0.00%|    message = f"Unable to find the number of features from X of type {type_name}"
   224|         0|            0|            0|  0.00%|    if not hasattr(X, "__len__") and not hasattr(X, "shape"):
   225|         0|            0|            0|  0.00%|        if not hasattr(X, "__array__"):
   226|         0|            0|            0|  0.00%|            raise TypeError(message)
   227|         0|            0|            0|  0.00%|        # Only convert X to a numpy array if there is no cheaper, heuristic
   228|         0|            0|            0|  0.00%|        # option.
   229|         0|            0|            0|  0.00%|        X = np.asarray(X)
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    if hasattr(X, "shape"):
   232|         0|            0|            0|  0.00%|        if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
   233|         0|            0|            0|  0.00%|            message += f" with shape {X.shape}"
   234|         0|            0|            0|  0.00%|            raise TypeError(message)
   235|         0|            0|            0|  0.00%|        return X.shape[1]
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    first_sample = X[0]
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    # Do not consider an array-like of strings or dicts to be a 2D array
   240|         0|            0|            0|  0.00%|    if isinstance(first_sample, (str, bytes, dict)):
   241|         0|            0|            0|  0.00%|        message += f" where the samples are of type {type(first_sample).__qualname__}"
   242|         0|            0|            0|  0.00%|        raise TypeError(message)
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|    try:
   245|         0|            0|            0|  0.00%|        # If X is a list of lists, for instance, we assume that all nested
   246|         0|            0|            0|  0.00%|        # lists have the same length without checking or converting to
   247|         0|            0|            0|  0.00%|        # a numpy array to keep this function call as cheap as possible.
   248|         0|            0|            0|  0.00%|        return len(first_sample)
   249|         0|            0|            0|  0.00%|    except Exception as err:
   250|         0|            0|            0|  0.00%|        raise TypeError(message) from err
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|
   253|        12|            0|            0|  0.00%|def _num_samples(x):
   254|         0|            0|            0|  0.00%|    """Return number of samples in array-like x."""
   255|        12|            0|            0|  0.00%|    message = "Expected sequence or array-like, got %s" % type(x)
   256|        12|            0|            0|  0.00%|    if hasattr(x, "fit") and callable(x.fit):
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:673 __getattr__
   257|         0|            0|            0|  0.00%|        # Don't get num_samples from an ensembles length!
   258|         0|            0|            0|  0.00%|        raise TypeError(message)
   259|         0|            0|            0|  0.00%|
   260|        12|            0|            0|  0.00%|    if not hasattr(x, "__len__") and not hasattr(x, "shape"):
   261|         0|            0|            0|  0.00%|        if hasattr(x, "__array__"):
   262|         0|            0|            0|  0.00%|            x = np.asarray(x)
   263|         0|            0|            0|  0.00%|        else:
   264|         0|            0|            0|  0.00%|            raise TypeError(message)
   265|         0|            0|            0|  0.00%|
   266|        12|            0|            0|  0.00%|    if hasattr(x, "shape") and x.shape is not None:
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   267|        12|            0|            0|  0.00%|        if len(x.shape) == 0:
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   268|         0|            0|            0|  0.00%|            raise TypeError(
   269|         0|            0|            0|  0.00%|                "Singleton array %r cannot be considered a valid collection." % x
   270|         0|            0|            0|  0.00%|            )
   271|         0|            0|            0|  0.00%|        # Check that shape is returning an integer or default to len
   272|         0|            0|            0|  0.00%|        # Dask dataframes may not return numeric shape[0] value
   273|        12|  0.000997305|  8.31087e-05|  0.00%|        if isinstance(x.shape[0], numbers.Integral):
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\abc.py:96 __instancecheck__
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   274|        12|            0|            0|  0.00%|            return x.shape[0]
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    try:
   277|         0|            0|            0|  0.00%|        return len(x)
   278|         0|            0|            0|  0.00%|    except TypeError as type_error:
   279|         0|            0|            0|  0.00%|        raise TypeError(message) from type_error
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|def check_memory(memory):
   283|         0|            0|            0|  0.00%|    """Check that ``memory`` is joblib.Memory-like.
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    joblib.Memory-like means that ``memory`` can be converted into a
   286|         0|            0|            0|  0.00%|    joblib.Memory instance (typically a str denoting the ``location``)
   287|         0|            0|            0|  0.00%|    or has the same interface (has a ``cache`` method).
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|    Parameters
   290|         0|            0|            0|  0.00%|    ----------
   291|         0|            0|            0|  0.00%|    memory : None, str or object with the joblib.Memory interface
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    Returns
   294|         0|            0|            0|  0.00%|    -------
   295|         0|            0|            0|  0.00%|    memory : object with the joblib.Memory interface
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|    Raises
   298|         0|            0|            0|  0.00%|    ------
   299|         0|            0|            0|  0.00%|    ValueError
   300|         0|            0|            0|  0.00%|        If ``memory`` is not joblib.Memory-like.
   301|         0|            0|            0|  0.00%|    """
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|    if memory is None or isinstance(memory, str):
   304|         0|            0|            0|  0.00%|        if parse_version(joblib.__version__) < parse_version("0.12"):
   305|         0|            0|            0|  0.00%|            memory = joblib.Memory(cachedir=memory, verbose=0)
   306|         0|            0|            0|  0.00%|        else:
   307|         0|            0|            0|  0.00%|            memory = joblib.Memory(location=memory, verbose=0)
   308|         0|            0|            0|  0.00%|    elif not hasattr(memory, "cache"):
   309|         0|            0|            0|  0.00%|        raise ValueError(
   310|         0|            0|            0|  0.00%|            "'memory' should be None, a string or have the same"
   311|         0|            0|            0|  0.00%|            " interface as joblib.Memory."
   312|         0|            0|            0|  0.00%|            " Got memory='{}' instead.".format(memory)
   313|         0|            0|            0|  0.00%|        )
   314|         0|            0|            0|  0.00%|    return memory
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|
   317|         4|            0|            0|  0.00%|def check_consistent_length(*arrays):
   318|         0|            0|            0|  0.00%|    """Check that all arrays have consistent first dimensions.
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    Checks whether all objects in arrays have the same shape or length.
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    Parameters
   323|         0|            0|            0|  0.00%|    ----------
   324|         0|            0|            0|  0.00%|    *arrays : list or tuple of input objects.
   325|         0|            0|            0|  0.00%|        Objects that will be checked for consistent length.
   326|         0|            0|            0|  0.00%|    """
   327|         0|            0|            0|  0.00%|
   328|        20|            0|            0|  0.00%|    lengths = [_num_samples(X) for X in arrays if X is not None]
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:253 _num_samples
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:328 <listcomp>
   329|         4|            0|            0|  0.00%|    uniques = np.unique(lengths)
(call)|         4|   0.00199437|  0.000498593|  0.01%|# <__array_function__ internals>:177 unique
   330|         4|            0|            0|  0.00%|    if len(uniques) > 1:
   331|         0|            0|            0|  0.00%|        raise ValueError(
   332|         0|            0|            0|  0.00%|            "Found input variables with inconsistent numbers of samples: %r"
   333|         0|            0|            0|  0.00%|            % [int(l) for l in lengths]
   334|         0|            0|            0|  0.00%|        )
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|def _make_indexable(iterable):
   338|         0|            0|            0|  0.00%|    """Ensure iterable supports indexing or convert to an indexable variant.
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|    Convert sparse matrices to csr and other non-indexable iterable to arrays.
   341|         0|            0|            0|  0.00%|    Let `None` and indexable objects (e.g. pandas dataframes) pass unchanged.
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    Parameters
   344|         0|            0|            0|  0.00%|    ----------
   345|         0|            0|            0|  0.00%|    iterable : {list, dataframe, ndarray, sparse matrix} or None
   346|         0|            0|            0|  0.00%|        Object to be converted to an indexable iterable.
   347|         0|            0|            0|  0.00%|    """
   348|         0|            0|            0|  0.00%|    if sp.issparse(iterable):
   349|         0|            0|            0|  0.00%|        return iterable.tocsr()
   350|         0|            0|            0|  0.00%|    elif hasattr(iterable, "__getitem__") or hasattr(iterable, "iloc"):
   351|         0|            0|            0|  0.00%|        return iterable
   352|         0|            0|            0|  0.00%|    elif iterable is None:
   353|         0|            0|            0|  0.00%|        return iterable
   354|         0|            0|            0|  0.00%|    return np.array(iterable)
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|def indexable(*iterables):
   358|         0|            0|            0|  0.00%|    """Make arrays indexable for cross-validation.
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|    Checks consistent length, passes through None, and ensures that everything
   361|         0|            0|            0|  0.00%|    can be indexed by converting sparse matrices to csr and converting
   362|         0|            0|            0|  0.00%|    non-interable objects to arrays.
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|    Parameters
   365|         0|            0|            0|  0.00%|    ----------
   366|         0|            0|            0|  0.00%|    *iterables : {lists, dataframes, ndarrays, sparse matrices}
   367|         0|            0|            0|  0.00%|        List of objects to ensure sliceability.
   368|         0|            0|            0|  0.00%|    """
   369|         0|            0|            0|  0.00%|    result = [_make_indexable(X) for X in iterables]
   370|         0|            0|            0|  0.00%|    check_consistent_length(*result)
   371|         0|            0|            0|  0.00%|    return result
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|
   374|         4|            0|            0|  0.00%|def _ensure_sparse_format(
   375|         0|            0|            0|  0.00%|    spmatrix, accept_sparse, dtype, copy, force_all_finite, accept_large_sparse
   376|         0|            0|            0|  0.00%|):
   377|         0|            0|            0|  0.00%|    """Convert a sparse matrix to a given format.
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|    Checks the sparse format of spmatrix and converts if necessary.
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    Parameters
   382|         0|            0|            0|  0.00%|    ----------
   383|         0|            0|            0|  0.00%|    spmatrix : sparse matrix
   384|         0|            0|            0|  0.00%|        Input to validate and convert.
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|    accept_sparse : str, bool or list/tuple of str
   387|         0|            0|            0|  0.00%|        String[s] representing allowed sparse matrix formats ('csc',
   388|         0|            0|            0|  0.00%|        'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'). If the input is sparse but
   389|         0|            0|            0|  0.00%|        not in the allowed format, it will be converted to the first listed
   390|         0|            0|            0|  0.00%|        format. True allows the input to be any format. False means
   391|         0|            0|            0|  0.00%|        that a sparse matrix input will raise an error.
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    dtype : str, type or None
   394|         0|            0|            0|  0.00%|        Data type of result. If None, the dtype of the input is preserved.
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|    copy : bool
   397|         0|            0|            0|  0.00%|        Whether a forced copy will be triggered. If copy=False, a copy might
   398|         0|            0|            0|  0.00%|        be triggered by a conversion.
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|    force_all_finite : bool or 'allow-nan'
   401|         0|            0|            0|  0.00%|        Whether to raise an error on np.inf, np.nan, pd.NA in X. The
   402|         0|            0|            0|  0.00%|        possibilities are:
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|        - True: Force all values of X to be finite.
   405|         0|            0|            0|  0.00%|        - False: accepts np.inf, np.nan, pd.NA in X.
   406|         0|            0|            0|  0.00%|        - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot
   407|         0|            0|            0|  0.00%|          be infinite.
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   410|         0|            0|            0|  0.00%|           ``force_all_finite`` accepts the string ``'allow-nan'``.
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|        .. versionchanged:: 0.23
   413|         0|            0|            0|  0.00%|           Accepts `pd.NA` and converts it into `np.nan`
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|    Returns
   416|         0|            0|            0|  0.00%|    -------
   417|         0|            0|            0|  0.00%|    spmatrix_converted : sparse matrix.
   418|         0|            0|            0|  0.00%|        Matrix that is ensured to have an allowed type.
   419|         0|            0|            0|  0.00%|    """
   420|         4|  0.000132322|  3.30806e-05|  0.00%|    if dtype is None:
   421|         0|            0|            0|  0.00%|        dtype = spmatrix.dtype
   422|         0|            0|            0|  0.00%|
   423|         4|            0|            0|  0.00%|    changed_format = False
   424|         0|            0|            0|  0.00%|
   425|         4|            0|            0|  0.00%|    if isinstance(accept_sparse, str):
   426|         0|            0|            0|  0.00%|        accept_sparse = [accept_sparse]
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|    # Indices dtype validation
   429|         4|            0|            0|  0.00%|    _check_large_sparse(spmatrix, accept_large_sparse)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:818 _check_large_sparse
   430|         0|            0|            0|  0.00%|
   431|         4|            0|            0|  0.00%|    if accept_sparse is False:
   432|         0|            0|            0|  0.00%|        raise TypeError(
   433|         0|            0|            0|  0.00%|            "A sparse matrix was passed, but dense "
   434|         0|            0|            0|  0.00%|            "data is required. Use X.toarray() to "
   435|         0|            0|            0|  0.00%|            "convert to a dense numpy array."
   436|         0|            0|            0|  0.00%|        )
   437|         4|            0|            0|  0.00%|    elif isinstance(accept_sparse, (list, tuple)):
   438|         4|            0|            0|  0.00%|        if len(accept_sparse) == 0:
   439|         0|            0|            0|  0.00%|            raise ValueError(
   440|         0|            0|            0|  0.00%|                "When providing 'accept_sparse' "
   441|         0|            0|            0|  0.00%|                "as a tuple or list, it must contain at "
   442|         0|            0|            0|  0.00%|                "least one string value."
   443|         0|            0|            0|  0.00%|            )
   444|         0|            0|            0|  0.00%|        # ensure correct sparse format
   445|         4|            0|            0|  0.00%|        if spmatrix.format not in accept_sparse:
   446|         0|            0|            0|  0.00%|            # create new with correct sparse
   447|         0|            0|            0|  0.00%|            spmatrix = spmatrix.asformat(accept_sparse[0])
   448|         0|            0|            0|  0.00%|            changed_format = True
   449|         0|            0|            0|  0.00%|    elif accept_sparse is not True:
   450|         0|            0|            0|  0.00%|        # any other type
   451|         0|            0|            0|  0.00%|        raise ValueError(
   452|         0|            0|            0|  0.00%|            "Parameter 'accept_sparse' should be a string, "
   453|         0|            0|            0|  0.00%|            "boolean or list of strings. You provided "
   454|         0|            0|            0|  0.00%|            "'accept_sparse={}'.".format(accept_sparse)
   455|         0|            0|            0|  0.00%|        )
   456|         0|            0|            0|  0.00%|
   457|         4|  0.000106812|  2.67029e-05|  0.00%|    if dtype != spmatrix.dtype:
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
   458|         0|            0|            0|  0.00%|        # convert dtype
   459|         4|            0|            0|  0.00%|        spmatrix = spmatrix.astype(dtype)
(call)|         4|   0.00199604|   0.00049901|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:68 astype
   460|         0|            0|            0|  0.00%|    elif copy and not changed_format:
   461|         0|            0|            0|  0.00%|        # force copy
   462|         0|            0|            0|  0.00%|        spmatrix = spmatrix.copy()
   463|         0|            0|            0|  0.00%|
   464|         4|            0|            0|  0.00%|    if force_all_finite:
   465|         4|            0|            0|  0.00%|        if not hasattr(spmatrix, "data"):
   466|         0|            0|            0|  0.00%|            warnings.warn(
   467|         0|            0|            0|  0.00%|                "Can't check %s sparse matrix for nan or inf." % spmatrix.format,
   468|         0|            0|            0|  0.00%|                stacklevel=2,
   469|         0|            0|            0|  0.00%|            )
   470|         0|            0|            0|  0.00%|        else:
   471|         4|            0|            0|  0.00%|            _assert_all_finite(spmatrix.data, allow_nan=force_all_finite == "allow-nan")
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:90 _assert_all_finite
   472|         0|            0|            0|  0.00%|
   473|         4|            0|            0|  0.00%|    return spmatrix
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|
   476|        12|            0|            0|  0.00%|def _ensure_no_complex_data(array):
   477|        24|            0|            0|  0.00%|    if (
   478|        12|            0|            0|  0.00%|        hasattr(array, "dtype")
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
   479|        12|            0|            0|  0.00%|        and array.dtype is not None
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
   480|        12|            0|            0|  0.00%|        and hasattr(array.dtype, "kind")
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
   481|        12|   0.00103664|   8.6387e-05|  0.00%|        and array.dtype.kind == "c"
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
   482|         0|            0|            0|  0.00%|    ):
   483|         0|            0|            0|  0.00%|        raise ValueError("Complex data not supported\n{}\n".format(array))
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|
   486|        12|            0|            0|  0.00%|def check_array(
   487|         0|            0|            0|  0.00%|    array,
   488|         0|            0|            0|  0.00%|    accept_sparse=False,
   489|         0|            0|            0|  0.00%|    *,
   490|         0|            0|            0|  0.00%|    accept_large_sparse=True,
   491|         0|            0|            0|  0.00%|    dtype="numeric",
   492|         0|            0|            0|  0.00%|    order=None,
   493|         0|            0|            0|  0.00%|    copy=False,
   494|         0|            0|            0|  0.00%|    force_all_finite=True,
   495|         0|            0|            0|  0.00%|    ensure_2d=True,
   496|         0|            0|            0|  0.00%|    allow_nd=False,
   497|         0|            0|            0|  0.00%|    ensure_min_samples=1,
   498|         0|            0|            0|  0.00%|    ensure_min_features=1,
   499|         0|            0|            0|  0.00%|    estimator=None,
   500|         0|            0|            0|  0.00%|):
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    """Input validation on an array, list, sparse matrix or similar.
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    By default, the input is checked to be a non-empty 2D array containing
   505|         0|            0|            0|  0.00%|    only finite values. If the dtype of the array is object, attempt
   506|         0|            0|            0|  0.00%|    converting to float, raising on failure.
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|    Parameters
   509|         0|            0|            0|  0.00%|    ----------
   510|         0|            0|            0|  0.00%|    array : object
   511|         0|            0|            0|  0.00%|        Input object to check / convert.
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|    accept_sparse : str, bool or list/tuple of str, default=False
   514|         0|            0|            0|  0.00%|        String[s] representing allowed sparse matrix formats, such as 'csc',
   515|         0|            0|            0|  0.00%|        'csr', etc. If the input is sparse but not in the allowed format,
   516|         0|            0|            0|  0.00%|        it will be converted to the first listed format. True allows the input
   517|         0|            0|            0|  0.00%|        to be any format. False means that a sparse matrix input will
   518|         0|            0|            0|  0.00%|        raise an error.
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|    accept_large_sparse : bool, default=True
   521|         0|            0|            0|  0.00%|        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
   522|         0|            0|            0|  0.00%|        accept_sparse, accept_large_sparse=False will cause it to be accepted
   523|         0|            0|            0|  0.00%|        only if its indices are stored with a 32-bit dtype.
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|    dtype : 'numeric', type, list of type or None, default='numeric'
   528|         0|            0|            0|  0.00%|        Data type of result. If None, the dtype of the input is preserved.
   529|         0|            0|            0|  0.00%|        If "numeric", dtype is preserved unless array.dtype is object.
   530|         0|            0|            0|  0.00%|        If dtype is a list of types, conversion on the first type is only
   531|         0|            0|            0|  0.00%|        performed if the dtype of the input is not in the list.
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|    order : {'F', 'C'} or None, default=None
   534|         0|            0|            0|  0.00%|        Whether an array will be forced to be fortran or c-style.
   535|         0|            0|            0|  0.00%|        When order is None (default), then if copy=False, nothing is ensured
   536|         0|            0|            0|  0.00%|        about the memory layout of the output array; otherwise (copy=True)
   537|         0|            0|            0|  0.00%|        the memory layout of the returned array is kept as close as possible
   538|         0|            0|            0|  0.00%|        to the original array.
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|    copy : bool, default=False
   541|         0|            0|            0|  0.00%|        Whether a forced copy will be triggered. If copy=False, a copy might
   542|         0|            0|            0|  0.00%|        be triggered by a conversion.
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|    force_all_finite : bool or 'allow-nan', default=True
   545|         0|            0|            0|  0.00%|        Whether to raise an error on np.inf, np.nan, pd.NA in array. The
   546|         0|            0|            0|  0.00%|        possibilities are:
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|        - True: Force all values of array to be finite.
   549|         0|            0|            0|  0.00%|        - False: accepts np.inf, np.nan, pd.NA in array.
   550|         0|            0|            0|  0.00%|        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
   551|         0|            0|            0|  0.00%|          cannot be infinite.
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   554|         0|            0|            0|  0.00%|           ``force_all_finite`` accepts the string ``'allow-nan'``.
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|        .. versionchanged:: 0.23
   557|         0|            0|            0|  0.00%|           Accepts `pd.NA` and converts it into `np.nan`
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|    ensure_2d : bool, default=True
   560|         0|            0|            0|  0.00%|        Whether to raise a value error if array is not 2D.
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    allow_nd : bool, default=False
   563|         0|            0|            0|  0.00%|        Whether to allow array.ndim > 2.
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|    ensure_min_samples : int, default=1
   566|         0|            0|            0|  0.00%|        Make sure that the array has a minimum number of samples in its first
   567|         0|            0|            0|  0.00%|        axis (rows for a 2D array). Setting to 0 disables this check.
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|    ensure_min_features : int, default=1
   570|         0|            0|            0|  0.00%|        Make sure that the 2D array has some minimum number of features
   571|         0|            0|            0|  0.00%|        (columns). The default value of 1 rejects empty datasets.
   572|         0|            0|            0|  0.00%|        This check is only enforced when the input data has effectively 2
   573|         0|            0|            0|  0.00%|        dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0
   574|         0|            0|            0|  0.00%|        disables this check.
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|    estimator : str or estimator instance, default=None
   577|         0|            0|            0|  0.00%|        If passed, include the name of the estimator in warning messages.
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    Returns
   580|         0|            0|            0|  0.00%|    -------
   581|         0|            0|            0|  0.00%|    array_converted : object
   582|         0|            0|            0|  0.00%|        The converted and validated array.
   583|         0|            0|            0|  0.00%|    """
   584|        12|            0|            0|  0.00%|    if isinstance(array, np.matrix):
   585|         0|            0|            0|  0.00%|        warnings.warn(
   586|         0|            0|            0|  0.00%|            "np.matrix usage is deprecated in 1.0 and will raise a TypeError "
   587|         0|            0|            0|  0.00%|            "in 1.2. Please convert to a numpy array with np.asarray. For "
   588|         0|            0|            0|  0.00%|            "more information see: "
   589|         0|            0|            0|  0.00%|            "https://numpy.org/doc/stable/reference/generated/numpy.matrix.html",  # noqa
   590|         0|            0|            0|  0.00%|            FutureWarning,
   591|         0|            0|            0|  0.00%|        )
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    # store reference to original array to check if copy is needed when
   594|         0|            0|            0|  0.00%|    # function returns
   595|        12|            0|            0|  0.00%|    array_orig = array
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    # store whether originally we wanted numeric dtype
   598|        12|            0|            0|  0.00%|    dtype_numeric = isinstance(dtype, str) and dtype == "numeric"
   599|         0|            0|            0|  0.00%|
   600|        12|            0|            0|  0.00%|    dtype_orig = getattr(array, "dtype", None)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
   601|        12|            0|            0|  0.00%|    if not hasattr(dtype_orig, "kind"):
   602|         0|            0|            0|  0.00%|        # not a data type (e.g. a column named dtype in a pandas DataFrame)
   603|         8|            0|            0|  0.00%|        dtype_orig = None
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|    # check if the object contains several dtypes (typically a pandas
   606|         0|            0|            0|  0.00%|    # DataFrame), and store them. If not, store None.
   607|        12|            0|            0|  0.00%|    dtypes_orig = None
   608|        12|            0|            0|  0.00%|    has_pd_integer_array = False
   609|        12|            0|            0|  0.00%|    if hasattr(array, "dtypes") and hasattr(array.dtypes, "__array__"):
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:673 __getattr__
   610|         0|            0|            0|  0.00%|        # throw warning if columns are sparse. If all columns are sparse, then
   611|         0|            0|            0|  0.00%|        # array.sparse exists and sparsity will be preserved (later).
   612|         0|            0|            0|  0.00%|        with suppress(ImportError):
   613|         0|            0|            0|  0.00%|            from pandas.api.types import is_sparse
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|            if not hasattr(array, "sparse") and array.dtypes.apply(is_sparse).any():
   616|         0|            0|            0|  0.00%|                warnings.warn(
   617|         0|            0|            0|  0.00%|                    "pandas.DataFrame with sparse columns found."
   618|         0|            0|            0|  0.00%|                    "It will be converted to a dense numpy array."
   619|         0|            0|            0|  0.00%|                )
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|        dtypes_orig = list(array.dtypes)
   622|         0|            0|            0|  0.00%|        # pandas boolean dtype __array__ interface coerces bools to objects
   623|         0|            0|            0|  0.00%|        for i, dtype_iter in enumerate(dtypes_orig):
   624|         0|            0|            0|  0.00%|            if dtype_iter.kind == "b":
   625|         0|            0|            0|  0.00%|                dtypes_orig[i] = np.dtype(object)
   626|         0|            0|            0|  0.00%|            elif dtype_iter.name.startswith(("Int", "UInt")):
   627|         0|            0|            0|  0.00%|                # name looks like an Integer Extension Array, now check for
   628|         0|            0|            0|  0.00%|                # the dtype
   629|         0|            0|            0|  0.00%|                with suppress(ImportError):
   630|         0|            0|            0|  0.00%|                    from pandas import (
   631|         0|            0|            0|  0.00%|                        Int8Dtype,
   632|         0|            0|            0|  0.00%|                        Int16Dtype,
   633|         0|            0|            0|  0.00%|                        Int32Dtype,
   634|         0|            0|            0|  0.00%|                        Int64Dtype,
   635|         0|            0|            0|  0.00%|                        UInt8Dtype,
   636|         0|            0|            0|  0.00%|                        UInt16Dtype,
   637|         0|            0|            0|  0.00%|                        UInt32Dtype,
   638|         0|            0|            0|  0.00%|                        UInt64Dtype,
   639|         0|            0|            0|  0.00%|                    )
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|                    if isinstance(
   642|         0|            0|            0|  0.00%|                        dtype_iter,
   643|         0|            0|            0|  0.00%|                        (
   644|         0|            0|            0|  0.00%|                            Int8Dtype,
   645|         0|            0|            0|  0.00%|                            Int16Dtype,
   646|         0|            0|            0|  0.00%|                            Int32Dtype,
   647|         0|            0|            0|  0.00%|                            Int64Dtype,
   648|         0|            0|            0|  0.00%|                            UInt8Dtype,
   649|         0|            0|            0|  0.00%|                            UInt16Dtype,
   650|         0|            0|            0|  0.00%|                            UInt32Dtype,
   651|         0|            0|            0|  0.00%|                            UInt64Dtype,
   652|         0|            0|            0|  0.00%|                        ),
   653|         0|            0|            0|  0.00%|                    ):
   654|         0|            0|            0|  0.00%|                        has_pd_integer_array = True
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|        if all(isinstance(dtype, np.dtype) for dtype in dtypes_orig):
   657|         0|            0|            0|  0.00%|            dtype_orig = np.result_type(*dtypes_orig)
   658|         0|            0|            0|  0.00%|
   659|        12|            0|            0|  0.00%|    if dtype_numeric:
   660|         0|            0|            0|  0.00%|        if dtype_orig is not None and dtype_orig.kind == "O":
   661|         0|            0|            0|  0.00%|            # if input is object, convert to float.
   662|         0|            0|            0|  0.00%|            dtype = np.float64
   663|         0|            0|            0|  0.00%|        else:
   664|         0|            0|            0|  0.00%|            dtype = None
   665|         0|            0|            0|  0.00%|
   666|        12|            0|            0|  0.00%|    if isinstance(dtype, (list, tuple)):
   667|         4|            0|            0|  0.00%|        if dtype_orig is not None and dtype_orig in dtype:
   668|         0|            0|            0|  0.00%|            # no dtype conversion required
   669|         0|            0|            0|  0.00%|            dtype = None
   670|         0|            0|            0|  0.00%|        else:
   671|         0|            0|            0|  0.00%|            # dtype conversion required. Let's select the first element of the
   672|         0|            0|            0|  0.00%|            # list of accepted types.
   673|         4|            0|            0|  0.00%|            dtype = dtype[0]
   674|         0|            0|            0|  0.00%|
   675|        12|            0|            0|  0.00%|    if has_pd_integer_array:
   676|         0|            0|            0|  0.00%|        # If there are any pandas integer extension arrays,
   677|         0|            0|            0|  0.00%|        array = array.astype(dtype)
   678|         0|            0|            0|  0.00%|
   679|        12|            0|            0|  0.00%|    if force_all_finite not in (True, False, "allow-nan"):
   680|         0|            0|            0|  0.00%|        raise ValueError(
   681|         0|            0|            0|  0.00%|            'force_all_finite should be a bool or "allow-nan". Got {!r} instead'.format(
   682|         0|            0|            0|  0.00%|                force_all_finite
   683|         0|            0|            0|  0.00%|            )
   684|         0|            0|            0|  0.00%|        )
   685|         0|            0|            0|  0.00%|
   686|        12|            0|            0|  0.00%|    if estimator is not None:
   687|         0|            0|            0|  0.00%|        if isinstance(estimator, str):
   688|         0|            0|            0|  0.00%|            estimator_name = estimator
   689|         0|            0|            0|  0.00%|        else:
   690|         0|            0|            0|  0.00%|            estimator_name = estimator.__class__.__name__
   691|         0|            0|            0|  0.00%|    else:
   692|        12|            0|            0|  0.00%|        estimator_name = "Estimator"
   693|        12|            0|            0|  0.00%|    context = " by %s" % estimator_name if estimator is not None else ""
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|    # When all dataframe columns are sparse, convert to a sparse array
   696|        12|            0|            0|  0.00%|    if hasattr(array, "sparse") and array.ndim > 1:
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:673 __getattr__
   697|         0|            0|            0|  0.00%|        # DataFrame.sparse only supports `to_coo`
   698|         0|            0|            0|  0.00%|        array = array.sparse.to_coo()
   699|         0|            0|            0|  0.00%|        if array.dtype == np.dtype("object"):
   700|         0|            0|            0|  0.00%|            unique_dtypes = set([dt.subtype.name for dt in array_orig.dtypes])
   701|         0|            0|            0|  0.00%|            if len(unique_dtypes) > 1:
   702|         0|            0|            0|  0.00%|                raise ValueError(
   703|         0|            0|            0|  0.00%|                    "Pandas DataFrame with mixed sparse extension arrays "
   704|         0|            0|            0|  0.00%|                    "generated a sparse matrix with object dtype which "
   705|         0|            0|            0|  0.00%|                    "can not be converted to a scipy sparse matrix."
   706|         0|            0|            0|  0.00%|                    "Sparse extension arrays should all have the same "
   707|         0|            0|            0|  0.00%|                    "numeric type."
   708|         0|            0|            0|  0.00%|                )
   709|         0|            0|            0|  0.00%|
   710|        12|  0.000995636|  8.29697e-05|  0.00%|    if sp.issparse(array):
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:1205 isspmatrix
   711|         4|  0.000997066|  0.000249267|  0.00%|        _ensure_no_complex_data(array)
(call)|         4|   0.00103664|  0.000259161|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:476 _ensure_no_complex_data
   712|         8|            0|            0|  0.00%|        array = _ensure_sparse_format(
(call)|         4|   0.00223517|  0.000558794|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:374 _ensure_sparse_format
   713|         4|            0|            0|  0.00%|            array,
   714|         4|            0|            0|  0.00%|            accept_sparse=accept_sparse,
   715|         4|            0|            0|  0.00%|            dtype=dtype,
   716|         4|            0|            0|  0.00%|            copy=copy,
   717|         4|            0|            0|  0.00%|            force_all_finite=force_all_finite,
   718|         4|            0|            0|  0.00%|            accept_large_sparse=accept_large_sparse,
   719|         0|            0|            0|  0.00%|        )
   720|         0|            0|            0|  0.00%|    else:
   721|         0|            0|            0|  0.00%|        # If np.array(..) gives ComplexWarning, then we convert the warning
   722|         0|            0|            0|  0.00%|        # to an error. This is needed because specifying a non complex
   723|         0|            0|            0|  0.00%|        # dtype to the function converts complex to real dtype,
   724|         0|            0|            0|  0.00%|        # thereby passing the test made in the lines following the scope
   725|         0|            0|            0|  0.00%|        # of warnings context manager.
   726|         8|            0|            0|  0.00%|        with warnings.catch_warnings():
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:441 __init__
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:462 __enter__
   727|         8|            0|            0|  0.00%|            try:
   728|         8|            0|            0|  0.00%|                warnings.simplefilter("error", ComplexWarning)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:165 simplefilter
   729|         8|            0|            0|  0.00%|                if dtype is not None and np.dtype(dtype).kind in "iu":
   730|         0|            0|            0|  0.00%|                    # Conversion float -> int should not contain NaN or
   731|         0|            0|            0|  0.00%|                    # inf (numpy#14412). We cannot use casting='safe' because
   732|         0|            0|            0|  0.00%|                    # then conversion float -> int would be disallowed.
   733|         0|            0|            0|  0.00%|                    array = np.asarray(array, order=order)
   734|         0|            0|            0|  0.00%|                    if array.dtype.kind == "f":
   735|         0|            0|            0|  0.00%|                        _assert_all_finite(array, allow_nan=False, msg_dtype=dtype)
   736|         0|            0|            0|  0.00%|                    array = array.astype(dtype, casting="unsafe", copy=False)
   737|         0|            0|            0|  0.00%|                else:
   738|         8|            0|            0|  0.00%|                    array = np.asarray(array, order=order, dtype=dtype)
(call)|         8|  0.000997543|  0.000124693|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:481 __exit__
   739|         0|            0|            0|  0.00%|            except ComplexWarning as complex_warning:
   740|         0|            0|            0|  0.00%|                raise ValueError(
   741|         0|            0|            0|  0.00%|                    "Complex data not supported\n{}\n".format(array)
   742|         0|            0|            0|  0.00%|                ) from complex_warning
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|        # It is possible that the np.array(..) gave no warning. This happens
   745|         0|            0|            0|  0.00%|        # when no dtype conversion happened, for example dtype = None. The
   746|         0|            0|            0|  0.00%|        # result is that np.array(..) produces an array of complex dtype
   747|         0|            0|            0|  0.00%|        # and we need to catch and raise exception for such cases.
   748|         8|            0|            0|  0.00%|        _ensure_no_complex_data(array)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:476 _ensure_no_complex_data
   749|         0|            0|            0|  0.00%|
   750|         8|            0|            0|  0.00%|        if ensure_2d:
   751|         0|            0|            0|  0.00%|            # If input is scalar raise error
   752|         0|            0|            0|  0.00%|            if array.ndim == 0:
   753|         0|            0|            0|  0.00%|                raise ValueError(
   754|         0|            0|            0|  0.00%|                    "Expected 2D array, got scalar array instead:\narray={}.\n"
   755|         0|            0|            0|  0.00%|                    "Reshape your data either using array.reshape(-1, 1) if "
   756|         0|            0|            0|  0.00%|                    "your data has a single feature or array.reshape(1, -1) "
   757|         0|            0|            0|  0.00%|                    "if it contains a single sample.".format(array)
   758|         0|            0|            0|  0.00%|                )
   759|         0|            0|            0|  0.00%|            # If input is 1D raise error
   760|         0|            0|            0|  0.00%|            if array.ndim == 1:
   761|         0|            0|            0|  0.00%|                raise ValueError(
   762|         0|            0|            0|  0.00%|                    "Expected 2D array, got 1D array instead:\narray={}.\n"
   763|         0|            0|            0|  0.00%|                    "Reshape your data either using array.reshape(-1, 1) if "
   764|         0|            0|            0|  0.00%|                    "your data has a single feature or array.reshape(1, -1) "
   765|         0|            0|            0|  0.00%|                    "if it contains a single sample.".format(array)
   766|         0|            0|            0|  0.00%|                )
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|        # make sure we actually converted to numeric:
   769|         8|            0|            0|  0.00%|        if dtype_numeric and array.dtype.kind in "OUSV":
   770|         0|            0|            0|  0.00%|            warnings.warn(
   771|         0|            0|            0|  0.00%|                "Arrays of bytes/strings is being converted to decimal "
   772|         0|            0|            0|  0.00%|                "numbers if dtype='numeric'. This behavior is deprecated in "
   773|         0|            0|            0|  0.00%|                "0.24 and will be removed in 1.1 (renaming of 0.26). Please "
   774|         0|            0|            0|  0.00%|                "convert your data to numeric values explicitly instead.",
   775|         0|            0|            0|  0.00%|                FutureWarning,
   776|         0|            0|            0|  0.00%|                stacklevel=2,
   777|         0|            0|            0|  0.00%|            )
   778|         0|            0|            0|  0.00%|            try:
   779|         0|            0|            0|  0.00%|                array = array.astype(np.float64)
   780|         0|            0|            0|  0.00%|            except ValueError as e:
   781|         0|            0|            0|  0.00%|                raise ValueError(
   782|         0|            0|            0|  0.00%|                    "Unable to convert array of bytes/strings "
   783|         0|            0|            0|  0.00%|                    "into decimal numbers with dtype='numeric'"
   784|         0|            0|            0|  0.00%|                ) from e
   785|         8|            0|            0|  0.00%|        if not allow_nd and array.ndim >= 3:
   786|         0|            0|            0|  0.00%|            raise ValueError(
   787|         0|            0|            0|  0.00%|                "Found array with dim %d. %s expected <= 2."
   788|         0|            0|            0|  0.00%|                % (array.ndim, estimator_name)
   789|         0|            0|            0|  0.00%|            )
   790|         0|            0|            0|  0.00%|
   791|         8|            0|            0|  0.00%|        if force_all_finite:
   792|         8|            0|            0|  0.00%|            _assert_all_finite(array, allow_nan=force_all_finite == "allow-nan")
(call)|         8|  0.000997066|  0.000124633|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:90 _assert_all_finite
   793|         0|            0|            0|  0.00%|
   794|        12|            0|            0|  0.00%|    if ensure_min_samples > 0:
   795|         4|            0|            0|  0.00%|        n_samples = _num_samples(array)
(call)|         4|  0.000997305|  0.000249326|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:253 _num_samples
   796|         4|            0|            0|  0.00%|        if n_samples < ensure_min_samples:
   797|         0|            0|            0|  0.00%|            raise ValueError(
   798|         0|            0|            0|  0.00%|                "Found array with %d sample(s) (shape=%s) while a"
   799|         0|            0|            0|  0.00%|                " minimum of %d is required%s."
   800|         0|            0|            0|  0.00%|                % (n_samples, array.shape, ensure_min_samples, context)
   801|         0|            0|            0|  0.00%|            )
   802|         0|            0|            0|  0.00%|
   803|        12|            0|            0|  0.00%|    if ensure_min_features > 0 and array.ndim == 2:
   804|         4|            0|            0|  0.00%|        n_features = array.shape[1]
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   805|         4|            0|            0|  0.00%|        if n_features < ensure_min_features:
   806|         0|            0|            0|  0.00%|            raise ValueError(
   807|         0|            0|            0|  0.00%|                "Found array with %d feature(s) (shape=%s) while"
   808|         0|            0|            0|  0.00%|                " a minimum of %d is required%s."
   809|         0|            0|            0|  0.00%|                % (n_features, array.shape, ensure_min_features, context)
   810|         0|            0|            0|  0.00%|            )
   811|         0|            0|            0|  0.00%|
   812|        12|            0|            0|  0.00%|    if copy and np.may_share_memory(array, array_orig):
   813|         0|            0|            0|  0.00%|        array = np.array(array, dtype=dtype, order=order)
   814|         0|            0|            0|  0.00%|
   815|        12|            0|            0|  0.00%|    return array
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|
   818|         4|            0|            0|  0.00%|def _check_large_sparse(X, accept_large_sparse=False):
   819|         0|            0|            0|  0.00%|    """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
   820|         4|            0|            0|  0.00%|    if not accept_large_sparse:
   821|         0|            0|            0|  0.00%|        supported_indices = ["int32"]
   822|         0|            0|            0|  0.00%|        if X.getformat() == "coo":
   823|         0|            0|            0|  0.00%|            index_keys = ["col", "row"]
   824|         0|            0|            0|  0.00%|        elif X.getformat() in ["csr", "csc", "bsr"]:
   825|         0|            0|            0|  0.00%|            index_keys = ["indices", "indptr"]
   826|         0|            0|            0|  0.00%|        else:
   827|         0|            0|            0|  0.00%|            return
   828|         0|            0|            0|  0.00%|        for key in index_keys:
   829|         0|            0|            0|  0.00%|            indices_datatype = getattr(X, key).dtype
   830|         0|            0|            0|  0.00%|            if indices_datatype not in supported_indices:
   831|         0|            0|            0|  0.00%|                raise ValueError(
   832|         0|            0|            0|  0.00%|                    "Only sparse matrices with 32-bit integer"
   833|         0|            0|            0|  0.00%|                    " indices are accepted. Got %s indices." % indices_datatype
   834|         0|            0|            0|  0.00%|                )
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|
   837|         0|            0|            0|  0.00%|def check_X_y(
   838|         0|            0|            0|  0.00%|    X,
   839|         0|            0|            0|  0.00%|    y,
   840|         0|            0|            0|  0.00%|    accept_sparse=False,
   841|         0|            0|            0|  0.00%|    *,
   842|         0|            0|            0|  0.00%|    accept_large_sparse=True,
   843|         0|            0|            0|  0.00%|    dtype="numeric",
   844|         0|            0|            0|  0.00%|    order=None,
   845|         0|            0|            0|  0.00%|    copy=False,
   846|         0|            0|            0|  0.00%|    force_all_finite=True,
   847|         0|            0|            0|  0.00%|    ensure_2d=True,
   848|         0|            0|            0|  0.00%|    allow_nd=False,
   849|         0|            0|            0|  0.00%|    multi_output=False,
   850|         0|            0|            0|  0.00%|    ensure_min_samples=1,
   851|         0|            0|            0|  0.00%|    ensure_min_features=1,
   852|         0|            0|            0|  0.00%|    y_numeric=False,
   853|         0|            0|            0|  0.00%|    estimator=None,
   854|         0|            0|            0|  0.00%|):
   855|         0|            0|            0|  0.00%|    """Input validation for standard estimators.
   856|         0|            0|            0|  0.00%|
   857|         0|            0|            0|  0.00%|    Checks X and y for consistent length, enforces X to be 2D and y 1D. By
   858|         0|            0|            0|  0.00%|    default, X is checked to be non-empty and containing only finite values.
   859|         0|            0|            0|  0.00%|    Standard input checks are also applied to y, such as checking that y
   860|         0|            0|            0|  0.00%|    does not have np.nan or np.inf targets. For multi-label y, set
   861|         0|            0|            0|  0.00%|    multi_output=True to allow 2D and sparse y. If the dtype of X is
   862|         0|            0|            0|  0.00%|    object, attempt converting to float, raising on failure.
   863|         0|            0|            0|  0.00%|
   864|         0|            0|            0|  0.00%|    Parameters
   865|         0|            0|            0|  0.00%|    ----------
   866|         0|            0|            0|  0.00%|    X : {ndarray, list, sparse matrix}
   867|         0|            0|            0|  0.00%|        Input data.
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|    y : {ndarray, list, sparse matrix}
   870|         0|            0|            0|  0.00%|        Labels.
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|    accept_sparse : str, bool or list of str, default=False
   873|         0|            0|            0|  0.00%|        String[s] representing allowed sparse matrix formats, such as 'csc',
   874|         0|            0|            0|  0.00%|        'csr', etc. If the input is sparse but not in the allowed format,
   875|         0|            0|            0|  0.00%|        it will be converted to the first listed format. True allows the input
   876|         0|            0|            0|  0.00%|        to be any format. False means that a sparse matrix input will
   877|         0|            0|            0|  0.00%|        raise an error.
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|    accept_large_sparse : bool, default=True
   880|         0|            0|            0|  0.00%|        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
   881|         0|            0|            0|  0.00%|        accept_sparse, accept_large_sparse will cause it to be accepted only
   882|         0|            0|            0|  0.00%|        if its indices are stored with a 32-bit dtype.
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|    dtype : 'numeric', type, list of type or None, default='numeric'
   887|         0|            0|            0|  0.00%|        Data type of result. If None, the dtype of the input is preserved.
   888|         0|            0|            0|  0.00%|        If "numeric", dtype is preserved unless array.dtype is object.
   889|         0|            0|            0|  0.00%|        If dtype is a list of types, conversion on the first type is only
   890|         0|            0|            0|  0.00%|        performed if the dtype of the input is not in the list.
   891|         0|            0|            0|  0.00%|
   892|         0|            0|            0|  0.00%|    order : {'F', 'C'}, default=None
   893|         0|            0|            0|  0.00%|        Whether an array will be forced to be fortran or c-style.
   894|         0|            0|            0|  0.00%|
   895|         0|            0|            0|  0.00%|    copy : bool, default=False
   896|         0|            0|            0|  0.00%|        Whether a forced copy will be triggered. If copy=False, a copy might
   897|         0|            0|            0|  0.00%|        be triggered by a conversion.
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|    force_all_finite : bool or 'allow-nan', default=True
   900|         0|            0|            0|  0.00%|        Whether to raise an error on np.inf, np.nan, pd.NA in X. This parameter
   901|         0|            0|            0|  0.00%|        does not influence whether y can have np.inf, np.nan, pd.NA values.
   902|         0|            0|            0|  0.00%|        The possibilities are:
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|        - True: Force all values of X to be finite.
   905|         0|            0|            0|  0.00%|        - False: accepts np.inf, np.nan, pd.NA in X.
   906|         0|            0|            0|  0.00%|        - 'allow-nan': accepts only np.nan or pd.NA values in X. Values cannot
   907|         0|            0|            0|  0.00%|          be infinite.
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   910|         0|            0|            0|  0.00%|           ``force_all_finite`` accepts the string ``'allow-nan'``.
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|        .. versionchanged:: 0.23
   913|         0|            0|            0|  0.00%|           Accepts `pd.NA` and converts it into `np.nan`
   914|         0|            0|            0|  0.00%|
   915|         0|            0|            0|  0.00%|    ensure_2d : bool, default=True
   916|         0|            0|            0|  0.00%|        Whether to raise a value error if X is not 2D.
   917|         0|            0|            0|  0.00%|
   918|         0|            0|            0|  0.00%|    allow_nd : bool, default=False
   919|         0|            0|            0|  0.00%|        Whether to allow X.ndim > 2.
   920|         0|            0|            0|  0.00%|
   921|         0|            0|            0|  0.00%|    multi_output : bool, default=False
   922|         0|            0|            0|  0.00%|        Whether to allow 2D y (array or sparse matrix). If false, y will be
   923|         0|            0|            0|  0.00%|        validated as a vector. y cannot have np.nan or np.inf values if
   924|         0|            0|            0|  0.00%|        multi_output=True.
   925|         0|            0|            0|  0.00%|
   926|         0|            0|            0|  0.00%|    ensure_min_samples : int, default=1
   927|         0|            0|            0|  0.00%|        Make sure that X has a minimum number of samples in its first
   928|         0|            0|            0|  0.00%|        axis (rows for a 2D array).
   929|         0|            0|            0|  0.00%|
   930|         0|            0|            0|  0.00%|    ensure_min_features : int, default=1
   931|         0|            0|            0|  0.00%|        Make sure that the 2D array has some minimum number of features
   932|         0|            0|            0|  0.00%|        (columns). The default value of 1 rejects empty datasets.
   933|         0|            0|            0|  0.00%|        This check is only enforced when X has effectively 2 dimensions or
   934|         0|            0|            0|  0.00%|        is originally 1D and ``ensure_2d`` is True. Setting to 0 disables
   935|         0|            0|            0|  0.00%|        this check.
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|    y_numeric : bool, default=False
   938|         0|            0|            0|  0.00%|        Whether to ensure that y has a numeric type. If dtype of y is object,
   939|         0|            0|            0|  0.00%|        it is converted to float64. Should only be used for regression
   940|         0|            0|            0|  0.00%|        algorithms.
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|    estimator : str or estimator instance, default=None
   943|         0|            0|            0|  0.00%|        If passed, include the name of the estimator in warning messages.
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|    Returns
   946|         0|            0|            0|  0.00%|    -------
   947|         0|            0|            0|  0.00%|    X_converted : object
   948|         0|            0|            0|  0.00%|        The converted and validated X.
   949|         0|            0|            0|  0.00%|
   950|         0|            0|            0|  0.00%|    y_converted : object
   951|         0|            0|            0|  0.00%|        The converted and validated y.
   952|         0|            0|            0|  0.00%|    """
   953|         0|            0|            0|  0.00%|    if y is None:
   954|         0|            0|            0|  0.00%|        raise ValueError("y cannot be None")
   955|         0|            0|            0|  0.00%|
   956|         0|            0|            0|  0.00%|    X = check_array(
   957|         0|            0|            0|  0.00%|        X,
   958|         0|            0|            0|  0.00%|        accept_sparse=accept_sparse,
   959|         0|            0|            0|  0.00%|        accept_large_sparse=accept_large_sparse,
   960|         0|            0|            0|  0.00%|        dtype=dtype,
   961|         0|            0|            0|  0.00%|        order=order,
   962|         0|            0|            0|  0.00%|        copy=copy,
   963|         0|            0|            0|  0.00%|        force_all_finite=force_all_finite,
   964|         0|            0|            0|  0.00%|        ensure_2d=ensure_2d,
   965|         0|            0|            0|  0.00%|        allow_nd=allow_nd,
   966|         0|            0|            0|  0.00%|        ensure_min_samples=ensure_min_samples,
   967|         0|            0|            0|  0.00%|        ensure_min_features=ensure_min_features,
   968|         0|            0|            0|  0.00%|        estimator=estimator,
   969|         0|            0|            0|  0.00%|    )
   970|         0|            0|            0|  0.00%|
   971|         0|            0|            0|  0.00%|    y = _check_y(y, multi_output=multi_output, y_numeric=y_numeric)
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|    check_consistent_length(X, y)
   974|         0|            0|            0|  0.00%|
   975|         0|            0|            0|  0.00%|    return X, y
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|def _check_y(y, multi_output=False, y_numeric=False):
   979|         0|            0|            0|  0.00%|    """Isolated part of check_X_y dedicated to y validation"""
   980|         0|            0|            0|  0.00%|    if multi_output:
   981|         0|            0|            0|  0.00%|        y = check_array(
   982|         0|            0|            0|  0.00%|            y, accept_sparse="csr", force_all_finite=True, ensure_2d=False, dtype=None
   983|         0|            0|            0|  0.00%|        )
   984|         0|            0|            0|  0.00%|    else:
   985|         0|            0|            0|  0.00%|        y = column_or_1d(y, warn=True)
   986|         0|            0|            0|  0.00%|        _assert_all_finite(y)
   987|         0|            0|            0|  0.00%|        _ensure_no_complex_data(y)
   988|         0|            0|            0|  0.00%|    if y_numeric and y.dtype.kind == "O":
   989|         0|            0|            0|  0.00%|        y = y.astype(np.float64)
   990|         0|            0|            0|  0.00%|
   991|         0|            0|            0|  0.00%|    return y
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|
   994|         0|            0|            0|  0.00%|def column_or_1d(y, *, warn=False):
   995|         0|            0|            0|  0.00%|    """Ravel column or 1d numpy array, else raises an error.
   996|         0|            0|            0|  0.00%|
   997|         0|            0|            0|  0.00%|    Parameters
   998|         0|            0|            0|  0.00%|    ----------
   999|         0|            0|            0|  0.00%|    y : array-like
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|    warn : bool, default=False
  1002|         0|            0|            0|  0.00%|       To control display of warnings.
  1003|         0|            0|            0|  0.00%|
  1004|         0|            0|            0|  0.00%|    Returns
  1005|         0|            0|            0|  0.00%|    -------
  1006|         0|            0|            0|  0.00%|    y : ndarray
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|    """
  1009|         0|            0|            0|  0.00%|    y = np.asarray(y)
  1010|         0|            0|            0|  0.00%|    shape = np.shape(y)
  1011|         0|            0|            0|  0.00%|    if len(shape) == 1:
  1012|         0|            0|            0|  0.00%|        return np.ravel(y)
  1013|         0|            0|            0|  0.00%|    if len(shape) == 2 and shape[1] == 1:
  1014|         0|            0|            0|  0.00%|        if warn:
  1015|         0|            0|            0|  0.00%|            warnings.warn(
  1016|         0|            0|            0|  0.00%|                "A column-vector y was passed when a 1d array was"
  1017|         0|            0|            0|  0.00%|                " expected. Please change the shape of y to "
  1018|         0|            0|            0|  0.00%|                "(n_samples, ), for example using ravel().",
  1019|         0|            0|            0|  0.00%|                DataConversionWarning,
  1020|         0|            0|            0|  0.00%|                stacklevel=2,
  1021|         0|            0|            0|  0.00%|            )
  1022|         0|            0|            0|  0.00%|        return np.ravel(y)
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|    raise ValueError(
  1025|         0|            0|            0|  0.00%|        "y should be a 1d array, got an array of shape {} instead.".format(shape)
  1026|         0|            0|            0|  0.00%|    )
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|
  1029|         0|            0|            0|  0.00%|def check_random_state(seed):
  1030|         0|            0|            0|  0.00%|    """Turn seed into a np.random.RandomState instance
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|    Parameters
  1033|         0|            0|            0|  0.00%|    ----------
  1034|         0|            0|            0|  0.00%|    seed : None, int or instance of RandomState
  1035|         0|            0|            0|  0.00%|        If seed is None, return the RandomState singleton used by np.random.
  1036|         0|            0|            0|  0.00%|        If seed is an int, return a new RandomState instance seeded with seed.
  1037|         0|            0|            0|  0.00%|        If seed is already a RandomState instance, return it.
  1038|         0|            0|            0|  0.00%|        Otherwise raise ValueError.
  1039|         0|            0|            0|  0.00%|    """
  1040|         0|            0|            0|  0.00%|    if seed is None or seed is np.random:
  1041|         0|            0|            0|  0.00%|        return np.random.mtrand._rand
  1042|         0|            0|            0|  0.00%|    if isinstance(seed, numbers.Integral):
  1043|         0|            0|            0|  0.00%|        return np.random.RandomState(seed)
  1044|         0|            0|            0|  0.00%|    if isinstance(seed, np.random.RandomState):
  1045|         0|            0|            0|  0.00%|        return seed
  1046|         0|            0|            0|  0.00%|    raise ValueError(
  1047|         0|            0|            0|  0.00%|        "%r cannot be used to seed a numpy.random.RandomState instance" % seed
  1048|         0|            0|            0|  0.00%|    )
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|
  1051|         0|            0|            0|  0.00%|def has_fit_parameter(estimator, parameter):
  1052|         0|            0|            0|  0.00%|    """Checks whether the estimator's fit method supports the given parameter.
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|    Parameters
  1055|         0|            0|            0|  0.00%|    ----------
  1056|         0|            0|            0|  0.00%|    estimator : object
  1057|         0|            0|            0|  0.00%|        An estimator to inspect.
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|    parameter : str
  1060|         0|            0|            0|  0.00%|        The searched parameter.
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|    Returns
  1063|         0|            0|            0|  0.00%|    -------
  1064|         0|            0|            0|  0.00%|    is_parameter: bool
  1065|         0|            0|            0|  0.00%|        Whether the parameter was found to be a named parameter of the
  1066|         0|            0|            0|  0.00%|        estimator's fit method.
  1067|         0|            0|            0|  0.00%|
  1068|         0|            0|            0|  0.00%|    Examples
  1069|         0|            0|            0|  0.00%|    --------
  1070|         0|            0|            0|  0.00%|    >>> from sklearn.svm import SVC
  1071|         0|            0|            0|  0.00%|    >>> from sklearn.utils.validation import has_fit_parameter
  1072|         0|            0|            0|  0.00%|    >>> has_fit_parameter(SVC(), "sample_weight")
  1073|         0|            0|            0|  0.00%|    True
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|    """
  1076|         0|            0|            0|  0.00%|    return parameter in signature(estimator.fit).parameters
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|
  1079|         0|            0|            0|  0.00%|def check_symmetric(array, *, tol=1e-10, raise_warning=True, raise_exception=False):
  1080|         0|            0|            0|  0.00%|    """Make sure that array is 2D, square and symmetric.
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|    If the array is not symmetric, then a symmetrized version is returned.
  1083|         0|            0|            0|  0.00%|    Optionally, a warning or exception is raised if the matrix is not
  1084|         0|            0|            0|  0.00%|    symmetric.
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|    Parameters
  1087|         0|            0|            0|  0.00%|    ----------
  1088|         0|            0|            0|  0.00%|    array : {ndarray, sparse matrix}
  1089|         0|            0|            0|  0.00%|        Input object to check / convert. Must be two-dimensional and square,
  1090|         0|            0|            0|  0.00%|        otherwise a ValueError will be raised.
  1091|         0|            0|            0|  0.00%|
  1092|         0|            0|            0|  0.00%|    tol : float, default=1e-10
  1093|         0|            0|            0|  0.00%|        Absolute tolerance for equivalence of arrays. Default = 1E-10.
  1094|         0|            0|            0|  0.00%|
  1095|         0|            0|            0|  0.00%|    raise_warning : bool, default=True
  1096|         0|            0|            0|  0.00%|        If True then raise a warning if conversion is required.
  1097|         0|            0|            0|  0.00%|
  1098|         0|            0|            0|  0.00%|    raise_exception : bool, default=False
  1099|         0|            0|            0|  0.00%|        If True then raise an exception if array is not symmetric.
  1100|         0|            0|            0|  0.00%|
  1101|         0|            0|            0|  0.00%|    Returns
  1102|         0|            0|            0|  0.00%|    -------
  1103|         0|            0|            0|  0.00%|    array_sym : {ndarray, sparse matrix}
  1104|         0|            0|            0|  0.00%|        Symmetrized version of the input array, i.e. the average of array
  1105|         0|            0|            0|  0.00%|        and array.transpose(). If sparse, then duplicate entries are first
  1106|         0|            0|            0|  0.00%|        summed and zeros are eliminated.
  1107|         0|            0|            0|  0.00%|    """
  1108|         0|            0|            0|  0.00%|    if (array.ndim != 2) or (array.shape[0] != array.shape[1]):
  1109|         0|            0|            0|  0.00%|        raise ValueError(
  1110|         0|            0|            0|  0.00%|            "array must be 2-dimensional and square. shape = {0}".format(array.shape)
  1111|         0|            0|            0|  0.00%|        )
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    if sp.issparse(array):
  1114|         0|            0|            0|  0.00%|        diff = array - array.T
  1115|         0|            0|            0|  0.00%|        # only csr, csc, and coo have `data` attribute
  1116|         0|            0|            0|  0.00%|        if diff.format not in ["csr", "csc", "coo"]:
  1117|         0|            0|            0|  0.00%|            diff = diff.tocsr()
  1118|         0|            0|            0|  0.00%|        symmetric = np.all(abs(diff.data) < tol)
  1119|         0|            0|            0|  0.00%|    else:
  1120|         0|            0|            0|  0.00%|        symmetric = np.allclose(array, array.T, atol=tol)
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|    if not symmetric:
  1123|         0|            0|            0|  0.00%|        if raise_exception:
  1124|         0|            0|            0|  0.00%|            raise ValueError("Array must be symmetric")
  1125|         0|            0|            0|  0.00%|        if raise_warning:
  1126|         0|            0|            0|  0.00%|            warnings.warn(
  1127|         0|            0|            0|  0.00%|                "Array is not symmetric, and will be converted "
  1128|         0|            0|            0|  0.00%|                "to symmetric by average with its transpose.",
  1129|         0|            0|            0|  0.00%|                stacklevel=2,
  1130|         0|            0|            0|  0.00%|            )
  1131|         0|            0|            0|  0.00%|        if sp.issparse(array):
  1132|         0|            0|            0|  0.00%|            conversion = "to" + array.format
  1133|         0|            0|            0|  0.00%|            array = getattr(0.5 * (array + array.T), conversion)()
  1134|         0|            0|            0|  0.00%|        else:
  1135|         0|            0|            0|  0.00%|            array = 0.5 * (array + array.T)
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|    return array
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):
  1141|         0|            0|            0|  0.00%|    """Perform is_fitted validation for estimator.
  1142|         0|            0|            0|  0.00%|
  1143|         0|            0|            0|  0.00%|    Checks if the estimator is fitted by verifying the presence of
  1144|         0|            0|            0|  0.00%|    fitted attributes (ending with a trailing underscore) and otherwise
  1145|         0|            0|            0|  0.00%|    raises a NotFittedError with the given message.
  1146|         0|            0|            0|  0.00%|
  1147|         0|            0|            0|  0.00%|    If an estimator does not set any attributes with a trailing underscore, it
  1148|         0|            0|            0|  0.00%|    can define a ``__sklearn_is_fitted__`` method returning a boolean to specify if the
  1149|         0|            0|            0|  0.00%|    estimator is fitted or not.
  1150|         0|            0|            0|  0.00%|
  1151|         0|            0|            0|  0.00%|    Parameters
  1152|         0|            0|            0|  0.00%|    ----------
  1153|         0|            0|            0|  0.00%|    estimator : estimator instance
  1154|         0|            0|            0|  0.00%|        estimator instance for which the check is performed.
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|    attributes : str, list or tuple of str, default=None
  1157|         0|            0|            0|  0.00%|        Attribute name(s) given as string or a list/tuple of strings
  1158|         0|            0|            0|  0.00%|        Eg.: ``["coef_", "estimator_", ...], "coef_"``
  1159|         0|            0|            0|  0.00%|
  1160|         0|            0|            0|  0.00%|        If `None`, `estimator` is considered fitted if there exist an
  1161|         0|            0|            0|  0.00%|        attribute that ends with a underscore and does not start with double
  1162|         0|            0|            0|  0.00%|        underscore.
  1163|         0|            0|            0|  0.00%|
  1164|         0|            0|            0|  0.00%|    msg : str, default=None
  1165|         0|            0|            0|  0.00%|        The default error message is, "This %(name)s instance is not fitted
  1166|         0|            0|            0|  0.00%|        yet. Call 'fit' with appropriate arguments before using this
  1167|         0|            0|            0|  0.00%|        estimator."
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|        For custom messages if "%(name)s" is present in the message string,
  1170|         0|            0|            0|  0.00%|        it is substituted for the estimator name.
  1171|         0|            0|            0|  0.00%|
  1172|         0|            0|            0|  0.00%|        Eg. : "Estimator, %(name)s, must be fitted before sparsifying".
  1173|         0|            0|            0|  0.00%|
  1174|         0|            0|            0|  0.00%|    all_or_any : callable, {all, any}, default=all
  1175|         0|            0|            0|  0.00%|        Specify whether all or any of the given attributes must exist.
  1176|         0|            0|            0|  0.00%|
  1177|         0|            0|            0|  0.00%|    Returns
  1178|         0|            0|            0|  0.00%|    -------
  1179|         0|            0|            0|  0.00%|    None
  1180|         0|            0|            0|  0.00%|
  1181|         0|            0|            0|  0.00%|    Raises
  1182|         0|            0|            0|  0.00%|    ------
  1183|         0|            0|            0|  0.00%|    NotFittedError
  1184|         0|            0|            0|  0.00%|        If the attributes are not found.
  1185|         0|            0|            0|  0.00%|    """
  1186|         0|            0|            0|  0.00%|    if isclass(estimator):
  1187|         0|            0|            0|  0.00%|        raise TypeError("{} is a class, not an instance.".format(estimator))
  1188|         0|            0|            0|  0.00%|    if msg is None:
  1189|         0|            0|            0|  0.00%|        msg = (
  1190|         0|            0|            0|  0.00%|            "This %(name)s instance is not fitted yet. Call 'fit' with "
  1191|         0|            0|            0|  0.00%|            "appropriate arguments before using this estimator."
  1192|         0|            0|            0|  0.00%|        )
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|    if not hasattr(estimator, "fit"):
  1195|         0|            0|            0|  0.00%|        raise TypeError("%s is not an estimator instance." % (estimator))
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|    if attributes is not None:
  1198|         0|            0|            0|  0.00%|        if not isinstance(attributes, (list, tuple)):
  1199|         0|            0|            0|  0.00%|            attributes = [attributes]
  1200|         0|            0|            0|  0.00%|        fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])
  1201|         0|            0|            0|  0.00%|    elif hasattr(estimator, "__sklearn_is_fitted__"):
  1202|         0|            0|            0|  0.00%|        fitted = estimator.__sklearn_is_fitted__()
  1203|         0|            0|            0|  0.00%|    else:
  1204|         0|            0|            0|  0.00%|        fitted = [
  1205|         0|            0|            0|  0.00%|            v for v in vars(estimator) if v.endswith("_") and not v.startswith("__")
  1206|         0|            0|            0|  0.00%|        ]
  1207|         0|            0|            0|  0.00%|
  1208|         0|            0|            0|  0.00%|    if not fitted:
  1209|         0|            0|            0|  0.00%|        raise NotFittedError(msg % {"name": type(estimator).__name__})
  1210|         0|            0|            0|  0.00%|
  1211|         0|            0|            0|  0.00%|
  1212|         0|            0|            0|  0.00%|def check_non_negative(X, whom):
  1213|         0|            0|            0|  0.00%|    """
  1214|         0|            0|            0|  0.00%|    Check if there is any negative value in an array.
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|    Parameters
  1217|         0|            0|            0|  0.00%|    ----------
  1218|         0|            0|            0|  0.00%|    X : {array-like, sparse matrix}
  1219|         0|            0|            0|  0.00%|        Input data.
  1220|         0|            0|            0|  0.00%|
  1221|         0|            0|            0|  0.00%|    whom : str
  1222|         0|            0|            0|  0.00%|        Who passed X to this function.
  1223|         0|            0|            0|  0.00%|    """
  1224|         0|            0|            0|  0.00%|    # avoid X.min() on sparse matrix since it also sorts the indices
  1225|         0|            0|            0|  0.00%|    if sp.issparse(X):
  1226|         0|            0|            0|  0.00%|        if X.format in ["lil", "dok"]:
  1227|         0|            0|            0|  0.00%|            X = X.tocsr()
  1228|         0|            0|            0|  0.00%|        if X.data.size == 0:
  1229|         0|            0|            0|  0.00%|            X_min = 0
  1230|         0|            0|            0|  0.00%|        else:
  1231|         0|            0|            0|  0.00%|            X_min = X.data.min()
  1232|         0|            0|            0|  0.00%|    else:
  1233|         0|            0|            0|  0.00%|        X_min = X.min()
  1234|         0|            0|            0|  0.00%|
  1235|         0|            0|            0|  0.00%|    if X_min < 0:
  1236|         0|            0|            0|  0.00%|        raise ValueError("Negative values in data passed to %s" % whom)
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|
  1239|         0|            0|            0|  0.00%|def check_scalar(
  1240|         0|            0|            0|  0.00%|    x,
  1241|         0|            0|            0|  0.00%|    name,
  1242|         0|            0|            0|  0.00%|    target_type,
  1243|         0|            0|            0|  0.00%|    *,
  1244|         0|            0|            0|  0.00%|    min_val=None,
  1245|         0|            0|            0|  0.00%|    max_val=None,
  1246|         0|            0|            0|  0.00%|    include_boundaries="both",
  1247|         0|            0|            0|  0.00%|):
  1248|         0|            0|            0|  0.00%|    """Validate scalar parameters type and value.
  1249|         0|            0|            0|  0.00%|
  1250|         0|            0|            0|  0.00%|    Parameters
  1251|         0|            0|            0|  0.00%|    ----------
  1252|         0|            0|            0|  0.00%|    x : object
  1253|         0|            0|            0|  0.00%|        The scalar parameter to validate.
  1254|         0|            0|            0|  0.00%|
  1255|         0|            0|            0|  0.00%|    name : str
  1256|         0|            0|            0|  0.00%|        The name of the parameter to be printed in error messages.
  1257|         0|            0|            0|  0.00%|
  1258|         0|            0|            0|  0.00%|    target_type : type or tuple
  1259|         0|            0|            0|  0.00%|        Acceptable data types for the parameter.
  1260|         0|            0|            0|  0.00%|
  1261|         0|            0|            0|  0.00%|    min_val : float or int, default=None
  1262|         0|            0|            0|  0.00%|        The minimum valid value the parameter can take. If None (default) it
  1263|         0|            0|            0|  0.00%|        is implied that the parameter does not have a lower bound.
  1264|         0|            0|            0|  0.00%|
  1265|         0|            0|            0|  0.00%|    max_val : float or int, default=False
  1266|         0|            0|            0|  0.00%|        The maximum valid value the parameter can take. If None (default) it
  1267|         0|            0|            0|  0.00%|        is implied that the parameter does not have an upper bound.
  1268|         0|            0|            0|  0.00%|
  1269|         0|            0|            0|  0.00%|    include_boundaries : {"left", "right", "both", "neither"}, default="both"
  1270|         0|            0|            0|  0.00%|        Whether the interval defined by `min_val` and `max_val` should include
  1271|         0|            0|            0|  0.00%|        the boundaries. Possible choices are:
  1272|         0|            0|            0|  0.00%|
  1273|         0|            0|            0|  0.00%|        - `"left"`: only `min_val` is included in the valid interval;
  1274|         0|            0|            0|  0.00%|        - `"right"`: only `max_val` is included in the valid interval;
  1275|         0|            0|            0|  0.00%|        - `"both"`: `min_val` and `max_val` are included in the valid interval;
  1276|         0|            0|            0|  0.00%|        - `"neither"`: neither `min_val` nor `max_val` are included in the
  1277|         0|            0|            0|  0.00%|          valid interval.
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|    Returns
  1280|         0|            0|            0|  0.00%|    -------
  1281|         0|            0|            0|  0.00%|    x : numbers.Number
  1282|         0|            0|            0|  0.00%|        The validated number.
  1283|         0|            0|            0|  0.00%|
  1284|         0|            0|            0|  0.00%|    Raises
  1285|         0|            0|            0|  0.00%|    ------
  1286|         0|            0|            0|  0.00%|    TypeError
  1287|         0|            0|            0|  0.00%|        If the parameter's type does not match the desired type.
  1288|         0|            0|            0|  0.00%|
  1289|         0|            0|            0|  0.00%|    ValueError
  1290|         0|            0|            0|  0.00%|        If the parameter's value violates the given bounds.
  1291|         0|            0|            0|  0.00%|    """
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|    if not isinstance(x, target_type):
  1294|         0|            0|            0|  0.00%|        raise TypeError(f"{name} must be an instance of {target_type}, not {type(x)}.")
  1295|         0|            0|            0|  0.00%|
  1296|         0|            0|            0|  0.00%|    expected_include_boundaries = ("left", "right", "both", "neither")
  1297|         0|            0|            0|  0.00%|    if include_boundaries not in expected_include_boundaries:
  1298|         0|            0|            0|  0.00%|        raise ValueError(
  1299|         0|            0|            0|  0.00%|            f"Unknown value for `include_boundaries`: {repr(include_boundaries)}. "
  1300|         0|            0|            0|  0.00%|            f"Possible values are: {expected_include_boundaries}."
  1301|         0|            0|            0|  0.00%|        )
  1302|         0|            0|            0|  0.00%|
  1303|         0|            0|            0|  0.00%|    comparison_operator = (
  1304|         0|            0|            0|  0.00%|        operator.lt if include_boundaries in ("left", "both") else operator.le
  1305|         0|            0|            0|  0.00%|    )
  1306|         0|            0|            0|  0.00%|    if min_val is not None and comparison_operator(x, min_val):
  1307|         0|            0|            0|  0.00%|        raise ValueError(
  1308|         0|            0|            0|  0.00%|            f"{name} == {x}, must be"
  1309|         0|            0|            0|  0.00%|            f" {'>=' if include_boundaries in ('left', 'both') else '>'} {min_val}."
  1310|         0|            0|            0|  0.00%|        )
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|    comparison_operator = (
  1313|         0|            0|            0|  0.00%|        operator.gt if include_boundaries in ("right", "both") else operator.ge
  1314|         0|            0|            0|  0.00%|    )
  1315|         0|            0|            0|  0.00%|    if max_val is not None and comparison_operator(x, max_val):
  1316|         0|            0|            0|  0.00%|        raise ValueError(
  1317|         0|            0|            0|  0.00%|            f"{name} == {x}, must be"
  1318|         0|            0|            0|  0.00%|            f" {'<=' if include_boundaries in ('right', 'both') else '<'} {max_val}."
  1319|         0|            0|            0|  0.00%|        )
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|    return x
  1322|         0|            0|            0|  0.00%|
  1323|         0|            0|            0|  0.00%|
  1324|         0|            0|            0|  0.00%|def _check_psd_eigenvalues(lambdas, enable_warnings=False):
  1325|         0|            0|            0|  0.00%|    """Check the eigenvalues of a positive semidefinite (PSD) matrix.
  1326|         0|            0|            0|  0.00%|
  1327|         0|            0|            0|  0.00%|    Checks the provided array of PSD matrix eigenvalues for numerical or
  1328|         0|            0|            0|  0.00%|    conditioning issues and returns a fixed validated version. This method
  1329|         0|            0|            0|  0.00%|    should typically be used if the PSD matrix is user-provided (e.g. a
  1330|         0|            0|            0|  0.00%|    Gram matrix) or computed using a user-provided dissimilarity metric
  1331|         0|            0|            0|  0.00%|    (e.g. kernel function), or if the decomposition process uses approximation
  1332|         0|            0|            0|  0.00%|    methods (randomized SVD, etc.).
  1333|         0|            0|            0|  0.00%|
  1334|         0|            0|            0|  0.00%|    It checks for three things:
  1335|         0|            0|            0|  0.00%|
  1336|         0|            0|            0|  0.00%|    - that there are no significant imaginary parts in eigenvalues (more than
  1337|         0|            0|            0|  0.00%|      1e-5 times the maximum real part). If this check fails, it raises a
  1338|         0|            0|            0|  0.00%|      ``ValueError``. Otherwise all non-significant imaginary parts that may
  1339|         0|            0|            0|  0.00%|      remain are set to zero. This operation is traced with a
  1340|         0|            0|            0|  0.00%|      ``PositiveSpectrumWarning`` when ``enable_warnings=True``.
  1341|         0|            0|            0|  0.00%|
  1342|         0|            0|            0|  0.00%|    - that eigenvalues are not all negative. If this check fails, it raises a
  1343|         0|            0|            0|  0.00%|      ``ValueError``
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|    - that there are no significant negative eigenvalues with absolute value
  1346|         0|            0|            0|  0.00%|      more than 1e-10 (1e-6) and more than 1e-5 (5e-3) times the largest
  1347|         0|            0|            0|  0.00%|      positive eigenvalue in double (simple) precision. If this check fails,
  1348|         0|            0|            0|  0.00%|      it raises a ``ValueError``. Otherwise all negative eigenvalues that may
  1349|         0|            0|            0|  0.00%|      remain are set to zero. This operation is traced with a
  1350|         0|            0|            0|  0.00%|      ``PositiveSpectrumWarning`` when ``enable_warnings=True``.
  1351|         0|            0|            0|  0.00%|
  1352|         0|            0|            0|  0.00%|    Finally, all the positive eigenvalues that are too small (with a value
  1353|         0|            0|            0|  0.00%|    smaller than the maximum eigenvalue multiplied by 1e-12 (2e-7)) are set to
  1354|         0|            0|            0|  0.00%|    zero. This operation is traced with a ``PositiveSpectrumWarning`` when
  1355|         0|            0|            0|  0.00%|    ``enable_warnings=True``.
  1356|         0|            0|            0|  0.00%|
  1357|         0|            0|            0|  0.00%|    Parameters
  1358|         0|            0|            0|  0.00%|    ----------
  1359|         0|            0|            0|  0.00%|    lambdas : array-like of shape (n_eigenvalues,)
  1360|         0|            0|            0|  0.00%|        Array of eigenvalues to check / fix.
  1361|         0|            0|            0|  0.00%|
  1362|         0|            0|            0|  0.00%|    enable_warnings : bool, default=False
  1363|         0|            0|            0|  0.00%|        When this is set to ``True``, a ``PositiveSpectrumWarning`` will be
  1364|         0|            0|            0|  0.00%|        raised when there are imaginary parts, negative eigenvalues, or
  1365|         0|            0|            0|  0.00%|        extremely small non-zero eigenvalues. Otherwise no warning will be
  1366|         0|            0|            0|  0.00%|        raised. In both cases, imaginary parts, negative eigenvalues, and
  1367|         0|            0|            0|  0.00%|        extremely small non-zero eigenvalues will be set to zero.
  1368|         0|            0|            0|  0.00%|
  1369|         0|            0|            0|  0.00%|    Returns
  1370|         0|            0|            0|  0.00%|    -------
  1371|         0|            0|            0|  0.00%|    lambdas_fixed : ndarray of shape (n_eigenvalues,)
  1372|         0|            0|            0|  0.00%|        A fixed validated copy of the array of eigenvalues.
  1373|         0|            0|            0|  0.00%|
  1374|         0|            0|            0|  0.00%|    Examples
  1375|         0|            0|            0|  0.00%|    --------
  1376|         0|            0|            0|  0.00%|    >>> from sklearn.utils.validation import _check_psd_eigenvalues
  1377|         0|            0|            0|  0.00%|    >>> _check_psd_eigenvalues([1, 2])      # nominal case
  1378|         0|            0|            0|  0.00%|    array([1, 2])
  1379|         0|            0|            0|  0.00%|    >>> _check_psd_eigenvalues([5, 5j])     # significant imag part
  1380|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1381|         0|            0|            0|  0.00%|        ...
  1382|         0|            0|            0|  0.00%|    ValueError: There are significant imaginary parts in eigenvalues (1
  1383|         0|            0|            0|  0.00%|        of the maximum real part). Either the matrix is not PSD, or there was
  1384|         0|            0|            0|  0.00%|        an issue while computing the eigendecomposition of the matrix.
  1385|         0|            0|            0|  0.00%|    >>> _check_psd_eigenvalues([5, 5e-5j])  # insignificant imag part
  1386|         0|            0|            0|  0.00%|    array([5., 0.])
  1387|         0|            0|            0|  0.00%|    >>> _check_psd_eigenvalues([-5, -1])    # all negative
  1388|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1389|         0|            0|            0|  0.00%|        ...
  1390|         0|            0|            0|  0.00%|    ValueError: All eigenvalues are negative (maximum is -1). Either the
  1391|         0|            0|            0|  0.00%|        matrix is not PSD, or there was an issue while computing the
  1392|         0|            0|            0|  0.00%|        eigendecomposition of the matrix.
  1393|         0|            0|            0|  0.00%|    >>> _check_psd_eigenvalues([5, -1])     # significant negative
  1394|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1395|         0|            0|            0|  0.00%|        ...
  1396|         0|            0|            0|  0.00%|    ValueError: There are significant negative eigenvalues (0.2 of the
  1397|         0|            0|            0|  0.00%|        maximum positive). Either the matrix is not PSD, or there was an issue
  1398|         0|            0|            0|  0.00%|        while computing the eigendecomposition of the matrix.
  1399|         0|            0|            0|  0.00%|    >>> _check_psd_eigenvalues([5, -5e-5])  # insignificant negative
  1400|         0|            0|            0|  0.00%|    array([5., 0.])
  1401|         0|            0|            0|  0.00%|    >>> _check_psd_eigenvalues([5, 4e-12])  # bad conditioning (too small)
  1402|         0|            0|            0|  0.00%|    array([5., 0.])
  1403|         0|            0|            0|  0.00%|
  1404|         0|            0|            0|  0.00%|    """
  1405|         0|            0|            0|  0.00%|
  1406|         0|            0|            0|  0.00%|    lambdas = np.array(lambdas)
  1407|         0|            0|            0|  0.00%|    is_double_precision = lambdas.dtype == np.float64
  1408|         0|            0|            0|  0.00%|
  1409|         0|            0|            0|  0.00%|    # note: the minimum value available is
  1410|         0|            0|            0|  0.00%|    #  - single-precision: np.finfo('float32').eps = 1.2e-07
  1411|         0|            0|            0|  0.00%|    #  - double-precision: np.finfo('float64').eps = 2.2e-16
  1412|         0|            0|            0|  0.00%|
  1413|         0|            0|            0|  0.00%|    # the various thresholds used for validation
  1414|         0|            0|            0|  0.00%|    # we may wish to change the value according to precision.
  1415|         0|            0|            0|  0.00%|    significant_imag_ratio = 1e-5
  1416|         0|            0|            0|  0.00%|    significant_neg_ratio = 1e-5 if is_double_precision else 5e-3
  1417|         0|            0|            0|  0.00%|    significant_neg_value = 1e-10 if is_double_precision else 1e-6
  1418|         0|            0|            0|  0.00%|    small_pos_ratio = 1e-12 if is_double_precision else 2e-7
  1419|         0|            0|            0|  0.00%|
  1420|         0|            0|            0|  0.00%|    # Check that there are no significant imaginary parts
  1421|         0|            0|            0|  0.00%|    if not np.isreal(lambdas).all():
  1422|         0|            0|            0|  0.00%|        max_imag_abs = np.abs(np.imag(lambdas)).max()
  1423|         0|            0|            0|  0.00%|        max_real_abs = np.abs(np.real(lambdas)).max()
  1424|         0|            0|            0|  0.00%|        if max_imag_abs > significant_imag_ratio * max_real_abs:
  1425|         0|            0|            0|  0.00%|            raise ValueError(
  1426|         0|            0|            0|  0.00%|                "There are significant imaginary parts in eigenvalues (%g "
  1427|         0|            0|            0|  0.00%|                "of the maximum real part). Either the matrix is not PSD, or "
  1428|         0|            0|            0|  0.00%|                "there was an issue while computing the eigendecomposition "
  1429|         0|            0|            0|  0.00%|                "of the matrix." % (max_imag_abs / max_real_abs)
  1430|         0|            0|            0|  0.00%|            )
  1431|         0|            0|            0|  0.00%|
  1432|         0|            0|            0|  0.00%|        # warn about imaginary parts being removed
  1433|         0|            0|            0|  0.00%|        if enable_warnings:
  1434|         0|            0|            0|  0.00%|            warnings.warn(
  1435|         0|            0|            0|  0.00%|                "There are imaginary parts in eigenvalues (%g "
  1436|         0|            0|            0|  0.00%|                "of the maximum real part). Either the matrix is not"
  1437|         0|            0|            0|  0.00%|                " PSD, or there was an issue while computing the "
  1438|         0|            0|            0|  0.00%|                "eigendecomposition of the matrix. Only the real "
  1439|         0|            0|            0|  0.00%|                "parts will be kept." % (max_imag_abs / max_real_abs),
  1440|         0|            0|            0|  0.00%|                PositiveSpectrumWarning,
  1441|         0|            0|            0|  0.00%|            )
  1442|         0|            0|            0|  0.00%|
  1443|         0|            0|            0|  0.00%|    # Remove all imaginary parts (even if zero)
  1444|         0|            0|            0|  0.00%|    lambdas = np.real(lambdas)
  1445|         0|            0|            0|  0.00%|
  1446|         0|            0|            0|  0.00%|    # Check that there are no significant negative eigenvalues
  1447|         0|            0|            0|  0.00%|    max_eig = lambdas.max()
  1448|         0|            0|            0|  0.00%|    if max_eig < 0:
  1449|         0|            0|            0|  0.00%|        raise ValueError(
  1450|         0|            0|            0|  0.00%|            "All eigenvalues are negative (maximum is %g). "
  1451|         0|            0|            0|  0.00%|            "Either the matrix is not PSD, or there was an "
  1452|         0|            0|            0|  0.00%|            "issue while computing the eigendecomposition of "
  1453|         0|            0|            0|  0.00%|            "the matrix." % max_eig
  1454|         0|            0|            0|  0.00%|        )
  1455|         0|            0|            0|  0.00%|
  1456|         0|            0|            0|  0.00%|    else:
  1457|         0|            0|            0|  0.00%|        min_eig = lambdas.min()
  1458|         0|            0|            0|  0.00%|        if (
  1459|         0|            0|            0|  0.00%|            min_eig < -significant_neg_ratio * max_eig
  1460|         0|            0|            0|  0.00%|            and min_eig < -significant_neg_value
  1461|         0|            0|            0|  0.00%|        ):
  1462|         0|            0|            0|  0.00%|            raise ValueError(
  1463|         0|            0|            0|  0.00%|                "There are significant negative eigenvalues (%g"
  1464|         0|            0|            0|  0.00%|                " of the maximum positive). Either the matrix is "
  1465|         0|            0|            0|  0.00%|                "not PSD, or there was an issue while computing "
  1466|         0|            0|            0|  0.00%|                "the eigendecomposition of the matrix." % (-min_eig / max_eig)
  1467|         0|            0|            0|  0.00%|            )
  1468|         0|            0|            0|  0.00%|        elif min_eig < 0:
  1469|         0|            0|            0|  0.00%|            # Remove all negative values and warn about it
  1470|         0|            0|            0|  0.00%|            if enable_warnings:
  1471|         0|            0|            0|  0.00%|                warnings.warn(
  1472|         0|            0|            0|  0.00%|                    "There are negative eigenvalues (%g of the "
  1473|         0|            0|            0|  0.00%|                    "maximum positive). Either the matrix is not "
  1474|         0|            0|            0|  0.00%|                    "PSD, or there was an issue while computing the"
  1475|         0|            0|            0|  0.00%|                    " eigendecomposition of the matrix. Negative "
  1476|         0|            0|            0|  0.00%|                    "eigenvalues will be replaced with 0." % (-min_eig / max_eig),
  1477|         0|            0|            0|  0.00%|                    PositiveSpectrumWarning,
  1478|         0|            0|            0|  0.00%|                )
  1479|         0|            0|            0|  0.00%|            lambdas[lambdas < 0] = 0
  1480|         0|            0|            0|  0.00%|
  1481|         0|            0|            0|  0.00%|    # Check for conditioning (small positive non-zeros)
  1482|         0|            0|            0|  0.00%|    too_small_lambdas = (0 < lambdas) & (lambdas < small_pos_ratio * max_eig)
  1483|         0|            0|            0|  0.00%|    if too_small_lambdas.any():
  1484|         0|            0|            0|  0.00%|        if enable_warnings:
  1485|         0|            0|            0|  0.00%|            warnings.warn(
  1486|         0|            0|            0|  0.00%|                "Badly conditioned PSD matrix spectrum: the largest "
  1487|         0|            0|            0|  0.00%|                "eigenvalue is more than %g times the smallest. "
  1488|         0|            0|            0|  0.00%|                "Small eigenvalues will be replaced with 0."
  1489|         0|            0|            0|  0.00%|                "" % (1 / small_pos_ratio),
  1490|         0|            0|            0|  0.00%|                PositiveSpectrumWarning,
  1491|         0|            0|            0|  0.00%|            )
  1492|         0|            0|            0|  0.00%|        lambdas[too_small_lambdas] = 0
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|    return lambdas
  1495|         0|            0|            0|  0.00%|
  1496|         0|            0|            0|  0.00%|
  1497|         0|            0|            0|  0.00%|def _check_sample_weight(sample_weight, X, dtype=None, copy=False):
  1498|         0|            0|            0|  0.00%|    """Validate sample weights.
  1499|         0|            0|            0|  0.00%|
  1500|         0|            0|            0|  0.00%|    Note that passing sample_weight=None will output an array of ones.
  1501|         0|            0|            0|  0.00%|    Therefore, in some cases, you may want to protect the call with:
  1502|         0|            0|            0|  0.00%|    if sample_weight is not None:
  1503|         0|            0|            0|  0.00%|        sample_weight = _check_sample_weight(...)
  1504|         0|            0|            0|  0.00%|
  1505|         0|            0|            0|  0.00%|    Parameters
  1506|         0|            0|            0|  0.00%|    ----------
  1507|         0|            0|            0|  0.00%|    sample_weight : {ndarray, Number or None}, shape (n_samples,)
  1508|         0|            0|            0|  0.00%|       Input sample weights.
  1509|         0|            0|            0|  0.00%|
  1510|         0|            0|            0|  0.00%|    X : {ndarray, list, sparse matrix}
  1511|         0|            0|            0|  0.00%|        Input data.
  1512|         0|            0|            0|  0.00%|
  1513|         0|            0|            0|  0.00%|    dtype : dtype, default=None
  1514|         0|            0|            0|  0.00%|       dtype of the validated `sample_weight`.
  1515|         0|            0|            0|  0.00%|       If None, and the input `sample_weight` is an array, the dtype of the
  1516|         0|            0|            0|  0.00%|       input is preserved; otherwise an array with the default numpy dtype
  1517|         0|            0|            0|  0.00%|       is be allocated.  If `dtype` is not one of `float32`, `float64`,
  1518|         0|            0|            0|  0.00%|       `None`, the output will be of dtype `float64`.
  1519|         0|            0|            0|  0.00%|
  1520|         0|            0|            0|  0.00%|    copy : bool, default=False
  1521|         0|            0|            0|  0.00%|        If True, a copy of sample_weight will be created.
  1522|         0|            0|            0|  0.00%|
  1523|         0|            0|            0|  0.00%|    Returns
  1524|         0|            0|            0|  0.00%|    -------
  1525|         0|            0|            0|  0.00%|    sample_weight : ndarray of shape (n_samples,)
  1526|         0|            0|            0|  0.00%|       Validated sample weight. It is guaranteed to be "C" contiguous.
  1527|         0|            0|            0|  0.00%|    """
  1528|         0|            0|            0|  0.00%|    n_samples = _num_samples(X)
  1529|         0|            0|            0|  0.00%|
  1530|         0|            0|            0|  0.00%|    if dtype is not None and dtype not in [np.float32, np.float64]:
  1531|         0|            0|            0|  0.00%|        dtype = np.float64
  1532|         0|            0|            0|  0.00%|
  1533|         0|            0|            0|  0.00%|    if sample_weight is None:
  1534|         0|            0|            0|  0.00%|        sample_weight = np.ones(n_samples, dtype=dtype)
  1535|         0|            0|            0|  0.00%|    elif isinstance(sample_weight, numbers.Number):
  1536|         0|            0|            0|  0.00%|        sample_weight = np.full(n_samples, sample_weight, dtype=dtype)
  1537|         0|            0|            0|  0.00%|    else:
  1538|         0|            0|            0|  0.00%|        if dtype is None:
  1539|         0|            0|            0|  0.00%|            dtype = [np.float64, np.float32]
  1540|         0|            0|            0|  0.00%|        sample_weight = check_array(
  1541|         0|            0|            0|  0.00%|            sample_weight,
  1542|         0|            0|            0|  0.00%|            accept_sparse=False,
  1543|         0|            0|            0|  0.00%|            ensure_2d=False,
  1544|         0|            0|            0|  0.00%|            dtype=dtype,
  1545|         0|            0|            0|  0.00%|            order="C",
  1546|         0|            0|            0|  0.00%|            copy=copy,
  1547|         0|            0|            0|  0.00%|        )
  1548|         0|            0|            0|  0.00%|        if sample_weight.ndim != 1:
  1549|         0|            0|            0|  0.00%|            raise ValueError("Sample weights must be 1D array or scalar")
  1550|         0|            0|            0|  0.00%|
  1551|         0|            0|            0|  0.00%|        if sample_weight.shape != (n_samples,):
  1552|         0|            0|            0|  0.00%|            raise ValueError(
  1553|         0|            0|            0|  0.00%|                "sample_weight.shape == {}, expected {}!".format(
  1554|         0|            0|            0|  0.00%|                    sample_weight.shape, (n_samples,)
  1555|         0|            0|            0|  0.00%|                )
  1556|         0|            0|            0|  0.00%|            )
  1557|         0|            0|            0|  0.00%|
  1558|         0|            0|            0|  0.00%|    return sample_weight
  1559|         0|            0|            0|  0.00%|
  1560|         0|            0|            0|  0.00%|
  1561|         0|            0|            0|  0.00%|def _allclose_dense_sparse(x, y, rtol=1e-7, atol=1e-9):
  1562|         0|            0|            0|  0.00%|    """Check allclose for sparse and dense data.
  1563|         0|            0|            0|  0.00%|
  1564|         0|            0|            0|  0.00%|    Both x and y need to be either sparse or dense, they
  1565|         0|            0|            0|  0.00%|    can't be mixed.
  1566|         0|            0|            0|  0.00%|
  1567|         0|            0|            0|  0.00%|    Parameters
  1568|         0|            0|            0|  0.00%|    ----------
  1569|         0|            0|            0|  0.00%|    x : {array-like, sparse matrix}
  1570|         0|            0|            0|  0.00%|        First array to compare.
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|    y : {array-like, sparse matrix}
  1573|         0|            0|            0|  0.00%|        Second array to compare.
  1574|         0|            0|            0|  0.00%|
  1575|         0|            0|            0|  0.00%|    rtol : float, default=1e-7
  1576|         0|            0|            0|  0.00%|        Relative tolerance; see numpy.allclose.
  1577|         0|            0|            0|  0.00%|
  1578|         0|            0|            0|  0.00%|    atol : float, default=1e-9
  1579|         0|            0|            0|  0.00%|        absolute tolerance; see numpy.allclose. Note that the default here is
  1580|         0|            0|            0|  0.00%|        more tolerant than the default for numpy.testing.assert_allclose, where
  1581|         0|            0|            0|  0.00%|        atol=0.
  1582|         0|            0|            0|  0.00%|    """
  1583|         0|            0|            0|  0.00%|    if sp.issparse(x) and sp.issparse(y):
  1584|         0|            0|            0|  0.00%|        x = x.tocsr()
  1585|         0|            0|            0|  0.00%|        y = y.tocsr()
  1586|         0|            0|            0|  0.00%|        x.sum_duplicates()
  1587|         0|            0|            0|  0.00%|        y.sum_duplicates()
  1588|         0|            0|            0|  0.00%|        return (
  1589|         0|            0|            0|  0.00%|            np.array_equal(x.indices, y.indices)
  1590|         0|            0|            0|  0.00%|            and np.array_equal(x.indptr, y.indptr)
  1591|         0|            0|            0|  0.00%|            and np.allclose(x.data, y.data, rtol=rtol, atol=atol)
  1592|         0|            0|            0|  0.00%|        )
  1593|         0|            0|            0|  0.00%|    elif not sp.issparse(x) and not sp.issparse(y):
  1594|         0|            0|            0|  0.00%|        return np.allclose(x, y, rtol=rtol, atol=atol)
  1595|         0|            0|            0|  0.00%|    raise ValueError(
  1596|         0|            0|            0|  0.00%|        "Can only compare two sparse matrices, not a sparse matrix and an array"
  1597|         0|            0|            0|  0.00%|    )
  1598|         0|            0|            0|  0.00%|
  1599|         0|            0|            0|  0.00%|
  1600|         0|            0|            0|  0.00%|def _check_fit_params(X, fit_params, indices=None):
  1601|         0|            0|            0|  0.00%|    """Check and validate the parameters passed during `fit`.
  1602|         0|            0|            0|  0.00%|
  1603|         0|            0|            0|  0.00%|    Parameters
  1604|         0|            0|            0|  0.00%|    ----------
  1605|         0|            0|            0|  0.00%|    X : array-like of shape (n_samples, n_features)
  1606|         0|            0|            0|  0.00%|        Data array.
  1607|         0|            0|            0|  0.00%|
  1608|         0|            0|            0|  0.00%|    fit_params : dict
  1609|         0|            0|            0|  0.00%|        Dictionary containing the parameters passed at fit.
  1610|         0|            0|            0|  0.00%|
  1611|         0|            0|            0|  0.00%|    indices : array-like of shape (n_samples,), default=None
  1612|         0|            0|            0|  0.00%|        Indices to be selected if the parameter has the same size as `X`.
  1613|         0|            0|            0|  0.00%|
  1614|         0|            0|            0|  0.00%|    Returns
  1615|         0|            0|            0|  0.00%|    -------
  1616|         0|            0|            0|  0.00%|    fit_params_validated : dict
  1617|         0|            0|            0|  0.00%|        Validated parameters. We ensure that the values support indexing.
  1618|         0|            0|            0|  0.00%|    """
  1619|         0|            0|            0|  0.00%|    from . import _safe_indexing
  1620|         0|            0|            0|  0.00%|
  1621|         0|            0|            0|  0.00%|    fit_params_validated = {}
  1622|         0|            0|            0|  0.00%|    for param_key, param_value in fit_params.items():
  1623|         0|            0|            0|  0.00%|        if not _is_arraylike(param_value) or _num_samples(param_value) != _num_samples(
  1624|         0|            0|            0|  0.00%|            X
  1625|         0|            0|            0|  0.00%|        ):
  1626|         0|            0|            0|  0.00%|            # Non-indexable pass-through (for now for backward-compatibility).
  1627|         0|            0|            0|  0.00%|            # https://github.com/scikit-learn/scikit-learn/issues/15805
  1628|         0|            0|            0|  0.00%|            fit_params_validated[param_key] = param_value
  1629|         0|            0|            0|  0.00%|        else:
  1630|         0|            0|            0|  0.00%|            # Any other fit_params should support indexing
  1631|         0|            0|            0|  0.00%|            # (e.g. for cross-validation).
  1632|         0|            0|            0|  0.00%|            fit_params_validated[param_key] = _make_indexable(param_value)
  1633|         0|            0|            0|  0.00%|            fit_params_validated[param_key] = _safe_indexing(
  1634|         0|            0|            0|  0.00%|                fit_params_validated[param_key], indices
  1635|         0|            0|            0|  0.00%|            )
  1636|         0|            0|            0|  0.00%|
  1637|         0|            0|            0|  0.00%|    return fit_params_validated
  1638|         0|            0|            0|  0.00%|
  1639|         0|            0|            0|  0.00%|
  1640|         0|            0|            0|  0.00%|def _get_feature_names(X):
  1641|         0|            0|            0|  0.00%|    """Get feature names from X.
  1642|         0|            0|            0|  0.00%|
  1643|         0|            0|            0|  0.00%|    Support for other array containers should place its implementation here.
  1644|         0|            0|            0|  0.00%|
  1645|         0|            0|            0|  0.00%|    Parameters
  1646|         0|            0|            0|  0.00%|    ----------
  1647|         0|            0|            0|  0.00%|    X : {ndarray, dataframe} of shape (n_samples, n_features)
  1648|         0|            0|            0|  0.00%|        Array container to extract feature names.
  1649|         0|            0|            0|  0.00%|
  1650|         0|            0|            0|  0.00%|        - pandas dataframe : The columns will be considered to be feature
  1651|         0|            0|            0|  0.00%|          names. If the dataframe contains non-string feature names, `None` is
  1652|         0|            0|            0|  0.00%|          returned.
  1653|         0|            0|            0|  0.00%|        - All other array containers will return `None`.
  1654|         0|            0|            0|  0.00%|
  1655|         0|            0|            0|  0.00%|    Returns
  1656|         0|            0|            0|  0.00%|    -------
  1657|         0|            0|            0|  0.00%|    names: ndarray or None
  1658|         0|            0|            0|  0.00%|        Feature names of `X`. Unrecognized array containers will return `None`.
  1659|         0|            0|            0|  0.00%|    """
  1660|         0|            0|            0|  0.00%|    feature_names = None
  1661|         0|            0|            0|  0.00%|
  1662|         0|            0|            0|  0.00%|    # extract feature names for support array containers
  1663|         0|            0|            0|  0.00%|    if hasattr(X, "columns"):
  1664|         0|            0|            0|  0.00%|        feature_names = np.asarray(X.columns, dtype=object)
  1665|         0|            0|            0|  0.00%|
  1666|         0|            0|            0|  0.00%|    if feature_names is None or len(feature_names) == 0:
  1667|         0|            0|            0|  0.00%|        return
  1668|         0|            0|            0|  0.00%|
  1669|         0|            0|            0|  0.00%|    types = sorted(t.__qualname__ for t in set(type(v) for v in feature_names))
  1670|         0|            0|            0|  0.00%|
  1671|         0|            0|            0|  0.00%|    # Warn when types are mixed.
  1672|         0|            0|            0|  0.00%|    # ints and strings do not warn
  1673|         0|            0|            0|  0.00%|    if len(types) > 1 or not (types[0].startswith("int") or types[0] == "str"):
  1674|         0|            0|            0|  0.00%|        # TODO: Convert to an error in 1.2
  1675|         0|            0|            0|  0.00%|        warnings.warn(
  1676|         0|            0|            0|  0.00%|            "Feature names only support names that are all strings. "
  1677|         0|            0|            0|  0.00%|            f"Got feature names with dtypes: {types}. An error will be raised "
  1678|         0|            0|            0|  0.00%|            "in 1.2.",
  1679|         0|            0|            0|  0.00%|            FutureWarning,
  1680|         0|            0|            0|  0.00%|        )
  1681|         0|            0|            0|  0.00%|        return
  1682|         0|            0|            0|  0.00%|
  1683|         0|            0|            0|  0.00%|    # Only feature names of all strings are supported
  1684|         0|            0|            0|  0.00%|    if types[0] == "str":
  1685|         0|            0|            0|  0.00%|        return feature_names
  1686|         0|            0|            0|  0.00%|
  1687|         0|            0|            0|  0.00%|
  1688|         0|            0|            0|  0.00%|def _check_feature_names_in(estimator, input_features=None):
  1689|         0|            0|            0|  0.00%|    """Get output feature names for transformation.
  1690|         0|            0|            0|  0.00%|
  1691|         0|            0|            0|  0.00%|    Parameters
  1692|         0|            0|            0|  0.00%|    ----------
  1693|         0|            0|            0|  0.00%|    input_features : array-like of str or None, default=None
  1694|         0|            0|            0|  0.00%|        Input features.
  1695|         0|            0|            0|  0.00%|
  1696|         0|            0|            0|  0.00%|        - If `input_features` is `None`, then `feature_names_in_` is
  1697|         0|            0|            0|  0.00%|            used as feature names in. If `feature_names_in_` is not defined,
  1698|         0|            0|            0|  0.00%|            then names are generated: `[x0, x1, ..., x(n_features_in_)]`.
  1699|         0|            0|            0|  0.00%|        - If `input_features` is an array-like, then `input_features` must
  1700|         0|            0|            0|  0.00%|            match `feature_names_in_` if `feature_names_in_` is defined.
  1701|         0|            0|            0|  0.00%|
  1702|         0|            0|            0|  0.00%|    Returns
  1703|         0|            0|            0|  0.00%|    -------
  1704|         0|            0|            0|  0.00%|    feature_names_in : ndarray of str
  1705|         0|            0|            0|  0.00%|        Feature names in.
  1706|         0|            0|            0|  0.00%|    """
  1707|         0|            0|            0|  0.00%|
  1708|         0|            0|            0|  0.00%|    feature_names_in_ = getattr(estimator, "feature_names_in_", None)
  1709|         0|            0|            0|  0.00%|    n_features_in_ = getattr(estimator, "n_features_in_", None)
  1710|         0|            0|            0|  0.00%|
  1711|         0|            0|            0|  0.00%|    if input_features is not None:
  1712|         0|            0|            0|  0.00%|        input_features = np.asarray(input_features, dtype=object)
  1713|         0|            0|            0|  0.00%|        if feature_names_in_ is not None and not np.array_equal(
  1714|         0|            0|            0|  0.00%|            feature_names_in_, input_features
  1715|         0|            0|            0|  0.00%|        ):
  1716|         0|            0|            0|  0.00%|            raise ValueError("input_features is not equal to feature_names_in_")
  1717|         0|            0|            0|  0.00%|
  1718|         0|            0|            0|  0.00%|        if n_features_in_ is not None and len(input_features) != n_features_in_:
  1719|         0|            0|            0|  0.00%|            raise ValueError(
  1720|         0|            0|            0|  0.00%|                "input_features should have length equal to number of "
  1721|         0|            0|            0|  0.00%|                f"features ({n_features_in_}), got {len(input_features)}"
  1722|         0|            0|            0|  0.00%|            )
  1723|         0|            0|            0|  0.00%|        return input_features
  1724|         0|            0|            0|  0.00%|
  1725|         0|            0|            0|  0.00%|    if feature_names_in_ is not None:
  1726|         0|            0|            0|  0.00%|        return feature_names_in_
  1727|         0|            0|            0|  0.00%|
  1728|         0|            0|            0|  0.00%|    # Generates feature names if `n_features_in_` is defined
  1729|         0|            0|            0|  0.00%|    if n_features_in_ is None:
  1730|         0|            0|            0|  0.00%|        raise ValueError("Unable to generate feature names without n_features_in_")
  1731|         0|            0|            0|  0.00%|
  1732|         0|            0|            0|  0.00%|    return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py
File duration: 0.00501299s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Base class for sparse matrices"""
     2|         0|            0|            0|  0.00%|import numpy as np
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|from .sputils import (isdense, isscalarlike, isintlike,
     5|         0|            0|            0|  0.00%|                      get_sum_dtype, validateaxis, check_reshape_kwargs,
     6|         0|            0|            0|  0.00%|                      check_shape, asmatrix)
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|__all__ = ['spmatrix', 'isspmatrix', 'issparse',
     9|         0|            0|            0|  0.00%|           'SparseWarning', 'SparseEfficiencyWarning']
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|class SparseWarning(Warning):
    13|         0|            0|            0|  0.00%|    pass
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|class SparseFormatWarning(SparseWarning):
    17|         0|            0|            0|  0.00%|    pass
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|class SparseEfficiencyWarning(SparseWarning):
    21|         0|            0|            0|  0.00%|    pass
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|# The formats that we might potentially understand.
    25|         0|            0|            0|  0.00%|_formats = {'csc': [0, "Compressed Sparse Column"],
    26|         0|            0|            0|  0.00%|            'csr': [1, "Compressed Sparse Row"],
    27|         0|            0|            0|  0.00%|            'dok': [2, "Dictionary Of Keys"],
    28|         0|            0|            0|  0.00%|            'lil': [3, "List of Lists"],
    29|         0|            0|            0|  0.00%|            'dod': [4, "Dictionary of Dictionaries"],
    30|         0|            0|            0|  0.00%|            'sss': [5, "Symmetric Sparse Skyline"],
    31|         0|            0|            0|  0.00%|            'coo': [6, "COOrdinate"],
    32|         0|            0|            0|  0.00%|            'lba': [7, "Linpack BAnded"],
    33|         0|            0|            0|  0.00%|            'egd': [8, "Ellpack-itpack Generalized Diagonal"],
    34|         0|            0|            0|  0.00%|            'dia': [9, "DIAgonal"],
    35|         0|            0|            0|  0.00%|            'bsr': [10, "Block Sparse Row"],
    36|         0|            0|            0|  0.00%|            'msr': [11, "Modified compressed Sparse Row"],
    37|         0|            0|            0|  0.00%|            'bsc': [12, "Block Sparse Column"],
    38|         0|            0|            0|  0.00%|            'msc': [13, "Modified compressed Sparse Column"],
    39|         0|            0|            0|  0.00%|            'ssk': [14, "Symmetric SKyline"],
    40|         0|            0|            0|  0.00%|            'nsk': [15, "Nonsymmetric SKyline"],
    41|         0|            0|            0|  0.00%|            'jad': [16, "JAgged Diagonal"],
    42|         0|            0|            0|  0.00%|            'uss': [17, "Unsymmetric Sparse Skyline"],
    43|         0|            0|            0|  0.00%|            'vbr': [18, "Variable Block Row"],
    44|         0|            0|            0|  0.00%|            'und': [19, "Undefined"]
    45|         0|            0|            0|  0.00%|            }
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|# These univariate ufuncs preserve zeros.
    49|         0|            0|            0|  0.00%|_ufuncs_with_fixed_point_at_zero = frozenset([
    50|         0|            0|            0|  0.00%|        np.sin, np.tan, np.arcsin, np.arctan, np.sinh, np.tanh, np.arcsinh,
    51|         0|            0|            0|  0.00%|        np.arctanh, np.rint, np.sign, np.expm1, np.log1p, np.deg2rad,
    52|         0|            0|            0|  0.00%|        np.rad2deg, np.floor, np.ceil, np.trunc, np.sqrt])
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|MAXPRINT = 50
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|class spmatrix:
    59|         0|            0|            0|  0.00%|    """ This class provides a base class for all sparse matrices.  It
    60|         0|            0|            0|  0.00%|    cannot be instantiated.  Most of the work is provided by subclasses.
    61|         0|            0|            0|  0.00%|    """
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    __array_priority__ = 10.1
    64|         0|            0|            0|  0.00%|    ndim = 2
    65|         0|            0|            0|  0.00%|
    66|        28|            0|            0|  0.00%|    def __init__(self, maxprint=MAXPRINT):
    67|        28|            0|            0|  0.00%|        self._shape = None
    68|        28|            0|            0|  0.00%|        if self.__class__.__name__ == 'spmatrix':
    69|         0|            0|            0|  0.00%|            raise ValueError("This class is not intended"
    70|         0|            0|            0|  0.00%|                             " to be instantiated directly.")
    71|        28|            0|            0|  0.00%|        self.maxprint = maxprint
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|    def set_shape(self, shape):
    74|         0|            0|            0|  0.00%|        """See `reshape`."""
    75|         0|            0|            0|  0.00%|        # Make sure copy is False since this is in place
    76|         0|            0|            0|  0.00%|        # Make sure format is unchanged because we are doing a __dict__ swap
    77|         0|            0|            0|  0.00%|        new_matrix = self.reshape(shape, copy=False).asformat(self.format)
    78|         0|            0|            0|  0.00%|        self.__dict__ = new_matrix.__dict__
    79|         0|            0|            0|  0.00%|
    80|       160|  0.000997066|  6.23167e-06|  0.00%|    def get_shape(self):
    81|         0|            0|            0|  0.00%|        """Get shape of a matrix."""
    82|       160|            0|            0|  0.00%|        return self._shape
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    shape = property(fget=get_shape, fset=set_shape)
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    def reshape(self, *args, **kwargs):
    87|         0|            0|            0|  0.00%|        """reshape(self, shape, order='C', copy=False)
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|        Gives a new shape to a sparse matrix without changing its data.
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|        Parameters
    92|         0|            0|            0|  0.00%|        ----------
    93|         0|            0|            0|  0.00%|        shape : length-2 tuple of ints
    94|         0|            0|            0|  0.00%|            The new shape should be compatible with the original shape.
    95|         0|            0|            0|  0.00%|        order : {'C', 'F'}, optional
    96|         0|            0|            0|  0.00%|            Read the elements using this index order. 'C' means to read and
    97|         0|            0|            0|  0.00%|            write the elements using C-like index order; e.g., read entire first
    98|         0|            0|            0|  0.00%|            row, then second row, etc. 'F' means to read and write the elements
    99|         0|            0|            0|  0.00%|            using Fortran-like index order; e.g., read entire first column, then
   100|         0|            0|            0|  0.00%|            second column, etc.
   101|         0|            0|            0|  0.00%|        copy : bool, optional
   102|         0|            0|            0|  0.00%|            Indicates whether or not attributes of self should be copied
   103|         0|            0|            0|  0.00%|            whenever possible. The degree to which attributes are copied varies
   104|         0|            0|            0|  0.00%|            depending on the type of sparse matrix being used.
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|        Returns
   107|         0|            0|            0|  0.00%|        -------
   108|         0|            0|            0|  0.00%|        reshaped_matrix : sparse matrix
   109|         0|            0|            0|  0.00%|            A sparse matrix with the given `shape`, not necessarily of the same
   110|         0|            0|            0|  0.00%|            format as the current object.
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|        See Also
   113|         0|            0|            0|  0.00%|        --------
   114|         0|            0|            0|  0.00%|        numpy.matrix.reshape : NumPy's implementation of 'reshape' for
   115|         0|            0|            0|  0.00%|                               matrices
   116|         0|            0|            0|  0.00%|        """
   117|         0|            0|            0|  0.00%|        # If the shape already matches, don't bother doing an actual reshape
   118|         0|            0|            0|  0.00%|        # Otherwise, the default is to convert to COO and use its reshape
   119|         0|            0|            0|  0.00%|        shape = check_shape(args, self.shape)
   120|         0|            0|            0|  0.00%|        order, copy = check_reshape_kwargs(kwargs)
   121|         0|            0|            0|  0.00%|        if shape == self.shape:
   122|         0|            0|            0|  0.00%|            if copy:
   123|         0|            0|            0|  0.00%|                return self.copy()
   124|         0|            0|            0|  0.00%|            else:
   125|         0|            0|            0|  0.00%|                return self
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|        return self.tocoo(copy=copy).reshape(shape, order=order, copy=False)
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    def resize(self, shape):
   130|         0|            0|            0|  0.00%|        """Resize the matrix in-place to dimensions given by ``shape``
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|        Any elements that lie within the new shape will remain at the same
   133|         0|            0|            0|  0.00%|        indices, while non-zero elements lying outside the new shape are
   134|         0|            0|            0|  0.00%|        removed.
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|        Parameters
   137|         0|            0|            0|  0.00%|        ----------
   138|         0|            0|            0|  0.00%|        shape : (int, int)
   139|         0|            0|            0|  0.00%|            number of rows and columns in the new matrix
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|        Notes
   142|         0|            0|            0|  0.00%|        -----
   143|         0|            0|            0|  0.00%|        The semantics are not identical to `numpy.ndarray.resize` or
   144|         0|            0|            0|  0.00%|        `numpy.resize`. Here, the same data will be maintained at each index
   145|         0|            0|            0|  0.00%|        before and after reshape, if that index is within the new bounds. In
   146|         0|            0|            0|  0.00%|        numpy, resizing maintains contiguity of the array, moving elements
   147|         0|            0|            0|  0.00%|        around in the logical matrix but not within a flattened representation.
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|        We give no guarantees about whether the underlying data attributes
   150|         0|            0|            0|  0.00%|        (arrays, etc.) will be modified in place or replaced with new objects.
   151|         0|            0|            0|  0.00%|        """
   152|         0|            0|            0|  0.00%|        # As an inplace operation, this requires implementation in each format.
   153|         0|            0|            0|  0.00%|        raise NotImplementedError(
   154|         0|            0|            0|  0.00%|            '{}.resize is not implemented'.format(type(self).__name__))
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|    def astype(self, dtype, casting='unsafe', copy=True):
   157|         0|            0|            0|  0.00%|        """Cast the matrix elements to a specified type.
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|        Parameters
   160|         0|            0|            0|  0.00%|        ----------
   161|         0|            0|            0|  0.00%|        dtype : string or numpy dtype
   162|         0|            0|            0|  0.00%|            Typecode or data-type to which to cast the data.
   163|         0|            0|            0|  0.00%|        casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
   164|         0|            0|            0|  0.00%|            Controls what kind of data casting may occur.
   165|         0|            0|            0|  0.00%|            Defaults to 'unsafe' for backwards compatibility.
   166|         0|            0|            0|  0.00%|            'no' means the data types should not be cast at all.
   167|         0|            0|            0|  0.00%|            'equiv' means only byte-order changes are allowed.
   168|         0|            0|            0|  0.00%|            'safe' means only casts which can preserve values are allowed.
   169|         0|            0|            0|  0.00%|            'same_kind' means only safe casts or casts within a kind,
   170|         0|            0|            0|  0.00%|            like float64 to float32, are allowed.
   171|         0|            0|            0|  0.00%|            'unsafe' means any data conversions may be done.
   172|         0|            0|            0|  0.00%|        copy : bool, optional
   173|         0|            0|            0|  0.00%|            If `copy` is `False`, the result might share some memory with this
   174|         0|            0|            0|  0.00%|            matrix. If `copy` is `True`, it is guaranteed that the result and
   175|         0|            0|            0|  0.00%|            this matrix do not share any memory.
   176|         0|            0|            0|  0.00%|        """
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|        dtype = np.dtype(dtype)
   179|         0|            0|            0|  0.00%|        if self.dtype != dtype:
   180|         0|            0|            0|  0.00%|            return self.tocsr().astype(
   181|         0|            0|            0|  0.00%|                dtype, casting=casting, copy=copy).asformat(self.format)
   182|         0|            0|            0|  0.00%|        elif copy:
   183|         0|            0|            0|  0.00%|            return self.copy()
   184|         0|            0|            0|  0.00%|        else:
   185|         0|            0|            0|  0.00%|            return self
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    def asfptype(self):
   188|         0|            0|            0|  0.00%|        """Upcast matrix to a floating point format (if necessary)"""
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|        fp_types = ['f', 'd', 'F', 'D']
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|        if self.dtype.char in fp_types:
   193|         0|            0|            0|  0.00%|            return self
   194|         0|            0|            0|  0.00%|        else:
   195|         0|            0|            0|  0.00%|            for fp_type in fp_types:
   196|         0|            0|            0|  0.00%|                if self.dtype <= np.dtype(fp_type):
   197|         0|            0|            0|  0.00%|                    return self.astype(fp_type)
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|            raise TypeError('cannot upcast [%s] to a floating '
   200|         0|            0|            0|  0.00%|                            'point format' % self.dtype.name)
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    def __iter__(self):
   203|         0|            0|            0|  0.00%|        for r in range(self.shape[0]):
   204|         0|            0|            0|  0.00%|            yield self[r, :]
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|    def getmaxprint(self):
   207|         0|            0|            0|  0.00%|        """Maximum number of elements to display when printed."""
   208|         0|            0|            0|  0.00%|        return self.maxprint
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|    def count_nonzero(self):
   211|         0|            0|            0|  0.00%|        """Number of non-zero entries, equivalent to
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|        np.count_nonzero(a.toarray())
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|        Unlike getnnz() and the nnz property, which return the number of stored
   216|         0|            0|            0|  0.00%|        entries (the length of the data attribute), this method counts the
   217|         0|            0|            0|  0.00%|        actual number of non-zero entries in data.
   218|         0|            0|            0|  0.00%|        """
   219|         0|            0|            0|  0.00%|        raise NotImplementedError("count_nonzero not implemented for %s." %
   220|         0|            0|            0|  0.00%|                                  self.__class__.__name__)
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|    def getnnz(self, axis=None):
   223|         0|            0|            0|  0.00%|        """Number of stored values, including explicit zeros.
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|        Parameters
   226|         0|            0|            0|  0.00%|        ----------
   227|         0|            0|            0|  0.00%|        axis : None, 0, or 1
   228|         0|            0|            0|  0.00%|            Select between the number of values across the whole matrix, in
   229|         0|            0|            0|  0.00%|            each column, or in each row.
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|        See also
   232|         0|            0|            0|  0.00%|        --------
   233|         0|            0|            0|  0.00%|        count_nonzero : Number of non-zero entries
   234|         0|            0|            0|  0.00%|        """
   235|         0|            0|            0|  0.00%|        raise NotImplementedError("getnnz not implemented for %s." %
   236|         0|            0|            0|  0.00%|                                  self.__class__.__name__)
   237|         0|            0|            0|  0.00%|
   238|        96|  0.000980377|  1.02123e-05|  0.00%|    @property
   239|         0|            0|            0|  0.00%|    def nnz(self):
   240|         0|            0|            0|  0.00%|        """Number of stored values, including explicit zeros.
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|        See also
   243|         0|            0|            0|  0.00%|        --------
   244|         0|            0|            0|  0.00%|        count_nonzero : Number of non-zero entries
   245|         0|            0|            0|  0.00%|        """
   246|        96|  0.000997543|  1.03911e-05|  0.00%|        return self.getnnz()
(call)|        24|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:239 getnnz
(call)|        72|  0.000992298|  1.37819e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:108 getnnz
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    def getformat(self):
   249|         0|            0|            0|  0.00%|        """Format of a matrix representation as a string."""
   250|         0|            0|            0|  0.00%|        return getattr(self, 'format', 'und')
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    def __repr__(self):
   253|         0|            0|            0|  0.00%|        _, format_name = _formats[self.getformat()]
   254|         0|            0|            0|  0.00%|        return "<%dx%d sparse matrix of type '%s'\n" \
   255|         0|            0|            0|  0.00%|               "\twith %d stored elements in %s format>" % \
   256|         0|            0|            0|  0.00%|               (self.shape + (self.dtype.type, self.nnz, format_name))
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|    def __str__(self):
   259|         0|            0|            0|  0.00%|        maxprint = self.getmaxprint()
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|        A = self.tocoo()
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|        # helper function, outputs "(i,j)  v"
   264|         0|            0|            0|  0.00%|        def tostr(row, col, data):
   265|         0|            0|            0|  0.00%|            triples = zip(list(zip(row, col)), data)
   266|         0|            0|            0|  0.00%|            return '\n'.join([('  %s\t%s' % t) for t in triples])
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|        if self.nnz > maxprint:
   269|         0|            0|            0|  0.00%|            half = maxprint // 2
   270|         0|            0|            0|  0.00%|            out = tostr(A.row[:half], A.col[:half], A.data[:half])
   271|         0|            0|            0|  0.00%|            out += "\n  :\t:\n"
   272|         0|            0|            0|  0.00%|            half = maxprint - maxprint//2
   273|         0|            0|            0|  0.00%|            out += tostr(A.row[-half:], A.col[-half:], A.data[-half:])
   274|         0|            0|            0|  0.00%|        else:
   275|         0|            0|            0|  0.00%|            out = tostr(A.row, A.col, A.data)
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|        return out
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|    def __bool__(self):  # Simple -- other ideas?
   280|         0|            0|            0|  0.00%|        if self.shape == (1, 1):
   281|         0|            0|            0|  0.00%|            return self.nnz != 0
   282|         0|            0|            0|  0.00%|        else:
   283|         0|            0|            0|  0.00%|            raise ValueError("The truth value of an array with more than one "
   284|         0|            0|            0|  0.00%|                             "element is ambiguous. Use a.any() or a.all().")
   285|         0|            0|            0|  0.00%|    __nonzero__ = __bool__
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|    # What should len(sparse) return? For consistency with dense matrices,
   288|         0|            0|            0|  0.00%|    # perhaps it should be the number of rows?  But for some uses the number of
   289|         0|            0|            0|  0.00%|    # non-zeros is more important.  For now, raise an exception!
   290|         0|            0|            0|  0.00%|    def __len__(self):
   291|         0|            0|            0|  0.00%|        raise TypeError("sparse matrix length is ambiguous; use getnnz()"
   292|         0|            0|            0|  0.00%|                        " or shape[0]")
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|    def asformat(self, format, copy=False):
   295|         0|            0|            0|  0.00%|        """Return this matrix in the passed format.
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|        Parameters
   298|         0|            0|            0|  0.00%|        ----------
   299|         0|            0|            0|  0.00%|        format : {str, None}
   300|         0|            0|            0|  0.00%|            The desired matrix format ("csr", "csc", "lil", "dok", "array", ...)
   301|         0|            0|            0|  0.00%|            or None for no conversion.
   302|         0|            0|            0|  0.00%|        copy : bool, optional
   303|         0|            0|            0|  0.00%|            If True, the result is guaranteed to not share data with self.
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|        Returns
   306|         0|            0|            0|  0.00%|        -------
   307|         0|            0|            0|  0.00%|        A : This matrix in the passed format.
   308|         0|            0|            0|  0.00%|        """
   309|         0|            0|            0|  0.00%|        if format is None or format == self.format:
   310|         0|            0|            0|  0.00%|            if copy:
   311|         0|            0|            0|  0.00%|                return self.copy()
   312|         0|            0|            0|  0.00%|            else:
   313|         0|            0|            0|  0.00%|                return self
   314|         0|            0|            0|  0.00%|        else:
   315|         0|            0|            0|  0.00%|            try:
   316|         0|            0|            0|  0.00%|                convert_method = getattr(self, 'to' + format)
   317|         0|            0|            0|  0.00%|            except AttributeError as e:
   318|         0|            0|            0|  0.00%|                raise ValueError('Format {} is unknown.'.format(format)) from e
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|            # Forward the copy kwarg, if it's accepted.
   321|         0|            0|            0|  0.00%|            try:
   322|         0|            0|            0|  0.00%|                return convert_method(copy=copy)
   323|         0|            0|            0|  0.00%|            except TypeError:
   324|         0|            0|            0|  0.00%|                return convert_method()
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    ###################################################################
   327|         0|            0|            0|  0.00%|    #  NOTE: All arithmetic operations use csr_matrix by default.
   328|         0|            0|            0|  0.00%|    # Therefore a new sparse matrix format just needs to define a
   329|         0|            0|            0|  0.00%|    # .tocsr() method to provide arithmetic support. Any of these
   330|         0|            0|            0|  0.00%|    # methods can be overridden for efficiency.
   331|         0|            0|            0|  0.00%|    ####################################################################
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    def multiply(self, other):
   334|         0|            0|            0|  0.00%|        """Point-wise multiplication by another matrix
   335|         0|            0|            0|  0.00%|        """
   336|         0|            0|            0|  0.00%|        return self.tocsr().multiply(other)
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    def maximum(self, other):
   339|         0|            0|            0|  0.00%|        """Element-wise maximum between this and another matrix."""
   340|         0|            0|            0|  0.00%|        return self.tocsr().maximum(other)
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|    def minimum(self, other):
   343|         0|            0|            0|  0.00%|        """Element-wise minimum between this and another matrix."""
   344|         0|            0|            0|  0.00%|        return self.tocsr().minimum(other)
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    def dot(self, other):
   347|         0|            0|            0|  0.00%|        """Ordinary dot product
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|        Examples
   350|         0|            0|            0|  0.00%|        --------
   351|         0|            0|            0|  0.00%|        >>> import numpy as np
   352|         0|            0|            0|  0.00%|        >>> from scipy.sparse import csr_matrix
   353|         0|            0|            0|  0.00%|        >>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
   354|         0|            0|            0|  0.00%|        >>> v = np.array([1, 0, -1])
   355|         0|            0|            0|  0.00%|        >>> A.dot(v)
   356|         0|            0|            0|  0.00%|        array([ 1, -3, -1], dtype=int64)
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|        """
   359|         0|            0|            0|  0.00%|        return self * other
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    def power(self, n, dtype=None):
   362|         0|            0|            0|  0.00%|        """Element-wise power."""
   363|         0|            0|            0|  0.00%|        return self.tocsr().power(n, dtype=dtype)
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|    def __eq__(self, other):
   366|         0|            0|            0|  0.00%|        return self.tocsr().__eq__(other)
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|    def __ne__(self, other):
   369|         0|            0|            0|  0.00%|        return self.tocsr().__ne__(other)
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|    def __lt__(self, other):
   372|         0|            0|            0|  0.00%|        return self.tocsr().__lt__(other)
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    def __gt__(self, other):
   375|         0|            0|            0|  0.00%|        return self.tocsr().__gt__(other)
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    def __le__(self, other):
   378|         0|            0|            0|  0.00%|        return self.tocsr().__le__(other)
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    def __ge__(self, other):
   381|         0|            0|            0|  0.00%|        return self.tocsr().__ge__(other)
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|    def __abs__(self):
   384|         0|            0|            0|  0.00%|        return abs(self.tocsr())
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|    def __round__(self, ndigits=0):
   387|         0|            0|            0|  0.00%|        return round(self.tocsr(), ndigits=ndigits)
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    def _add_sparse(self, other):
   390|         0|            0|            0|  0.00%|        return self.tocsr()._add_sparse(other)
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|    def _add_dense(self, other):
   393|         0|            0|            0|  0.00%|        return self.tocoo()._add_dense(other)
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    def _sub_sparse(self, other):
   396|         0|            0|            0|  0.00%|        return self.tocsr()._sub_sparse(other)
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    def _sub_dense(self, other):
   399|         0|            0|            0|  0.00%|        return self.todense() - other
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|    def _rsub_dense(self, other):
   402|         0|            0|            0|  0.00%|        # note: this can't be replaced by other + (-self) for unsigned types
   403|         0|            0|            0|  0.00%|        return other - self.todense()
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    def __add__(self, other):  # self + other
   406|         0|            0|            0|  0.00%|        if isscalarlike(other):
   407|         0|            0|            0|  0.00%|            if other == 0:
   408|         0|            0|            0|  0.00%|                return self.copy()
   409|         0|            0|            0|  0.00%|            # Now we would add this scalar to every element.
   410|         0|            0|            0|  0.00%|            raise NotImplementedError('adding a nonzero scalar to a '
   411|         0|            0|            0|  0.00%|                                      'sparse matrix is not supported')
   412|         0|            0|            0|  0.00%|        elif isspmatrix(other):
   413|         0|            0|            0|  0.00%|            if other.shape != self.shape:
   414|         0|            0|            0|  0.00%|                raise ValueError("inconsistent shapes")
   415|         0|            0|            0|  0.00%|            return self._add_sparse(other)
   416|         0|            0|            0|  0.00%|        elif isdense(other):
   417|         0|            0|            0|  0.00%|            other = np.broadcast_to(other, self.shape)
   418|         0|            0|            0|  0.00%|            return self._add_dense(other)
   419|         0|            0|            0|  0.00%|        else:
   420|         0|            0|            0|  0.00%|            return NotImplemented
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    def __radd__(self,other):  # other + self
   423|         0|            0|            0|  0.00%|        return self.__add__(other)
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|    def __sub__(self, other):  # self - other
   426|         0|            0|            0|  0.00%|        if isscalarlike(other):
   427|         0|            0|            0|  0.00%|            if other == 0:
   428|         0|            0|            0|  0.00%|                return self.copy()
   429|         0|            0|            0|  0.00%|            raise NotImplementedError('subtracting a nonzero scalar from a '
   430|         0|            0|            0|  0.00%|                                      'sparse matrix is not supported')
   431|         0|            0|            0|  0.00%|        elif isspmatrix(other):
   432|         0|            0|            0|  0.00%|            if other.shape != self.shape:
   433|         0|            0|            0|  0.00%|                raise ValueError("inconsistent shapes")
   434|         0|            0|            0|  0.00%|            return self._sub_sparse(other)
   435|         0|            0|            0|  0.00%|        elif isdense(other):
   436|         0|            0|            0|  0.00%|            other = np.broadcast_to(other, self.shape)
   437|         0|            0|            0|  0.00%|            return self._sub_dense(other)
   438|         0|            0|            0|  0.00%|        else:
   439|         0|            0|            0|  0.00%|            return NotImplemented
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|    def __rsub__(self,other):  # other - self
   442|         0|            0|            0|  0.00%|        if isscalarlike(other):
   443|         0|            0|            0|  0.00%|            if other == 0:
   444|         0|            0|            0|  0.00%|                return -self.copy()
   445|         0|            0|            0|  0.00%|            raise NotImplementedError('subtracting a sparse matrix from a '
   446|         0|            0|            0|  0.00%|                                      'nonzero scalar is not supported')
   447|         0|            0|            0|  0.00%|        elif isdense(other):
   448|         0|            0|            0|  0.00%|            other = np.broadcast_to(other, self.shape)
   449|         0|            0|            0|  0.00%|            return self._rsub_dense(other)
   450|         0|            0|            0|  0.00%|        else:
   451|         0|            0|            0|  0.00%|            return NotImplemented
   452|         0|            0|            0|  0.00%|
   453|         8|            0|            0|  0.00%|    def __mul__(self, other):
   454|         0|            0|            0|  0.00%|        """interpret other and call one of the following
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|        self._mul_scalar()
   457|         0|            0|            0|  0.00%|        self._mul_vector()
   458|         0|            0|            0|  0.00%|        self._mul_multivector()
   459|         0|            0|            0|  0.00%|        self._mul_sparse_matrix()
   460|         0|            0|            0|  0.00%|        """
   461|         0|            0|            0|  0.00%|
   462|         8|            0|            0|  0.00%|        M, N = self.shape
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   463|         0|            0|            0|  0.00%|
   464|         8|            0|            0|  0.00%|        if other.__class__ is np.ndarray:
   465|         0|            0|            0|  0.00%|            # Fast path for the most common case
   466|         0|            0|            0|  0.00%|            if other.shape == (N,):
   467|         0|            0|            0|  0.00%|                return self._mul_vector(other)
   468|         0|            0|            0|  0.00%|            elif other.shape == (N, 1):
   469|         0|            0|            0|  0.00%|                return self._mul_vector(other.ravel()).reshape(M, 1)
   470|         0|            0|            0|  0.00%|            elif other.ndim == 2 and other.shape[0] == N:
   471|         0|            0|            0|  0.00%|                return self._mul_multivector(other)
   472|         0|            0|            0|  0.00%|
   473|         8|            0|            0|  0.00%|        if isscalarlike(other):
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:193 isscalarlike
   474|         0|            0|            0|  0.00%|            # scalar value
   475|         0|            0|            0|  0.00%|            return self._mul_scalar(other)
   476|         0|            0|            0|  0.00%|
   477|         8|            0|            0|  0.00%|        if issparse(other):
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:1205 isspmatrix
   478|         0|            0|            0|  0.00%|            if self.shape[1] != other.shape[0]:
   479|         0|            0|            0|  0.00%|                raise ValueError('dimension mismatch')
   480|         0|            0|            0|  0.00%|            return self._mul_sparse_matrix(other)
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|        # If it's a list or whatever, treat it like a matrix
   483|         8|            0|            0|  0.00%|        other_a = np.asanyarray(other)
   484|         0|            0|            0|  0.00%|
   485|         8|            0|            0|  0.00%|        if other_a.ndim == 0 and other_a.dtype == np.object_:
   486|         0|            0|            0|  0.00%|            # Not interpretable as an array; return NotImplemented so that
   487|         0|            0|            0|  0.00%|            # other's __rmul__ can kick in if that's implemented.
   488|         0|            0|            0|  0.00%|            return NotImplemented
   489|         0|            0|            0|  0.00%|
   490|         8|            0|            0|  0.00%|        try:
   491|         8|            0|            0|  0.00%|            other.shape
   492|         0|            0|            0|  0.00%|        except AttributeError:
   493|         0|            0|            0|  0.00%|            other = other_a
   494|         0|            0|            0|  0.00%|
   495|         8|            0|            0|  0.00%|        if other.ndim == 1 or other.ndim == 2 and other.shape[1] == 1:
   496|         0|            0|            0|  0.00%|            # dense row or column vector
   497|         8|            0|            0|  0.00%|            if other.shape != (N,) and other.shape != (N, 1):
   498|         0|            0|            0|  0.00%|                raise ValueError('dimension mismatch')
   499|         0|            0|            0|  0.00%|
   500|         8|            0|            0|  0.00%|            result = self._mul_vector(np.ravel(other))
(call)|         8|            0|            0|  0.00%|# <__array_function__ internals>:177 ravel
(call)|         8|  0.000968695|  0.000121087|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:469 _mul_vector
   501|         0|            0|            0|  0.00%|
   502|         8|            0|            0|  0.00%|            if isinstance(other, np.matrix):
   503|         8|            0|            0|  0.00%|                result = asmatrix(result)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:363 asmatrix
   504|         0|            0|            0|  0.00%|
   505|         8|            0|            0|  0.00%|            if other.ndim == 2 and other.shape[1] == 1:
   506|         0|            0|            0|  0.00%|                # If 'other' was an (nx1) column vector, reshape the result
   507|         8|            0|            0|  0.00%|                result = result.reshape(-1, 1)
(call)|         8|  0.000997066|  0.000124633|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:167 __array_finalize__
   508|         0|            0|            0|  0.00%|
   509|         8|            0|            0|  0.00%|            return result
   510|         0|            0|            0|  0.00%|
   511|         0|            0|            0|  0.00%|        elif other.ndim == 2:
   512|         0|            0|            0|  0.00%|            ##
   513|         0|            0|            0|  0.00%|            # dense 2D array or matrix ("multivector")
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|            if other.shape[0] != self.shape[1]:
   516|         0|            0|            0|  0.00%|                raise ValueError('dimension mismatch')
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|            result = self._mul_multivector(np.asarray(other))
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|            if isinstance(other, np.matrix):
   521|         0|            0|            0|  0.00%|                result = asmatrix(result)
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|            return result
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|        else:
   526|         0|            0|            0|  0.00%|            raise ValueError('could not interpret dimensions')
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|    # by default, use CSR for __mul__ handlers
   529|         0|            0|            0|  0.00%|    def _mul_scalar(self, other):
   530|         0|            0|            0|  0.00%|        return self.tocsr()._mul_scalar(other)
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|    def _mul_vector(self, other):
   533|         0|            0|            0|  0.00%|        return self.tocsr()._mul_vector(other)
   534|         0|            0|            0|  0.00%|
   535|         0|            0|            0|  0.00%|    def _mul_multivector(self, other):
   536|         0|            0|            0|  0.00%|        return self.tocsr()._mul_multivector(other)
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|    def _mul_sparse_matrix(self, other):
   539|         0|            0|            0|  0.00%|        return self.tocsr()._mul_sparse_matrix(other)
   540|         0|            0|            0|  0.00%|
   541|         4|            0|            0|  0.00%|    def __rmul__(self, other):  # other * self
   542|         4|            0|            0|  0.00%|        if isscalarlike(other):
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:193 isscalarlike
   543|         0|            0|            0|  0.00%|            return self.__mul__(other)
   544|         0|            0|            0|  0.00%|        else:
   545|         0|            0|            0|  0.00%|            # Don't use asarray unless we have to
   546|         4|            0|            0|  0.00%|            try:
   547|         4|            0|            0|  0.00%|                tr = other.transpose()
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:167 __array_finalize__
   548|         0|            0|            0|  0.00%|            except AttributeError:
   549|         0|            0|            0|  0.00%|                tr = np.asarray(other).transpose()
   550|         4|            0|            0|  0.00%|            return (self.transpose() * tr).transpose()
(call)|         4|   0.00401998|   0.00100499|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py:135 transpose
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:453 __mul__
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:167 __array_finalize__
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|    #######################
   553|         0|            0|            0|  0.00%|    # matmul (@) operator #
   554|         0|            0|            0|  0.00%|    #######################
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    def __matmul__(self, other):
   557|         0|            0|            0|  0.00%|        if isscalarlike(other):
   558|         0|            0|            0|  0.00%|            raise ValueError("Scalar operands are not allowed, "
   559|         0|            0|            0|  0.00%|                             "use '*' instead")
   560|         0|            0|            0|  0.00%|        return self.__mul__(other)
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    def __rmatmul__(self, other):
   563|         0|            0|            0|  0.00%|        if isscalarlike(other):
   564|         0|            0|            0|  0.00%|            raise ValueError("Scalar operands are not allowed, "
   565|         0|            0|            0|  0.00%|                             "use '*' instead")
   566|         0|            0|            0|  0.00%|        return self.__rmul__(other)
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    ####################
   569|         0|            0|            0|  0.00%|    # Other Arithmetic #
   570|         0|            0|            0|  0.00%|    ####################
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    def _divide(self, other, true_divide=False, rdivide=False):
   573|         0|            0|            0|  0.00%|        if isscalarlike(other):
   574|         0|            0|            0|  0.00%|            if rdivide:
   575|         0|            0|            0|  0.00%|                if true_divide:
   576|         0|            0|            0|  0.00%|                    return np.true_divide(other, self.todense())
   577|         0|            0|            0|  0.00%|                else:
   578|         0|            0|            0|  0.00%|                    return np.divide(other, self.todense())
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|            if true_divide and np.can_cast(self.dtype, np.float_):
   581|         0|            0|            0|  0.00%|                return self.astype(np.float_)._mul_scalar(1./other)
   582|         0|            0|            0|  0.00%|            else:
   583|         0|            0|            0|  0.00%|                r = self._mul_scalar(1./other)
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|                scalar_dtype = np.asarray(other).dtype
   586|         0|            0|            0|  0.00%|                if (np.issubdtype(self.dtype, np.integer) and
   587|         0|            0|            0|  0.00%|                        np.issubdtype(scalar_dtype, np.integer)):
   588|         0|            0|            0|  0.00%|                    return r.astype(self.dtype)
   589|         0|            0|            0|  0.00%|                else:
   590|         0|            0|            0|  0.00%|                    return r
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|        elif isdense(other):
   593|         0|            0|            0|  0.00%|            if not rdivide:
   594|         0|            0|            0|  0.00%|                if true_divide:
   595|         0|            0|            0|  0.00%|                    return np.true_divide(self.todense(), other)
   596|         0|            0|            0|  0.00%|                else:
   597|         0|            0|            0|  0.00%|                    return np.divide(self.todense(), other)
   598|         0|            0|            0|  0.00%|            else:
   599|         0|            0|            0|  0.00%|                if true_divide:
   600|         0|            0|            0|  0.00%|                    return np.true_divide(other, self.todense())
   601|         0|            0|            0|  0.00%|                else:
   602|         0|            0|            0|  0.00%|                    return np.divide(other, self.todense())
   603|         0|            0|            0|  0.00%|        elif isspmatrix(other):
   604|         0|            0|            0|  0.00%|            if rdivide:
   605|         0|            0|            0|  0.00%|                return other._divide(self, true_divide, rdivide=False)
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|            self_csr = self.tocsr()
   608|         0|            0|            0|  0.00%|            if true_divide and np.can_cast(self.dtype, np.float_):
   609|         0|            0|            0|  0.00%|                return self_csr.astype(np.float_)._divide_sparse(other)
   610|         0|            0|            0|  0.00%|            else:
   611|         0|            0|            0|  0.00%|                return self_csr._divide_sparse(other)
   612|         0|            0|            0|  0.00%|        else:
   613|         0|            0|            0|  0.00%|            return NotImplemented
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    def __truediv__(self, other):
   616|         0|            0|            0|  0.00%|        return self._divide(other, true_divide=True)
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|    def __div__(self, other):
   619|         0|            0|            0|  0.00%|        # Always do true division
   620|         0|            0|            0|  0.00%|        return self._divide(other, true_divide=True)
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|    def __rtruediv__(self, other):
   623|         0|            0|            0|  0.00%|        # Implementing this as the inverse would be too magical -- bail out
   624|         0|            0|            0|  0.00%|        return NotImplemented
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|    def __rdiv__(self, other):
   627|         0|            0|            0|  0.00%|        # Implementing this as the inverse would be too magical -- bail out
   628|         0|            0|            0|  0.00%|        return NotImplemented
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|    def __neg__(self):
   631|         0|            0|            0|  0.00%|        return -self.tocsr()
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|    def __iadd__(self, other):
   634|         0|            0|            0|  0.00%|        return NotImplemented
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|    def __isub__(self, other):
   637|         0|            0|            0|  0.00%|        return NotImplemented
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|    def __imul__(self, other):
   640|         0|            0|            0|  0.00%|        return NotImplemented
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    def __idiv__(self, other):
   643|         0|            0|            0|  0.00%|        return self.__itruediv__(other)
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    def __itruediv__(self, other):
   646|         0|            0|            0|  0.00%|        return NotImplemented
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|    def __pow__(self, other):
   649|         0|            0|            0|  0.00%|        if self.shape[0] != self.shape[1]:
   650|         0|            0|            0|  0.00%|            raise TypeError('matrix is not square')
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|        if isintlike(other):
   653|         0|            0|            0|  0.00%|            other = int(other)
   654|         0|            0|            0|  0.00%|            if other < 0:
   655|         0|            0|            0|  0.00%|                raise ValueError('exponent must be >= 0')
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|            if other == 0:
   658|         0|            0|            0|  0.00%|                from .construct import eye
   659|         0|            0|            0|  0.00%|                return eye(self.shape[0], dtype=self.dtype)
   660|         0|            0|            0|  0.00%|            elif other == 1:
   661|         0|            0|            0|  0.00%|                return self.copy()
   662|         0|            0|            0|  0.00%|            else:
   663|         0|            0|            0|  0.00%|                tmp = self.__pow__(other//2)
   664|         0|            0|            0|  0.00%|                if (other % 2):
   665|         0|            0|            0|  0.00%|                    return self * tmp * tmp
   666|         0|            0|            0|  0.00%|                else:
   667|         0|            0|            0|  0.00%|                    return tmp * tmp
   668|         0|            0|            0|  0.00%|        elif isscalarlike(other):
   669|         0|            0|            0|  0.00%|            raise ValueError('exponent must be an integer')
   670|         0|            0|            0|  0.00%|        else:
   671|         0|            0|            0|  0.00%|            return NotImplemented
   672|         0|            0|            0|  0.00%|
   673|        42|            0|            0|  0.00%|    def __getattr__(self, attr):
   674|        42|            0|            0|  0.00%|        if attr == 'A':
   675|         0|            0|            0|  0.00%|            return self.toarray()
   676|        42|            0|            0|  0.00%|        elif attr == 'T':
   677|         0|            0|            0|  0.00%|            return self.transpose()
   678|        42|            0|            0|  0.00%|        elif attr == 'H':
   679|         0|            0|            0|  0.00%|            return self.getH()
   680|        42|            0|            0|  0.00%|        elif attr == 'real':
   681|         0|            0|            0|  0.00%|            return self._real()
   682|        42|            0|            0|  0.00%|        elif attr == 'imag':
   683|         0|            0|            0|  0.00%|            return self._imag()
   684|        42|            0|            0|  0.00%|        elif attr == 'size':
   685|         0|            0|            0|  0.00%|            return self.getnnz()
   686|         0|            0|            0|  0.00%|        else:
   687|        42|            0|            0|  0.00%|            raise AttributeError(attr + " not found")
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    def transpose(self, axes=None, copy=False):
   690|         0|            0|            0|  0.00%|        """
   691|         0|            0|            0|  0.00%|        Reverses the dimensions of the sparse matrix.
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|        Parameters
   694|         0|            0|            0|  0.00%|        ----------
   695|         0|            0|            0|  0.00%|        axes : None, optional
   696|         0|            0|            0|  0.00%|            This argument is in the signature *solely* for NumPy
   697|         0|            0|            0|  0.00%|            compatibility reasons. Do not pass in anything except
   698|         0|            0|            0|  0.00%|            for the default value.
   699|         0|            0|            0|  0.00%|        copy : bool, optional
   700|         0|            0|            0|  0.00%|            Indicates whether or not attributes of `self` should be
   701|         0|            0|            0|  0.00%|            copied whenever possible. The degree to which attributes
   702|         0|            0|            0|  0.00%|            are copied varies depending on the type of sparse matrix
   703|         0|            0|            0|  0.00%|            being used.
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|        Returns
   706|         0|            0|            0|  0.00%|        -------
   707|         0|            0|            0|  0.00%|        p : `self` with the dimensions reversed.
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        See Also
   710|         0|            0|            0|  0.00%|        --------
   711|         0|            0|            0|  0.00%|        numpy.matrix.transpose : NumPy's implementation of 'transpose'
   712|         0|            0|            0|  0.00%|                                 for matrices
   713|         0|            0|            0|  0.00%|        """
   714|         0|            0|            0|  0.00%|        return self.tocsr(copy=copy).transpose(axes=axes, copy=False)
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|    def conj(self, copy=True):
   717|         0|            0|            0|  0.00%|        """Element-wise complex conjugation.
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|        If the matrix is of non-complex data type and `copy` is False,
   720|         0|            0|            0|  0.00%|        this method does nothing and the data is not copied.
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|        Parameters
   723|         0|            0|            0|  0.00%|        ----------
   724|         0|            0|            0|  0.00%|        copy : bool, optional
   725|         0|            0|            0|  0.00%|            If True, the result is guaranteed to not share data with self.
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|        Returns
   728|         0|            0|            0|  0.00%|        -------
   729|         0|            0|            0|  0.00%|        A : The element-wise complex conjugate.
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|        """
   732|         0|            0|            0|  0.00%|        if np.issubdtype(self.dtype, np.complexfloating):
   733|         0|            0|            0|  0.00%|            return self.tocsr(copy=copy).conj(copy=False)
   734|         0|            0|            0|  0.00%|        elif copy:
   735|         0|            0|            0|  0.00%|            return self.copy()
   736|         0|            0|            0|  0.00%|        else:
   737|         0|            0|            0|  0.00%|            return self
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|    def conjugate(self, copy=True):
   740|         0|            0|            0|  0.00%|        return self.conj(copy=copy)
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|    conjugate.__doc__ = conj.__doc__
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|    # Renamed conjtranspose() -> getH() for compatibility with dense matrices
   745|         0|            0|            0|  0.00%|    def getH(self):
   746|         0|            0|            0|  0.00%|        """Return the Hermitian transpose of this matrix.
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|        See Also
   749|         0|            0|            0|  0.00%|        --------
   750|         0|            0|            0|  0.00%|        numpy.matrix.getH : NumPy's implementation of `getH` for matrices
   751|         0|            0|            0|  0.00%|        """
   752|         0|            0|            0|  0.00%|        return self.transpose().conj()
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|    def _real(self):
   755|         0|            0|            0|  0.00%|        return self.tocsr()._real()
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|    def _imag(self):
   758|         0|            0|            0|  0.00%|        return self.tocsr()._imag()
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|    def nonzero(self):
   761|         0|            0|            0|  0.00%|        """nonzero indices
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|        Returns a tuple of arrays (row,col) containing the indices
   764|         0|            0|            0|  0.00%|        of the non-zero elements of the matrix.
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|        Examples
   767|         0|            0|            0|  0.00%|        --------
   768|         0|            0|            0|  0.00%|        >>> from scipy.sparse import csr_matrix
   769|         0|            0|            0|  0.00%|        >>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
   770|         0|            0|            0|  0.00%|        >>> A.nonzero()
   771|         0|            0|            0|  0.00%|        (array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|        """
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|        # convert to COOrdinate format
   776|         0|            0|            0|  0.00%|        A = self.tocoo()
   777|         0|            0|            0|  0.00%|        nz_mask = A.data != 0
   778|         0|            0|            0|  0.00%|        return (A.row[nz_mask], A.col[nz_mask])
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|    def getcol(self, j):
   781|         0|            0|            0|  0.00%|        """Returns a copy of column j of the matrix, as an (m x 1) sparse
   782|         0|            0|            0|  0.00%|        matrix (column vector).
   783|         0|            0|            0|  0.00%|        """
   784|         0|            0|            0|  0.00%|        # Spmatrix subclasses should override this method for efficiency.
   785|         0|            0|            0|  0.00%|        # Post-multiply by a (n x 1) column vector 'a' containing all zeros
   786|         0|            0|            0|  0.00%|        # except for a_j = 1
   787|         0|            0|            0|  0.00%|        from .csc import csc_matrix
   788|         0|            0|            0|  0.00%|        n = self.shape[1]
   789|         0|            0|            0|  0.00%|        if j < 0:
   790|         0|            0|            0|  0.00%|            j += n
   791|         0|            0|            0|  0.00%|        if j < 0 or j >= n:
   792|         0|            0|            0|  0.00%|            raise IndexError("index out of bounds")
   793|         0|            0|            0|  0.00%|        col_selector = csc_matrix(([1], [[j], [0]]),
   794|         0|            0|            0|  0.00%|                                  shape=(n, 1), dtype=self.dtype)
   795|         0|            0|            0|  0.00%|        return self * col_selector
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|    def getrow(self, i):
   798|         0|            0|            0|  0.00%|        """Returns a copy of row i of the matrix, as a (1 x n) sparse
   799|         0|            0|            0|  0.00%|        matrix (row vector).
   800|         0|            0|            0|  0.00%|        """
   801|         0|            0|            0|  0.00%|        # Spmatrix subclasses should override this method for efficiency.
   802|         0|            0|            0|  0.00%|        # Pre-multiply by a (1 x m) row vector 'a' containing all zeros
   803|         0|            0|            0|  0.00%|        # except for a_i = 1
   804|         0|            0|            0|  0.00%|        from .csr import csr_matrix
   805|         0|            0|            0|  0.00%|        m = self.shape[0]
   806|         0|            0|            0|  0.00%|        if i < 0:
   807|         0|            0|            0|  0.00%|            i += m
   808|         0|            0|            0|  0.00%|        if i < 0 or i >= m:
   809|         0|            0|            0|  0.00%|            raise IndexError("index out of bounds")
   810|         0|            0|            0|  0.00%|        row_selector = csr_matrix(([1], [[0], [i]]),
   811|         0|            0|            0|  0.00%|                                  shape=(1, m), dtype=self.dtype)
   812|         0|            0|            0|  0.00%|        return row_selector * self
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|    # The following dunder methods cannot be implemented.
   815|         0|            0|            0|  0.00%|    #
   816|         0|            0|            0|  0.00%|    # def __array__(self):
   817|         0|            0|            0|  0.00%|    #     # Sparse matrices rely on NumPy wrapping them in object arrays under
   818|         0|            0|            0|  0.00%|    #     # the hood to make unary ufuncs work on them. So we cannot raise
   819|         0|            0|            0|  0.00%|    #     # TypeError here - which would be handy to not give users object
   820|         0|            0|            0|  0.00%|    #     # arrays they probably don't want (they're looking for `.toarray()`).
   821|         0|            0|            0|  0.00%|    #     #
   822|         0|            0|            0|  0.00%|    #     # Conversion with `toarray()` would also break things because of the
   823|         0|            0|            0|  0.00%|    #     # behavior discussed above, plus we want to avoid densification by
   824|         0|            0|            0|  0.00%|    #     # accident because that can too easily blow up memory.
   825|         0|            0|            0|  0.00%|    #
   826|         0|            0|            0|  0.00%|    # def __array_ufunc__(self):
   827|         0|            0|            0|  0.00%|    #     # We cannot implement __array_ufunc__ due to mismatching semantics.
   828|         0|            0|            0|  0.00%|    #     # See gh-7707 and gh-7349 for details.
   829|         0|            0|            0|  0.00%|    #
   830|         0|            0|            0|  0.00%|    # def __array_function__(self):
   831|         0|            0|            0|  0.00%|    #     # We cannot implement __array_function__ due to mismatching semantics.
   832|         0|            0|            0|  0.00%|    #     # See gh-10362 for details.
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|    def todense(self, order=None, out=None):
   835|         0|            0|            0|  0.00%|        """
   836|         0|            0|            0|  0.00%|        Return a dense matrix representation of this matrix.
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|        Parameters
   839|         0|            0|            0|  0.00%|        ----------
   840|         0|            0|            0|  0.00%|        order : {'C', 'F'}, optional
   841|         0|            0|            0|  0.00%|            Whether to store multi-dimensional data in C (row-major)
   842|         0|            0|            0|  0.00%|            or Fortran (column-major) order in memory. The default
   843|         0|            0|            0|  0.00%|            is 'None', indicating the NumPy default of C-ordered.
   844|         0|            0|            0|  0.00%|            Cannot be specified in conjunction with the `out`
   845|         0|            0|            0|  0.00%|            argument.
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|        out : ndarray, 2-D, optional
   848|         0|            0|            0|  0.00%|            If specified, uses this array (or `numpy.matrix`) as the
   849|         0|            0|            0|  0.00%|            output buffer instead of allocating a new array to
   850|         0|            0|            0|  0.00%|            return. The provided array must have the same shape and
   851|         0|            0|            0|  0.00%|            dtype as the sparse matrix on which you are calling the
   852|         0|            0|            0|  0.00%|            method.
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|        Returns
   855|         0|            0|            0|  0.00%|        -------
   856|         0|            0|            0|  0.00%|        arr : numpy.matrix, 2-D
   857|         0|            0|            0|  0.00%|            A NumPy matrix object with the same shape and containing
   858|         0|            0|            0|  0.00%|            the same data represented by the sparse matrix, with the
   859|         0|            0|            0|  0.00%|            requested memory order. If `out` was passed and was an
   860|         0|            0|            0|  0.00%|            array (rather than a `numpy.matrix`), it will be filled
   861|         0|            0|            0|  0.00%|            with the appropriate values and returned wrapped in a
   862|         0|            0|            0|  0.00%|            `numpy.matrix` object that shares the same memory.
   863|         0|            0|            0|  0.00%|        """
   864|         0|            0|            0|  0.00%|        return asmatrix(self.toarray(order=order, out=out))
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|    def toarray(self, order=None, out=None):
   867|         0|            0|            0|  0.00%|        """
   868|         0|            0|            0|  0.00%|        Return a dense ndarray representation of this matrix.
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|        Parameters
   871|         0|            0|            0|  0.00%|        ----------
   872|         0|            0|            0|  0.00%|        order : {'C', 'F'}, optional
   873|         0|            0|            0|  0.00%|            Whether to store multidimensional data in C (row-major)
   874|         0|            0|            0|  0.00%|            or Fortran (column-major) order in memory. The default
   875|         0|            0|            0|  0.00%|            is 'None', indicating the NumPy default of C-ordered.
   876|         0|            0|            0|  0.00%|            Cannot be specified in conjunction with the `out`
   877|         0|            0|            0|  0.00%|            argument.
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|        out : ndarray, 2-D, optional
   880|         0|            0|            0|  0.00%|            If specified, uses this array as the output buffer
   881|         0|            0|            0|  0.00%|            instead of allocating a new array to return. The provided
   882|         0|            0|            0|  0.00%|            array must have the same shape and dtype as the sparse
   883|         0|            0|            0|  0.00%|            matrix on which you are calling the method. For most
   884|         0|            0|            0|  0.00%|            sparse types, `out` is required to be memory contiguous
   885|         0|            0|            0|  0.00%|            (either C or Fortran ordered).
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|        Returns
   888|         0|            0|            0|  0.00%|        -------
   889|         0|            0|            0|  0.00%|        arr : ndarray, 2-D
   890|         0|            0|            0|  0.00%|            An array with the same shape and containing the same
   891|         0|            0|            0|  0.00%|            data represented by the sparse matrix, with the requested
   892|         0|            0|            0|  0.00%|            memory order. If `out` was passed, the same object is
   893|         0|            0|            0|  0.00%|            returned after being modified in-place to contain the
   894|         0|            0|            0|  0.00%|            appropriate values.
   895|         0|            0|            0|  0.00%|        """
   896|         0|            0|            0|  0.00%|        return self.tocoo(copy=False).toarray(order=order, out=out)
   897|         0|            0|            0|  0.00%|
   898|         0|            0|            0|  0.00%|    # Any sparse matrix format deriving from spmatrix must define one of
   899|         0|            0|            0|  0.00%|    # tocsr or tocoo. The other conversion methods may be implemented for
   900|         0|            0|            0|  0.00%|    # efficiency, but are not required.
   901|         0|            0|            0|  0.00%|    def tocsr(self, copy=False):
   902|         0|            0|            0|  0.00%|        """Convert this matrix to Compressed Sparse Row format.
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|        With copy=False, the data/indices may be shared between this matrix and
   905|         0|            0|            0|  0.00%|        the resultant csr_matrix.
   906|         0|            0|            0|  0.00%|        """
   907|         0|            0|            0|  0.00%|        return self.tocoo(copy=copy).tocsr(copy=False)
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|    def todok(self, copy=False):
   910|         0|            0|            0|  0.00%|        """Convert this matrix to Dictionary Of Keys format.
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|        With copy=False, the data/indices may be shared between this matrix and
   913|         0|            0|            0|  0.00%|        the resultant dok_matrix.
   914|         0|            0|            0|  0.00%|        """
   915|         0|            0|            0|  0.00%|        return self.tocoo(copy=copy).todok(copy=False)
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|    def tocoo(self, copy=False):
   918|         0|            0|            0|  0.00%|        """Convert this matrix to COOrdinate format.
   919|         0|            0|            0|  0.00%|
   920|         0|            0|            0|  0.00%|        With copy=False, the data/indices may be shared between this matrix and
   921|         0|            0|            0|  0.00%|        the resultant coo_matrix.
   922|         0|            0|            0|  0.00%|        """
   923|         0|            0|            0|  0.00%|        return self.tocsr(copy=False).tocoo(copy=copy)
   924|         0|            0|            0|  0.00%|
   925|         0|            0|            0|  0.00%|    def tolil(self, copy=False):
   926|         0|            0|            0|  0.00%|        """Convert this matrix to List of Lists format.
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|        With copy=False, the data/indices may be shared between this matrix and
   929|         0|            0|            0|  0.00%|        the resultant lil_matrix.
   930|         0|            0|            0|  0.00%|        """
   931|         0|            0|            0|  0.00%|        return self.tocsr(copy=False).tolil(copy=copy)
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|    def todia(self, copy=False):
   934|         0|            0|            0|  0.00%|        """Convert this matrix to sparse DIAgonal format.
   935|         0|            0|            0|  0.00%|
   936|         0|            0|            0|  0.00%|        With copy=False, the data/indices may be shared between this matrix and
   937|         0|            0|            0|  0.00%|        the resultant dia_matrix.
   938|         0|            0|            0|  0.00%|        """
   939|         0|            0|            0|  0.00%|        return self.tocoo(copy=copy).todia(copy=False)
   940|         0|            0|            0|  0.00%|
   941|         0|            0|            0|  0.00%|    def tobsr(self, blocksize=None, copy=False):
   942|         0|            0|            0|  0.00%|        """Convert this matrix to Block Sparse Row format.
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|        With copy=False, the data/indices may be shared between this matrix and
   945|         0|            0|            0|  0.00%|        the resultant bsr_matrix.
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|        When blocksize=(R, C) is provided, it will be used for construction of
   948|         0|            0|            0|  0.00%|        the bsr_matrix.
   949|         0|            0|            0|  0.00%|        """
   950|         0|            0|            0|  0.00%|        return self.tocsr(copy=False).tobsr(blocksize=blocksize, copy=copy)
   951|         0|            0|            0|  0.00%|
   952|         0|            0|            0|  0.00%|    def tocsc(self, copy=False):
   953|         0|            0|            0|  0.00%|        """Convert this matrix to Compressed Sparse Column format.
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|        With copy=False, the data/indices may be shared between this matrix and
   956|         0|            0|            0|  0.00%|        the resultant csc_matrix.
   957|         0|            0|            0|  0.00%|        """
   958|         0|            0|            0|  0.00%|        return self.tocsr(copy=copy).tocsc(copy=False)
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|    def copy(self):
   961|         0|            0|            0|  0.00%|        """Returns a copy of this matrix.
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|        No data/indices will be shared between the returned value and current
   964|         0|            0|            0|  0.00%|        matrix.
   965|         0|            0|            0|  0.00%|        """
   966|         0|            0|            0|  0.00%|        return self.__class__(self, copy=True)
   967|         0|            0|            0|  0.00%|
   968|         8|            0|            0|  0.00%|    def sum(self, axis=None, dtype=None, out=None):
   969|         0|            0|            0|  0.00%|        """
   970|         0|            0|            0|  0.00%|        Sum the matrix elements over a given axis.
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|        Parameters
   973|         0|            0|            0|  0.00%|        ----------
   974|         0|            0|            0|  0.00%|        axis : {-2, -1, 0, 1, None} optional
   975|         0|            0|            0|  0.00%|            Axis along which the sum is computed. The default is to
   976|         0|            0|            0|  0.00%|            compute the sum of all the matrix elements, returning a scalar
   977|         0|            0|            0|  0.00%|            (i.e., `axis` = `None`).
   978|         0|            0|            0|  0.00%|        dtype : dtype, optional
   979|         0|            0|            0|  0.00%|            The type of the returned matrix and of the accumulator in which
   980|         0|            0|            0|  0.00%|            the elements are summed.  The dtype of `a` is used by default
   981|         0|            0|            0|  0.00%|            unless `a` has an integer dtype of less precision than the default
   982|         0|            0|            0|  0.00%|            platform integer.  In that case, if `a` is signed then the platform
   983|         0|            0|            0|  0.00%|            integer is used while if `a` is unsigned then an unsigned integer
   984|         0|            0|            0|  0.00%|            of the same precision as the platform integer is used.
   985|         0|            0|            0|  0.00%|
   986|         0|            0|            0|  0.00%|            .. versionadded:: 0.18.0
   987|         0|            0|            0|  0.00%|
   988|         0|            0|            0|  0.00%|        out : np.matrix, optional
   989|         0|            0|            0|  0.00%|            Alternative output matrix in which to place the result. It must
   990|         0|            0|            0|  0.00%|            have the same shape as the expected output, but the type of the
   991|         0|            0|            0|  0.00%|            output values will be cast if necessary.
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|            .. versionadded:: 0.18.0
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|        Returns
   996|         0|            0|            0|  0.00%|        -------
   997|         0|            0|            0|  0.00%|        sum_along_axis : np.matrix
   998|         0|            0|            0|  0.00%|            A matrix with the same shape as `self`, with the specified
   999|         0|            0|            0|  0.00%|            axis removed.
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|        See Also
  1002|         0|            0|            0|  0.00%|        --------
  1003|         0|            0|            0|  0.00%|        numpy.matrix.sum : NumPy's implementation of 'sum' for matrices
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|        """
  1006|         8|            0|            0|  0.00%|        validateaxis(axis)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:254 validateaxis
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|        # We use multiplication by a matrix of ones to achieve this.
  1009|         0|            0|            0|  0.00%|        # For some sparse matrix formats more efficient methods are
  1010|         0|            0|            0|  0.00%|        # possible -- these should override this function.
  1011|         8|    0.0010016|    0.0001252|  0.00%|        m, n = self.shape
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
  1012|         0|            0|            0|  0.00%|
  1013|         0|            0|            0|  0.00%|        # Mimic numpy's casting.
  1014|         8|            0|            0|  0.00%|        res_dtype = get_sum_dtype(self.dtype)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:184 get_sum_dtype
  1015|         0|            0|            0|  0.00%|
  1016|         8|            0|            0|  0.00%|        if axis is None:
  1017|         0|            0|            0|  0.00%|            # sum over rows and columns
  1018|        12|            0|            0|  0.00%|            return (self * asmatrix(np.ones(
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:149 ones
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:363 asmatrix
(call)|         4|   0.00196576|   0.00049144|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:453 __mul__
(call)|         4|   0.00107503|  0.000268757|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:287 sum
  1019|         4|            0|            0|  0.00%|                (n, 1), dtype=res_dtype))).sum(
  1020|         4|            0|            0|  0.00%|                dtype=dtype, out=out)
  1021|         0|            0|            0|  0.00%|
  1022|         4|            0|            0|  0.00%|        if axis < 0:
  1023|         0|            0|            0|  0.00%|            axis += 2
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|        # axis = 0 or 1 now
  1026|         4|            0|            0|  0.00%|        if axis == 0:
  1027|         0|            0|            0|  0.00%|            # sum over columns
  1028|        12|            0|            0|  0.00%|            ret = asmatrix(np.ones(
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:149 ones
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:363 asmatrix
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:215 __mul__
(call)|         4|   0.00401998|   0.00100499|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:541 __rmul__
  1029|         8|            0|            0|  0.00%|                (1, m), dtype=res_dtype)) * self
  1030|         0|            0|            0|  0.00%|        else:
  1031|         0|            0|            0|  0.00%|            # sum over rows
  1032|         0|            0|            0|  0.00%|            ret = self * asmatrix(
  1033|         0|            0|            0|  0.00%|                np.ones((n, 1), dtype=res_dtype))
  1034|         0|            0|            0|  0.00%|
  1035|         4|            0|            0|  0.00%|        if out is not None and out.shape != ret.shape:
  1036|         0|            0|            0|  0.00%|            raise ValueError("dimensions do not match")
  1037|         0|            0|            0|  0.00%|
  1038|         4|            0|            0|  0.00%|        return ret.sum(axis=(), dtype=dtype, out=out)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:287 sum
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|    def mean(self, axis=None, dtype=None, out=None):
  1041|         0|            0|            0|  0.00%|        """
  1042|         0|            0|            0|  0.00%|        Compute the arithmetic mean along the specified axis.
  1043|         0|            0|            0|  0.00%|
  1044|         0|            0|            0|  0.00%|        Returns the average of the matrix elements. The average is taken
  1045|         0|            0|            0|  0.00%|        over all elements in the matrix by default, otherwise over the
  1046|         0|            0|            0|  0.00%|        specified axis. `float64` intermediate and return values are used
  1047|         0|            0|            0|  0.00%|        for integer inputs.
  1048|         0|            0|            0|  0.00%|
  1049|         0|            0|            0|  0.00%|        Parameters
  1050|         0|            0|            0|  0.00%|        ----------
  1051|         0|            0|            0|  0.00%|        axis : {-2, -1, 0, 1, None} optional
  1052|         0|            0|            0|  0.00%|            Axis along which the mean is computed. The default is to compute
  1053|         0|            0|            0|  0.00%|            the mean of all elements in the matrix (i.e., `axis` = `None`).
  1054|         0|            0|            0|  0.00%|        dtype : data-type, optional
  1055|         0|            0|            0|  0.00%|            Type to use in computing the mean. For integer inputs, the default
  1056|         0|            0|            0|  0.00%|            is `float64`; for floating point inputs, it is the same as the
  1057|         0|            0|            0|  0.00%|            input dtype.
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|            .. versionadded:: 0.18.0
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|        out : np.matrix, optional
  1062|         0|            0|            0|  0.00%|            Alternative output matrix in which to place the result. It must
  1063|         0|            0|            0|  0.00%|            have the same shape as the expected output, but the type of the
  1064|         0|            0|            0|  0.00%|            output values will be cast if necessary.
  1065|         0|            0|            0|  0.00%|
  1066|         0|            0|            0|  0.00%|            .. versionadded:: 0.18.0
  1067|         0|            0|            0|  0.00%|
  1068|         0|            0|            0|  0.00%|        Returns
  1069|         0|            0|            0|  0.00%|        -------
  1070|         0|            0|            0|  0.00%|        m : np.matrix
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|        See Also
  1073|         0|            0|            0|  0.00%|        --------
  1074|         0|            0|            0|  0.00%|        numpy.matrix.mean : NumPy's implementation of 'mean' for matrices
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|        """
  1077|         0|            0|            0|  0.00%|        def _is_integral(dtype):
  1078|         0|            0|            0|  0.00%|            return (np.issubdtype(dtype, np.integer) or
  1079|         0|            0|            0|  0.00%|                    np.issubdtype(dtype, np.bool_))
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|        validateaxis(axis)
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|        res_dtype = self.dtype.type
  1084|         0|            0|            0|  0.00%|        integral = _is_integral(self.dtype)
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|        # output dtype
  1087|         0|            0|            0|  0.00%|        if dtype is None:
  1088|         0|            0|            0|  0.00%|            if integral:
  1089|         0|            0|            0|  0.00%|                res_dtype = np.float64
  1090|         0|            0|            0|  0.00%|        else:
  1091|         0|            0|            0|  0.00%|            res_dtype = np.dtype(dtype).type
  1092|         0|            0|            0|  0.00%|
  1093|         0|            0|            0|  0.00%|        # intermediate dtype for summation
  1094|         0|            0|            0|  0.00%|        inter_dtype = np.float64 if integral else res_dtype
  1095|         0|            0|            0|  0.00%|        inter_self = self.astype(inter_dtype)
  1096|         0|            0|            0|  0.00%|
  1097|         0|            0|            0|  0.00%|        if axis is None:
  1098|         0|            0|            0|  0.00%|            return (inter_self / np.array(
  1099|         0|            0|            0|  0.00%|                self.shape[0] * self.shape[1]))\
  1100|         0|            0|            0|  0.00%|                .sum(dtype=res_dtype, out=out)
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|        if axis < 0:
  1103|         0|            0|            0|  0.00%|            axis += 2
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|        # axis = 0 or 1 now
  1106|         0|            0|            0|  0.00%|        if axis == 0:
  1107|         0|            0|            0|  0.00%|            return (inter_self * (1.0 / self.shape[0])).sum(
  1108|         0|            0|            0|  0.00%|                axis=0, dtype=res_dtype, out=out)
  1109|         0|            0|            0|  0.00%|        else:
  1110|         0|            0|            0|  0.00%|            return (inter_self * (1.0 / self.shape[1])).sum(
  1111|         0|            0|            0|  0.00%|                axis=1, dtype=res_dtype, out=out)
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    def diagonal(self, k=0):
  1114|         0|            0|            0|  0.00%|        """Returns the kth diagonal of the matrix.
  1115|         0|            0|            0|  0.00%|
  1116|         0|            0|            0|  0.00%|        Parameters
  1117|         0|            0|            0|  0.00%|        ----------
  1118|         0|            0|            0|  0.00%|        k : int, optional
  1119|         0|            0|            0|  0.00%|            Which diagonal to get, corresponding to elements a[i, i+k].
  1120|         0|            0|            0|  0.00%|            Default: 0 (the main diagonal).
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|            .. versionadded:: 1.0
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|        See also
  1125|         0|            0|            0|  0.00%|        --------
  1126|         0|            0|            0|  0.00%|        numpy.diagonal : Equivalent numpy function.
  1127|         0|            0|            0|  0.00%|
  1128|         0|            0|            0|  0.00%|        Examples
  1129|         0|            0|            0|  0.00%|        --------
  1130|         0|            0|            0|  0.00%|        >>> from scipy.sparse import csr_matrix
  1131|         0|            0|            0|  0.00%|        >>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
  1132|         0|            0|            0|  0.00%|        >>> A.diagonal()
  1133|         0|            0|            0|  0.00%|        array([1, 0, 5])
  1134|         0|            0|            0|  0.00%|        >>> A.diagonal(k=1)
  1135|         0|            0|            0|  0.00%|        array([2, 3])
  1136|         0|            0|            0|  0.00%|        """
  1137|         0|            0|            0|  0.00%|        return self.tocsr().diagonal(k=k)
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|    def setdiag(self, values, k=0):
  1140|         0|            0|            0|  0.00%|        """
  1141|         0|            0|            0|  0.00%|        Set diagonal or off-diagonal elements of the array.
  1142|         0|            0|            0|  0.00%|
  1143|         0|            0|            0|  0.00%|        Parameters
  1144|         0|            0|            0|  0.00%|        ----------
  1145|         0|            0|            0|  0.00%|        values : array_like
  1146|         0|            0|            0|  0.00%|            New values of the diagonal elements.
  1147|         0|            0|            0|  0.00%|
  1148|         0|            0|            0|  0.00%|            Values may have any length. If the diagonal is longer than values,
  1149|         0|            0|            0|  0.00%|            then the remaining diagonal entries will not be set. If values are
  1150|         0|            0|            0|  0.00%|            longer than the diagonal, then the remaining values are ignored.
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|            If a scalar value is given, all of the diagonal is set to it.
  1153|         0|            0|            0|  0.00%|
  1154|         0|            0|            0|  0.00%|        k : int, optional
  1155|         0|            0|            0|  0.00%|            Which off-diagonal to set, corresponding to elements a[i,i+k].
  1156|         0|            0|            0|  0.00%|            Default: 0 (the main diagonal).
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|        """
  1159|         0|            0|            0|  0.00%|        M, N = self.shape
  1160|         0|            0|            0|  0.00%|        if (k > 0 and k >= N) or (k < 0 and -k >= M):
  1161|         0|            0|            0|  0.00%|            raise ValueError("k exceeds matrix dimensions")
  1162|         0|            0|            0|  0.00%|        self._setdiag(np.asarray(values), k)
  1163|         0|            0|            0|  0.00%|
  1164|         0|            0|            0|  0.00%|    def _setdiag(self, values, k):
  1165|         0|            0|            0|  0.00%|        M, N = self.shape
  1166|         0|            0|            0|  0.00%|        if k < 0:
  1167|         0|            0|            0|  0.00%|            if values.ndim == 0:
  1168|         0|            0|            0|  0.00%|                # broadcast
  1169|         0|            0|            0|  0.00%|                max_index = min(M+k, N)
  1170|         0|            0|            0|  0.00%|                for i in range(max_index):
  1171|         0|            0|            0|  0.00%|                    self[i - k, i] = values
  1172|         0|            0|            0|  0.00%|            else:
  1173|         0|            0|            0|  0.00%|                max_index = min(M+k, N, len(values))
  1174|         0|            0|            0|  0.00%|                if max_index <= 0:
  1175|         0|            0|            0|  0.00%|                    return
  1176|         0|            0|            0|  0.00%|                for i, v in enumerate(values[:max_index]):
  1177|         0|            0|            0|  0.00%|                    self[i - k, i] = v
  1178|         0|            0|            0|  0.00%|        else:
  1179|         0|            0|            0|  0.00%|            if values.ndim == 0:
  1180|         0|            0|            0|  0.00%|                # broadcast
  1181|         0|            0|            0|  0.00%|                max_index = min(M, N-k)
  1182|         0|            0|            0|  0.00%|                for i in range(max_index):
  1183|         0|            0|            0|  0.00%|                    self[i, i + k] = values
  1184|         0|            0|            0|  0.00%|            else:
  1185|         0|            0|            0|  0.00%|                max_index = min(M, N-k, len(values))
  1186|         0|            0|            0|  0.00%|                if max_index <= 0:
  1187|         0|            0|            0|  0.00%|                    return
  1188|         0|            0|            0|  0.00%|                for i, v in enumerate(values[:max_index]):
  1189|         0|            0|            0|  0.00%|                    self[i, i + k] = v
  1190|         0|            0|            0|  0.00%|
  1191|         0|            0|            0|  0.00%|    def _process_toarray_args(self, order, out):
  1192|         0|            0|            0|  0.00%|        if out is not None:
  1193|         0|            0|            0|  0.00%|            if order is not None:
  1194|         0|            0|            0|  0.00%|                raise ValueError('order cannot be specified if out '
  1195|         0|            0|            0|  0.00%|                                 'is not None')
  1196|         0|            0|            0|  0.00%|            if out.shape != self.shape or out.dtype != self.dtype:
  1197|         0|            0|            0|  0.00%|                raise ValueError('out array must be same dtype and shape as '
  1198|         0|            0|            0|  0.00%|                                 'sparse matrix')
  1199|         0|            0|            0|  0.00%|            out[...] = 0.
  1200|         0|            0|            0|  0.00%|            return out
  1201|         0|            0|            0|  0.00%|        else:
  1202|         0|            0|            0|  0.00%|            return np.zeros(self.shape, dtype=self.dtype, order=order)
  1203|         0|            0|            0|  0.00%|
  1204|         0|            0|            0|  0.00%|
  1205|        44|            0|            0|  0.00%|def isspmatrix(x):
  1206|         0|            0|            0|  0.00%|    """Is x of a sparse matrix type?
  1207|         0|            0|            0|  0.00%|
  1208|         0|            0|            0|  0.00%|    Parameters
  1209|         0|            0|            0|  0.00%|    ----------
  1210|         0|            0|            0|  0.00%|    x
  1211|         0|            0|            0|  0.00%|        object to check for being a sparse matrix
  1212|         0|            0|            0|  0.00%|
  1213|         0|            0|            0|  0.00%|    Returns
  1214|         0|            0|            0|  0.00%|    -------
  1215|         0|            0|            0|  0.00%|    bool
  1216|         0|            0|            0|  0.00%|        True if x is a sparse matrix, False otherwise
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|    Notes
  1219|         0|            0|            0|  0.00%|    -----
  1220|         0|            0|            0|  0.00%|    issparse and isspmatrix are aliases for the same function.
  1221|         0|            0|            0|  0.00%|
  1222|         0|            0|            0|  0.00%|    Examples
  1223|         0|            0|            0|  0.00%|    --------
  1224|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csr_matrix, isspmatrix
  1225|         0|            0|            0|  0.00%|    >>> isspmatrix(csr_matrix([[5]]))
  1226|         0|            0|            0|  0.00%|    True
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|    >>> from scipy.sparse import isspmatrix
  1229|         0|            0|            0|  0.00%|    >>> isspmatrix(5)
  1230|         0|            0|            0|  0.00%|    False
  1231|         0|            0|            0|  0.00%|    """
  1232|        44|   0.00103641|  2.35547e-05|  0.00%|    return isinstance(x, spmatrix)
  1233|         0|            0|            0|  0.00%|
  1234|         0|            0|            0|  0.00%|
  1235|         0|            0|            0|  0.00%|issparse = isspmatrix
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\arraysetops.py
File duration: 0.00449777s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Set operations for arrays based on sorting.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|Notes
     5|         0|            0|            0|  0.00%|-----
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|For floating point arrays, inaccurate results may appear due to usual round-off
     8|         0|            0|            0|  0.00%|and floating point comparison issues.
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|Speed could be gained in some operations by an implementation of
    11|         0|            0|            0|  0.00%|`numpy.sort`, that can provide directly the permutation vectors, thus avoiding
    12|         0|            0|            0|  0.00%|calls to `numpy.argsort`.
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|Original author: Robert Cimrman
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|"""
    17|         0|            0|            0|  0.00%|import functools
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|import numpy as np
    20|         0|            0|            0|  0.00%|from numpy.core import overrides
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    24|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|__all__ = [
    28|         0|            0|            0|  0.00%|    'ediff1d', 'intersect1d', 'setxor1d', 'union1d', 'setdiff1d', 'unique',
    29|         0|            0|            0|  0.00%|    'in1d', 'isin'
    30|         0|            0|            0|  0.00%|    ]
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|def _ediff1d_dispatcher(ary, to_end=None, to_begin=None):
    34|         0|            0|            0|  0.00%|    return (ary, to_end, to_begin)
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|@array_function_dispatch(_ediff1d_dispatcher)
    38|         0|            0|            0|  0.00%|def ediff1d(ary, to_end=None, to_begin=None):
    39|         0|            0|            0|  0.00%|    """
    40|         0|            0|            0|  0.00%|    The differences between consecutive elements of an array.
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    Parameters
    43|         0|            0|            0|  0.00%|    ----------
    44|         0|            0|            0|  0.00%|    ary : array_like
    45|         0|            0|            0|  0.00%|        If necessary, will be flattened before the differences are taken.
    46|         0|            0|            0|  0.00%|    to_end : array_like, optional
    47|         0|            0|            0|  0.00%|        Number(s) to append at the end of the returned differences.
    48|         0|            0|            0|  0.00%|    to_begin : array_like, optional
    49|         0|            0|            0|  0.00%|        Number(s) to prepend at the beginning of the returned differences.
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    Returns
    52|         0|            0|            0|  0.00%|    -------
    53|         0|            0|            0|  0.00%|    ediff1d : ndarray
    54|         0|            0|            0|  0.00%|        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|    See Also
    57|         0|            0|            0|  0.00%|    --------
    58|         0|            0|            0|  0.00%|    diff, gradient
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    Notes
    61|         0|            0|            0|  0.00%|    -----
    62|         0|            0|            0|  0.00%|    When applied to masked arrays, this function drops the mask information
    63|         0|            0|            0|  0.00%|    if the `to_begin` and/or `to_end` parameters are used.
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    Examples
    66|         0|            0|            0|  0.00%|    --------
    67|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 4, 7, 0])
    68|         0|            0|            0|  0.00%|    >>> np.ediff1d(x)
    69|         0|            0|            0|  0.00%|    array([ 1,  2,  3, -7])
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
    72|         0|            0|            0|  0.00%|    array([-99,   1,   2, ...,  -7,  88,  99])
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|    The returned array is always 1D.
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|    >>> y = [[1, 2, 4], [1, 6, 24]]
    77|         0|            0|            0|  0.00%|    >>> np.ediff1d(y)
    78|         0|            0|            0|  0.00%|    array([ 1,  2, -3,  5, 18])
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|    """
    81|         0|            0|            0|  0.00%|    # force a 1d array
    82|         0|            0|            0|  0.00%|    ary = np.asanyarray(ary).ravel()
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    # enforce that the dtype of `ary` is used for the output
    85|         0|            0|            0|  0.00%|    dtype_req = ary.dtype
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|    # fast track default case
    88|         0|            0|            0|  0.00%|    if to_begin is None and to_end is None:
    89|         0|            0|            0|  0.00%|        return ary[1:] - ary[:-1]
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|    if to_begin is None:
    92|         0|            0|            0|  0.00%|        l_begin = 0
    93|         0|            0|            0|  0.00%|    else:
    94|         0|            0|            0|  0.00%|        to_begin = np.asanyarray(to_begin)
    95|         0|            0|            0|  0.00%|        if not np.can_cast(to_begin, dtype_req, casting="same_kind"):
    96|         0|            0|            0|  0.00%|            raise TypeError("dtype of `to_begin` must be compatible "
    97|         0|            0|            0|  0.00%|                            "with input `ary` under the `same_kind` rule.")
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|        to_begin = to_begin.ravel()
   100|         0|            0|            0|  0.00%|        l_begin = len(to_begin)
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    if to_end is None:
   103|         0|            0|            0|  0.00%|        l_end = 0
   104|         0|            0|            0|  0.00%|    else:
   105|         0|            0|            0|  0.00%|        to_end = np.asanyarray(to_end)
   106|         0|            0|            0|  0.00%|        if not np.can_cast(to_end, dtype_req, casting="same_kind"):
   107|         0|            0|            0|  0.00%|            raise TypeError("dtype of `to_end` must be compatible "
   108|         0|            0|            0|  0.00%|                            "with input `ary` under the `same_kind` rule.")
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|        to_end = to_end.ravel()
   111|         0|            0|            0|  0.00%|        l_end = len(to_end)
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    # do the calculation in place and copy to_begin and to_end
   114|         0|            0|            0|  0.00%|    l_diff = max(len(ary) - 1, 0)
   115|         0|            0|            0|  0.00%|    result = np.empty(l_diff + l_begin + l_end, dtype=ary.dtype)
   116|         0|            0|            0|  0.00%|    result = ary.__array_wrap__(result)
   117|         0|            0|            0|  0.00%|    if l_begin > 0:
   118|         0|            0|            0|  0.00%|        result[:l_begin] = to_begin
   119|         0|            0|            0|  0.00%|    if l_end > 0:
   120|         0|            0|            0|  0.00%|        result[l_begin + l_diff:] = to_end
   121|         0|            0|            0|  0.00%|    np.subtract(ary[1:], ary[:-1], result[l_begin:l_begin + l_diff])
   122|         0|            0|            0|  0.00%|    return result
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|        36|            0|            0|  0.00%|def _unpack_tuple(x):
   126|         0|            0|            0|  0.00%|    """ Unpacks one-element tuples for use as return values """
   127|        36|            0|            0|  0.00%|    if len(x) == 1:
   128|        20|            0|            0|  0.00%|        return x[0]
   129|         0|            0|            0|  0.00%|    else:
   130|        16|            0|            0|  0.00%|        return x
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|        36|            0|            0|  0.00%|def _unique_dispatcher(ar, return_index=None, return_inverse=None,
   134|         0|            0|            0|  0.00%|                       return_counts=None, axis=None):
   135|        36|            0|            0|  0.00%|    return (ar,)
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|
   138|        36|            0|            0|  0.00%|@array_function_dispatch(_unique_dispatcher)
   139|         0|            0|            0|  0.00%|def unique(ar, return_index=False, return_inverse=False,
   140|         0|            0|            0|  0.00%|           return_counts=False, axis=None):
   141|         0|            0|            0|  0.00%|    """
   142|         0|            0|            0|  0.00%|    Find the unique elements of an array.
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    Returns the sorted unique elements of an array. There are three optional
   145|         0|            0|            0|  0.00%|    outputs in addition to the unique elements:
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    * the indices of the input array that give the unique values
   148|         0|            0|            0|  0.00%|    * the indices of the unique array that reconstruct the input array
   149|         0|            0|            0|  0.00%|    * the number of times each unique value comes up in the input array
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|    Parameters
   152|         0|            0|            0|  0.00%|    ----------
   153|         0|            0|            0|  0.00%|    ar : array_like
   154|         0|            0|            0|  0.00%|        Input array. Unless `axis` is specified, this will be flattened if it
   155|         0|            0|            0|  0.00%|        is not already 1-D.
   156|         0|            0|            0|  0.00%|    return_index : bool, optional
   157|         0|            0|            0|  0.00%|        If True, also return the indices of `ar` (along the specified axis,
   158|         0|            0|            0|  0.00%|        if provided, or in the flattened array) that result in the unique array.
   159|         0|            0|            0|  0.00%|    return_inverse : bool, optional
   160|         0|            0|            0|  0.00%|        If True, also return the indices of the unique array (for the specified
   161|         0|            0|            0|  0.00%|        axis, if provided) that can be used to reconstruct `ar`.
   162|         0|            0|            0|  0.00%|    return_counts : bool, optional
   163|         0|            0|            0|  0.00%|        If True, also return the number of times each unique item appears
   164|         0|            0|            0|  0.00%|        in `ar`.
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|    axis : int or None, optional
   169|         0|            0|            0|  0.00%|        The axis to operate on. If None, `ar` will be flattened. If an integer,
   170|         0|            0|            0|  0.00%|        the subarrays indexed by the given axis will be flattened and treated
   171|         0|            0|            0|  0.00%|        as the elements of a 1-D array with the dimension of the given axis,
   172|         0|            0|            0|  0.00%|        see the notes for more details.  Object arrays or structured arrays
   173|         0|            0|            0|  0.00%|        that contain objects are not supported if the `axis` kwarg is used. The
   174|         0|            0|            0|  0.00%|        default is None.
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|        .. versionadded:: 1.13.0
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    Returns
   179|         0|            0|            0|  0.00%|    -------
   180|         0|            0|            0|  0.00%|    unique : ndarray
   181|         0|            0|            0|  0.00%|        The sorted unique values.
   182|         0|            0|            0|  0.00%|    unique_indices : ndarray, optional
   183|         0|            0|            0|  0.00%|        The indices of the first occurrences of the unique values in the
   184|         0|            0|            0|  0.00%|        original array. Only provided if `return_index` is True.
   185|         0|            0|            0|  0.00%|    unique_inverse : ndarray, optional
   186|         0|            0|            0|  0.00%|        The indices to reconstruct the original array from the
   187|         0|            0|            0|  0.00%|        unique array. Only provided if `return_inverse` is True.
   188|         0|            0|            0|  0.00%|    unique_counts : ndarray, optional
   189|         0|            0|            0|  0.00%|        The number of times each of the unique values comes up in the
   190|         0|            0|            0|  0.00%|        original array. Only provided if `return_counts` is True.
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|    See Also
   195|         0|            0|            0|  0.00%|    --------
   196|         0|            0|            0|  0.00%|    numpy.lib.arraysetops : Module with a number of other functions for
   197|         0|            0|            0|  0.00%|                            performing set operations on arrays.
   198|         0|            0|            0|  0.00%|    repeat : Repeat elements of an array.
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|    Notes
   201|         0|            0|            0|  0.00%|    -----
   202|         0|            0|            0|  0.00%|    When an axis is specified the subarrays indexed by the axis are sorted.
   203|         0|            0|            0|  0.00%|    This is done by making the specified axis the first dimension of the array
   204|         0|            0|            0|  0.00%|    (move the axis to the first dimension to keep the order of the other axes)
   205|         0|            0|            0|  0.00%|    and then flattening the subarrays in C order. The flattened subarrays are
   206|         0|            0|            0|  0.00%|    then viewed as a structured type with each element given a label, with the
   207|         0|            0|            0|  0.00%|    effect that we end up with a 1-D array of structured types that can be
   208|         0|            0|            0|  0.00%|    treated in the same way as any other 1-D array. The result is that the
   209|         0|            0|            0|  0.00%|    flattened subarrays are sorted in lexicographic order starting with the
   210|         0|            0|            0|  0.00%|    first element.
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|    .. versionchanged: NumPy 1.21
   213|         0|            0|            0|  0.00%|        If nan values are in the input array, a single nan is put
   214|         0|            0|            0|  0.00%|        to the end of the sorted unique values.
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|        Also for complex arrays all NaN values are considered equivalent
   217|         0|            0|            0|  0.00%|        (no matter whether the NaN is in the real or imaginary part).
   218|         0|            0|            0|  0.00%|        As the representant for the returned array the smallest one in the
   219|         0|            0|            0|  0.00%|        lexicographical order is chosen - see np.sort for how the lexicographical
   220|         0|            0|            0|  0.00%|        order is defined for complex arrays.
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|    Examples
   223|         0|            0|            0|  0.00%|    --------
   224|         0|            0|            0|  0.00%|    >>> np.unique([1, 1, 2, 2, 3, 3])
   225|         0|            0|            0|  0.00%|    array([1, 2, 3])
   226|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 1], [2, 3]])
   227|         0|            0|            0|  0.00%|    >>> np.unique(a)
   228|         0|            0|            0|  0.00%|    array([1, 2, 3])
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|    Return the unique rows of a 2D array
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
   233|         0|            0|            0|  0.00%|    >>> np.unique(a, axis=0)
   234|         0|            0|            0|  0.00%|    array([[1, 0, 0], [2, 3, 4]])
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    Return the indices of the original array that give the unique values:
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|    >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
   239|         0|            0|            0|  0.00%|    >>> u, indices = np.unique(a, return_index=True)
   240|         0|            0|            0|  0.00%|    >>> u
   241|         0|            0|            0|  0.00%|    array(['a', 'b', 'c'], dtype='<U1')
   242|         0|            0|            0|  0.00%|    >>> indices
   243|         0|            0|            0|  0.00%|    array([0, 1, 3])
   244|         0|            0|            0|  0.00%|    >>> a[indices]
   245|         0|            0|            0|  0.00%|    array(['a', 'b', 'c'], dtype='<U1')
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    Reconstruct the input array from the unique values and inverse:
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
   250|         0|            0|            0|  0.00%|    >>> u, indices = np.unique(a, return_inverse=True)
   251|         0|            0|            0|  0.00%|    >>> u
   252|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 6])
   253|         0|            0|            0|  0.00%|    >>> indices
   254|         0|            0|            0|  0.00%|    array([0, 1, 4, 3, 1, 2, 1])
   255|         0|            0|            0|  0.00%|    >>> u[indices]
   256|         0|            0|            0|  0.00%|    array([1, 2, 6, 4, 2, 3, 2])
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|    Reconstruct the input values from the unique values and counts:
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
   261|         0|            0|            0|  0.00%|    >>> values, counts = np.unique(a, return_counts=True)
   262|         0|            0|            0|  0.00%|    >>> values
   263|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 6])
   264|         0|            0|            0|  0.00%|    >>> counts
   265|         0|            0|            0|  0.00%|    array([1, 3, 1, 1, 1])
   266|         0|            0|            0|  0.00%|    >>> np.repeat(values, counts)
   267|         0|            0|            0|  0.00%|    array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|    """
   270|        36|  0.000508547|  1.41263e-05|  0.00%|    ar = np.asanyarray(ar)
   271|        36|            0|            0|  0.00%|    if axis is None:
   272|        36|            0|            0|  0.00%|        ret = _unique1d(ar, return_index, return_inverse, return_counts)
(call)|        36|   0.00398731|  0.000110759|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\arraysetops.py:320 _unique1d
   273|        36|  0.000997305|  2.77029e-05|  0.00%|        return _unpack_tuple(ret)
(call)|        36|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\lib\arraysetops.py:125 _unpack_tuple
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    # axis was specified and not None
   276|         0|            0|            0|  0.00%|    try:
   277|         0|            0|            0|  0.00%|        ar = np.moveaxis(ar, axis, 0)
   278|         0|            0|            0|  0.00%|    except np.AxisError:
   279|         0|            0|            0|  0.00%|        # this removes the "axis1" or "axis2" prefix from the error message
   280|         0|            0|            0|  0.00%|        raise np.AxisError(axis, ar.ndim) from None
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    # Must reshape to a contiguous 2D array for this to work...
   283|         0|            0|            0|  0.00%|    orig_shape, orig_dtype = ar.shape, ar.dtype
   284|         0|            0|            0|  0.00%|    ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
   285|         0|            0|            0|  0.00%|    ar = np.ascontiguousarray(ar)
   286|         0|            0|            0|  0.00%|    dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
   289|         0|            0|            0|  0.00%|    # data type with `m` fields where each field has the data type of `ar`.
   290|         0|            0|            0|  0.00%|    # In the following, we create the array `consolidated`, which has
   291|         0|            0|            0|  0.00%|    # shape `(n,)` with data type `dtype`.
   292|         0|            0|            0|  0.00%|    try:
   293|         0|            0|            0|  0.00%|        if ar.shape[1] > 0:
   294|         0|            0|            0|  0.00%|            consolidated = ar.view(dtype)
   295|         0|            0|            0|  0.00%|        else:
   296|         0|            0|            0|  0.00%|            # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
   297|         0|            0|            0|  0.00%|            # a data type with itemsize 0, and the call `ar.view(dtype)` will
   298|         0|            0|            0|  0.00%|            # fail.  Instead, we'll use `np.empty` to explicitly create the
   299|         0|            0|            0|  0.00%|            # array with shape `(len(ar),)`.  Because `dtype` in this case has
   300|         0|            0|            0|  0.00%|            # itemsize 0, the total size of the result is still 0 bytes.
   301|         0|            0|            0|  0.00%|            consolidated = np.empty(len(ar), dtype=dtype)
   302|         0|            0|            0|  0.00%|    except TypeError as e:
   303|         0|            0|            0|  0.00%|        # There's no good way to do this for object arrays, etc...
   304|         0|            0|            0|  0.00%|        msg = 'The axis argument to unique is not supported for dtype {dt}'
   305|         0|            0|            0|  0.00%|        raise TypeError(msg.format(dt=ar.dtype)) from e
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    def reshape_uniq(uniq):
   308|         0|            0|            0|  0.00%|        n = len(uniq)
   309|         0|            0|            0|  0.00%|        uniq = uniq.view(orig_dtype)
   310|         0|            0|            0|  0.00%|        uniq = uniq.reshape(n, *orig_shape[1:])
   311|         0|            0|            0|  0.00%|        uniq = np.moveaxis(uniq, 0, axis)
   312|         0|            0|            0|  0.00%|        return uniq
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|    output = _unique1d(consolidated, return_index,
   315|         0|            0|            0|  0.00%|                       return_inverse, return_counts)
   316|         0|            0|            0|  0.00%|    output = (reshape_uniq(output[0]),) + output[1:]
   317|         0|            0|            0|  0.00%|    return _unpack_tuple(output)
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|
   320|        36|            0|            0|  0.00%|def _unique1d(ar, return_index=False, return_inverse=False,
   321|         0|            0|            0|  0.00%|              return_counts=False):
   322|         0|            0|            0|  0.00%|    """
   323|         0|            0|            0|  0.00%|    Find the unique elements of an array, ignoring shape.
   324|         0|            0|            0|  0.00%|    """
   325|        36|  0.000996828|  2.76897e-05|  0.00%|    ar = np.asanyarray(ar).flatten()
   326|         0|            0|            0|  0.00%|
   327|        36|            0|            0|  0.00%|    optional_indices = return_index or return_inverse
   328|         0|            0|            0|  0.00%|
   329|        36|            0|            0|  0.00%|    if optional_indices:
   330|        16|            0|            0|  0.00%|        perm = ar.argsort(kind='mergesort' if return_index else 'quicksort')
   331|        16|            0|            0|  0.00%|        aux = ar[perm]
   332|         0|            0|            0|  0.00%|    else:
   333|        20|            0|            0|  0.00%|        ar.sort()
   334|        20|            0|            0|  0.00%|        aux = ar
   335|        36|            0|            0|  0.00%|    mask = np.empty(aux.shape, dtype=np.bool_)
   336|        36|            0|            0|  0.00%|    mask[:1] = True
   337|        36|            0|            0|  0.00%|    if aux.shape[0] > 0 and aux.dtype.kind in "cfmM" and np.isnan(aux[-1]):
   338|         0|            0|            0|  0.00%|        if aux.dtype.kind == "c":  # for complex all NaNs are considered equivalent
   339|         0|            0|            0|  0.00%|            aux_firstnan = np.searchsorted(np.isnan(aux), True, side='left')
   340|         0|            0|            0|  0.00%|        else:
   341|         0|            0|            0|  0.00%|            aux_firstnan = np.searchsorted(aux, aux[-1], side='left')
   342|         0|            0|            0|  0.00%|        if aux_firstnan > 0:
   343|         0|            0|            0|  0.00%|            mask[1:aux_firstnan] = (
   344|         0|            0|            0|  0.00%|                aux[1:aux_firstnan] != aux[:aux_firstnan - 1])
   345|         0|            0|            0|  0.00%|        mask[aux_firstnan] = True
   346|         0|            0|            0|  0.00%|        mask[aux_firstnan + 1:] = False
   347|         0|            0|            0|  0.00%|    else:
   348|        36|            0|            0|  0.00%|        mask[1:] = aux[1:] != aux[:-1]
   349|         0|            0|            0|  0.00%|
   350|        36|            0|            0|  0.00%|    ret = (aux[mask],)
   351|        36|            0|            0|  0.00%|    if return_index:
   352|         0|            0|            0|  0.00%|        ret += (perm[mask],)
   353|        36|   0.00099802|  2.77228e-05|  0.00%|    if return_inverse:
   354|        16|            0|            0|  0.00%|        imask = np.cumsum(mask) - 1
(call)|        16|  0.000995398|  6.22123e-05|  0.00%|# <__array_function__ internals>:177 cumsum
   355|        16|            0|            0|  0.00%|        inv_idx = np.empty(mask.shape, dtype=np.intp)
   356|        16|            0|            0|  0.00%|        inv_idx[perm] = imask
   357|        16|            0|            0|  0.00%|        ret += (inv_idx,)
   358|        36|  0.000997066|  2.76963e-05|  0.00%|    if return_counts:
   359|         0|            0|            0|  0.00%|        idx = np.concatenate(np.nonzero(mask) + ([mask.size],))
   360|         0|            0|            0|  0.00%|        ret += (np.diff(idx),)
   361|        36|            0|            0|  0.00%|    return ret
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|def _intersect1d_dispatcher(
   365|         0|            0|            0|  0.00%|        ar1, ar2, assume_unique=None, return_indices=None):
   366|         0|            0|            0|  0.00%|    return (ar1, ar2)
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|@array_function_dispatch(_intersect1d_dispatcher)
   370|         0|            0|            0|  0.00%|def intersect1d(ar1, ar2, assume_unique=False, return_indices=False):
   371|         0|            0|            0|  0.00%|    """
   372|         0|            0|            0|  0.00%|    Find the intersection of two arrays.
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    Return the sorted, unique values that are in both of the input arrays.
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    Parameters
   377|         0|            0|            0|  0.00%|    ----------
   378|         0|            0|            0|  0.00%|    ar1, ar2 : array_like
   379|         0|            0|            0|  0.00%|        Input arrays. Will be flattened if not already 1D.
   380|         0|            0|            0|  0.00%|    assume_unique : bool
   381|         0|            0|            0|  0.00%|        If True, the input arrays are both assumed to be unique, which
   382|         0|            0|            0|  0.00%|        can speed up the calculation.  If True but ``ar1`` or ``ar2`` are not
   383|         0|            0|            0|  0.00%|        unique, incorrect results and out-of-bounds indices could result.
   384|         0|            0|            0|  0.00%|        Default is False.
   385|         0|            0|            0|  0.00%|    return_indices : bool
   386|         0|            0|            0|  0.00%|        If True, the indices which correspond to the intersection of the two
   387|         0|            0|            0|  0.00%|        arrays are returned. The first instance of a value is used if there are
   388|         0|            0|            0|  0.00%|        multiple. Default is False.
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|    Returns
   393|         0|            0|            0|  0.00%|    -------
   394|         0|            0|            0|  0.00%|    intersect1d : ndarray
   395|         0|            0|            0|  0.00%|        Sorted 1D array of common and unique elements.
   396|         0|            0|            0|  0.00%|    comm1 : ndarray
   397|         0|            0|            0|  0.00%|        The indices of the first occurrences of the common values in `ar1`.
   398|         0|            0|            0|  0.00%|        Only provided if `return_indices` is True.
   399|         0|            0|            0|  0.00%|    comm2 : ndarray
   400|         0|            0|            0|  0.00%|        The indices of the first occurrences of the common values in `ar2`.
   401|         0|            0|            0|  0.00%|        Only provided if `return_indices` is True.
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    See Also
   405|         0|            0|            0|  0.00%|    --------
   406|         0|            0|            0|  0.00%|    numpy.lib.arraysetops : Module with a number of other functions for
   407|         0|            0|            0|  0.00%|                            performing set operations on arrays.
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    Examples
   410|         0|            0|            0|  0.00%|    --------
   411|         0|            0|            0|  0.00%|    >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
   412|         0|            0|            0|  0.00%|    array([1, 3])
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    To intersect more than two arrays, use functools.reduce:
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|    >>> from functools import reduce
   417|         0|            0|            0|  0.00%|    >>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
   418|         0|            0|            0|  0.00%|    array([3])
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    To return the indices of the values common to the input arrays
   421|         0|            0|            0|  0.00%|    along with the intersected values:
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    >>> x = np.array([1, 1, 2, 3, 4])
   424|         0|            0|            0|  0.00%|    >>> y = np.array([2, 1, 4, 6])
   425|         0|            0|            0|  0.00%|    >>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
   426|         0|            0|            0|  0.00%|    >>> x_ind, y_ind
   427|         0|            0|            0|  0.00%|    (array([0, 2, 4]), array([1, 0, 2]))
   428|         0|            0|            0|  0.00%|    >>> xy, x[x_ind], y[y_ind]
   429|         0|            0|            0|  0.00%|    (array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|    """
   432|         0|            0|            0|  0.00%|    ar1 = np.asanyarray(ar1)
   433|         0|            0|            0|  0.00%|    ar2 = np.asanyarray(ar2)
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    if not assume_unique:
   436|         0|            0|            0|  0.00%|        if return_indices:
   437|         0|            0|            0|  0.00%|            ar1, ind1 = unique(ar1, return_index=True)
   438|         0|            0|            0|  0.00%|            ar2, ind2 = unique(ar2, return_index=True)
   439|         0|            0|            0|  0.00%|        else:
   440|         0|            0|            0|  0.00%|            ar1 = unique(ar1)
   441|         0|            0|            0|  0.00%|            ar2 = unique(ar2)
   442|         0|            0|            0|  0.00%|    else:
   443|         0|            0|            0|  0.00%|        ar1 = ar1.ravel()
   444|         0|            0|            0|  0.00%|        ar2 = ar2.ravel()
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|    aux = np.concatenate((ar1, ar2))
   447|         0|            0|            0|  0.00%|    if return_indices:
   448|         0|            0|            0|  0.00%|        aux_sort_indices = np.argsort(aux, kind='mergesort')
   449|         0|            0|            0|  0.00%|        aux = aux[aux_sort_indices]
   450|         0|            0|            0|  0.00%|    else:
   451|         0|            0|            0|  0.00%|        aux.sort()
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    mask = aux[1:] == aux[:-1]
   454|         0|            0|            0|  0.00%|    int1d = aux[:-1][mask]
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|    if return_indices:
   457|         0|            0|            0|  0.00%|        ar1_indices = aux_sort_indices[:-1][mask]
   458|         0|            0|            0|  0.00%|        ar2_indices = aux_sort_indices[1:][mask] - ar1.size
   459|         0|            0|            0|  0.00%|        if not assume_unique:
   460|         0|            0|            0|  0.00%|            ar1_indices = ind1[ar1_indices]
   461|         0|            0|            0|  0.00%|            ar2_indices = ind2[ar2_indices]
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|        return int1d, ar1_indices, ar2_indices
   464|         0|            0|            0|  0.00%|    else:
   465|         0|            0|            0|  0.00%|        return int1d
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|def _setxor1d_dispatcher(ar1, ar2, assume_unique=None):
   469|         0|            0|            0|  0.00%|    return (ar1, ar2)
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|@array_function_dispatch(_setxor1d_dispatcher)
   473|         0|            0|            0|  0.00%|def setxor1d(ar1, ar2, assume_unique=False):
   474|         0|            0|            0|  0.00%|    """
   475|         0|            0|            0|  0.00%|    Find the set exclusive-or of two arrays.
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|    Return the sorted, unique values that are in only one (not both) of the
   478|         0|            0|            0|  0.00%|    input arrays.
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|    Parameters
   481|         0|            0|            0|  0.00%|    ----------
   482|         0|            0|            0|  0.00%|    ar1, ar2 : array_like
   483|         0|            0|            0|  0.00%|        Input arrays.
   484|         0|            0|            0|  0.00%|    assume_unique : bool
   485|         0|            0|            0|  0.00%|        If True, the input arrays are both assumed to be unique, which
   486|         0|            0|            0|  0.00%|        can speed up the calculation.  Default is False.
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|    Returns
   489|         0|            0|            0|  0.00%|    -------
   490|         0|            0|            0|  0.00%|    setxor1d : ndarray
   491|         0|            0|            0|  0.00%|        Sorted 1D array of unique values that are in only one of the input
   492|         0|            0|            0|  0.00%|        arrays.
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    Examples
   495|         0|            0|            0|  0.00%|    --------
   496|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3, 2, 4])
   497|         0|            0|            0|  0.00%|    >>> b = np.array([2, 3, 5, 7, 5])
   498|         0|            0|            0|  0.00%|    >>> np.setxor1d(a,b)
   499|         0|            0|            0|  0.00%|    array([1, 4, 5, 7])
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|    """
   502|         0|            0|            0|  0.00%|    if not assume_unique:
   503|         0|            0|            0|  0.00%|        ar1 = unique(ar1)
   504|         0|            0|            0|  0.00%|        ar2 = unique(ar2)
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|    aux = np.concatenate((ar1, ar2))
   507|         0|            0|            0|  0.00%|    if aux.size == 0:
   508|         0|            0|            0|  0.00%|        return aux
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|    aux.sort()
   511|         0|            0|            0|  0.00%|    flag = np.concatenate(([True], aux[1:] != aux[:-1], [True]))
   512|         0|            0|            0|  0.00%|    return aux[flag[1:] & flag[:-1]]
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|def _in1d_dispatcher(ar1, ar2, assume_unique=None, invert=None):
   516|         0|            0|            0|  0.00%|    return (ar1, ar2)
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|@array_function_dispatch(_in1d_dispatcher)
   520|         0|            0|            0|  0.00%|def in1d(ar1, ar2, assume_unique=False, invert=False):
   521|         0|            0|            0|  0.00%|    """
   522|         0|            0|            0|  0.00%|    Test whether each element of a 1-D array is also present in a second array.
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|    Returns a boolean array the same length as `ar1` that is True
   525|         0|            0|            0|  0.00%|    where an element of `ar1` is in `ar2` and False otherwise.
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|    We recommend using :func:`isin` instead of `in1d` for new code.
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|    Parameters
   530|         0|            0|            0|  0.00%|    ----------
   531|         0|            0|            0|  0.00%|    ar1 : (M,) array_like
   532|         0|            0|            0|  0.00%|        Input array.
   533|         0|            0|            0|  0.00%|    ar2 : array_like
   534|         0|            0|            0|  0.00%|        The values against which to test each value of `ar1`.
   535|         0|            0|            0|  0.00%|    assume_unique : bool, optional
   536|         0|            0|            0|  0.00%|        If True, the input arrays are both assumed to be unique, which
   537|         0|            0|            0|  0.00%|        can speed up the calculation.  Default is False.
   538|         0|            0|            0|  0.00%|    invert : bool, optional
   539|         0|            0|            0|  0.00%|        If True, the values in the returned array are inverted (that is,
   540|         0|            0|            0|  0.00%|        False where an element of `ar1` is in `ar2` and True otherwise).
   541|         0|            0|            0|  0.00%|        Default is False. ``np.in1d(a, b, invert=True)`` is equivalent
   542|         0|            0|            0|  0.00%|        to (but is faster than) ``np.invert(in1d(a, b))``.
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|        .. versionadded:: 1.8.0
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|    Returns
   547|         0|            0|            0|  0.00%|    -------
   548|         0|            0|            0|  0.00%|    in1d : (M,) ndarray, bool
   549|         0|            0|            0|  0.00%|        The values `ar1[in1d]` are in `ar2`.
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|    See Also
   552|         0|            0|            0|  0.00%|    --------
   553|         0|            0|            0|  0.00%|    isin                  : Version of this function that preserves the
   554|         0|            0|            0|  0.00%|                            shape of ar1.
   555|         0|            0|            0|  0.00%|    numpy.lib.arraysetops : Module with a number of other functions for
   556|         0|            0|            0|  0.00%|                            performing set operations on arrays.
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|    Notes
   559|         0|            0|            0|  0.00%|    -----
   560|         0|            0|            0|  0.00%|    `in1d` can be considered as an element-wise function version of the
   561|         0|            0|            0|  0.00%|    python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly
   562|         0|            0|            0|  0.00%|    equivalent to ``np.array([item in b for item in a])``.
   563|         0|            0|            0|  0.00%|    However, this idea fails if `ar2` is a set, or similar (non-sequence)
   564|         0|            0|            0|  0.00%|    container:  As ``ar2`` is converted to an array, in those cases
   565|         0|            0|            0|  0.00%|    ``asarray(ar2)`` is an object array rather than the expected array of
   566|         0|            0|            0|  0.00%|    contained values.
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    .. versionadded:: 1.4.0
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|    Examples
   571|         0|            0|            0|  0.00%|    --------
   572|         0|            0|            0|  0.00%|    >>> test = np.array([0, 1, 2, 5, 0])
   573|         0|            0|            0|  0.00%|    >>> states = [0, 2]
   574|         0|            0|            0|  0.00%|    >>> mask = np.in1d(test, states)
   575|         0|            0|            0|  0.00%|    >>> mask
   576|         0|            0|            0|  0.00%|    array([ True, False,  True, False,  True])
   577|         0|            0|            0|  0.00%|    >>> test[mask]
   578|         0|            0|            0|  0.00%|    array([0, 2, 0])
   579|         0|            0|            0|  0.00%|    >>> mask = np.in1d(test, states, invert=True)
   580|         0|            0|            0|  0.00%|    >>> mask
   581|         0|            0|            0|  0.00%|    array([False,  True, False,  True, False])
   582|         0|            0|            0|  0.00%|    >>> test[mask]
   583|         0|            0|            0|  0.00%|    array([1, 5])
   584|         0|            0|            0|  0.00%|    """
   585|         0|            0|            0|  0.00%|    # Ravel both arrays, behavior for the first array could be different
   586|         0|            0|            0|  0.00%|    ar1 = np.asarray(ar1).ravel()
   587|         0|            0|            0|  0.00%|    ar2 = np.asarray(ar2).ravel()
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|    # Ensure that iteration through object arrays yields size-1 arrays
   590|         0|            0|            0|  0.00%|    if ar2.dtype == object:
   591|         0|            0|            0|  0.00%|        ar2 = ar2.reshape(-1, 1)
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    # Check if one of the arrays may contain arbitrary objects
   594|         0|            0|            0|  0.00%|    contains_object = ar1.dtype.hasobject or ar2.dtype.hasobject
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|    # This code is run when
   597|         0|            0|            0|  0.00%|    # a) the first condition is true, making the code significantly faster
   598|         0|            0|            0|  0.00%|    # b) the second condition is true (i.e. `ar1` or `ar2` may contain
   599|         0|            0|            0|  0.00%|    #    arbitrary objects), since then sorting is not guaranteed to work
   600|         0|            0|            0|  0.00%|    if len(ar2) < 10 * len(ar1) ** 0.145 or contains_object:
   601|         0|            0|            0|  0.00%|        if invert:
   602|         0|            0|            0|  0.00%|            mask = np.ones(len(ar1), dtype=bool)
   603|         0|            0|            0|  0.00%|            for a in ar2:
   604|         0|            0|            0|  0.00%|                mask &= (ar1 != a)
   605|         0|            0|            0|  0.00%|        else:
   606|         0|            0|            0|  0.00%|            mask = np.zeros(len(ar1), dtype=bool)
   607|         0|            0|            0|  0.00%|            for a in ar2:
   608|         0|            0|            0|  0.00%|                mask |= (ar1 == a)
   609|         0|            0|            0|  0.00%|        return mask
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|    # Otherwise use sorting
   612|         0|            0|            0|  0.00%|    if not assume_unique:
   613|         0|            0|            0|  0.00%|        ar1, rev_idx = np.unique(ar1, return_inverse=True)
   614|         0|            0|            0|  0.00%|        ar2 = np.unique(ar2)
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|    ar = np.concatenate((ar1, ar2))
   617|         0|            0|            0|  0.00%|    # We need this to be a stable sort, so always use 'mergesort'
   618|         0|            0|            0|  0.00%|    # here. The values from the first array should always come before
   619|         0|            0|            0|  0.00%|    # the values from the second array.
   620|         0|            0|            0|  0.00%|    order = ar.argsort(kind='mergesort')
   621|         0|            0|            0|  0.00%|    sar = ar[order]
   622|         0|            0|            0|  0.00%|    if invert:
   623|         0|            0|            0|  0.00%|        bool_ar = (sar[1:] != sar[:-1])
   624|         0|            0|            0|  0.00%|    else:
   625|         0|            0|            0|  0.00%|        bool_ar = (sar[1:] == sar[:-1])
   626|         0|            0|            0|  0.00%|    flag = np.concatenate((bool_ar, [invert]))
   627|         0|            0|            0|  0.00%|    ret = np.empty(ar.shape, dtype=bool)
   628|         0|            0|            0|  0.00%|    ret[order] = flag
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|    if assume_unique:
   631|         0|            0|            0|  0.00%|        return ret[:len(ar1)]
   632|         0|            0|            0|  0.00%|    else:
   633|         0|            0|            0|  0.00%|        return ret[rev_idx]
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|def _isin_dispatcher(element, test_elements, assume_unique=None, invert=None):
   637|         0|            0|            0|  0.00%|    return (element, test_elements)
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|@array_function_dispatch(_isin_dispatcher)
   641|         0|            0|            0|  0.00%|def isin(element, test_elements, assume_unique=False, invert=False):
   642|         0|            0|            0|  0.00%|    """
   643|         0|            0|            0|  0.00%|    Calculates `element in test_elements`, broadcasting over `element` only.
   644|         0|            0|            0|  0.00%|    Returns a boolean array of the same shape as `element` that is True
   645|         0|            0|            0|  0.00%|    where an element of `element` is in `test_elements` and False otherwise.
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    Parameters
   648|         0|            0|            0|  0.00%|    ----------
   649|         0|            0|            0|  0.00%|    element : array_like
   650|         0|            0|            0|  0.00%|        Input array.
   651|         0|            0|            0|  0.00%|    test_elements : array_like
   652|         0|            0|            0|  0.00%|        The values against which to test each value of `element`.
   653|         0|            0|            0|  0.00%|        This argument is flattened if it is an array or array_like.
   654|         0|            0|            0|  0.00%|        See notes for behavior with non-array-like parameters.
   655|         0|            0|            0|  0.00%|    assume_unique : bool, optional
   656|         0|            0|            0|  0.00%|        If True, the input arrays are both assumed to be unique, which
   657|         0|            0|            0|  0.00%|        can speed up the calculation.  Default is False.
   658|         0|            0|            0|  0.00%|    invert : bool, optional
   659|         0|            0|            0|  0.00%|        If True, the values in the returned array are inverted, as if
   660|         0|            0|            0|  0.00%|        calculating `element not in test_elements`. Default is False.
   661|         0|            0|            0|  0.00%|        ``np.isin(a, b, invert=True)`` is equivalent to (but faster
   662|         0|            0|            0|  0.00%|        than) ``np.invert(np.isin(a, b))``.
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|    Returns
   665|         0|            0|            0|  0.00%|    -------
   666|         0|            0|            0|  0.00%|    isin : ndarray, bool
   667|         0|            0|            0|  0.00%|        Has the same shape as `element`. The values `element[isin]`
   668|         0|            0|            0|  0.00%|        are in `test_elements`.
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|    See Also
   671|         0|            0|            0|  0.00%|    --------
   672|         0|            0|            0|  0.00%|    in1d                  : Flattened version of this function.
   673|         0|            0|            0|  0.00%|    numpy.lib.arraysetops : Module with a number of other functions for
   674|         0|            0|            0|  0.00%|                            performing set operations on arrays.
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|    Notes
   677|         0|            0|            0|  0.00%|    -----
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|    `isin` is an element-wise function version of the python keyword `in`.
   680|         0|            0|            0|  0.00%|    ``isin(a, b)`` is roughly equivalent to
   681|         0|            0|            0|  0.00%|    ``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|    `element` and `test_elements` are converted to arrays if they are not
   684|         0|            0|            0|  0.00%|    already. If `test_elements` is a set (or other non-sequence collection)
   685|         0|            0|            0|  0.00%|    it will be converted to an object array with one element, rather than an
   686|         0|            0|            0|  0.00%|    array of the values contained in `test_elements`. This is a consequence
   687|         0|            0|            0|  0.00%|    of the `array` constructor's way of handling non-sequence collections.
   688|         0|            0|            0|  0.00%|    Converting the set to a list usually gives the desired behavior.
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|    .. versionadded:: 1.13.0
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    Examples
   693|         0|            0|            0|  0.00%|    --------
   694|         0|            0|            0|  0.00%|    >>> element = 2*np.arange(4).reshape((2, 2))
   695|         0|            0|            0|  0.00%|    >>> element
   696|         0|            0|            0|  0.00%|    array([[0, 2],
   697|         0|            0|            0|  0.00%|           [4, 6]])
   698|         0|            0|            0|  0.00%|    >>> test_elements = [1, 2, 4, 8]
   699|         0|            0|            0|  0.00%|    >>> mask = np.isin(element, test_elements)
   700|         0|            0|            0|  0.00%|    >>> mask
   701|         0|            0|            0|  0.00%|    array([[False,  True],
   702|         0|            0|            0|  0.00%|           [ True, False]])
   703|         0|            0|            0|  0.00%|    >>> element[mask]
   704|         0|            0|            0|  0.00%|    array([2, 4])
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|    The indices of the matched values can be obtained with `nonzero`:
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|    >>> np.nonzero(mask)
   709|         0|            0|            0|  0.00%|    (array([0, 1]), array([1, 0]))
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    The test can also be inverted:
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|    >>> mask = np.isin(element, test_elements, invert=True)
   714|         0|            0|            0|  0.00%|    >>> mask
   715|         0|            0|            0|  0.00%|    array([[ True, False],
   716|         0|            0|            0|  0.00%|           [False,  True]])
   717|         0|            0|            0|  0.00%|    >>> element[mask]
   718|         0|            0|            0|  0.00%|    array([0, 6])
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|    Because of how `array` handles sets, the following does not
   721|         0|            0|            0|  0.00%|    work as expected:
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|    >>> test_set = {1, 2, 4, 8}
   724|         0|            0|            0|  0.00%|    >>> np.isin(element, test_set)
   725|         0|            0|            0|  0.00%|    array([[False, False],
   726|         0|            0|            0|  0.00%|           [False, False]])
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|    Casting the set to a list gives the expected result:
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|    >>> np.isin(element, list(test_set))
   731|         0|            0|            0|  0.00%|    array([[False,  True],
   732|         0|            0|            0|  0.00%|           [ True, False]])
   733|         0|            0|            0|  0.00%|    """
   734|         0|            0|            0|  0.00%|    element = np.asarray(element)
   735|         0|            0|            0|  0.00%|    return in1d(element, test_elements, assume_unique=assume_unique,
   736|         0|            0|            0|  0.00%|                invert=invert).reshape(element.shape)
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|def _union1d_dispatcher(ar1, ar2):
   740|         0|            0|            0|  0.00%|    return (ar1, ar2)
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|@array_function_dispatch(_union1d_dispatcher)
   744|         0|            0|            0|  0.00%|def union1d(ar1, ar2):
   745|         0|            0|            0|  0.00%|    """
   746|         0|            0|            0|  0.00%|    Find the union of two arrays.
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|    Return the unique, sorted array of values that are in either of the two
   749|         0|            0|            0|  0.00%|    input arrays.
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|    Parameters
   752|         0|            0|            0|  0.00%|    ----------
   753|         0|            0|            0|  0.00%|    ar1, ar2 : array_like
   754|         0|            0|            0|  0.00%|        Input arrays. They are flattened if they are not already 1D.
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|    Returns
   757|         0|            0|            0|  0.00%|    -------
   758|         0|            0|            0|  0.00%|    union1d : ndarray
   759|         0|            0|            0|  0.00%|        Unique, sorted union of the input arrays.
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|    See Also
   762|         0|            0|            0|  0.00%|    --------
   763|         0|            0|            0|  0.00%|    numpy.lib.arraysetops : Module with a number of other functions for
   764|         0|            0|            0|  0.00%|                            performing set operations on arrays.
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    Examples
   767|         0|            0|            0|  0.00%|    --------
   768|         0|            0|            0|  0.00%|    >>> np.union1d([-1, 0, 1], [-2, 0, 2])
   769|         0|            0|            0|  0.00%|    array([-2, -1,  0,  1,  2])
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|    To find the union of more than two arrays, use functools.reduce:
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|    >>> from functools import reduce
   774|         0|            0|            0|  0.00%|    >>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
   775|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 6])
   776|         0|            0|            0|  0.00%|    """
   777|         0|            0|            0|  0.00%|    return unique(np.concatenate((ar1, ar2), axis=None))
   778|         0|            0|            0|  0.00%|
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|def _setdiff1d_dispatcher(ar1, ar2, assume_unique=None):
   781|         0|            0|            0|  0.00%|    return (ar1, ar2)
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|@array_function_dispatch(_setdiff1d_dispatcher)
   785|         0|            0|            0|  0.00%|def setdiff1d(ar1, ar2, assume_unique=False):
   786|         0|            0|            0|  0.00%|    """
   787|         0|            0|            0|  0.00%|    Find the set difference of two arrays.
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|    Return the unique values in `ar1` that are not in `ar2`.
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|    Parameters
   792|         0|            0|            0|  0.00%|    ----------
   793|         0|            0|            0|  0.00%|    ar1 : array_like
   794|         0|            0|            0|  0.00%|        Input array.
   795|         0|            0|            0|  0.00%|    ar2 : array_like
   796|         0|            0|            0|  0.00%|        Input comparison array.
   797|         0|            0|            0|  0.00%|    assume_unique : bool
   798|         0|            0|            0|  0.00%|        If True, the input arrays are both assumed to be unique, which
   799|         0|            0|            0|  0.00%|        can speed up the calculation.  Default is False.
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|    Returns
   802|         0|            0|            0|  0.00%|    -------
   803|         0|            0|            0|  0.00%|    setdiff1d : ndarray
   804|         0|            0|            0|  0.00%|        1D array of values in `ar1` that are not in `ar2`. The result
   805|         0|            0|            0|  0.00%|        is sorted when `assume_unique=False`, but otherwise only sorted
   806|         0|            0|            0|  0.00%|        if the input is sorted.
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|    See Also
   809|         0|            0|            0|  0.00%|    --------
   810|         0|            0|            0|  0.00%|    numpy.lib.arraysetops : Module with a number of other functions for
   811|         0|            0|            0|  0.00%|                            performing set operations on arrays.
   812|         0|            0|            0|  0.00%|
   813|         0|            0|            0|  0.00%|    Examples
   814|         0|            0|            0|  0.00%|    --------
   815|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3, 2, 4, 1])
   816|         0|            0|            0|  0.00%|    >>> b = np.array([3, 4, 5, 6])
   817|         0|            0|            0|  0.00%|    >>> np.setdiff1d(a, b)
   818|         0|            0|            0|  0.00%|    array([1, 2])
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|    """
   821|         0|            0|            0|  0.00%|    if assume_unique:
   822|         0|            0|            0|  0.00%|        ar1 = np.asarray(ar1).ravel()
   823|         0|            0|            0|  0.00%|    else:
   824|         0|            0|            0|  0.00%|        ar1 = unique(ar1)
   825|         0|            0|            0|  0.00%|        ar2 = unique(ar2)
   826|         0|            0|            0|  0.00%|    return ar1[in1d(ar1, ar2, assume_unique=True, invert=True)]
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py
File duration: 0.00306988s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|__all__ = ['matrix', 'bmat', 'mat', 'asmatrix']
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import sys
     4|         0|            0|            0|  0.00%|import warnings
     5|         0|            0|            0|  0.00%|import ast
     6|         0|            0|            0|  0.00%|import numpy.core.numeric as N
     7|         0|            0|            0|  0.00%|from numpy.core.numeric import concatenate, isscalar
     8|         0|            0|            0|  0.00%|from numpy.core.overrides import set_module
     9|         0|            0|            0|  0.00%|# While not in __all__, matrix_power used to be defined here, so we import
    10|         0|            0|            0|  0.00%|# it for backward compatibility.
    11|         0|            0|            0|  0.00%|from numpy.linalg import matrix_power
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|def _convert_from_string(data):
    15|         0|            0|            0|  0.00%|    for char in '[]':
    16|         0|            0|            0|  0.00%|        data = data.replace(char, '')
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|    rows = data.split(';')
    19|         0|            0|            0|  0.00%|    newdata = []
    20|         0|            0|            0|  0.00%|    count = 0
    21|         0|            0|            0|  0.00%|    for row in rows:
    22|         0|            0|            0|  0.00%|        trow = row.split(',')
    23|         0|            0|            0|  0.00%|        newrow = []
    24|         0|            0|            0|  0.00%|        for col in trow:
    25|         0|            0|            0|  0.00%|            temp = col.split()
    26|         0|            0|            0|  0.00%|            newrow.extend(map(ast.literal_eval, temp))
    27|         0|            0|            0|  0.00%|        if count == 0:
    28|         0|            0|            0|  0.00%|            Ncols = len(newrow)
    29|         0|            0|            0|  0.00%|        elif len(newrow) != Ncols:
    30|         0|            0|            0|  0.00%|            raise ValueError("Rows not the same size.")
    31|         0|            0|            0|  0.00%|        count += 1
    32|         0|            0|            0|  0.00%|        newdata.append(newrow)
    33|         0|            0|            0|  0.00%|    return newdata
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|@set_module('numpy')
    37|         0|            0|            0|  0.00%|def asmatrix(data, dtype=None):
    38|         0|            0|            0|  0.00%|    """
    39|         0|            0|            0|  0.00%|    Interpret the input as a matrix.
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|    Unlike `matrix`, `asmatrix` does not make a copy if the input is already
    42|         0|            0|            0|  0.00%|    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    Parameters
    45|         0|            0|            0|  0.00%|    ----------
    46|         0|            0|            0|  0.00%|    data : array_like
    47|         0|            0|            0|  0.00%|        Input data.
    48|         0|            0|            0|  0.00%|    dtype : data-type
    49|         0|            0|            0|  0.00%|       Data-type of the output matrix.
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    Returns
    52|         0|            0|            0|  0.00%|    -------
    53|         0|            0|            0|  0.00%|    mat : matrix
    54|         0|            0|            0|  0.00%|        `data` interpreted as a matrix.
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|    Examples
    57|         0|            0|            0|  0.00%|    --------
    58|         0|            0|            0|  0.00%|    >>> x = np.array([[1, 2], [3, 4]])
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    >>> m = np.asmatrix(x)
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    >>> x[0,0] = 5
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    >>> m
    65|         0|            0|            0|  0.00%|    matrix([[5, 2],
    66|         0|            0|            0|  0.00%|            [3, 4]])
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    """
    69|         0|            0|            0|  0.00%|    return matrix(data, dtype=dtype, copy=False)
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|@set_module('numpy')
    73|         0|            0|            0|  0.00%|class matrix(N.ndarray):
    74|         0|            0|            0|  0.00%|    """
    75|         0|            0|            0|  0.00%|    matrix(data, dtype=None, copy=True)
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    .. note:: It is no longer recommended to use this class, even for linear
    78|         0|            0|            0|  0.00%|              algebra. Instead use regular arrays. The class may be removed
    79|         0|            0|            0|  0.00%|              in the future.
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    Returns a matrix from an array-like object, or from a string of data.
    82|         0|            0|            0|  0.00%|    A matrix is a specialized 2-D array that retains its 2-D nature
    83|         0|            0|            0|  0.00%|    through operations.  It has certain special operators, such as ``*``
    84|         0|            0|            0|  0.00%|    (matrix multiplication) and ``**`` (matrix power).
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    Parameters
    87|         0|            0|            0|  0.00%|    ----------
    88|         0|            0|            0|  0.00%|    data : array_like or string
    89|         0|            0|            0|  0.00%|       If `data` is a string, it is interpreted as a matrix with commas
    90|         0|            0|            0|  0.00%|       or spaces separating columns, and semicolons separating rows.
    91|         0|            0|            0|  0.00%|    dtype : data-type
    92|         0|            0|            0|  0.00%|       Data-type of the output matrix.
    93|         0|            0|            0|  0.00%|    copy : bool
    94|         0|            0|            0|  0.00%|       If `data` is already an `ndarray`, then this flag determines
    95|         0|            0|            0|  0.00%|       whether the data is copied (the default), or whether a view is
    96|         0|            0|            0|  0.00%|       constructed.
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    See Also
    99|         0|            0|            0|  0.00%|    --------
   100|         0|            0|            0|  0.00%|    array
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    Examples
   103|         0|            0|            0|  0.00%|    --------
   104|         0|            0|            0|  0.00%|    >>> a = np.matrix('1 2; 3 4')
   105|         0|            0|            0|  0.00%|    >>> a
   106|         0|            0|            0|  0.00%|    matrix([[1, 2],
   107|         0|            0|            0|  0.00%|            [3, 4]])
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|    >>> np.matrix([[1, 2], [3, 4]])
   110|         0|            0|            0|  0.00%|    matrix([[1, 2],
   111|         0|            0|            0|  0.00%|            [3, 4]])
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    """
   114|         0|            0|            0|  0.00%|    __array_priority__ = 10.0
   115|         0|            0|            0|  0.00%|    def __new__(subtype, data, dtype=None, copy=True):
   116|         0|            0|            0|  0.00%|        warnings.warn('the matrix subclass is not the recommended way to '
   117|         0|            0|            0|  0.00%|                      'represent matrices or deal with linear algebra (see '
   118|         0|            0|            0|  0.00%|                      'https://docs.scipy.org/doc/numpy/user/'
   119|         0|            0|            0|  0.00%|                      'numpy-for-matlab-users.html). '
   120|         0|            0|            0|  0.00%|                      'Please adjust your code to use regular ndarray.',
   121|         0|            0|            0|  0.00%|                      PendingDeprecationWarning, stacklevel=2)
   122|         0|            0|            0|  0.00%|        if isinstance(data, matrix):
   123|         0|            0|            0|  0.00%|            dtype2 = data.dtype
   124|         0|            0|            0|  0.00%|            if (dtype is None):
   125|         0|            0|            0|  0.00%|                dtype = dtype2
   126|         0|            0|            0|  0.00%|            if (dtype2 == dtype) and (not copy):
   127|         0|            0|            0|  0.00%|                return data
   128|         0|            0|            0|  0.00%|            return data.astype(dtype)
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|        if isinstance(data, N.ndarray):
   131|         0|            0|            0|  0.00%|            if dtype is None:
   132|         0|            0|            0|  0.00%|                intype = data.dtype
   133|         0|            0|            0|  0.00%|            else:
   134|         0|            0|            0|  0.00%|                intype = N.dtype(dtype)
   135|         0|            0|            0|  0.00%|            new = data.view(subtype)
   136|         0|            0|            0|  0.00%|            if intype != data.dtype:
   137|         0|            0|            0|  0.00%|                return new.astype(intype)
   138|         0|            0|            0|  0.00%|            if copy: return new.copy()
   139|         0|            0|            0|  0.00%|            else: return new
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|        if isinstance(data, str):
   142|         0|            0|            0|  0.00%|            data = _convert_from_string(data)
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|        # now convert data to an array
   145|         0|            0|            0|  0.00%|        arr = N.array(data, dtype=dtype, copy=copy)
   146|         0|            0|            0|  0.00%|        ndim = arr.ndim
   147|         0|            0|            0|  0.00%|        shape = arr.shape
   148|         0|            0|            0|  0.00%|        if (ndim > 2):
   149|         0|            0|            0|  0.00%|            raise ValueError("matrix must be 2-dimensional")
   150|         0|            0|            0|  0.00%|        elif ndim == 0:
   151|         0|            0|            0|  0.00%|            shape = (1, 1)
   152|         0|            0|            0|  0.00%|        elif ndim == 1:
   153|         0|            0|            0|  0.00%|            shape = (1, shape[0])
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|        order = 'C'
   156|         0|            0|            0|  0.00%|        if (ndim == 2) and arr.flags.fortran:
   157|         0|            0|            0|  0.00%|            order = 'F'
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|        if not (order or arr.flags.contiguous):
   160|         0|            0|            0|  0.00%|            arr = arr.copy()
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|        ret = N.ndarray.__new__(subtype, shape, arr.dtype,
   163|         0|            0|            0|  0.00%|                                buffer=arr,
   164|         0|            0|            0|  0.00%|                                order=order)
   165|         0|            0|            0|  0.00%|        return ret
   166|         0|            0|            0|  0.00%|
   167|        64|   0.00199485|  3.11695e-05|  0.01%|    def __array_finalize__(self, obj):
   168|        64|            0|            0|  0.00%|        self._getitem = False
   169|        64|  0.000997305|  1.55829e-05|  0.00%|        if (isinstance(obj, matrix) and obj._getitem): return
   170|        64|            0|            0|  0.00%|        ndim = self.ndim
   171|        64|            0|            0|  0.00%|        if (ndim == 2):
   172|        52|            0|            0|  0.00%|            return
   173|        12|            0|            0|  0.00%|        if (ndim > 2):
   174|         0|            0|            0|  0.00%|            newshape = tuple([x for x in self.shape if x > 1])
   175|         0|            0|            0|  0.00%|            ndim = len(newshape)
   176|         0|            0|            0|  0.00%|            if ndim == 2:
   177|         0|            0|            0|  0.00%|                self.shape = newshape
   178|         0|            0|            0|  0.00%|                return
   179|         0|            0|            0|  0.00%|            elif (ndim > 2):
   180|         0|            0|            0|  0.00%|                raise ValueError("shape too large to be a matrix.")
   181|         0|            0|            0|  0.00%|        else:
   182|        12|            0|            0|  0.00%|            newshape = self.shape
   183|        12|            0|            0|  0.00%|        if ndim == 0:
   184|         0|            0|            0|  0.00%|            self.shape = (1, 1)
   185|        12|            0|            0|  0.00%|        elif ndim == 1:
   186|        12|            0|            0|  0.00%|            self.shape = (1, newshape[0])
(call)|        12|  0.000997782|  8.31485e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:167 __array_finalize__
   187|        12|            0|            0|  0.00%|        return
   188|         0|            0|            0|  0.00%|
   189|         4|            0|            0|  0.00%|    def __getitem__(self, index):
   190|         4|            0|            0|  0.00%|        self._getitem = True
   191|         0|            0|            0|  0.00%|
   192|         4|            0|            0|  0.00%|        try:
   193|         4|            0|            0|  0.00%|            out = N.ndarray.__getitem__(self, index)
   194|         0|            0|            0|  0.00%|        finally:
   195|         4|            0|            0|  0.00%|            self._getitem = False
   196|         0|            0|            0|  0.00%|
   197|         4|            0|            0|  0.00%|        if not isinstance(out, N.ndarray):
   198|         4|            0|            0|  0.00%|            return out
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|        if out.ndim == 0:
   201|         0|            0|            0|  0.00%|            return out[()]
   202|         0|            0|            0|  0.00%|        if out.ndim == 1:
   203|         0|            0|            0|  0.00%|            sh = out.shape[0]
   204|         0|            0|            0|  0.00%|            # Determine when we should have a column array
   205|         0|            0|            0|  0.00%|            try:
   206|         0|            0|            0|  0.00%|                n = len(index)
   207|         0|            0|            0|  0.00%|            except Exception:
   208|         0|            0|            0|  0.00%|                n = 0
   209|         0|            0|            0|  0.00%|            if n > 1 and isscalar(index[1]):
   210|         0|            0|            0|  0.00%|                out.shape = (sh, 1)
   211|         0|            0|            0|  0.00%|            else:
   212|         0|            0|            0|  0.00%|                out.shape = (1, sh)
   213|         0|            0|            0|  0.00%|        return out
   214|         0|            0|            0|  0.00%|
   215|         4|            0|            0|  0.00%|    def __mul__(self, other):
   216|         4|            0|            0|  0.00%|        if isinstance(other, (N.ndarray, list, tuple)) :
   217|         0|            0|            0|  0.00%|            # This promotes 1-D vectors to row vectors
   218|         0|            0|            0|  0.00%|            return N.dot(self, asmatrix(other))
   219|         4|            0|            0|  0.00%|        if isscalar(other) or not hasattr(other, '__rmul__') :
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:1859 isscalar
   220|         0|            0|            0|  0.00%|            return N.dot(self, other)
   221|         4|            0|            0|  0.00%|        return NotImplemented
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    def __rmul__(self, other):
   224|         0|            0|            0|  0.00%|        return N.dot(other, self)
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|    def __imul__(self, other):
   227|         0|            0|            0|  0.00%|        self[:] = self * other
   228|         0|            0|            0|  0.00%|        return self
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|    def __pow__(self, other):
   231|         0|            0|            0|  0.00%|        return matrix_power(self, other)
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|    def __ipow__(self, other):
   234|         0|            0|            0|  0.00%|        self[:] = self ** other
   235|         0|            0|            0|  0.00%|        return self
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    def __rpow__(self, other):
   238|         0|            0|            0|  0.00%|        return NotImplemented
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    def _align(self, axis):
   241|         0|            0|            0|  0.00%|        """A convenience function for operations that need to preserve axis
   242|         0|            0|            0|  0.00%|        orientation.
   243|         0|            0|            0|  0.00%|        """
   244|         0|            0|            0|  0.00%|        if axis is None:
   245|         0|            0|            0|  0.00%|            return self[0, 0]
   246|         0|            0|            0|  0.00%|        elif axis==0:
   247|         0|            0|            0|  0.00%|            return self
   248|         0|            0|            0|  0.00%|        elif axis==1:
   249|         0|            0|            0|  0.00%|            return self.transpose()
   250|         0|            0|            0|  0.00%|        else:
   251|         0|            0|            0|  0.00%|            raise ValueError("unsupported axis")
   252|         0|            0|            0|  0.00%|
   253|        12|            0|            0|  0.00%|    def _collapse(self, axis):
   254|         0|            0|            0|  0.00%|        """A convenience function for operations that want to collapse
   255|         0|            0|            0|  0.00%|        to a scalar like _align, but are using keepdims=True
   256|         0|            0|            0|  0.00%|        """
   257|        12|            0|            0|  0.00%|        if axis is None:
   258|         4|  7.77245e-05|  1.94311e-05|  0.00%|            return self[0, 0]
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:189 __getitem__
   259|         0|            0|            0|  0.00%|        else:
   260|         8|            0|            0|  0.00%|            return self
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    # Necessary because base-class tolist expects dimension
   263|         0|            0|            0|  0.00%|    #  reduction by x[0]
   264|         0|            0|            0|  0.00%|    def tolist(self):
   265|         0|            0|            0|  0.00%|        """
   266|         0|            0|            0|  0.00%|        Return the matrix as a (possibly nested) list.
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|        See `ndarray.tolist` for full documentation.
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|        See Also
   271|         0|            0|            0|  0.00%|        --------
   272|         0|            0|            0|  0.00%|        ndarray.tolist
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|        Examples
   275|         0|            0|            0|  0.00%|        --------
   276|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   277|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   278|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   279|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   280|         0|            0|            0|  0.00%|        >>> x.tolist()
   281|         0|            0|            0|  0.00%|        [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|        """
   284|         0|            0|            0|  0.00%|        return self.__array__().tolist()
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|    # To preserve orientation of result...
   287|        12|            0|            0|  0.00%|    def sum(self, axis=None, dtype=None, out=None):
   288|         0|            0|            0|  0.00%|        """
   289|         0|            0|            0|  0.00%|        Returns the sum of the matrix elements, along the given axis.
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        Refer to `numpy.sum` for full documentation.
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|        See Also
   294|         0|            0|            0|  0.00%|        --------
   295|         0|            0|            0|  0.00%|        numpy.sum
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|        Notes
   298|         0|            0|            0|  0.00%|        -----
   299|         0|            0|            0|  0.00%|        This is the same as `ndarray.sum`, except that where an `ndarray` would
   300|         0|            0|            0|  0.00%|        be returned, a `matrix` object is returned instead.
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|        Examples
   303|         0|            0|            0|  0.00%|        --------
   304|         0|            0|            0|  0.00%|        >>> x = np.matrix([[1, 2], [4, 3]])
   305|         0|            0|            0|  0.00%|        >>> x.sum()
   306|         0|            0|            0|  0.00%|        10
   307|         0|            0|            0|  0.00%|        >>> x.sum(axis=1)
   308|         0|            0|            0|  0.00%|        matrix([[3],
   309|         0|            0|            0|  0.00%|                [7]])
   310|         0|            0|            0|  0.00%|        >>> x.sum(axis=1, dtype='float')
   311|         0|            0|            0|  0.00%|        matrix([[3.],
   312|         0|            0|            0|  0.00%|                [7.]])
   313|         0|            0|            0|  0.00%|        >>> out = np.zeros((2, 1), dtype='float')
   314|         0|            0|            0|  0.00%|        >>> x.sum(axis=1, dtype='float', out=np.asmatrix(out))
   315|         0|            0|            0|  0.00%|        matrix([[3.],
   316|         0|            0|            0|  0.00%|                [7.]])
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|        """
   319|        12|            0|            0|  0.00%|        return N.ndarray.sum(self, axis, dtype, out, keepdims=True)._collapse(axis)
(call)|        12|  0.000997305|  8.31087e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:46 _sum
(call)|        12|  7.77245e-05|  6.47704e-06|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:253 _collapse
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    # To update docstring from array to matrix...
   323|         0|            0|            0|  0.00%|    def squeeze(self, axis=None):
   324|         0|            0|            0|  0.00%|        """
   325|         0|            0|            0|  0.00%|        Return a possibly reshaped matrix.
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|        Refer to `numpy.squeeze` for more documentation.
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|        Parameters
   330|         0|            0|            0|  0.00%|        ----------
   331|         0|            0|            0|  0.00%|        axis : None or int or tuple of ints, optional
   332|         0|            0|            0|  0.00%|            Selects a subset of the axes of length one in the shape.
   333|         0|            0|            0|  0.00%|            If an axis is selected with shape entry greater than one,
   334|         0|            0|            0|  0.00%|            an error is raised.
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|        Returns
   337|         0|            0|            0|  0.00%|        -------
   338|         0|            0|            0|  0.00%|        squeezed : matrix
   339|         0|            0|            0|  0.00%|            The matrix, but as a (1, N) matrix if it had shape (N, 1).
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|        See Also
   342|         0|            0|            0|  0.00%|        --------
   343|         0|            0|            0|  0.00%|        numpy.squeeze : related function
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|        Notes
   346|         0|            0|            0|  0.00%|        -----
   347|         0|            0|            0|  0.00%|        If `m` has a single column then that column is returned
   348|         0|            0|            0|  0.00%|        as the single row of a matrix.  Otherwise `m` is returned.
   349|         0|            0|            0|  0.00%|        The returned matrix is always either `m` itself or a view into `m`.
   350|         0|            0|            0|  0.00%|        Supplying an axis keyword argument will not affect the returned matrix
   351|         0|            0|            0|  0.00%|        but it may cause an error to be raised.
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|        Examples
   354|         0|            0|            0|  0.00%|        --------
   355|         0|            0|            0|  0.00%|        >>> c = np.matrix([[1], [2]])
   356|         0|            0|            0|  0.00%|        >>> c
   357|         0|            0|            0|  0.00%|        matrix([[1],
   358|         0|            0|            0|  0.00%|                [2]])
   359|         0|            0|            0|  0.00%|        >>> c.squeeze()
   360|         0|            0|            0|  0.00%|        matrix([[1, 2]])
   361|         0|            0|            0|  0.00%|        >>> r = c.T
   362|         0|            0|            0|  0.00%|        >>> r
   363|         0|            0|            0|  0.00%|        matrix([[1, 2]])
   364|         0|            0|            0|  0.00%|        >>> r.squeeze()
   365|         0|            0|            0|  0.00%|        matrix([[1, 2]])
   366|         0|            0|            0|  0.00%|        >>> m = np.matrix([[1, 2], [3, 4]])
   367|         0|            0|            0|  0.00%|        >>> m.squeeze()
   368|         0|            0|            0|  0.00%|        matrix([[1, 2],
   369|         0|            0|            0|  0.00%|                [3, 4]])
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|        """
   372|         0|            0|            0|  0.00%|        return N.ndarray.squeeze(self, axis=axis)
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|    # To update docstring from array to matrix...
   376|         0|            0|            0|  0.00%|    def flatten(self, order='C'):
   377|         0|            0|            0|  0.00%|        """
   378|         0|            0|            0|  0.00%|        Return a flattened copy of the matrix.
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|        All `N` elements of the matrix are placed into a single row.
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|        Parameters
   383|         0|            0|            0|  0.00%|        ----------
   384|         0|            0|            0|  0.00%|        order : {'C', 'F', 'A', 'K'}, optional
   385|         0|            0|            0|  0.00%|            'C' means to flatten in row-major (C-style) order. 'F' means to
   386|         0|            0|            0|  0.00%|            flatten in column-major (Fortran-style) order. 'A' means to
   387|         0|            0|            0|  0.00%|            flatten in column-major order if `m` is Fortran *contiguous* in
   388|         0|            0|            0|  0.00%|            memory, row-major order otherwise. 'K' means to flatten `m` in
   389|         0|            0|            0|  0.00%|            the order the elements occur in memory. The default is 'C'.
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|        Returns
   392|         0|            0|            0|  0.00%|        -------
   393|         0|            0|            0|  0.00%|        y : matrix
   394|         0|            0|            0|  0.00%|            A copy of the matrix, flattened to a `(1, N)` matrix where `N`
   395|         0|            0|            0|  0.00%|            is the number of elements in the original matrix.
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|        See Also
   398|         0|            0|            0|  0.00%|        --------
   399|         0|            0|            0|  0.00%|        ravel : Return a flattened array.
   400|         0|            0|            0|  0.00%|        flat : A 1-D flat iterator over the matrix.
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|        Examples
   403|         0|            0|            0|  0.00%|        --------
   404|         0|            0|            0|  0.00%|        >>> m = np.matrix([[1,2], [3,4]])
   405|         0|            0|            0|  0.00%|        >>> m.flatten()
   406|         0|            0|            0|  0.00%|        matrix([[1, 2, 3, 4]])
   407|         0|            0|            0|  0.00%|        >>> m.flatten('F')
   408|         0|            0|            0|  0.00%|        matrix([[1, 3, 2, 4]])
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|        """
   411|         0|            0|            0|  0.00%|        return N.ndarray.flatten(self, order=order)
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    def mean(self, axis=None, dtype=None, out=None):
   414|         0|            0|            0|  0.00%|        """
   415|         0|            0|            0|  0.00%|        Returns the average of the matrix elements along the given axis.
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|        Refer to `numpy.mean` for full documentation.
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|        See Also
   420|         0|            0|            0|  0.00%|        --------
   421|         0|            0|            0|  0.00%|        numpy.mean
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|        Notes
   424|         0|            0|            0|  0.00%|        -----
   425|         0|            0|            0|  0.00%|        Same as `ndarray.mean` except that, where that returns an `ndarray`,
   426|         0|            0|            0|  0.00%|        this returns a `matrix` object.
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|        Examples
   429|         0|            0|            0|  0.00%|        --------
   430|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3, 4)))
   431|         0|            0|            0|  0.00%|        >>> x
   432|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   433|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   434|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   435|         0|            0|            0|  0.00%|        >>> x.mean()
   436|         0|            0|            0|  0.00%|        5.5
   437|         0|            0|            0|  0.00%|        >>> x.mean(0)
   438|         0|            0|            0|  0.00%|        matrix([[4., 5., 6., 7.]])
   439|         0|            0|            0|  0.00%|        >>> x.mean(1)
   440|         0|            0|            0|  0.00%|        matrix([[ 1.5],
   441|         0|            0|            0|  0.00%|                [ 5.5],
   442|         0|            0|            0|  0.00%|                [ 9.5]])
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|        """
   445|         0|            0|            0|  0.00%|        return N.ndarray.mean(self, axis, dtype, out, keepdims=True)._collapse(axis)
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    def std(self, axis=None, dtype=None, out=None, ddof=0):
   448|         0|            0|            0|  0.00%|        """
   449|         0|            0|            0|  0.00%|        Return the standard deviation of the array elements along the given axis.
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|        Refer to `numpy.std` for full documentation.
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|        See Also
   454|         0|            0|            0|  0.00%|        --------
   455|         0|            0|            0|  0.00%|        numpy.std
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|        Notes
   458|         0|            0|            0|  0.00%|        -----
   459|         0|            0|            0|  0.00%|        This is the same as `ndarray.std`, except that where an `ndarray` would
   460|         0|            0|            0|  0.00%|        be returned, a `matrix` object is returned instead.
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|        Examples
   463|         0|            0|            0|  0.00%|        --------
   464|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3, 4)))
   465|         0|            0|            0|  0.00%|        >>> x
   466|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   467|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   468|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   469|         0|            0|            0|  0.00%|        >>> x.std()
   470|         0|            0|            0|  0.00%|        3.4520525295346629 # may vary
   471|         0|            0|            0|  0.00%|        >>> x.std(0)
   472|         0|            0|            0|  0.00%|        matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary
   473|         0|            0|            0|  0.00%|        >>> x.std(1)
   474|         0|            0|            0|  0.00%|        matrix([[ 1.11803399],
   475|         0|            0|            0|  0.00%|                [ 1.11803399],
   476|         0|            0|            0|  0.00%|                [ 1.11803399]])
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|        """
   479|         0|            0|            0|  0.00%|        return N.ndarray.std(self, axis, dtype, out, ddof, keepdims=True)._collapse(axis)
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|    def var(self, axis=None, dtype=None, out=None, ddof=0):
   482|         0|            0|            0|  0.00%|        """
   483|         0|            0|            0|  0.00%|        Returns the variance of the matrix elements, along the given axis.
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|        Refer to `numpy.var` for full documentation.
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|        See Also
   488|         0|            0|            0|  0.00%|        --------
   489|         0|            0|            0|  0.00%|        numpy.var
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|        Notes
   492|         0|            0|            0|  0.00%|        -----
   493|         0|            0|            0|  0.00%|        This is the same as `ndarray.var`, except that where an `ndarray` would
   494|         0|            0|            0|  0.00%|        be returned, a `matrix` object is returned instead.
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|        Examples
   497|         0|            0|            0|  0.00%|        --------
   498|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3, 4)))
   499|         0|            0|            0|  0.00%|        >>> x
   500|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   501|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   502|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   503|         0|            0|            0|  0.00%|        >>> x.var()
   504|         0|            0|            0|  0.00%|        11.916666666666666
   505|         0|            0|            0|  0.00%|        >>> x.var(0)
   506|         0|            0|            0|  0.00%|        matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary
   507|         0|            0|            0|  0.00%|        >>> x.var(1)
   508|         0|            0|            0|  0.00%|        matrix([[1.25],
   509|         0|            0|            0|  0.00%|                [1.25],
   510|         0|            0|            0|  0.00%|                [1.25]])
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|        """
   513|         0|            0|            0|  0.00%|        return N.ndarray.var(self, axis, dtype, out, ddof, keepdims=True)._collapse(axis)
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|    def prod(self, axis=None, dtype=None, out=None):
   516|         0|            0|            0|  0.00%|        """
   517|         0|            0|            0|  0.00%|        Return the product of the array elements over the given axis.
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|        Refer to `prod` for full documentation.
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|        See Also
   522|         0|            0|            0|  0.00%|        --------
   523|         0|            0|            0|  0.00%|        prod, ndarray.prod
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|        Notes
   526|         0|            0|            0|  0.00%|        -----
   527|         0|            0|            0|  0.00%|        Same as `ndarray.prod`, except, where that returns an `ndarray`, this
   528|         0|            0|            0|  0.00%|        returns a `matrix` object instead.
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|        Examples
   531|         0|            0|            0|  0.00%|        --------
   532|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   533|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   534|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   535|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   536|         0|            0|            0|  0.00%|        >>> x.prod()
   537|         0|            0|            0|  0.00%|        0
   538|         0|            0|            0|  0.00%|        >>> x.prod(0)
   539|         0|            0|            0|  0.00%|        matrix([[  0,  45, 120, 231]])
   540|         0|            0|            0|  0.00%|        >>> x.prod(1)
   541|         0|            0|            0|  0.00%|        matrix([[   0],
   542|         0|            0|            0|  0.00%|                [ 840],
   543|         0|            0|            0|  0.00%|                [7920]])
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|        """
   546|         0|            0|            0|  0.00%|        return N.ndarray.prod(self, axis, dtype, out, keepdims=True)._collapse(axis)
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|    def any(self, axis=None, out=None):
   549|         0|            0|            0|  0.00%|        """
   550|         0|            0|            0|  0.00%|        Test whether any array element along a given axis evaluates to True.
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|        Refer to `numpy.any` for full documentation.
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|        Parameters
   555|         0|            0|            0|  0.00%|        ----------
   556|         0|            0|            0|  0.00%|        axis : int, optional
   557|         0|            0|            0|  0.00%|            Axis along which logical OR is performed
   558|         0|            0|            0|  0.00%|        out : ndarray, optional
   559|         0|            0|            0|  0.00%|            Output to existing array instead of creating new one, must have
   560|         0|            0|            0|  0.00%|            same shape as expected output
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|        Returns
   563|         0|            0|            0|  0.00%|        -------
   564|         0|            0|            0|  0.00%|            any : bool, ndarray
   565|         0|            0|            0|  0.00%|                Returns a single bool if `axis` is ``None``; otherwise,
   566|         0|            0|            0|  0.00%|                returns `ndarray`
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|        """
   569|         0|            0|            0|  0.00%|        return N.ndarray.any(self, axis, out, keepdims=True)._collapse(axis)
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|    def all(self, axis=None, out=None):
   572|         0|            0|            0|  0.00%|        """
   573|         0|            0|            0|  0.00%|        Test whether all matrix elements along a given axis evaluate to True.
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|        Parameters
   576|         0|            0|            0|  0.00%|        ----------
   577|         0|            0|            0|  0.00%|        See `numpy.all` for complete descriptions
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|        See Also
   580|         0|            0|            0|  0.00%|        --------
   581|         0|            0|            0|  0.00%|        numpy.all
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|        Notes
   584|         0|            0|            0|  0.00%|        -----
   585|         0|            0|            0|  0.00%|        This is the same as `ndarray.all`, but it returns a `matrix` object.
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|        Examples
   588|         0|            0|            0|  0.00%|        --------
   589|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   590|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   591|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   592|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   593|         0|            0|            0|  0.00%|        >>> y = x[0]; y
   594|         0|            0|            0|  0.00%|        matrix([[0, 1, 2, 3]])
   595|         0|            0|            0|  0.00%|        >>> (x == y)
   596|         0|            0|            0|  0.00%|        matrix([[ True,  True,  True,  True],
   597|         0|            0|            0|  0.00%|                [False, False, False, False],
   598|         0|            0|            0|  0.00%|                [False, False, False, False]])
   599|         0|            0|            0|  0.00%|        >>> (x == y).all()
   600|         0|            0|            0|  0.00%|        False
   601|         0|            0|            0|  0.00%|        >>> (x == y).all(0)
   602|         0|            0|            0|  0.00%|        matrix([[False, False, False, False]])
   603|         0|            0|            0|  0.00%|        >>> (x == y).all(1)
   604|         0|            0|            0|  0.00%|        matrix([[ True],
   605|         0|            0|            0|  0.00%|                [False],
   606|         0|            0|            0|  0.00%|                [False]])
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|        """
   609|         0|            0|            0|  0.00%|        return N.ndarray.all(self, axis, out, keepdims=True)._collapse(axis)
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|    def max(self, axis=None, out=None):
   612|         0|            0|            0|  0.00%|        """
   613|         0|            0|            0|  0.00%|        Return the maximum value along an axis.
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|        Parameters
   616|         0|            0|            0|  0.00%|        ----------
   617|         0|            0|            0|  0.00%|        See `amax` for complete descriptions
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|        See Also
   620|         0|            0|            0|  0.00%|        --------
   621|         0|            0|            0|  0.00%|        amax, ndarray.max
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|        Notes
   624|         0|            0|            0|  0.00%|        -----
   625|         0|            0|            0|  0.00%|        This is the same as `ndarray.max`, but returns a `matrix` object
   626|         0|            0|            0|  0.00%|        where `ndarray.max` would return an ndarray.
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|        Examples
   629|         0|            0|            0|  0.00%|        --------
   630|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   631|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   632|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   633|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   634|         0|            0|            0|  0.00%|        >>> x.max()
   635|         0|            0|            0|  0.00%|        11
   636|         0|            0|            0|  0.00%|        >>> x.max(0)
   637|         0|            0|            0|  0.00%|        matrix([[ 8,  9, 10, 11]])
   638|         0|            0|            0|  0.00%|        >>> x.max(1)
   639|         0|            0|            0|  0.00%|        matrix([[ 3],
   640|         0|            0|            0|  0.00%|                [ 7],
   641|         0|            0|            0|  0.00%|                [11]])
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|        """
   644|         0|            0|            0|  0.00%|        return N.ndarray.max(self, axis, out, keepdims=True)._collapse(axis)
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|    def argmax(self, axis=None, out=None):
   647|         0|            0|            0|  0.00%|        """
   648|         0|            0|            0|  0.00%|        Indexes of the maximum values along an axis.
   649|         0|            0|            0|  0.00%|
   650|         0|            0|            0|  0.00%|        Return the indexes of the first occurrences of the maximum values
   651|         0|            0|            0|  0.00%|        along the specified axis.  If axis is None, the index is for the
   652|         0|            0|            0|  0.00%|        flattened matrix.
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|        Parameters
   655|         0|            0|            0|  0.00%|        ----------
   656|         0|            0|            0|  0.00%|        See `numpy.argmax` for complete descriptions
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|        See Also
   659|         0|            0|            0|  0.00%|        --------
   660|         0|            0|            0|  0.00%|        numpy.argmax
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|        Notes
   663|         0|            0|            0|  0.00%|        -----
   664|         0|            0|            0|  0.00%|        This is the same as `ndarray.argmax`, but returns a `matrix` object
   665|         0|            0|            0|  0.00%|        where `ndarray.argmax` would return an `ndarray`.
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|        Examples
   668|         0|            0|            0|  0.00%|        --------
   669|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   670|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   671|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   672|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   673|         0|            0|            0|  0.00%|        >>> x.argmax()
   674|         0|            0|            0|  0.00%|        11
   675|         0|            0|            0|  0.00%|        >>> x.argmax(0)
   676|         0|            0|            0|  0.00%|        matrix([[2, 2, 2, 2]])
   677|         0|            0|            0|  0.00%|        >>> x.argmax(1)
   678|         0|            0|            0|  0.00%|        matrix([[3],
   679|         0|            0|            0|  0.00%|                [3],
   680|         0|            0|            0|  0.00%|                [3]])
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|        """
   683|         0|            0|            0|  0.00%|        return N.ndarray.argmax(self, axis, out)._align(axis)
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|    def min(self, axis=None, out=None):
   686|         0|            0|            0|  0.00%|        """
   687|         0|            0|            0|  0.00%|        Return the minimum value along an axis.
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|        Parameters
   690|         0|            0|            0|  0.00%|        ----------
   691|         0|            0|            0|  0.00%|        See `amin` for complete descriptions.
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|        See Also
   694|         0|            0|            0|  0.00%|        --------
   695|         0|            0|            0|  0.00%|        amin, ndarray.min
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|        Notes
   698|         0|            0|            0|  0.00%|        -----
   699|         0|            0|            0|  0.00%|        This is the same as `ndarray.min`, but returns a `matrix` object
   700|         0|            0|            0|  0.00%|        where `ndarray.min` would return an ndarray.
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|        Examples
   703|         0|            0|            0|  0.00%|        --------
   704|         0|            0|            0|  0.00%|        >>> x = -np.matrix(np.arange(12).reshape((3,4))); x
   705|         0|            0|            0|  0.00%|        matrix([[  0,  -1,  -2,  -3],
   706|         0|            0|            0|  0.00%|                [ -4,  -5,  -6,  -7],
   707|         0|            0|            0|  0.00%|                [ -8,  -9, -10, -11]])
   708|         0|            0|            0|  0.00%|        >>> x.min()
   709|         0|            0|            0|  0.00%|        -11
   710|         0|            0|            0|  0.00%|        >>> x.min(0)
   711|         0|            0|            0|  0.00%|        matrix([[ -8,  -9, -10, -11]])
   712|         0|            0|            0|  0.00%|        >>> x.min(1)
   713|         0|            0|            0|  0.00%|        matrix([[ -3],
   714|         0|            0|            0|  0.00%|                [ -7],
   715|         0|            0|            0|  0.00%|                [-11]])
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|        """
   718|         0|            0|            0|  0.00%|        return N.ndarray.min(self, axis, out, keepdims=True)._collapse(axis)
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|    def argmin(self, axis=None, out=None):
   721|         0|            0|            0|  0.00%|        """
   722|         0|            0|            0|  0.00%|        Indexes of the minimum values along an axis.
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|        Return the indexes of the first occurrences of the minimum values
   725|         0|            0|            0|  0.00%|        along the specified axis.  If axis is None, the index is for the
   726|         0|            0|            0|  0.00%|        flattened matrix.
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|        Parameters
   729|         0|            0|            0|  0.00%|        ----------
   730|         0|            0|            0|  0.00%|        See `numpy.argmin` for complete descriptions.
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|        See Also
   733|         0|            0|            0|  0.00%|        --------
   734|         0|            0|            0|  0.00%|        numpy.argmin
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|        Notes
   737|         0|            0|            0|  0.00%|        -----
   738|         0|            0|            0|  0.00%|        This is the same as `ndarray.argmin`, but returns a `matrix` object
   739|         0|            0|            0|  0.00%|        where `ndarray.argmin` would return an `ndarray`.
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|        Examples
   742|         0|            0|            0|  0.00%|        --------
   743|         0|            0|            0|  0.00%|        >>> x = -np.matrix(np.arange(12).reshape((3,4))); x
   744|         0|            0|            0|  0.00%|        matrix([[  0,  -1,  -2,  -3],
   745|         0|            0|            0|  0.00%|                [ -4,  -5,  -6,  -7],
   746|         0|            0|            0|  0.00%|                [ -8,  -9, -10, -11]])
   747|         0|            0|            0|  0.00%|        >>> x.argmin()
   748|         0|            0|            0|  0.00%|        11
   749|         0|            0|            0|  0.00%|        >>> x.argmin(0)
   750|         0|            0|            0|  0.00%|        matrix([[2, 2, 2, 2]])
   751|         0|            0|            0|  0.00%|        >>> x.argmin(1)
   752|         0|            0|            0|  0.00%|        matrix([[3],
   753|         0|            0|            0|  0.00%|                [3],
   754|         0|            0|            0|  0.00%|                [3]])
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|        """
   757|         0|            0|            0|  0.00%|        return N.ndarray.argmin(self, axis, out)._align(axis)
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|    def ptp(self, axis=None, out=None):
   760|         0|            0|            0|  0.00%|        """
   761|         0|            0|            0|  0.00%|        Peak-to-peak (maximum - minimum) value along the given axis.
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|        Refer to `numpy.ptp` for full documentation.
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|        See Also
   766|         0|            0|            0|  0.00%|        --------
   767|         0|            0|            0|  0.00%|        numpy.ptp
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|        Notes
   770|         0|            0|            0|  0.00%|        -----
   771|         0|            0|            0|  0.00%|        Same as `ndarray.ptp`, except, where that would return an `ndarray` object,
   772|         0|            0|            0|  0.00%|        this returns a `matrix` object.
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|        Examples
   775|         0|            0|            0|  0.00%|        --------
   776|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   777|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   778|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   779|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   780|         0|            0|            0|  0.00%|        >>> x.ptp()
   781|         0|            0|            0|  0.00%|        11
   782|         0|            0|            0|  0.00%|        >>> x.ptp(0)
   783|         0|            0|            0|  0.00%|        matrix([[8, 8, 8, 8]])
   784|         0|            0|            0|  0.00%|        >>> x.ptp(1)
   785|         0|            0|            0|  0.00%|        matrix([[3],
   786|         0|            0|            0|  0.00%|                [3],
   787|         0|            0|            0|  0.00%|                [3]])
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|        """
   790|         0|            0|            0|  0.00%|        return N.ndarray.ptp(self, axis, out)._align(axis)
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|    @property
   793|         0|            0|            0|  0.00%|    def I(self):
   794|         0|            0|            0|  0.00%|        """
   795|         0|            0|            0|  0.00%|        Returns the (multiplicative) inverse of invertible `self`.
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|        Parameters
   798|         0|            0|            0|  0.00%|        ----------
   799|         0|            0|            0|  0.00%|        None
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|        Returns
   802|         0|            0|            0|  0.00%|        -------
   803|         0|            0|            0|  0.00%|        ret : matrix object
   804|         0|            0|            0|  0.00%|            If `self` is non-singular, `ret` is such that ``ret * self`` ==
   805|         0|            0|            0|  0.00%|            ``self * ret`` == ``np.matrix(np.eye(self[0,:].size))`` all return
   806|         0|            0|            0|  0.00%|            ``True``.
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|        Raises
   809|         0|            0|            0|  0.00%|        ------
   810|         0|            0|            0|  0.00%|        numpy.linalg.LinAlgError: Singular matrix
   811|         0|            0|            0|  0.00%|            If `self` is singular.
   812|         0|            0|            0|  0.00%|
   813|         0|            0|            0|  0.00%|        See Also
   814|         0|            0|            0|  0.00%|        --------
   815|         0|            0|            0|  0.00%|        linalg.inv
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|        Examples
   818|         0|            0|            0|  0.00%|        --------
   819|         0|            0|            0|  0.00%|        >>> m = np.matrix('[1, 2; 3, 4]'); m
   820|         0|            0|            0|  0.00%|        matrix([[1, 2],
   821|         0|            0|            0|  0.00%|                [3, 4]])
   822|         0|            0|            0|  0.00%|        >>> m.getI()
   823|         0|            0|            0|  0.00%|        matrix([[-2. ,  1. ],
   824|         0|            0|            0|  0.00%|                [ 1.5, -0.5]])
   825|         0|            0|            0|  0.00%|        >>> m.getI() * m
   826|         0|            0|            0|  0.00%|        matrix([[ 1.,  0.], # may vary
   827|         0|            0|            0|  0.00%|                [ 0.,  1.]])
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|        """
   830|         0|            0|            0|  0.00%|        M, N = self.shape
   831|         0|            0|            0|  0.00%|        if M == N:
   832|         0|            0|            0|  0.00%|            from numpy.linalg import inv as func
   833|         0|            0|            0|  0.00%|        else:
   834|         0|            0|            0|  0.00%|            from numpy.linalg import pinv as func
   835|         0|            0|            0|  0.00%|        return asmatrix(func(self))
   836|         0|            0|            0|  0.00%|
   837|         0|            0|            0|  0.00%|    @property
   838|         0|            0|            0|  0.00%|    def A(self):
   839|         0|            0|            0|  0.00%|        """
   840|         0|            0|            0|  0.00%|        Return `self` as an `ndarray` object.
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|        Equivalent to ``np.asarray(self)``.
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|        Parameters
   845|         0|            0|            0|  0.00%|        ----------
   846|         0|            0|            0|  0.00%|        None
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|        Returns
   849|         0|            0|            0|  0.00%|        -------
   850|         0|            0|            0|  0.00%|        ret : ndarray
   851|         0|            0|            0|  0.00%|            `self` as an `ndarray`
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|        Examples
   854|         0|            0|            0|  0.00%|        --------
   855|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   856|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   857|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   858|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   859|         0|            0|            0|  0.00%|        >>> x.getA()
   860|         0|            0|            0|  0.00%|        array([[ 0,  1,  2,  3],
   861|         0|            0|            0|  0.00%|               [ 4,  5,  6,  7],
   862|         0|            0|            0|  0.00%|               [ 8,  9, 10, 11]])
   863|         0|            0|            0|  0.00%|
   864|         0|            0|            0|  0.00%|        """
   865|         0|            0|            0|  0.00%|        return self.__array__()
   866|         0|            0|            0|  0.00%|
   867|         0|            0|            0|  0.00%|    @property
   868|         0|            0|            0|  0.00%|    def A1(self):
   869|         0|            0|            0|  0.00%|        """
   870|         0|            0|            0|  0.00%|        Return `self` as a flattened `ndarray`.
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|        Equivalent to ``np.asarray(x).ravel()``
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|        Parameters
   875|         0|            0|            0|  0.00%|        ----------
   876|         0|            0|            0|  0.00%|        None
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|        Returns
   879|         0|            0|            0|  0.00%|        -------
   880|         0|            0|            0|  0.00%|        ret : ndarray
   881|         0|            0|            0|  0.00%|            `self`, 1-D, as an `ndarray`
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|        Examples
   884|         0|            0|            0|  0.00%|        --------
   885|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4))); x
   886|         0|            0|            0|  0.00%|        matrix([[ 0,  1,  2,  3],
   887|         0|            0|            0|  0.00%|                [ 4,  5,  6,  7],
   888|         0|            0|            0|  0.00%|                [ 8,  9, 10, 11]])
   889|         0|            0|            0|  0.00%|        >>> x.getA1()
   890|         0|            0|            0|  0.00%|        array([ 0,  1,  2, ...,  9, 10, 11])
   891|         0|            0|            0|  0.00%|
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|        """
   894|         0|            0|            0|  0.00%|        return self.__array__().ravel()
   895|         0|            0|            0|  0.00%|
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|    def ravel(self, order='C'):
   898|         0|            0|            0|  0.00%|        """
   899|         0|            0|            0|  0.00%|        Return a flattened matrix.
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|        Refer to `numpy.ravel` for more documentation.
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|        Parameters
   904|         0|            0|            0|  0.00%|        ----------
   905|         0|            0|            0|  0.00%|        order : {'C', 'F', 'A', 'K'}, optional
   906|         0|            0|            0|  0.00%|            The elements of `m` are read using this index order. 'C' means to
   907|         0|            0|            0|  0.00%|            index the elements in C-like order, with the last axis index
   908|         0|            0|            0|  0.00%|            changing fastest, back to the first axis index changing slowest.
   909|         0|            0|            0|  0.00%|            'F' means to index the elements in Fortran-like index order, with
   910|         0|            0|            0|  0.00%|            the first index changing fastest, and the last index changing
   911|         0|            0|            0|  0.00%|            slowest. Note that the 'C' and 'F' options take no account of the
   912|         0|            0|            0|  0.00%|            memory layout of the underlying array, and only refer to the order
   913|         0|            0|            0|  0.00%|            of axis indexing.  'A' means to read the elements in Fortran-like
   914|         0|            0|            0|  0.00%|            index order if `m` is Fortran *contiguous* in memory, C-like order
   915|         0|            0|            0|  0.00%|            otherwise.  'K' means to read the elements in the order they occur
   916|         0|            0|            0|  0.00%|            in memory, except for reversing the data when strides are negative.
   917|         0|            0|            0|  0.00%|            By default, 'C' index order is used.
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|        Returns
   920|         0|            0|            0|  0.00%|        -------
   921|         0|            0|            0|  0.00%|        ret : matrix
   922|         0|            0|            0|  0.00%|            Return the matrix flattened to shape `(1, N)` where `N`
   923|         0|            0|            0|  0.00%|            is the number of elements in the original matrix.
   924|         0|            0|            0|  0.00%|            A copy is made only if necessary.
   925|         0|            0|            0|  0.00%|
   926|         0|            0|            0|  0.00%|        See Also
   927|         0|            0|            0|  0.00%|        --------
   928|         0|            0|            0|  0.00%|        matrix.flatten : returns a similar output matrix but always a copy
   929|         0|            0|            0|  0.00%|        matrix.flat : a flat iterator on the array.
   930|         0|            0|            0|  0.00%|        numpy.ravel : related function which returns an ndarray
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|        """
   933|         0|            0|            0|  0.00%|        return N.ndarray.ravel(self, order=order)
   934|         0|            0|            0|  0.00%|
   935|         4|            0|            0|  0.00%|    @property
   936|         0|            0|            0|  0.00%|    def T(self):
   937|         0|            0|            0|  0.00%|        """
   938|         0|            0|            0|  0.00%|        Returns the transpose of the matrix.
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|        Does *not* conjugate!  For the complex conjugate transpose, use ``.H``.
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|        Parameters
   943|         0|            0|            0|  0.00%|        ----------
   944|         0|            0|            0|  0.00%|        None
   945|         0|            0|            0|  0.00%|
   946|         0|            0|            0|  0.00%|        Returns
   947|         0|            0|            0|  0.00%|        -------
   948|         0|            0|            0|  0.00%|        ret : matrix object
   949|         0|            0|            0|  0.00%|            The (non-conjugated) transpose of the matrix.
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|        See Also
   952|         0|            0|            0|  0.00%|        --------
   953|         0|            0|            0|  0.00%|        transpose, getH
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|        Examples
   956|         0|            0|            0|  0.00%|        --------
   957|         0|            0|            0|  0.00%|        >>> m = np.matrix('[1, 2; 3, 4]')
   958|         0|            0|            0|  0.00%|        >>> m
   959|         0|            0|            0|  0.00%|        matrix([[1, 2],
   960|         0|            0|            0|  0.00%|                [3, 4]])
   961|         0|            0|            0|  0.00%|        >>> m.getT()
   962|         0|            0|            0|  0.00%|        matrix([[1, 3],
   963|         0|            0|            0|  0.00%|                [2, 4]])
   964|         0|            0|            0|  0.00%|
   965|         0|            0|            0|  0.00%|        """
   966|         4|            0|            0|  0.00%|        return self.transpose()
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:167 __array_finalize__
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|    @property
   969|         0|            0|            0|  0.00%|    def H(self):
   970|         0|            0|            0|  0.00%|        """
   971|         0|            0|            0|  0.00%|        Returns the (complex) conjugate transpose of `self`.
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|        Equivalent to ``np.transpose(self)`` if `self` is real-valued.
   974|         0|            0|            0|  0.00%|
   975|         0|            0|            0|  0.00%|        Parameters
   976|         0|            0|            0|  0.00%|        ----------
   977|         0|            0|            0|  0.00%|        None
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|        Returns
   980|         0|            0|            0|  0.00%|        -------
   981|         0|            0|            0|  0.00%|        ret : matrix object
   982|         0|            0|            0|  0.00%|            complex conjugate transpose of `self`
   983|         0|            0|            0|  0.00%|
   984|         0|            0|            0|  0.00%|        Examples
   985|         0|            0|            0|  0.00%|        --------
   986|         0|            0|            0|  0.00%|        >>> x = np.matrix(np.arange(12).reshape((3,4)))
   987|         0|            0|            0|  0.00%|        >>> z = x - 1j*x; z
   988|         0|            0|            0|  0.00%|        matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],
   989|         0|            0|            0|  0.00%|                [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],
   990|         0|            0|            0|  0.00%|                [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])
   991|         0|            0|            0|  0.00%|        >>> z.getH()
   992|         0|            0|            0|  0.00%|        matrix([[ 0. -0.j,  4. +4.j,  8. +8.j],
   993|         0|            0|            0|  0.00%|                [ 1. +1.j,  5. +5.j,  9. +9.j],
   994|         0|            0|            0|  0.00%|                [ 2. +2.j,  6. +6.j, 10.+10.j],
   995|         0|            0|            0|  0.00%|                [ 3. +3.j,  7. +7.j, 11.+11.j]])
   996|         0|            0|            0|  0.00%|
   997|         0|            0|            0|  0.00%|        """
   998|         0|            0|            0|  0.00%|        if issubclass(self.dtype.type, N.complexfloating):
   999|         0|            0|            0|  0.00%|            return self.transpose().conjugate()
  1000|         0|            0|            0|  0.00%|        else:
  1001|         0|            0|            0|  0.00%|            return self.transpose()
  1002|         0|            0|            0|  0.00%|
  1003|         0|            0|            0|  0.00%|    # kept for compatibility
  1004|         0|            0|            0|  0.00%|    getT = T.fget
  1005|         0|            0|            0|  0.00%|    getA = A.fget
  1006|         0|            0|            0|  0.00%|    getA1 = A1.fget
  1007|         0|            0|            0|  0.00%|    getH = H.fget
  1008|         0|            0|            0|  0.00%|    getI = I.fget
  1009|         0|            0|            0|  0.00%|
  1010|         0|            0|            0|  0.00%|def _from_string(str, gdict, ldict):
  1011|         0|            0|            0|  0.00%|    rows = str.split(';')
  1012|         0|            0|            0|  0.00%|    rowtup = []
  1013|         0|            0|            0|  0.00%|    for row in rows:
  1014|         0|            0|            0|  0.00%|        trow = row.split(',')
  1015|         0|            0|            0|  0.00%|        newrow = []
  1016|         0|            0|            0|  0.00%|        for x in trow:
  1017|         0|            0|            0|  0.00%|            newrow.extend(x.split())
  1018|         0|            0|            0|  0.00%|        trow = newrow
  1019|         0|            0|            0|  0.00%|        coltup = []
  1020|         0|            0|            0|  0.00%|        for col in trow:
  1021|         0|            0|            0|  0.00%|            col = col.strip()
  1022|         0|            0|            0|  0.00%|            try:
  1023|         0|            0|            0|  0.00%|                thismat = ldict[col]
  1024|         0|            0|            0|  0.00%|            except KeyError:
  1025|         0|            0|            0|  0.00%|                try:
  1026|         0|            0|            0|  0.00%|                    thismat = gdict[col]
  1027|         0|            0|            0|  0.00%|                except KeyError as e:
  1028|         0|            0|            0|  0.00%|                    raise NameError(f"name {col!r} is not defined") from None
  1029|         0|            0|            0|  0.00%|
  1030|         0|            0|            0|  0.00%|            coltup.append(thismat)
  1031|         0|            0|            0|  0.00%|        rowtup.append(concatenate(coltup, axis=-1))
  1032|         0|            0|            0|  0.00%|    return concatenate(rowtup, axis=0)
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|
  1035|         0|            0|            0|  0.00%|@set_module('numpy')
  1036|         0|            0|            0|  0.00%|def bmat(obj, ldict=None, gdict=None):
  1037|         0|            0|            0|  0.00%|    """
  1038|         0|            0|            0|  0.00%|    Build a matrix object from a string, nested sequence, or array.
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|    Parameters
  1041|         0|            0|            0|  0.00%|    ----------
  1042|         0|            0|            0|  0.00%|    obj : str or array_like
  1043|         0|            0|            0|  0.00%|        Input data. If a string, variables in the current scope may be
  1044|         0|            0|            0|  0.00%|        referenced by name.
  1045|         0|            0|            0|  0.00%|    ldict : dict, optional
  1046|         0|            0|            0|  0.00%|        A dictionary that replaces local operands in current frame.
  1047|         0|            0|            0|  0.00%|        Ignored if `obj` is not a string or `gdict` is None.
  1048|         0|            0|            0|  0.00%|    gdict : dict, optional
  1049|         0|            0|            0|  0.00%|        A dictionary that replaces global operands in current frame.
  1050|         0|            0|            0|  0.00%|        Ignored if `obj` is not a string.
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|    Returns
  1053|         0|            0|            0|  0.00%|    -------
  1054|         0|            0|            0|  0.00%|    out : matrix
  1055|         0|            0|            0|  0.00%|        Returns a matrix object, which is a specialized 2-D array.
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|    See Also
  1058|         0|            0|            0|  0.00%|    --------
  1059|         0|            0|            0|  0.00%|    block :
  1060|         0|            0|            0|  0.00%|        A generalization of this function for N-d arrays, that returns normal
  1061|         0|            0|            0|  0.00%|        ndarrays.
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|    Examples
  1064|         0|            0|            0|  0.00%|    --------
  1065|         0|            0|            0|  0.00%|    >>> A = np.mat('1 1; 1 1')
  1066|         0|            0|            0|  0.00%|    >>> B = np.mat('2 2; 2 2')
  1067|         0|            0|            0|  0.00%|    >>> C = np.mat('3 4; 5 6')
  1068|         0|            0|            0|  0.00%|    >>> D = np.mat('7 8; 9 0')
  1069|         0|            0|            0|  0.00%|
  1070|         0|            0|            0|  0.00%|    All the following expressions construct the same block matrix:
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|    >>> np.bmat([[A, B], [C, D]])
  1073|         0|            0|            0|  0.00%|    matrix([[1, 1, 2, 2],
  1074|         0|            0|            0|  0.00%|            [1, 1, 2, 2],
  1075|         0|            0|            0|  0.00%|            [3, 4, 7, 8],
  1076|         0|            0|            0|  0.00%|            [5, 6, 9, 0]])
  1077|         0|            0|            0|  0.00%|    >>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])
  1078|         0|            0|            0|  0.00%|    matrix([[1, 1, 2, 2],
  1079|         0|            0|            0|  0.00%|            [1, 1, 2, 2],
  1080|         0|            0|            0|  0.00%|            [3, 4, 7, 8],
  1081|         0|            0|            0|  0.00%|            [5, 6, 9, 0]])
  1082|         0|            0|            0|  0.00%|    >>> np.bmat('A,B; C,D')
  1083|         0|            0|            0|  0.00%|    matrix([[1, 1, 2, 2],
  1084|         0|            0|            0|  0.00%|            [1, 1, 2, 2],
  1085|         0|            0|            0|  0.00%|            [3, 4, 7, 8],
  1086|         0|            0|            0|  0.00%|            [5, 6, 9, 0]])
  1087|         0|            0|            0|  0.00%|
  1088|         0|            0|            0|  0.00%|    """
  1089|         0|            0|            0|  0.00%|    if isinstance(obj, str):
  1090|         0|            0|            0|  0.00%|        if gdict is None:
  1091|         0|            0|            0|  0.00%|            # get previous frame
  1092|         0|            0|            0|  0.00%|            frame = sys._getframe().f_back
  1093|         0|            0|            0|  0.00%|            glob_dict = frame.f_globals
  1094|         0|            0|            0|  0.00%|            loc_dict = frame.f_locals
  1095|         0|            0|            0|  0.00%|        else:
  1096|         0|            0|            0|  0.00%|            glob_dict = gdict
  1097|         0|            0|            0|  0.00%|            loc_dict = ldict
  1098|         0|            0|            0|  0.00%|
  1099|         0|            0|            0|  0.00%|        return matrix(_from_string(obj, glob_dict, loc_dict))
  1100|         0|            0|            0|  0.00%|
  1101|         0|            0|            0|  0.00%|    if isinstance(obj, (tuple, list)):
  1102|         0|            0|            0|  0.00%|        # [[A,B],[C,D]]
  1103|         0|            0|            0|  0.00%|        arr_rows = []
  1104|         0|            0|            0|  0.00%|        for row in obj:
  1105|         0|            0|            0|  0.00%|            if isinstance(row, N.ndarray):  # not 2-d
  1106|         0|            0|            0|  0.00%|                return matrix(concatenate(obj, axis=-1))
  1107|         0|            0|            0|  0.00%|            else:
  1108|         0|            0|            0|  0.00%|                arr_rows.append(concatenate(row, axis=-1))
  1109|         0|            0|            0|  0.00%|        return matrix(concatenate(arr_rows, axis=0))
  1110|         0|            0|            0|  0.00%|    if isinstance(obj, N.ndarray):
  1111|         0|            0|            0|  0.00%|        return matrix(obj)
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|mat = asmatrix
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\metrics\cluster\_supervised.py
File duration: 0.00304699s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Utilities to evaluate the clustering performance of models.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|Functions named as *_score return a scalar value to maximize: the higher the
     4|         0|            0|            0|  0.00%|better.
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|# Authors: Olivier Grisel <olivier.grisel@ensta.org>
     8|         0|            0|            0|  0.00%|#          Wei LI <kuantkid@gmail.com>
     9|         0|            0|            0|  0.00%|#          Diego Molla <dmolla-aliod@gmail.com>
    10|         0|            0|            0|  0.00%|#          Arnaud Fouchet <foucheta@gmail.com>
    11|         0|            0|            0|  0.00%|#          Thierry Guillemot <thierry.guillemot.work@gmail.com>
    12|         0|            0|            0|  0.00%|#          Gregory Stupp <stuppie@gmail.com>
    13|         0|            0|            0|  0.00%|#          Joel Nothman <joel.nothman@gmail.com>
    14|         0|            0|            0|  0.00%|#          Arya McCarthy <arya@jhu.edu>
    15|         0|            0|            0|  0.00%|#          Uwe F Mayer <uwe_f_mayer@yahoo.com>
    16|         0|            0|            0|  0.00%|# License: BSD 3 clause
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|import warnings
    20|         0|            0|            0|  0.00%|from math import log
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|import numpy as np
    23|         0|            0|            0|  0.00%|from scipy import sparse as sp
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|from ._expected_mutual_info_fast import expected_mutual_information
    26|         0|            0|            0|  0.00%|from ...utils.fixes import _astype_copy_false
    27|         0|            0|            0|  0.00%|from ...utils.multiclass import type_of_target
    28|         0|            0|            0|  0.00%|from ...utils.validation import check_array, check_consistent_length
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         4|            0|            0|  0.00%|def check_clusterings(labels_true, labels_pred):
    32|         0|            0|            0|  0.00%|    """Check that the labels arrays are 1D and of same dimension.
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|    Parameters
    35|         0|            0|            0|  0.00%|    ----------
    36|         0|            0|            0|  0.00%|    labels_true : array-like of shape (n_samples,)
    37|         0|            0|            0|  0.00%|        The true labels.
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,)
    40|         0|            0|            0|  0.00%|        The predicted labels.
    41|         0|            0|            0|  0.00%|    """
    42|         8|            0|            0|  0.00%|    labels_true = check_array(
(call)|         4|    0.0019927|  0.000498176|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:486 check_array
    43|         4|            0|            0|  0.00%|        labels_true,
    44|         4|            0|            0|  0.00%|        ensure_2d=False,
    45|         4|            0|            0|  0.00%|        ensure_min_samples=0,
    46|         4|            0|            0|  0.00%|        dtype=None,
    47|         0|            0|            0|  0.00%|    )
    48|         0|            0|            0|  0.00%|
    49|         8|            0|            0|  0.00%|    labels_pred = check_array(
(call)|         4|  0.000997543|  0.000249386|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:486 check_array
    50|         4|            0|            0|  0.00%|        labels_pred,
    51|         4|            0|            0|  0.00%|        ensure_2d=False,
    52|         4|            0|            0|  0.00%|        ensure_min_samples=0,
    53|         4|            0|            0|  0.00%|        dtype=None,
    54|         0|            0|            0|  0.00%|    )
    55|         0|            0|            0|  0.00%|
    56|         4|            0|            0|  0.00%|    type_label = type_of_target(labels_true)
(call)|         4|   0.00299358|  0.000748396|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\multiclass.py:201 type_of_target
    57|         4|            0|            0|  0.00%|    type_pred = type_of_target(labels_pred)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\multiclass.py:201 type_of_target
    58|         0|            0|            0|  0.00%|
    59|         4|            0|            0|  0.00%|    if "continuous" in (type_pred, type_label):
    60|         0|            0|            0|  0.00%|        msg = (
    61|         0|            0|            0|  0.00%|            "Clustering metrics expects discrete values but received"
    62|         0|            0|            0|  0.00%|            f" {type_label} values for label, and {type_pred} values "
    63|         0|            0|            0|  0.00%|            "for target"
    64|         0|            0|            0|  0.00%|        )
    65|         0|            0|            0|  0.00%|        warnings.warn(msg, UserWarning)
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|    # input checks
    68|         4|            0|            0|  0.00%|    if labels_true.ndim != 1:
    69|         0|            0|            0|  0.00%|        raise ValueError("labels_true must be 1D: shape is %r" % (labels_true.shape,))
    70|         4|            0|            0|  0.00%|    if labels_pred.ndim != 1:
    71|         0|            0|            0|  0.00%|        raise ValueError("labels_pred must be 1D: shape is %r" % (labels_pred.shape,))
    72|         4|            0|            0|  0.00%|    check_consistent_length(labels_true, labels_pred)
(call)|         4|   0.00199437|  0.000498593|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:317 check_consistent_length
    73|         0|            0|            0|  0.00%|
    74|         4|            0|            0|  0.00%|    return labels_true, labels_pred
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         4|   0.00101018|  0.000252545|  0.00%|def _generalized_average(U, V, average_method):
    78|         0|            0|            0|  0.00%|    """Return a particular mean of two numbers."""
    79|         4|            0|            0|  0.00%|    if average_method == "min":
    80|         0|            0|            0|  0.00%|        return min(U, V)
    81|         4|            0|            0|  0.00%|    elif average_method == "geometric":
    82|         0|            0|            0|  0.00%|        return np.sqrt(U * V)
    83|         4|            0|            0|  0.00%|    elif average_method == "arithmetic":
    84|         4|            0|            0|  0.00%|        return np.mean([U, V])
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 mean
    85|         0|            0|            0|  0.00%|    elif average_method == "max":
    86|         0|            0|            0|  0.00%|        return max(U, V)
    87|         0|            0|            0|  0.00%|    else:
    88|         0|            0|            0|  0.00%|        raise ValueError(
    89|         0|            0|            0|  0.00%|            "'average_method' must be 'min', 'geometric', 'arithmetic', or 'max'"
    90|         0|            0|            0|  0.00%|        )
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         4|            0|            0|  0.00%|def contingency_matrix(
    94|         0|            0|            0|  0.00%|    labels_true, labels_pred, *, eps=None, sparse=False, dtype=np.int64
    95|         0|            0|            0|  0.00%|):
    96|         0|            0|            0|  0.00%|    """Build a contingency matrix describing the relationship between labels.
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    Parameters
    99|         0|            0|            0|  0.00%|    ----------
   100|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   101|         0|            0|            0|  0.00%|        Ground truth class labels to be used as a reference.
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,)
   104|         0|            0|            0|  0.00%|        Cluster labels to evaluate.
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|    eps : float, default=None
   107|         0|            0|            0|  0.00%|        If a float, that value is added to all values in the contingency
   108|         0|            0|            0|  0.00%|        matrix. This helps to stop NaN propagation.
   109|         0|            0|            0|  0.00%|        If ``None``, nothing is adjusted.
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    sparse : bool, default=False
   112|         0|            0|            0|  0.00%|        If `True`, return a sparse CSR continency matrix. If `eps` is not
   113|         0|            0|            0|  0.00%|        `None` and `sparse` is `True` will raise ValueError.
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|        .. versionadded:: 0.18
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|    dtype : numeric type, default=np.int64
   118|         0|            0|            0|  0.00%|        Output dtype. Ignored if `eps` is not `None`.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|        .. versionadded:: 0.24
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|    Returns
   123|         0|            0|            0|  0.00%|    -------
   124|         0|            0|            0|  0.00%|    contingency : {array-like, sparse}, shape=[n_classes_true, n_classes_pred]
   125|         0|            0|            0|  0.00%|        Matrix :math:`C` such that :math:`C_{i, j}` is the number of samples in
   126|         0|            0|            0|  0.00%|        true class :math:`i` and in predicted class :math:`j`. If
   127|         0|            0|            0|  0.00%|        ``eps is None``, the dtype of this array will be integer unless set
   128|         0|            0|            0|  0.00%|        otherwise with the ``dtype`` argument. If ``eps`` is given, the dtype
   129|         0|            0|            0|  0.00%|        will be float.
   130|         0|            0|            0|  0.00%|        Will be a ``sklearn.sparse.csr_matrix`` if ``sparse=True``.
   131|         0|            0|            0|  0.00%|    """
   132|         0|            0|            0|  0.00%|
   133|         4|            0|            0|  0.00%|    if eps is not None and sparse:
   134|         0|            0|            0|  0.00%|        raise ValueError("Cannot set 'eps' when sparse=True")
   135|         0|            0|            0|  0.00%|
   136|         4|            0|            0|  0.00%|    classes, class_idx = np.unique(labels_true, return_inverse=True)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 unique
   137|         4|            0|            0|  0.00%|    clusters, cluster_idx = np.unique(labels_pred, return_inverse=True)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 unique
   138|         4|            0|            0|  0.00%|    n_classes = classes.shape[0]
   139|         4|            0|            0|  0.00%|    n_clusters = clusters.shape[0]
   140|         0|            0|            0|  0.00%|    # Using coo_matrix to accelerate simple histogram calculation,
   141|         0|            0|            0|  0.00%|    # i.e. bins are consecutive integers
   142|         0|            0|            0|  0.00%|    # Currently, coo_matrix is faster than histogram2d for simple cases
   143|         8|            0|            0|  0.00%|    contingency = sp.coo_matrix(
(call)|         4|   0.00299048|  0.000747621|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:126 __init__
   144|         4|            0|            0|  0.00%|        (np.ones(class_idx.shape[0]), (class_idx, cluster_idx)),
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\numeric.py:149 ones
   145|         4|            0|            0|  0.00%|        shape=(n_classes, n_clusters),
   146|         4|            0|            0|  0.00%|        dtype=dtype,
   147|         0|            0|            0|  0.00%|    )
   148|         4|            0|            0|  0.00%|    if sparse:
   149|         4|            0|            0|  0.00%|        contingency = contingency.tocsr()
(call)|         4|   0.00693178|   0.00173295|  0.02%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:372 tocsr
   150|         4|            0|            0|  0.00%|        contingency.sum_duplicates()
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1099 sum_duplicates
   151|         0|            0|            0|  0.00%|    else:
   152|         0|            0|            0|  0.00%|        contingency = contingency.toarray()
   153|         0|            0|            0|  0.00%|        if eps is not None:
   154|         0|            0|            0|  0.00%|            # don't use += as contingency is integer
   155|         0|            0|            0|  0.00%|            contingency = contingency + eps
   156|         4|            0|            0|  0.00%|    return contingency
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|# clustering measures
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|def pair_confusion_matrix(labels_true, labels_pred):
   163|         0|            0|            0|  0.00%|    """Pair confusion matrix arising from two clusterings.
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    The pair confusion matrix :math:`C` computes a 2 by 2 similarity matrix
   166|         0|            0|            0|  0.00%|    between two clusterings by considering all pairs of samples and counting
   167|         0|            0|            0|  0.00%|    pairs that are assigned into the same or into different clusters under
   168|         0|            0|            0|  0.00%|    the true and predicted clusterings.
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    Considering a pair of samples that is clustered together a positive pair,
   171|         0|            0|            0|  0.00%|    then as in binary classification the count of true negatives is
   172|         0|            0|            0|  0.00%|    :math:`C_{00}`, false negatives is :math:`C_{10}`, true positives is
   173|         0|            0|            0|  0.00%|    :math:`C_{11}` and false positives is :math:`C_{01}`.
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <pair_confusion_matrix>`.
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|    Parameters
   178|         0|            0|            0|  0.00%|    ----------
   179|         0|            0|            0|  0.00%|    labels_true : array-like of shape (n_samples,), dtype=integral
   180|         0|            0|            0|  0.00%|        Ground truth class labels to be used as a reference.
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,), dtype=integral
   183|         0|            0|            0|  0.00%|        Cluster labels to evaluate.
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    Returns
   186|         0|            0|            0|  0.00%|    -------
   187|         0|            0|            0|  0.00%|    C : ndarray of shape (2, 2), dtype=np.int64
   188|         0|            0|            0|  0.00%|        The contingency matrix.
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    See Also
   191|         0|            0|            0|  0.00%|    --------
   192|         0|            0|            0|  0.00%|    rand_score: Rand Score
   193|         0|            0|            0|  0.00%|    adjusted_rand_score: Adjusted Rand Score
   194|         0|            0|            0|  0.00%|    adjusted_mutual_info_score: Adjusted Mutual Information
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|    Examples
   197|         0|            0|            0|  0.00%|    --------
   198|         0|            0|            0|  0.00%|    Perfectly matching labelings have all non-zero entries on the
   199|         0|            0|            0|  0.00%|    diagonal regardless of actual label values:
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import pair_confusion_matrix
   202|         0|            0|            0|  0.00%|      >>> pair_confusion_matrix([0, 0, 1, 1], [1, 1, 0, 0])
   203|         0|            0|            0|  0.00%|      array([[8, 0],
   204|         0|            0|            0|  0.00%|             [0, 4]]...
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|    Labelings that assign all classes members to the same clusters
   207|         0|            0|            0|  0.00%|    are complete but may be not always pure, hence penalized, and
   208|         0|            0|            0|  0.00%|    have some off-diagonal non-zero entries:
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|      >>> pair_confusion_matrix([0, 0, 1, 2], [0, 0, 1, 1])
   211|         0|            0|            0|  0.00%|      array([[8, 2],
   212|         0|            0|            0|  0.00%|             [0, 2]]...
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    Note that the matrix is not symmetric.
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    References
   217|         0|            0|            0|  0.00%|    ----------
   218|         0|            0|            0|  0.00%|    .. L. Hubert and P. Arabie, Comparing Partitions, Journal of
   219|         0|            0|            0|  0.00%|      Classification 1985
   220|         0|            0|            0|  0.00%|      https://link.springer.com/article/10.1007%2FBF01908075
   221|         0|            0|            0|  0.00%|    """
   222|         0|            0|            0|  0.00%|    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)
   223|         0|            0|            0|  0.00%|    n_samples = np.int64(labels_true.shape[0])
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|    # Computation using the contingency data
   226|         0|            0|            0|  0.00%|    contingency = contingency_matrix(
   227|         0|            0|            0|  0.00%|        labels_true, labels_pred, sparse=True, dtype=np.int64
   228|         0|            0|            0|  0.00%|    )
   229|         0|            0|            0|  0.00%|    n_c = np.ravel(contingency.sum(axis=1))
   230|         0|            0|            0|  0.00%|    n_k = np.ravel(contingency.sum(axis=0))
   231|         0|            0|            0|  0.00%|    sum_squares = (contingency.data ** 2).sum()
   232|         0|            0|            0|  0.00%|    C = np.empty((2, 2), dtype=np.int64)
   233|         0|            0|            0|  0.00%|    C[1, 1] = sum_squares - n_samples
   234|         0|            0|            0|  0.00%|    C[0, 1] = contingency.dot(n_k).sum() - sum_squares
   235|         0|            0|            0|  0.00%|    C[1, 0] = contingency.transpose().dot(n_c).sum() - sum_squares
   236|         0|            0|            0|  0.00%|    C[0, 0] = n_samples ** 2 - C[0, 1] - C[1, 0] - sum_squares
   237|         0|            0|            0|  0.00%|    return C
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|def rand_score(labels_true, labels_pred):
   241|         0|            0|            0|  0.00%|    """Rand index.
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    The Rand Index computes a similarity measure between two clusterings
   244|         0|            0|            0|  0.00%|    by considering all pairs of samples and counting pairs that are
   245|         0|            0|            0|  0.00%|    assigned in the same or different clusters in the predicted and
   246|         0|            0|            0|  0.00%|    true clusterings.
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    The raw RI score is:
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|        RI = (number of agreeing pairs) / (number of pairs)
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <rand_score>`.
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    Parameters
   255|         0|            0|            0|  0.00%|    ----------
   256|         0|            0|            0|  0.00%|    labels_true : array-like of shape (n_samples,), dtype=integral
   257|         0|            0|            0|  0.00%|        Ground truth class labels to be used as a reference.
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,), dtype=integral
   260|         0|            0|            0|  0.00%|        Cluster labels to evaluate.
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    Returns
   263|         0|            0|            0|  0.00%|    -------
   264|         0|            0|            0|  0.00%|    RI : float
   265|         0|            0|            0|  0.00%|       Similarity score between 0.0 and 1.0, inclusive, 1.0 stands for
   266|         0|            0|            0|  0.00%|       perfect match.
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|    See Also
   269|         0|            0|            0|  0.00%|    --------
   270|         0|            0|            0|  0.00%|    adjusted_rand_score: Adjusted Rand Score
   271|         0|            0|            0|  0.00%|    adjusted_mutual_info_score: Adjusted Mutual Information
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    Examples
   274|         0|            0|            0|  0.00%|    --------
   275|         0|            0|            0|  0.00%|    Perfectly matching labelings have a score of 1 even
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import rand_score
   278|         0|            0|            0|  0.00%|      >>> rand_score([0, 0, 1, 1], [1, 1, 0, 0])
   279|         0|            0|            0|  0.00%|      1.0
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    Labelings that assign all classes members to the same clusters
   282|         0|            0|            0|  0.00%|    are complete but may not always be pure, hence penalized:
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|      >>> rand_score([0, 0, 1, 2], [0, 0, 1, 1])
   285|         0|            0|            0|  0.00%|      0.83...
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|    References
   288|         0|            0|            0|  0.00%|    ----------
   289|         0|            0|            0|  0.00%|    .. L. Hubert and P. Arabie, Comparing Partitions, Journal of
   290|         0|            0|            0|  0.00%|      Classification 1985
   291|         0|            0|            0|  0.00%|      https://link.springer.com/article/10.1007%2FBF01908075
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    .. https://en.wikipedia.org/wiki/Simple_matching_coefficient
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    .. https://en.wikipedia.org/wiki/Rand_index
   296|         0|            0|            0|  0.00%|    """
   297|         0|            0|            0|  0.00%|    contingency = pair_confusion_matrix(labels_true, labels_pred)
   298|         0|            0|            0|  0.00%|    numerator = contingency.diagonal().sum()
   299|         0|            0|            0|  0.00%|    denominator = contingency.sum()
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    if numerator == denominator or denominator == 0:
   302|         0|            0|            0|  0.00%|        # Special limit cases: no clustering since the data is not split;
   303|         0|            0|            0|  0.00%|        # or trivial clustering where each document is assigned a unique
   304|         0|            0|            0|  0.00%|        # cluster. These are perfect matches hence return 1.0.
   305|         0|            0|            0|  0.00%|        return 1.0
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    return numerator / denominator
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|def adjusted_rand_score(labels_true, labels_pred):
   311|         0|            0|            0|  0.00%|    """Rand index adjusted for chance.
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|    The Rand Index computes a similarity measure between two clusterings
   314|         0|            0|            0|  0.00%|    by considering all pairs of samples and counting pairs that are
   315|         0|            0|            0|  0.00%|    assigned in the same or different clusters in the predicted and
   316|         0|            0|            0|  0.00%|    true clusterings.
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    The raw RI score is then "adjusted for chance" into the ARI score
   319|         0|            0|            0|  0.00%|    using the following scheme::
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|        ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    The adjusted Rand index is thus ensured to have a value close to
   324|         0|            0|            0|  0.00%|    0.0 for random labeling independently of the number of clusters and
   325|         0|            0|            0|  0.00%|    samples and exactly 1.0 when the clusterings are identical (up to
   326|         0|            0|            0|  0.00%|    a permutation).
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|    ARI is a symmetric measure::
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|        adjusted_rand_score(a, b) == adjusted_rand_score(b, a)
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <adjusted_rand_score>`.
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|    Parameters
   335|         0|            0|            0|  0.00%|    ----------
   336|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   337|         0|            0|            0|  0.00%|        Ground truth class labels to be used as a reference
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,)
   340|         0|            0|            0|  0.00%|        Cluster labels to evaluate
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|    Returns
   343|         0|            0|            0|  0.00%|    -------
   344|         0|            0|            0|  0.00%|    ARI : float
   345|         0|            0|            0|  0.00%|       Similarity score between -1.0 and 1.0. Random labelings have an ARI
   346|         0|            0|            0|  0.00%|       close to 0.0. 1.0 stands for perfect match.
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    Examples
   349|         0|            0|            0|  0.00%|    --------
   350|         0|            0|            0|  0.00%|    Perfectly matching labelings have a score of 1 even
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import adjusted_rand_score
   353|         0|            0|            0|  0.00%|      >>> adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 1])
   354|         0|            0|            0|  0.00%|      1.0
   355|         0|            0|            0|  0.00%|      >>> adjusted_rand_score([0, 0, 1, 1], [1, 1, 0, 0])
   356|         0|            0|            0|  0.00%|      1.0
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|    Labelings that assign all classes members to the same clusters
   359|         0|            0|            0|  0.00%|    are complete but may not always be pure, hence penalized::
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|      >>> adjusted_rand_score([0, 0, 1, 2], [0, 0, 1, 1])
   362|         0|            0|            0|  0.00%|      0.57...
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|    ARI is symmetric, so labelings that have pure clusters with members
   365|         0|            0|            0|  0.00%|    coming from the same classes but unnecessary splits are penalized::
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|      >>> adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 2])
   368|         0|            0|            0|  0.00%|      0.57...
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    If classes members are completely split across different clusters, the
   371|         0|            0|            0|  0.00%|    assignment is totally incomplete, hence the ARI is very low::
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|      >>> adjusted_rand_score([0, 0, 0, 0], [0, 1, 2, 3])
   374|         0|            0|            0|  0.00%|      0.0
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    References
   377|         0|            0|            0|  0.00%|    ----------
   378|         0|            0|            0|  0.00%|    .. [Hubert1985] L. Hubert and P. Arabie, Comparing Partitions,
   379|         0|            0|            0|  0.00%|      Journal of Classification 1985
   380|         0|            0|            0|  0.00%|      https://link.springer.com/article/10.1007%2FBF01908075
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|    .. [Steinley2004] D. Steinley, Properties of the Hubert-Arabie
   383|         0|            0|            0|  0.00%|      adjusted Rand index, Psychological Methods 2004
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    .. [wk] https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    See Also
   388|         0|            0|            0|  0.00%|    --------
   389|         0|            0|            0|  0.00%|    adjusted_mutual_info_score : Adjusted Mutual Information.
   390|         0|            0|            0|  0.00%|    """
   391|         0|            0|            0|  0.00%|    (tn, fp), (fn, tp) = pair_confusion_matrix(labels_true, labels_pred)
   392|         0|            0|            0|  0.00%|    # convert to Python integer types, to avoid overflow or underflow
   393|         0|            0|            0|  0.00%|    tn, fp, fn, tp = int(tn), int(fp), int(fn), int(tp)
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    # Special cases: empty data or full agreement
   396|         0|            0|            0|  0.00%|    if fn == 0 and fp == 0:
   397|         0|            0|            0|  0.00%|        return 1.0
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    return 2.0 * (tp * tn - fn * fp) / ((tp + fn) * (fn + tn) + (tp + fp) * (fp + tn))
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|def homogeneity_completeness_v_measure(labels_true, labels_pred, *, beta=1.0):
   403|         0|            0|            0|  0.00%|    """Compute the homogeneity and completeness and V-Measure scores at once.
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    Those metrics are based on normalized conditional entropy measures of
   406|         0|            0|            0|  0.00%|    the clustering labeling to evaluate given the knowledge of a Ground
   407|         0|            0|            0|  0.00%|    Truth class labels of the same samples.
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    A clustering result satisfies homogeneity if all of its clusters
   410|         0|            0|            0|  0.00%|    contain only data points which are members of a single class.
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    A clustering result satisfies completeness if all the data points
   413|         0|            0|            0|  0.00%|    that are members of a given class are elements of the same cluster.
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|    Both scores have positive values between 0.0 and 1.0, larger values
   416|         0|            0|            0|  0.00%|    being desirable.
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|    Those 3 metrics are independent of the absolute values of the labels:
   419|         0|            0|            0|  0.00%|    a permutation of the class or cluster label values won't change the
   420|         0|            0|            0|  0.00%|    score values in any way.
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    V-Measure is furthermore symmetric: swapping ``labels_true`` and
   423|         0|            0|            0|  0.00%|    ``label_pred`` will give the same score. This does not hold for
   424|         0|            0|            0|  0.00%|    homogeneity and completeness. V-Measure is identical to
   425|         0|            0|            0|  0.00%|    :func:`normalized_mutual_info_score` with the arithmetic averaging
   426|         0|            0|            0|  0.00%|    method.
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <homogeneity_completeness>`.
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|    Parameters
   431|         0|            0|            0|  0.00%|    ----------
   432|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   433|         0|            0|            0|  0.00%|        ground truth class labels to be used as a reference
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,)
   436|         0|            0|            0|  0.00%|        cluster labels to evaluate
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|    beta : float, default=1.0
   439|         0|            0|            0|  0.00%|        Ratio of weight attributed to ``homogeneity`` vs ``completeness``.
   440|         0|            0|            0|  0.00%|        If ``beta`` is greater than 1, ``completeness`` is weighted more
   441|         0|            0|            0|  0.00%|        strongly in the calculation. If ``beta`` is less than 1,
   442|         0|            0|            0|  0.00%|        ``homogeneity`` is weighted more strongly.
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|    Returns
   445|         0|            0|            0|  0.00%|    -------
   446|         0|            0|            0|  0.00%|    homogeneity : float
   447|         0|            0|            0|  0.00%|       score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    completeness : float
   450|         0|            0|            0|  0.00%|       score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|    v_measure : float
   453|         0|            0|            0|  0.00%|        harmonic mean of the first two
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    See Also
   456|         0|            0|            0|  0.00%|    --------
   457|         0|            0|            0|  0.00%|    homogeneity_score
   458|         0|            0|            0|  0.00%|    completeness_score
   459|         0|            0|            0|  0.00%|    v_measure_score
   460|         0|            0|            0|  0.00%|    """
   461|         0|            0|            0|  0.00%|    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|    if len(labels_true) == 0:
   464|         0|            0|            0|  0.00%|        return 1.0, 1.0, 1.0
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|    entropy_C = entropy(labels_true)
   467|         0|            0|            0|  0.00%|    entropy_K = entropy(labels_pred)
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|    contingency = contingency_matrix(labels_true, labels_pred, sparse=True)
   470|         0|            0|            0|  0.00%|    MI = mutual_info_score(None, None, contingency=contingency)
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|    homogeneity = MI / (entropy_C) if entropy_C else 1.0
   473|         0|            0|            0|  0.00%|    completeness = MI / (entropy_K) if entropy_K else 1.0
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|    if homogeneity + completeness == 0.0:
   476|         0|            0|            0|  0.00%|        v_measure_score = 0.0
   477|         0|            0|            0|  0.00%|    else:
   478|         0|            0|            0|  0.00%|        v_measure_score = (
   479|         0|            0|            0|  0.00%|            (1 + beta)
   480|         0|            0|            0|  0.00%|            * homogeneity
   481|         0|            0|            0|  0.00%|            * completeness
   482|         0|            0|            0|  0.00%|            / (beta * homogeneity + completeness)
   483|         0|            0|            0|  0.00%|        )
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|    return homogeneity, completeness, v_measure_score
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|def homogeneity_score(labels_true, labels_pred):
   489|         0|            0|            0|  0.00%|    """Homogeneity metric of a cluster labeling given a ground truth.
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    A clustering result satisfies homogeneity if all of its clusters
   492|         0|            0|            0|  0.00%|    contain only data points which are members of a single class.
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    This metric is independent of the absolute values of the labels:
   495|         0|            0|            0|  0.00%|    a permutation of the class or cluster label values won't change the
   496|         0|            0|            0|  0.00%|    score value in any way.
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|    This metric is not symmetric: switching ``label_true`` with ``label_pred``
   499|         0|            0|            0|  0.00%|    will return the :func:`completeness_score` which will be different in
   500|         0|            0|            0|  0.00%|    general.
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <homogeneity_completeness>`.
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    Parameters
   505|         0|            0|            0|  0.00%|    ----------
   506|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   507|         0|            0|            0|  0.00%|        ground truth class labels to be used as a reference
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,)
   510|         0|            0|            0|  0.00%|        cluster labels to evaluate
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    Returns
   513|         0|            0|            0|  0.00%|    -------
   514|         0|            0|            0|  0.00%|    homogeneity : float
   515|         0|            0|            0|  0.00%|       score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|    References
   518|         0|            0|            0|  0.00%|    ----------
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|    .. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   521|         0|            0|            0|  0.00%|       conditional entropy-based external cluster evaluation measure
   522|         0|            0|            0|  0.00%|       <https://aclweb.org/anthology/D/D07/D07-1043.pdf>`_
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|    See Also
   525|         0|            0|            0|  0.00%|    --------
   526|         0|            0|            0|  0.00%|    completeness_score
   527|         0|            0|            0|  0.00%|    v_measure_score
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|    Examples
   530|         0|            0|            0|  0.00%|    --------
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|    Perfect labelings are homogeneous::
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import homogeneity_score
   535|         0|            0|            0|  0.00%|      >>> homogeneity_score([0, 0, 1, 1], [1, 1, 0, 0])
   536|         0|            0|            0|  0.00%|      1.0
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|    Non-perfect labelings that further split classes into more clusters can be
   539|         0|            0|            0|  0.00%|    perfectly homogeneous::
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|      >>> print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 0, 1, 2]))
   542|         0|            0|            0|  0.00%|      1.000000
   543|         0|            0|            0|  0.00%|      >>> print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 1, 2, 3]))
   544|         0|            0|            0|  0.00%|      1.000000
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|    Clusters that include samples from different classes do not make for an
   547|         0|            0|            0|  0.00%|    homogeneous labeling::
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|      >>> print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 1, 0, 1]))
   550|         0|            0|            0|  0.00%|      0.0...
   551|         0|            0|            0|  0.00%|      >>> print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 0, 0, 0]))
   552|         0|            0|            0|  0.00%|      0.0...
   553|         0|            0|            0|  0.00%|    """
   554|         0|            0|            0|  0.00%|    return homogeneity_completeness_v_measure(labels_true, labels_pred)[0]
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|def completeness_score(labels_true, labels_pred):
   558|         0|            0|            0|  0.00%|    """Completeness metric of a cluster labeling given a ground truth.
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|    A clustering result satisfies completeness if all the data points
   561|         0|            0|            0|  0.00%|    that are members of a given class are elements of the same cluster.
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|    This metric is independent of the absolute values of the labels:
   564|         0|            0|            0|  0.00%|    a permutation of the class or cluster label values won't change the
   565|         0|            0|            0|  0.00%|    score value in any way.
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|    This metric is not symmetric: switching ``label_true`` with ``label_pred``
   568|         0|            0|            0|  0.00%|    will return the :func:`homogeneity_score` which will be different in
   569|         0|            0|            0|  0.00%|    general.
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <homogeneity_completeness>`.
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|    Parameters
   574|         0|            0|            0|  0.00%|    ----------
   575|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   576|         0|            0|            0|  0.00%|        ground truth class labels to be used as a reference
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,)
   579|         0|            0|            0|  0.00%|        cluster labels to evaluate
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|    Returns
   582|         0|            0|            0|  0.00%|    -------
   583|         0|            0|            0|  0.00%|    completeness : float
   584|         0|            0|            0|  0.00%|       score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|    References
   587|         0|            0|            0|  0.00%|    ----------
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|    .. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   590|         0|            0|            0|  0.00%|       conditional entropy-based external cluster evaluation measure
   591|         0|            0|            0|  0.00%|       <https://aclweb.org/anthology/D/D07/D07-1043.pdf>`_
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    See Also
   594|         0|            0|            0|  0.00%|    --------
   595|         0|            0|            0|  0.00%|    homogeneity_score
   596|         0|            0|            0|  0.00%|    v_measure_score
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|    Examples
   599|         0|            0|            0|  0.00%|    --------
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|    Perfect labelings are complete::
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import completeness_score
   604|         0|            0|            0|  0.00%|      >>> completeness_score([0, 0, 1, 1], [1, 1, 0, 0])
   605|         0|            0|            0|  0.00%|      1.0
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|    Non-perfect labelings that assign all classes members to the same clusters
   608|         0|            0|            0|  0.00%|    are still complete::
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|      >>> print(completeness_score([0, 0, 1, 1], [0, 0, 0, 0]))
   611|         0|            0|            0|  0.00%|      1.0
   612|         0|            0|            0|  0.00%|      >>> print(completeness_score([0, 1, 2, 3], [0, 0, 1, 1]))
   613|         0|            0|            0|  0.00%|      0.999...
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    If classes members are split across different clusters, the
   616|         0|            0|            0|  0.00%|    assignment cannot be complete::
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|      >>> print(completeness_score([0, 0, 1, 1], [0, 1, 0, 1]))
   619|         0|            0|            0|  0.00%|      0.0
   620|         0|            0|            0|  0.00%|      >>> print(completeness_score([0, 0, 0, 0], [0, 1, 2, 3]))
   621|         0|            0|            0|  0.00%|      0.0
   622|         0|            0|            0|  0.00%|    """
   623|         0|            0|            0|  0.00%|    return homogeneity_completeness_v_measure(labels_true, labels_pred)[1]
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|def v_measure_score(labels_true, labels_pred, *, beta=1.0):
   627|         0|            0|            0|  0.00%|    """V-measure cluster labeling given a ground truth.
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|    This score is identical to :func:`normalized_mutual_info_score` with
   630|         0|            0|            0|  0.00%|    the ``'arithmetic'`` option for averaging.
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|    The V-measure is the harmonic mean between homogeneity and completeness::
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|        v = (1 + beta) * homogeneity * completeness
   635|         0|            0|            0|  0.00%|             / (beta * homogeneity + completeness)
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|    This metric is independent of the absolute values of the labels:
   638|         0|            0|            0|  0.00%|    a permutation of the class or cluster label values won't change the
   639|         0|            0|            0|  0.00%|    score value in any way.
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|    This metric is furthermore symmetric: switching ``label_true`` with
   642|         0|            0|            0|  0.00%|    ``label_pred`` will return the same score value. This can be useful to
   643|         0|            0|            0|  0.00%|    measure the agreement of two independent label assignments strategies
   644|         0|            0|            0|  0.00%|    on the same dataset when the real ground truth is not known.
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <homogeneity_completeness>`.
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|    Parameters
   650|         0|            0|            0|  0.00%|    ----------
   651|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   652|         0|            0|            0|  0.00%|        ground truth class labels to be used as a reference
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|    labels_pred : array-like of shape (n_samples,)
   655|         0|            0|            0|  0.00%|        cluster labels to evaluate
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|    beta : float, default=1.0
   658|         0|            0|            0|  0.00%|        Ratio of weight attributed to ``homogeneity`` vs ``completeness``.
   659|         0|            0|            0|  0.00%|        If ``beta`` is greater than 1, ``completeness`` is weighted more
   660|         0|            0|            0|  0.00%|        strongly in the calculation. If ``beta`` is less than 1,
   661|         0|            0|            0|  0.00%|        ``homogeneity`` is weighted more strongly.
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    Returns
   664|         0|            0|            0|  0.00%|    -------
   665|         0|            0|            0|  0.00%|    v_measure : float
   666|         0|            0|            0|  0.00%|       score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|    References
   669|         0|            0|            0|  0.00%|    ----------
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|    .. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   672|         0|            0|            0|  0.00%|       conditional entropy-based external cluster evaluation measure
   673|         0|            0|            0|  0.00%|       <https://aclweb.org/anthology/D/D07/D07-1043.pdf>`_
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|    See Also
   676|         0|            0|            0|  0.00%|    --------
   677|         0|            0|            0|  0.00%|    homogeneity_score
   678|         0|            0|            0|  0.00%|    completeness_score
   679|         0|            0|            0|  0.00%|    normalized_mutual_info_score
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|    Examples
   682|         0|            0|            0|  0.00%|    --------
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|    Perfect labelings are both homogeneous and complete, hence have score 1.0::
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import v_measure_score
   687|         0|            0|            0|  0.00%|      >>> v_measure_score([0, 0, 1, 1], [0, 0, 1, 1])
   688|         0|            0|            0|  0.00%|      1.0
   689|         0|            0|            0|  0.00%|      >>> v_measure_score([0, 0, 1, 1], [1, 1, 0, 0])
   690|         0|            0|            0|  0.00%|      1.0
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    Labelings that assign all classes members to the same clusters
   693|         0|            0|            0|  0.00%|    are complete be not homogeneous, hence penalized::
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|      >>> print("%.6f" % v_measure_score([0, 0, 1, 2], [0, 0, 1, 1]))
   696|         0|            0|            0|  0.00%|      0.8...
   697|         0|            0|            0|  0.00%|      >>> print("%.6f" % v_measure_score([0, 1, 2, 3], [0, 0, 1, 1]))
   698|         0|            0|            0|  0.00%|      0.66...
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|    Labelings that have pure clusters with members coming from the same
   701|         0|            0|            0|  0.00%|    classes are homogeneous but un-necessary splits harms completeness
   702|         0|            0|            0|  0.00%|    and thus penalize V-measure as well::
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|      >>> print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 0, 1, 2]))
   705|         0|            0|            0|  0.00%|      0.8...
   706|         0|            0|            0|  0.00%|      >>> print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 1, 2, 3]))
   707|         0|            0|            0|  0.00%|      0.66...
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|    If classes members are completely split across different clusters,
   710|         0|            0|            0|  0.00%|    the assignment is totally incomplete, hence the V-Measure is null::
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|      >>> print("%.6f" % v_measure_score([0, 0, 0, 0], [0, 1, 2, 3]))
   713|         0|            0|            0|  0.00%|      0.0...
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|    Clusters that include samples from totally different classes totally
   716|         0|            0|            0|  0.00%|    destroy the homogeneity of the labeling, hence::
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|      >>> print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 0, 0, 0]))
   719|         0|            0|            0|  0.00%|      0.0...
   720|         0|            0|            0|  0.00%|    """
   721|         0|            0|            0|  0.00%|    return homogeneity_completeness_v_measure(labels_true, labels_pred, beta=beta)[2]
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|
   724|         4|            0|            0|  0.00%|def mutual_info_score(labels_true, labels_pred, *, contingency=None):
   725|         0|            0|            0|  0.00%|    """Mutual Information between two clusterings.
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|    The Mutual Information is a measure of the similarity between two labels
   728|         0|            0|            0|  0.00%|    of the same data. Where :math:`|U_i|` is the number of the samples
   729|         0|            0|            0|  0.00%|    in cluster :math:`U_i` and :math:`|V_j|` is the number of the
   730|         0|            0|            0|  0.00%|    samples in cluster :math:`V_j`, the Mutual Information
   731|         0|            0|            0|  0.00%|    between clusterings :math:`U` and :math:`V` is given as:
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|    .. math::
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|        MI(U,V)=\\sum_{i=1}^{|U|} \\sum_{j=1}^{|V|} \\frac{|U_i\\cap V_j|}{N}
   736|         0|            0|            0|  0.00%|        \\log\\frac{N|U_i \\cap V_j|}{|U_i||V_j|}
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|    This metric is independent of the absolute values of the labels:
   739|         0|            0|            0|  0.00%|    a permutation of the class or cluster label values won't change the
   740|         0|            0|            0|  0.00%|    score value in any way.
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|    This metric is furthermore symmetric: switching :math:`U` (i.e
   743|         0|            0|            0|  0.00%|    ``label_true``) with :math:`V` (i.e. ``label_pred``) will return the
   744|         0|            0|            0|  0.00%|    same score value. This can be useful to measure the agreement of two
   745|         0|            0|            0|  0.00%|    independent label assignments strategies on the same dataset when the
   746|         0|            0|            0|  0.00%|    real ground truth is not known.
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <mutual_info_score>`.
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|    Parameters
   751|         0|            0|            0|  0.00%|    ----------
   752|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   753|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets, called :math:`U` in
   754|         0|            0|            0|  0.00%|        the above formula.
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|    labels_pred : int array-like of shape (n_samples,)
   757|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets, called :math:`V` in
   758|         0|            0|            0|  0.00%|        the above formula.
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|    contingency : {ndarray, sparse matrix} of shape \
   761|         0|            0|            0|  0.00%|            (n_classes_true, n_classes_pred), default=None
   762|         0|            0|            0|  0.00%|        A contingency matrix given by the :func:`contingency_matrix` function.
   763|         0|            0|            0|  0.00%|        If value is ``None``, it will be computed, otherwise the given value is
   764|         0|            0|            0|  0.00%|        used, with ``labels_true`` and ``labels_pred`` ignored.
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    Returns
   767|         0|            0|            0|  0.00%|    -------
   768|         0|            0|            0|  0.00%|    mi : float
   769|         0|            0|            0|  0.00%|       Mutual information, a non-negative value, measured in nats using the
   770|         0|            0|            0|  0.00%|       natural logarithm.
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|    Notes
   773|         0|            0|            0|  0.00%|    -----
   774|         0|            0|            0|  0.00%|    The logarithm used is the natural logarithm (base-e).
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|    See Also
   777|         0|            0|            0|  0.00%|    --------
   778|         0|            0|            0|  0.00%|    adjusted_mutual_info_score : Adjusted against chance Mutual Information.
   779|         0|            0|            0|  0.00%|    normalized_mutual_info_score : Normalized Mutual Information.
   780|         0|            0|            0|  0.00%|    """
   781|         4|            0|            0|  0.00%|    if contingency is None:
   782|         0|            0|            0|  0.00%|        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)
   783|         0|            0|            0|  0.00%|        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)
   784|         0|            0|            0|  0.00%|    else:
   785|         8|            0|            0|  0.00%|        contingency = check_array(
(call)|         4|   0.00526619|   0.00131655|  0.02%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\validation.py:486 check_array
   786|         4|            0|            0|  0.00%|            contingency,
   787|         4|            0|            0|  0.00%|            accept_sparse=["csr", "csc", "coo"],
   788|         4|            0|            0|  0.00%|            dtype=[int, np.int32, np.int64],
   789|         0|            0|            0|  0.00%|        )
   790|         0|            0|            0|  0.00%|
   791|         4|            0|            0|  0.00%|    if isinstance(contingency, np.ndarray):
   792|         0|            0|            0|  0.00%|        # For an array
   793|         0|            0|            0|  0.00%|        nzx, nzy = np.nonzero(contingency)
   794|         0|            0|            0|  0.00%|        nz_val = contingency[nzx, nzy]
   795|         4|            0|            0|  0.00%|    elif sp.issparse(contingency):
(call)|         4|   0.00103641|  0.000259101|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:1205 isspmatrix
   796|         0|            0|            0|  0.00%|        # For a sparse matrix
   797|         4|            0|            0|  0.00%|        nzx, nzy, nz_val = sp.find(contingency)
(call)|         4|   0.00398779|  0.000996947|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\extract.py:12 find
   798|         0|            0|            0|  0.00%|    else:
   799|         0|            0|            0|  0.00%|        raise ValueError("Unsupported type for 'contingency': %s" % type(contingency))
   800|         0|            0|            0|  0.00%|
   801|         4|   4.3869e-05|  1.09673e-05|  0.00%|    contingency_sum = contingency.sum()
(call)|         4|   0.00404239|    0.0010106|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:588 sum
   802|         4|            0|            0|  0.00%|    pi = np.ravel(contingency.sum(axis=1))
(call)|         4|   0.00219488|   0.00054872|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:588 sum
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 ravel
   803|         4|            0|            0|  0.00%|    pj = np.ravel(contingency.sum(axis=0))
(call)|         4|   0.00401998|   0.00100499|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:588 sum
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 ravel
   804|         4|            0|            0|  0.00%|    log_contingency_nm = np.log(nz_val)
   805|         4|  0.000997066|  0.000249267|  0.00%|    contingency_nm = nz_val / contingency_sum
   806|         0|            0|            0|  0.00%|    # Don't need to calculate the full outer product, just for non-zeroes
   807|         8|            0|            0|  0.00%|    outer = pi.take(nzx).astype(np.int64, copy=False) * pj.take(nzy).astype(
   808|         4|            0|            0|  0.00%|        np.int64, copy=False
   809|         0|            0|            0|  0.00%|    )
   810|         4|            0|            0|  0.00%|    log_outer = -np.log(outer) + log(pi.sum()) + log(pj.sum())
(call)|         8|   0.00099802|  0.000124753|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:46 _sum
   811|         4|            0|            0|  0.00%|    mi = (
   812|         8|            0|            0|  0.00%|        contingency_nm * (log_contingency_nm - log(contingency_sum))
   813|         4|            0|            0|  0.00%|        + contingency_nm * log_outer
   814|         0|            0|            0|  0.00%|    )
   815|         4|            0|            0|  0.00%|    mi = np.where(np.abs(mi) < np.finfo(mi.dtype).eps, 0.0, mi)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:457 __new__
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 where
   816|         4|            0|            0|  0.00%|    return np.clip(mi.sum(), 0.0, None)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:46 _sum
(call)|         4|   0.00148654|  0.000371635|  0.00%|# <__array_function__ internals>:177 clip
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|
   819|         0|            0|            0|  0.00%|def adjusted_mutual_info_score(
   820|         0|            0|            0|  0.00%|    labels_true, labels_pred, *, average_method="arithmetic"
   821|         0|            0|            0|  0.00%|):
   822|         0|            0|            0|  0.00%|    """Adjusted Mutual Information between two clusterings.
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|    Adjusted Mutual Information (AMI) is an adjustment of the Mutual
   825|         0|            0|            0|  0.00%|    Information (MI) score to account for chance. It accounts for the fact that
   826|         0|            0|            0|  0.00%|    the MI is generally higher for two clusterings with a larger number of
   827|         0|            0|            0|  0.00%|    clusters, regardless of whether there is actually more information shared.
   828|         0|            0|            0|  0.00%|    For two clusterings :math:`U` and :math:`V`, the AMI is given as::
   829|         0|            0|            0|  0.00%|
   830|         0|            0|            0|  0.00%|        AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [avg(H(U), H(V)) - E(MI(U, V))]
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    This metric is independent of the absolute values of the labels:
   833|         0|            0|            0|  0.00%|    a permutation of the class or cluster label values won't change the
   834|         0|            0|            0|  0.00%|    score value in any way.
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|    This metric is furthermore symmetric: switching :math:`U` (``label_true``)
   837|         0|            0|            0|  0.00%|    with :math:`V` (``labels_pred``) will return the same score value. This can
   838|         0|            0|            0|  0.00%|    be useful to measure the agreement of two independent label assignments
   839|         0|            0|            0|  0.00%|    strategies on the same dataset when the real ground truth is not known.
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|    Be mindful that this function is an order of magnitude slower than other
   842|         0|            0|            0|  0.00%|    metrics, such as the Adjusted Rand Index.
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <mutual_info_score>`.
   845|         0|            0|            0|  0.00%|
   846|         0|            0|            0|  0.00%|    Parameters
   847|         0|            0|            0|  0.00%|    ----------
   848|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   849|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets, called :math:`U` in
   850|         0|            0|            0|  0.00%|        the above formula.
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|    labels_pred : int array-like of shape (n_samples,)
   853|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets, called :math:`V` in
   854|         0|            0|            0|  0.00%|        the above formula.
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|    average_method : str, default='arithmetic'
   857|         0|            0|            0|  0.00%|        How to compute the normalizer in the denominator. Possible options
   858|         0|            0|            0|  0.00%|        are 'min', 'geometric', 'arithmetic', and 'max'.
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   861|         0|            0|            0|  0.00%|
   862|         0|            0|            0|  0.00%|        .. versionchanged:: 0.22
   863|         0|            0|            0|  0.00%|           The default value of ``average_method`` changed from 'max' to
   864|         0|            0|            0|  0.00%|           'arithmetic'.
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|    Returns
   867|         0|            0|            0|  0.00%|    -------
   868|         0|            0|            0|  0.00%|    ami: float (upperlimited by 1.0)
   869|         0|            0|            0|  0.00%|       The AMI returns a value of 1 when the two partitions are identical
   870|         0|            0|            0|  0.00%|       (ie perfectly matched). Random partitions (independent labellings) have
   871|         0|            0|            0|  0.00%|       an expected AMI around 0 on average hence can be negative. The value is
   872|         0|            0|            0|  0.00%|       in adjusted nats (based on the natural logarithm).
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|    See Also
   875|         0|            0|            0|  0.00%|    --------
   876|         0|            0|            0|  0.00%|    adjusted_rand_score : Adjusted Rand Index.
   877|         0|            0|            0|  0.00%|    mutual_info_score : Mutual Information (not adjusted for chance).
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|    Examples
   880|         0|            0|            0|  0.00%|    --------
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|    Perfect labelings are both homogeneous and complete, hence have
   883|         0|            0|            0|  0.00%|    score 1.0::
   884|         0|            0|            0|  0.00%|
   885|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import adjusted_mutual_info_score
   886|         0|            0|            0|  0.00%|      >>> adjusted_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])
   887|         0|            0|            0|  0.00%|      ... # doctest: +SKIP
   888|         0|            0|            0|  0.00%|      1.0
   889|         0|            0|            0|  0.00%|      >>> adjusted_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])
   890|         0|            0|            0|  0.00%|      ... # doctest: +SKIP
   891|         0|            0|            0|  0.00%|      1.0
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|    If classes members are completely split across different clusters,
   894|         0|            0|            0|  0.00%|    the assignment is totally in-complete, hence the AMI is null::
   895|         0|            0|            0|  0.00%|
   896|         0|            0|            0|  0.00%|      >>> adjusted_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])
   897|         0|            0|            0|  0.00%|      ... # doctest: +SKIP
   898|         0|            0|            0|  0.00%|      0.0
   899|         0|            0|            0|  0.00%|
   900|         0|            0|            0|  0.00%|    References
   901|         0|            0|            0|  0.00%|    ----------
   902|         0|            0|            0|  0.00%|    .. [1] `Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for
   903|         0|            0|            0|  0.00%|       Clusterings Comparison: Variants, Properties, Normalization and
   904|         0|            0|            0|  0.00%|       Correction for Chance, JMLR
   905|         0|            0|            0|  0.00%|       <http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf>`_
   906|         0|            0|            0|  0.00%|
   907|         0|            0|            0|  0.00%|    .. [2] `Wikipedia entry for the Adjusted Mutual Information
   908|         0|            0|            0|  0.00%|       <https://en.wikipedia.org/wiki/Adjusted_Mutual_Information>`_
   909|         0|            0|            0|  0.00%|    """
   910|         0|            0|            0|  0.00%|    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)
   911|         0|            0|            0|  0.00%|    n_samples = labels_true.shape[0]
   912|         0|            0|            0|  0.00%|    classes = np.unique(labels_true)
   913|         0|            0|            0|  0.00%|    clusters = np.unique(labels_pred)
   914|         0|            0|            0|  0.00%|    # Special limit cases: no clustering since the data is not split.
   915|         0|            0|            0|  0.00%|    # This is a perfect match hence return 1.0.
   916|         0|            0|            0|  0.00%|    if (
   917|         0|            0|            0|  0.00%|        classes.shape[0] == clusters.shape[0] == 1
   918|         0|            0|            0|  0.00%|        or classes.shape[0] == clusters.shape[0] == 0
   919|         0|            0|            0|  0.00%|    ):
   920|         0|            0|            0|  0.00%|        return 1.0
   921|         0|            0|            0|  0.00%|    contingency = contingency_matrix(labels_true, labels_pred, sparse=True)
   922|         0|            0|            0|  0.00%|    contingency = contingency.astype(np.float64, **_astype_copy_false(contingency))
   923|         0|            0|            0|  0.00%|    # Calculate the MI for the two clusterings
   924|         0|            0|            0|  0.00%|    mi = mutual_info_score(labels_true, labels_pred, contingency=contingency)
   925|         0|            0|            0|  0.00%|    # Calculate the expected value for the mutual information
   926|         0|            0|            0|  0.00%|    emi = expected_mutual_information(contingency, n_samples)
   927|         0|            0|            0|  0.00%|    # Calculate entropy for each labeling
   928|         0|            0|            0|  0.00%|    h_true, h_pred = entropy(labels_true), entropy(labels_pred)
   929|         0|            0|            0|  0.00%|    normalizer = _generalized_average(h_true, h_pred, average_method)
   930|         0|            0|            0|  0.00%|    denominator = normalizer - emi
   931|         0|            0|            0|  0.00%|    # Avoid 0.0 / 0.0 when expectation equals maximum, i.e a perfect match.
   932|         0|            0|            0|  0.00%|    # normalizer should always be >= emi, but because of floating-point
   933|         0|            0|            0|  0.00%|    # representation, sometimes emi is slightly larger. Correct this
   934|         0|            0|            0|  0.00%|    # by preserving the sign.
   935|         0|            0|            0|  0.00%|    if denominator < 0:
   936|         0|            0|            0|  0.00%|        denominator = min(denominator, -np.finfo("float64").eps)
   937|         0|            0|            0|  0.00%|    else:
   938|         0|            0|            0|  0.00%|        denominator = max(denominator, np.finfo("float64").eps)
   939|         0|            0|            0|  0.00%|    ami = (mi - emi) / denominator
   940|         0|            0|            0|  0.00%|    return ami
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|
   943|         4|            0|            0|  0.00%|def normalized_mutual_info_score(
   944|         0|            0|            0|  0.00%|    labels_true, labels_pred, *, average_method="arithmetic"
   945|         0|            0|            0|  0.00%|):
   946|         0|            0|            0|  0.00%|    """Normalized Mutual Information between two clusterings.
   947|         0|            0|            0|  0.00%|
   948|         0|            0|            0|  0.00%|    Normalized Mutual Information (NMI) is a normalization of the Mutual
   949|         0|            0|            0|  0.00%|    Information (MI) score to scale the results between 0 (no mutual
   950|         0|            0|            0|  0.00%|    information) and 1 (perfect correlation). In this function, mutual
   951|         0|            0|            0|  0.00%|    information is normalized by some generalized mean of ``H(labels_true)``
   952|         0|            0|            0|  0.00%|    and ``H(labels_pred))``, defined by the `average_method`.
   953|         0|            0|            0|  0.00%|
   954|         0|            0|            0|  0.00%|    This measure is not adjusted for chance. Therefore
   955|         0|            0|            0|  0.00%|    :func:`adjusted_mutual_info_score` might be preferred.
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|    This metric is independent of the absolute values of the labels:
   958|         0|            0|            0|  0.00%|    a permutation of the class or cluster label values won't change the
   959|         0|            0|            0|  0.00%|    score value in any way.
   960|         0|            0|            0|  0.00%|
   961|         0|            0|            0|  0.00%|    This metric is furthermore symmetric: switching ``label_true`` with
   962|         0|            0|            0|  0.00%|    ``label_pred`` will return the same score value. This can be useful to
   963|         0|            0|            0|  0.00%|    measure the agreement of two independent label assignments strategies
   964|         0|            0|            0|  0.00%|    on the same dataset when the real ground truth is not known.
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <mutual_info_score>`.
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|    Parameters
   969|         0|            0|            0|  0.00%|    ----------
   970|         0|            0|            0|  0.00%|    labels_true : int array, shape = [n_samples]
   971|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets.
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|    labels_pred : int array-like of shape (n_samples,)
   974|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets.
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|    average_method : str, default='arithmetic'
   977|         0|            0|            0|  0.00%|        How to compute the normalizer in the denominator. Possible options
   978|         0|            0|            0|  0.00%|        are 'min', 'geometric', 'arithmetic', and 'max'.
   979|         0|            0|            0|  0.00%|
   980|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
   981|         0|            0|            0|  0.00%|
   982|         0|            0|            0|  0.00%|        .. versionchanged:: 0.22
   983|         0|            0|            0|  0.00%|           The default value of ``average_method`` changed from 'geometric' to
   984|         0|            0|            0|  0.00%|           'arithmetic'.
   985|         0|            0|            0|  0.00%|
   986|         0|            0|            0|  0.00%|    Returns
   987|         0|            0|            0|  0.00%|    -------
   988|         0|            0|            0|  0.00%|    nmi : float
   989|         0|            0|            0|  0.00%|       Score between 0.0 and 1.0 in normalized nats (based on the natural
   990|         0|            0|            0|  0.00%|       logarithm). 1.0 stands for perfectly complete labeling.
   991|         0|            0|            0|  0.00%|
   992|         0|            0|            0|  0.00%|    See Also
   993|         0|            0|            0|  0.00%|    --------
   994|         0|            0|            0|  0.00%|    v_measure_score : V-Measure (NMI with arithmetic mean option).
   995|         0|            0|            0|  0.00%|    adjusted_rand_score : Adjusted Rand Index.
   996|         0|            0|            0|  0.00%|    adjusted_mutual_info_score : Adjusted Mutual Information (adjusted
   997|         0|            0|            0|  0.00%|        against chance).
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|    Examples
  1000|         0|            0|            0|  0.00%|    --------
  1001|         0|            0|            0|  0.00%|
  1002|         0|            0|            0|  0.00%|    Perfect labelings are both homogeneous and complete, hence have
  1003|         0|            0|            0|  0.00%|    score 1.0::
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import normalized_mutual_info_score
  1006|         0|            0|            0|  0.00%|      >>> normalized_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])
  1007|         0|            0|            0|  0.00%|      ... # doctest: +SKIP
  1008|         0|            0|            0|  0.00%|      1.0
  1009|         0|            0|            0|  0.00%|      >>> normalized_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])
  1010|         0|            0|            0|  0.00%|      ... # doctest: +SKIP
  1011|         0|            0|            0|  0.00%|      1.0
  1012|         0|            0|            0|  0.00%|
  1013|         0|            0|            0|  0.00%|    If classes members are completely split across different clusters,
  1014|         0|            0|            0|  0.00%|    the assignment is totally in-complete, hence the NMI is null::
  1015|         0|            0|            0|  0.00%|
  1016|         0|            0|            0|  0.00%|      >>> normalized_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])
  1017|         0|            0|            0|  0.00%|      ... # doctest: +SKIP
  1018|         0|            0|            0|  0.00%|      0.0
  1019|         0|            0|            0|  0.00%|    """
  1020|         4|            0|            0|  0.00%|    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)
(call)|         4|    0.0079782|   0.00199455|  0.02%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\metrics\cluster\_supervised.py:31 check_clusterings
  1021|         4|            0|            0|  0.00%|    classes = np.unique(labels_true)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 unique
  1022|         4|            0|            0|  0.00%|    clusters = np.unique(labels_pred)
(call)|         4|  0.000997066|  0.000249267|  0.00%|# <__array_function__ internals>:177 unique
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|    # Special limit cases: no clustering since the data is not split.
  1025|         0|            0|            0|  0.00%|    # This is a perfect match hence return 1.0.
  1026|        12|            0|            0|  0.00%|    if (
  1027|         6|  0.000995874|  0.000165979|  0.00%|        classes.shape[0] == clusters.shape[0] == 1
  1028|         6|            0|            0|  0.00%|        or classes.shape[0] == clusters.shape[0] == 0
  1029|         0|            0|            0|  0.00%|    ):
  1030|         0|            0|            0|  0.00%|        return 1.0
  1031|         4|            0|            0|  0.00%|    contingency = contingency_matrix(labels_true, labels_pred, sparse=True)
(call)|         4|   0.00992227|   0.00248057|  0.03%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\metrics\cluster\_supervised.py:93 contingency_matrix
  1032|         4|            0|            0|  0.00%|    contingency = contingency.astype(np.float64, **_astype_copy_false(contingency))
(call)|         4|  0.000997305|  0.000249326|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\fixes.py:45 _astype_copy_false
(call)|         4|   0.00310349|  0.000775874|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:68 astype
  1033|         0|            0|            0|  0.00%|    # Calculate the MI for the two clusterings
  1034|         4|            0|            0|  0.00%|    mi = mutual_info_score(labels_true, labels_pred, contingency=contingency)
(call)|         4|    0.0240731|   0.00601828|  0.07%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\metrics\cluster\_supervised.py:724 mutual_info_score
  1035|         0|            0|            0|  0.00%|    # Calculate the expected value for the mutual information
  1036|         0|            0|            0|  0.00%|    # Calculate entropy for each labeling
  1037|         4|            0|            0|  0.00%|    h_true, h_pred = entropy(labels_true), entropy(labels_pred)
(call)|         8|   0.00250077|  0.000312597|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\metrics\cluster\_supervised.py:1123 entropy
  1038|         4|            0|            0|  0.00%|    normalizer = _generalized_average(h_true, h_pred, average_method)
(call)|         4|   0.00101018|  0.000252545|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\metrics\cluster\_supervised.py:77 _generalized_average
  1039|         0|            0|            0|  0.00%|    # Avoid 0.0 / 0.0 when either entropy is zero.
  1040|         4|            0|            0|  0.00%|    normalizer = max(normalizer, np.finfo("float64").eps)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\getlimits.py:457 __new__
  1041|         4|            0|            0|  0.00%|    nmi = mi / normalizer
  1042|         4|            0|            0|  0.00%|    return nmi
  1043|         0|            0|            0|  0.00%|
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|def fowlkes_mallows_score(labels_true, labels_pred, *, sparse=False):
  1046|         0|            0|            0|  0.00%|    """Measure the similarity of two clusterings of a set of points.
  1047|         0|            0|            0|  0.00%|
  1048|         0|            0|            0|  0.00%|    .. versionadded:: 0.18
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|    The Fowlkes-Mallows index (FMI) is defined as the geometric mean between of
  1051|         0|            0|            0|  0.00%|    the precision and recall::
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|        FMI = TP / sqrt((TP + FP) * (TP + FN))
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|    Where ``TP`` is the number of **True Positive** (i.e. the number of pair of
  1056|         0|            0|            0|  0.00%|    points that belongs in the same clusters in both ``labels_true`` and
  1057|         0|            0|            0|  0.00%|    ``labels_pred``), ``FP`` is the number of **False Positive** (i.e. the
  1058|         0|            0|            0|  0.00%|    number of pair of points that belongs in the same clusters in
  1059|         0|            0|            0|  0.00%|    ``labels_true`` and not in ``labels_pred``) and ``FN`` is the number of
  1060|         0|            0|            0|  0.00%|    **False Negative** (i.e the number of pair of points that belongs in the
  1061|         0|            0|            0|  0.00%|    same clusters in ``labels_pred`` and not in ``labels_True``).
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|    The score ranges from 0 to 1. A high value indicates a good similarity
  1064|         0|            0|            0|  0.00%|    between two clusters.
  1065|         0|            0|            0|  0.00%|
  1066|         0|            0|            0|  0.00%|    Read more in the :ref:`User Guide <fowlkes_mallows_scores>`.
  1067|         0|            0|            0|  0.00%|
  1068|         0|            0|            0|  0.00%|    Parameters
  1069|         0|            0|            0|  0.00%|    ----------
  1070|         0|            0|            0|  0.00%|    labels_true : int array, shape = (``n_samples``,)
  1071|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets.
  1072|         0|            0|            0|  0.00%|
  1073|         0|            0|            0|  0.00%|    labels_pred : array, shape = (``n_samples``, )
  1074|         0|            0|            0|  0.00%|        A clustering of the data into disjoint subsets.
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|    sparse : bool, default=False
  1077|         0|            0|            0|  0.00%|        Compute contingency matrix internally with sparse matrix.
  1078|         0|            0|            0|  0.00%|
  1079|         0|            0|            0|  0.00%|    Returns
  1080|         0|            0|            0|  0.00%|    -------
  1081|         0|            0|            0|  0.00%|    score : float
  1082|         0|            0|            0|  0.00%|       The resulting Fowlkes-Mallows score.
  1083|         0|            0|            0|  0.00%|
  1084|         0|            0|            0|  0.00%|    Examples
  1085|         0|            0|            0|  0.00%|    --------
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|    Perfect labelings are both homogeneous and complete, hence have
  1088|         0|            0|            0|  0.00%|    score 1.0::
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|      >>> from sklearn.metrics.cluster import fowlkes_mallows_score
  1091|         0|            0|            0|  0.00%|      >>> fowlkes_mallows_score([0, 0, 1, 1], [0, 0, 1, 1])
  1092|         0|            0|            0|  0.00%|      1.0
  1093|         0|            0|            0|  0.00%|      >>> fowlkes_mallows_score([0, 0, 1, 1], [1, 1, 0, 0])
  1094|         0|            0|            0|  0.00%|      1.0
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|    If classes members are completely split across different clusters,
  1097|         0|            0|            0|  0.00%|    the assignment is totally random, hence the FMI is null::
  1098|         0|            0|            0|  0.00%|
  1099|         0|            0|            0|  0.00%|      >>> fowlkes_mallows_score([0, 0, 0, 0], [0, 1, 2, 3])
  1100|         0|            0|            0|  0.00%|      0.0
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|    References
  1103|         0|            0|            0|  0.00%|    ----------
  1104|         0|            0|            0|  0.00%|    .. [1] `E. B. Fowkles and C. L. Mallows, 1983. "A method for comparing two
  1105|         0|            0|            0|  0.00%|       hierarchical clusterings". Journal of the American Statistical
  1106|         0|            0|            0|  0.00%|       Association
  1107|         0|            0|            0|  0.00%|       <https://www.tandfonline.com/doi/abs/10.1080/01621459.1983.10478008>`_
  1108|         0|            0|            0|  0.00%|
  1109|         0|            0|            0|  0.00%|    .. [2] `Wikipedia entry for the Fowlkes-Mallows Index
  1110|         0|            0|            0|  0.00%|           <https://en.wikipedia.org/wiki/Fowlkes-Mallows_index>`_
  1111|         0|            0|            0|  0.00%|    """
  1112|         0|            0|            0|  0.00%|    labels_true, labels_pred = check_clusterings(labels_true, labels_pred)
  1113|         0|            0|            0|  0.00%|    (n_samples,) = labels_true.shape
  1114|         0|            0|            0|  0.00%|
  1115|         0|            0|            0|  0.00%|    c = contingency_matrix(labels_true, labels_pred, sparse=True)
  1116|         0|            0|            0|  0.00%|    c = c.astype(np.int64, **_astype_copy_false(c))
  1117|         0|            0|            0|  0.00%|    tk = np.dot(c.data, c.data) - n_samples
  1118|         0|            0|            0|  0.00%|    pk = np.sum(np.asarray(c.sum(axis=0)).ravel() ** 2) - n_samples
  1119|         0|            0|            0|  0.00%|    qk = np.sum(np.asarray(c.sum(axis=1)).ravel() ** 2) - n_samples
  1120|         0|            0|            0|  0.00%|    return np.sqrt(tk / pk) * np.sqrt(tk / qk) if tk != 0.0 else 0.0
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|
  1123|         8|            0|            0|  0.00%|def entropy(labels):
  1124|         0|            0|            0|  0.00%|    """Calculates the entropy for a labeling.
  1125|         0|            0|            0|  0.00%|
  1126|         0|            0|            0|  0.00%|    Parameters
  1127|         0|            0|            0|  0.00%|    ----------
  1128|         0|            0|            0|  0.00%|    labels : int array, shape = [n_samples]
  1129|         0|            0|            0|  0.00%|        The labels
  1130|         0|            0|            0|  0.00%|
  1131|         0|            0|            0|  0.00%|    Notes
  1132|         0|            0|            0|  0.00%|    -----
  1133|         0|            0|            0|  0.00%|    The logarithm used is the natural logarithm (base-e).
  1134|         0|            0|            0|  0.00%|    """
  1135|         8|            0|            0|  0.00%|    if len(labels) == 0:
  1136|         0|            0|            0|  0.00%|        return 1.0
  1137|         8|            0|            0|  0.00%|    label_idx = np.unique(labels, return_inverse=True)[1]
(call)|         8|   0.00250077|  0.000312597|  0.01%|# <__array_function__ internals>:177 unique
  1138|         8|            0|            0|  0.00%|    pi = np.bincount(label_idx).astype(np.float64)
(call)|         8|            0|            0|  0.00%|# <__array_function__ internals>:177 bincount
  1139|         8|            0|            0|  0.00%|    pi = pi[pi > 0]
  1140|         8|            0|            0|  0.00%|    pi_sum = np.sum(pi)
(call)|         8|            0|            0|  0.00%|# <__array_function__ internals>:177 sum
  1141|         0|            0|            0|  0.00%|    # log(a / b) should be calculated as log(a) - log(b) for
  1142|         0|            0|            0|  0.00%|    # possible loss of precision
  1143|         8|            0|            0|  0.00%|    return -np.sum((pi / pi_sum) * (np.log(pi) - log(pi_sum)))
(call)|         8|            0|            0|  0.00%|# <__array_function__ internals>:177 sum
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\__init__.py
File duration: 0.00206757s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Contains the core of NumPy: ndarray, ufuncs, dtypes, etc.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|Please note that this module is private.  All functions and objects
     5|         0|            0|            0|  0.00%|are available in the main ``numpy`` namespace - use that instead.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|"""
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from numpy.version import version as __version__
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|import os
    12|         0|            0|            0|  0.00%|import warnings
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|# disables OpenBLAS affinity setting of the main thread that limits
    15|         0|            0|            0|  0.00%|# python threads or processes to one core
    16|         0|            0|            0|  0.00%|env_added = []
    17|         0|            0|            0|  0.00%|for envkey in ['OPENBLAS_MAIN_FREE', 'GOTOBLAS_MAIN_FREE']:
    18|         0|            0|            0|  0.00%|    if envkey not in os.environ:
    19|         0|            0|            0|  0.00%|        os.environ[envkey] = '1'
    20|         0|            0|            0|  0.00%|        env_added.append(envkey)
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|try:
    23|         0|            0|            0|  0.00%|    from . import multiarray
    24|         0|            0|            0|  0.00%|except ImportError as exc:
    25|         0|            0|            0|  0.00%|    import sys
    26|         0|            0|            0|  0.00%|    msg = """
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|IMPORTANT: PLEASE READ THIS FOR ADVICE ON HOW TO SOLVE THIS ISSUE!
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|Importing the numpy C-extensions failed. This error can happen for
    31|         0|            0|            0|  0.00%|many reasons, often due to issues with your setup or how NumPy was
    32|         0|            0|            0|  0.00%|installed.
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|We have compiled some common reasons and troubleshooting tips at:
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    https://numpy.org/devdocs/user/troubleshooting-importerror.html
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|Please note and check the following:
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|  * The Python version is: Python%d.%d from "%s"
    41|         0|            0|            0|  0.00%|  * The NumPy version is: "%s"
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|and make sure that they are the versions you expect.
    44|         0|            0|            0|  0.00%|Please carefully study the documentation linked above for further help.
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|Original error was: %s
    47|         0|            0|            0|  0.00%|""" % (sys.version_info[0], sys.version_info[1], sys.executable,
    48|         0|            0|            0|  0.00%|        __version__, exc)
    49|         0|            0|            0|  0.00%|    raise ImportError(msg)
    50|         0|            0|            0|  0.00%|finally:
    51|         0|            0|            0|  0.00%|    for envkey in env_added:
    52|         0|            0|            0|  0.00%|        del os.environ[envkey]
    53|         0|            0|            0|  0.00%|del envkey
    54|         0|            0|            0|  0.00%|del env_added
    55|         0|            0|            0|  0.00%|del os
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|from . import umath
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|# Check that multiarray,umath are pure python modules wrapping
    60|         0|            0|            0|  0.00%|# _multiarray_umath and not either of the old c-extension modules
    61|         0|            0|            0|  0.00%|if not (hasattr(multiarray, '_multiarray_umath') and
    62|         0|            0|            0|  0.00%|        hasattr(umath, '_multiarray_umath')):
    63|         0|            0|            0|  0.00%|    import sys
    64|         0|            0|            0|  0.00%|    path = sys.modules['numpy'].__path__
    65|         0|            0|            0|  0.00%|    msg = ("Something is wrong with the numpy installation. "
    66|         0|            0|            0|  0.00%|        "While importing we detected an older version of "
    67|         0|            0|            0|  0.00%|        "numpy in {}. One method of fixing this is to repeatedly uninstall "
    68|         0|            0|            0|  0.00%|        "numpy until none is found, then reinstall this version.")
    69|         0|            0|            0|  0.00%|    raise ImportError(msg.format(path))
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|from . import numerictypes as nt
    72|         0|            0|            0|  0.00%|multiarray.set_typeDict(nt.sctypeDict)
    73|         0|            0|            0|  0.00%|from . import numeric
    74|         0|            0|            0|  0.00%|from .numeric import *
    75|         0|            0|            0|  0.00%|from . import fromnumeric
    76|         0|            0|            0|  0.00%|from .fromnumeric import *
    77|         0|            0|            0|  0.00%|from . import defchararray as char
    78|         0|            0|            0|  0.00%|from . import records as rec
    79|         0|            0|            0|  0.00%|from .records import record, recarray, format_parser
    80|         0|            0|            0|  0.00%|from .memmap import *
    81|         0|            0|            0|  0.00%|from .defchararray import chararray
    82|         0|            0|            0|  0.00%|from . import function_base
    83|         0|            0|            0|  0.00%|from .function_base import *
    84|         0|            0|            0|  0.00%|from . import _machar
    85|         0|            0|            0|  0.00%|from ._machar import *
    86|         0|            0|            0|  0.00%|from . import getlimits
    87|         0|            0|            0|  0.00%|from .getlimits import *
    88|         0|            0|            0|  0.00%|from . import shape_base
    89|         0|            0|            0|  0.00%|from .shape_base import *
    90|         0|            0|            0|  0.00%|from . import einsumfunc
    91|         0|            0|            0|  0.00%|from .einsumfunc import *
    92|         0|            0|            0|  0.00%|del nt
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|from .fromnumeric import amax as max, amin as min, round_ as round
    95|         0|            0|            0|  0.00%|from .numeric import absolute as abs
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|# do this after everything else, to minimize the chance of this misleadingly
    98|         0|            0|            0|  0.00%|# appearing in an import-time traceback
    99|         0|            0|            0|  0.00%|from . import _add_newdocs
   100|         0|            0|            0|  0.00%|from . import _add_newdocs_scalars
   101|         0|            0|            0|  0.00%|# add these for module-freeze analysis (like PyInstaller)
   102|         0|            0|            0|  0.00%|from . import _dtype_ctypes
   103|         0|            0|            0|  0.00%|from . import _internal
   104|         0|            0|            0|  0.00%|from . import _dtype
   105|         0|            0|            0|  0.00%|from . import _methods
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|__all__ = ['char', 'rec', 'memmap']
   108|         0|            0|            0|  0.00%|__all__ += numeric.__all__
   109|         0|            0|            0|  0.00%|__all__ += ['record', 'recarray', 'format_parser']
   110|         0|            0|            0|  0.00%|__all__ += ['chararray']
   111|         0|            0|            0|  0.00%|__all__ += function_base.__all__
   112|         0|            0|            0|  0.00%|__all__ += getlimits.__all__
   113|         0|            0|            0|  0.00%|__all__ += shape_base.__all__
   114|         0|            0|            0|  0.00%|__all__ += einsumfunc.__all__
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|# We used to use `np.core._ufunc_reconstruct` to unpickle. This is unnecessary,
   117|         0|            0|            0|  0.00%|# but old pickles saved before 1.20 will be using it, and there is no reason
   118|         0|            0|            0|  0.00%|# to break loading them.
   119|         0|            0|            0|  0.00%|def _ufunc_reconstruct(module, name):
   120|         0|            0|            0|  0.00%|    # The `fromlist` kwarg is required to ensure that `mod` points to the
   121|         0|            0|            0|  0.00%|    # inner-most module rather than the parent package when module name is
   122|         0|            0|            0|  0.00%|    # nested. This makes it possible to pickle non-toplevel ufuncs such as
   123|         0|            0|            0|  0.00%|    # scipy.special.expit for instance.
   124|         0|            0|            0|  0.00%|    mod = __import__(module, fromlist=[name])
   125|         0|            0|            0|  0.00%|    return getattr(mod, name)
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|def _ufunc_reduce(func):
   129|         0|            0|            0|  0.00%|    # Report the `__name__`. pickle will try to find the module. Note that
   130|         0|            0|            0|  0.00%|    # pickle supports for this `__name__` to be a `__qualname__`. It may
   131|         0|            0|            0|  0.00%|    # make sense to add a `__qualname__` to ufuncs, to allow this more
   132|         0|            0|            0|  0.00%|    # explicitly (Numba has ufuncs as attributes).
   133|         0|            0|            0|  0.00%|    # See also: https://github.com/dask/distributed/issues/3450
   134|         0|            0|            0|  0.00%|    return func.__name__
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|def _DType_reconstruct(scalar_type):
   138|         0|            0|            0|  0.00%|    # This is a work-around to pickle type(np.dtype(np.float64)), etc.
   139|         0|            0|            0|  0.00%|    # and it should eventually be replaced with a better solution, e.g. when
   140|         0|            0|            0|  0.00%|    # DTypes become HeapTypes.
   141|         0|            0|            0|  0.00%|    return type(dtype(scalar_type))
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|       120|            0|            0|  0.00%|def _DType_reduce(DType):
   145|         0|            0|            0|  0.00%|    # To pickle a DType without having to add top-level names, pickle the
   146|         0|            0|            0|  0.00%|    # scalar type for now (and assume that reconstruction will be possible).
   147|       120|   0.00103188|  8.59896e-06|  0.00%|    if DType is dtype:
   148|       120|   0.00103569|  8.63075e-06|  0.00%|        return "dtype"  # must pickle `np.dtype` as a singleton.
   149|         0|            0|            0|  0.00%|    scalar_type = DType.type  # pickle the scalar type for reconstruction
   150|         0|            0|            0|  0.00%|    return _DType_reconstruct, (scalar_type,)
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|def __getattr__(name):
   154|         0|            0|            0|  0.00%|    # Deprecated 2021-10-20, NumPy 1.22
   155|         0|            0|            0|  0.00%|    if name == "machar":
   156|         0|            0|            0|  0.00%|        warnings.warn(
   157|         0|            0|            0|  0.00%|            "The `np.core.machar` module is deprecated (NumPy 1.22)",
   158|         0|            0|            0|  0.00%|            DeprecationWarning, stacklevel=2,
   159|         0|            0|            0|  0.00%|        )
   160|         0|            0|            0|  0.00%|        return _machar
   161|         0|            0|            0|  0.00%|    raise AttributeError(f"Module {__name__!r} has no attribute {name!r}")
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|import copyreg
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|copyreg.pickle(ufunc, _ufunc_reduce)
   167|         0|            0|            0|  0.00%|copyreg.pickle(type(dtype), _DType_reduce, _DType_reconstruct)
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|# Unclutter namespace (must keep _*_reconstruct for unpickling)
   170|         0|            0|            0|  0.00%|del copyreg
   171|         0|            0|            0|  0.00%|del _ufunc_reduce
   172|         0|            0|            0|  0.00%|del _DType_reduce
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|from numpy._pytesttester import PytestTester
   175|         0|            0|            0|  0.00%|test = PytestTester(__name__)
   176|         0|            0|            0|  0.00%|del PytestTester
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py
File duration: 0.00199509s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Python part of the warnings subsystem."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import sys
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|__all__ = ["warn", "warn_explicit", "showwarning",
     7|         0|            0|            0|  0.00%|           "formatwarning", "filterwarnings", "simplefilter",
     8|         0|            0|            0|  0.00%|           "resetwarnings", "catch_warnings"]
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|def showwarning(message, category, filename, lineno, file=None, line=None):
    11|         0|            0|            0|  0.00%|    """Hook to write a warning to a file; replace if you like."""
    12|         0|            0|            0|  0.00%|    msg = WarningMessage(message, category, filename, lineno, file, line)
    13|         0|            0|            0|  0.00%|    _showwarnmsg_impl(msg)
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|def formatwarning(message, category, filename, lineno, line=None):
    16|         0|            0|            0|  0.00%|    """Function to format a warning the standard way."""
    17|         0|            0|            0|  0.00%|    msg = WarningMessage(message, category, filename, lineno, None, line)
    18|         0|            0|            0|  0.00%|    return _formatwarnmsg_impl(msg)
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|def _showwarnmsg_impl(msg):
    21|         0|            0|            0|  0.00%|    file = msg.file
    22|         0|            0|            0|  0.00%|    if file is None:
    23|         0|            0|            0|  0.00%|        file = sys.stderr
    24|         0|            0|            0|  0.00%|        if file is None:
    25|         0|            0|            0|  0.00%|            # sys.stderr is None when run with pythonw.exe:
    26|         0|            0|            0|  0.00%|            # warnings get lost
    27|         0|            0|            0|  0.00%|            return
    28|         0|            0|            0|  0.00%|    text = _formatwarnmsg(msg)
    29|         0|            0|            0|  0.00%|    try:
    30|         0|            0|            0|  0.00%|        file.write(text)
    31|         0|            0|            0|  0.00%|    except OSError:
    32|         0|            0|            0|  0.00%|        # the file (probably stderr) is invalid - this warning gets lost.
    33|         0|            0|            0|  0.00%|        pass
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|def _formatwarnmsg_impl(msg):
    36|         0|            0|            0|  0.00%|    category = msg.category.__name__
    37|         0|            0|            0|  0.00%|    s =  f"{msg.filename}:{msg.lineno}: {category}: {msg.message}\n"
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    if msg.line is None:
    40|         0|            0|            0|  0.00%|        try:
    41|         0|            0|            0|  0.00%|            import linecache
    42|         0|            0|            0|  0.00%|            line = linecache.getline(msg.filename, msg.lineno)
    43|         0|            0|            0|  0.00%|        except Exception:
    44|         0|            0|            0|  0.00%|            # When a warning is logged during Python shutdown, linecache
    45|         0|            0|            0|  0.00%|            # and the import machinery don't work anymore
    46|         0|            0|            0|  0.00%|            line = None
    47|         0|            0|            0|  0.00%|            linecache = None
    48|         0|            0|            0|  0.00%|    else:
    49|         0|            0|            0|  0.00%|        line = msg.line
    50|         0|            0|            0|  0.00%|    if line:
    51|         0|            0|            0|  0.00%|        line = line.strip()
    52|         0|            0|            0|  0.00%|        s += "  %s\n" % line
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|    if msg.source is not None:
    55|         0|            0|            0|  0.00%|        try:
    56|         0|            0|            0|  0.00%|            import tracemalloc
    57|         0|            0|            0|  0.00%|        # Logging a warning should not raise a new exception:
    58|         0|            0|            0|  0.00%|        # catch Exception, not only ImportError and RecursionError.
    59|         0|            0|            0|  0.00%|        except Exception:
    60|         0|            0|            0|  0.00%|            # don't suggest to enable tracemalloc if it's not available
    61|         0|            0|            0|  0.00%|            tracing = True
    62|         0|            0|            0|  0.00%|            tb = None
    63|         0|            0|            0|  0.00%|        else:
    64|         0|            0|            0|  0.00%|            tracing = tracemalloc.is_tracing()
    65|         0|            0|            0|  0.00%|            try:
    66|         0|            0|            0|  0.00%|                tb = tracemalloc.get_object_traceback(msg.source)
    67|         0|            0|            0|  0.00%|            except Exception:
    68|         0|            0|            0|  0.00%|                # When a warning is logged during Python shutdown, tracemalloc
    69|         0|            0|            0|  0.00%|                # and the import machinery don't work anymore
    70|         0|            0|            0|  0.00%|                tb = None
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|        if tb is not None:
    73|         0|            0|            0|  0.00%|            s += 'Object allocated at (most recent call last):\n'
    74|         0|            0|            0|  0.00%|            for frame in tb:
    75|         0|            0|            0|  0.00%|                s += ('  File "%s", lineno %s\n'
    76|         0|            0|            0|  0.00%|                      % (frame.filename, frame.lineno))
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|                try:
    79|         0|            0|            0|  0.00%|                    if linecache is not None:
    80|         0|            0|            0|  0.00%|                        line = linecache.getline(frame.filename, frame.lineno)
    81|         0|            0|            0|  0.00%|                    else:
    82|         0|            0|            0|  0.00%|                        line = None
    83|         0|            0|            0|  0.00%|                except Exception:
    84|         0|            0|            0|  0.00%|                    line = None
    85|         0|            0|            0|  0.00%|                if line:
    86|         0|            0|            0|  0.00%|                    line = line.strip()
    87|         0|            0|            0|  0.00%|                    s += '    %s\n' % line
    88|         0|            0|            0|  0.00%|        elif not tracing:
    89|         0|            0|            0|  0.00%|            s += (f'{category}: Enable tracemalloc to get the object '
    90|         0|            0|            0|  0.00%|                  f'allocation traceback\n')
    91|         0|            0|            0|  0.00%|    return s
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|# Keep a reference to check if the function was replaced
    94|         0|            0|            0|  0.00%|_showwarning_orig = showwarning
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|def _showwarnmsg(msg):
    97|         0|            0|            0|  0.00%|    """Hook to write a warning to a file; replace if you like."""
    98|         0|            0|            0|  0.00%|    try:
    99|         0|            0|            0|  0.00%|        sw = showwarning
   100|         0|            0|            0|  0.00%|    except NameError:
   101|         0|            0|            0|  0.00%|        pass
   102|         0|            0|            0|  0.00%|    else:
   103|         0|            0|            0|  0.00%|        if sw is not _showwarning_orig:
   104|         0|            0|            0|  0.00%|            # warnings.showwarning() was replaced
   105|         0|            0|            0|  0.00%|            if not callable(sw):
   106|         0|            0|            0|  0.00%|                raise TypeError("warnings.showwarning() must be set to a "
   107|         0|            0|            0|  0.00%|                                "function or method")
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|            sw(msg.message, msg.category, msg.filename, msg.lineno,
   110|         0|            0|            0|  0.00%|               msg.file, msg.line)
   111|         0|            0|            0|  0.00%|            return
   112|         0|            0|            0|  0.00%|    _showwarnmsg_impl(msg)
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|# Keep a reference to check if the function was replaced
   115|         0|            0|            0|  0.00%|_formatwarning_orig = formatwarning
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|def _formatwarnmsg(msg):
   118|         0|            0|            0|  0.00%|    """Function to format a warning the standard way."""
   119|         0|            0|            0|  0.00%|    try:
   120|         0|            0|            0|  0.00%|        fw = formatwarning
   121|         0|            0|            0|  0.00%|    except NameError:
   122|         0|            0|            0|  0.00%|        pass
   123|         0|            0|            0|  0.00%|    else:
   124|         0|            0|            0|  0.00%|        if fw is not _formatwarning_orig:
   125|         0|            0|            0|  0.00%|            # warnings.formatwarning() was replaced
   126|         0|            0|            0|  0.00%|            return fw(msg.message, msg.category,
   127|         0|            0|            0|  0.00%|                      msg.filename, msg.lineno, msg.line)
   128|         0|            0|            0|  0.00%|    return _formatwarnmsg_impl(msg)
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|def filterwarnings(action, message="", category=Warning, module="", lineno=0,
   131|         0|            0|            0|  0.00%|                   append=False):
   132|         0|            0|            0|  0.00%|    """Insert an entry into the list of warnings filters (at the front).
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    'action' -- one of "error", "ignore", "always", "default", "module",
   135|         0|            0|            0|  0.00%|                or "once"
   136|         0|            0|            0|  0.00%|    'message' -- a regex that the warning message must match
   137|         0|            0|            0|  0.00%|    'category' -- a class that the warning must be a subclass of
   138|         0|            0|            0|  0.00%|    'module' -- a regex that the module name must match
   139|         0|            0|            0|  0.00%|    'lineno' -- an integer line number, 0 matches all warnings
   140|         0|            0|            0|  0.00%|    'append' -- if true, append to the list of filters
   141|         0|            0|            0|  0.00%|    """
   142|         0|            0|            0|  0.00%|    assert action in ("error", "ignore", "always", "default", "module",
   143|         0|            0|            0|  0.00%|                      "once"), "invalid action: %r" % (action,)
   144|         0|            0|            0|  0.00%|    assert isinstance(message, str), "message must be a string"
   145|         0|            0|            0|  0.00%|    assert isinstance(category, type), "category must be a class"
   146|         0|            0|            0|  0.00%|    assert issubclass(category, Warning), "category must be a Warning subclass"
   147|         0|            0|            0|  0.00%|    assert isinstance(module, str), "module must be a string"
   148|         0|            0|            0|  0.00%|    assert isinstance(lineno, int) and lineno >= 0, \
   149|         0|            0|            0|  0.00%|           "lineno must be an int >= 0"
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|    if message or module:
   152|         0|            0|            0|  0.00%|        import re
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|    if message:
   155|         0|            0|            0|  0.00%|        message = re.compile(message, re.I)
   156|         0|            0|            0|  0.00%|    else:
   157|         0|            0|            0|  0.00%|        message = None
   158|         0|            0|            0|  0.00%|    if module:
   159|         0|            0|            0|  0.00%|        module = re.compile(module)
   160|         0|            0|            0|  0.00%|    else:
   161|         0|            0|            0|  0.00%|        module = None
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|    _add_filter(action, message, category, module, lineno, append=append)
   164|         0|            0|            0|  0.00%|
   165|        24|            0|            0|  0.00%|def simplefilter(action, category=Warning, lineno=0, append=False):
   166|         0|            0|            0|  0.00%|    """Insert a simple entry into the list of warnings filters (at the front).
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|    A simple filter matches all modules and messages.
   169|         0|            0|            0|  0.00%|    'action' -- one of "error", "ignore", "always", "default", "module",
   170|         0|            0|            0|  0.00%|                or "once"
   171|         0|            0|            0|  0.00%|    'category' -- a class that the warning must be a subclass of
   172|         0|            0|            0|  0.00%|    'lineno' -- an integer line number, 0 matches all warnings
   173|         0|            0|            0|  0.00%|    'append' -- if true, append to the list of filters
   174|         0|            0|            0|  0.00%|    """
   175|        24|            0|            0|  0.00%|    assert action in ("error", "ignore", "always", "default", "module",
   176|         0|            0|            0|  0.00%|                      "once"), "invalid action: %r" % (action,)
   177|        24|            0|            0|  0.00%|    assert isinstance(lineno, int) and lineno >= 0, \
   178|         0|            0|            0|  0.00%|           "lineno must be an int >= 0"
   179|        24|            0|            0|  0.00%|    _add_filter(action, None, category, None, lineno, append=append)
(call)|        24|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:181 _add_filter
   180|         0|            0|            0|  0.00%|
   181|        24|            0|            0|  0.00%|def _add_filter(*item, append):
   182|         0|            0|            0|  0.00%|    # Remove possible duplicate filters, so new one will be placed
   183|         0|            0|            0|  0.00%|    # in correct place. If append=True and duplicate exists, do nothing.
   184|        24|            0|            0|  0.00%|    if not append:
   185|        24|            0|            0|  0.00%|        try:
   186|        24|            0|            0|  0.00%|            filters.remove(item)
   187|        24|            0|            0|  0.00%|        except ValueError:
   188|        24|            0|            0|  0.00%|            pass
   189|        24|            0|            0|  0.00%|        filters.insert(0, item)
   190|         0|            0|            0|  0.00%|    else:
   191|         0|            0|            0|  0.00%|        if item not in filters:
   192|         0|            0|            0|  0.00%|            filters.append(item)
   193|        24|            0|            0|  0.00%|    _filters_mutated()
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|def resetwarnings():
   196|         0|            0|            0|  0.00%|    """Clear the list of warning filters, so that no filters are active."""
   197|         0|            0|            0|  0.00%|    filters[:] = []
   198|         0|            0|            0|  0.00%|    _filters_mutated()
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|class _OptionError(Exception):
   201|         0|            0|            0|  0.00%|    """Exception used by option processing helpers."""
   202|         0|            0|            0|  0.00%|    pass
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|# Helper to process -W options passed via sys.warnoptions
   205|         0|            0|            0|  0.00%|def _processoptions(args):
   206|         0|            0|            0|  0.00%|    for arg in args:
   207|         0|            0|            0|  0.00%|        try:
   208|         0|            0|            0|  0.00%|            _setoption(arg)
   209|         0|            0|            0|  0.00%|        except _OptionError as msg:
   210|         0|            0|            0|  0.00%|            print("Invalid -W option ignored:", msg, file=sys.stderr)
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|# Helper for _processoptions()
   213|         0|            0|            0|  0.00%|def _setoption(arg):
   214|         0|            0|            0|  0.00%|    import re
   215|         0|            0|            0|  0.00%|    parts = arg.split(':')
   216|         0|            0|            0|  0.00%|    if len(parts) > 5:
   217|         0|            0|            0|  0.00%|        raise _OptionError("too many fields (max 5): %r" % (arg,))
   218|         0|            0|            0|  0.00%|    while len(parts) < 5:
   219|         0|            0|            0|  0.00%|        parts.append('')
   220|         0|            0|            0|  0.00%|    action, message, category, module, lineno = [s.strip()
   221|         0|            0|            0|  0.00%|                                                 for s in parts]
   222|         0|            0|            0|  0.00%|    action = _getaction(action)
   223|         0|            0|            0|  0.00%|    message = re.escape(message)
   224|         0|            0|            0|  0.00%|    category = _getcategory(category)
   225|         0|            0|            0|  0.00%|    module = re.escape(module)
   226|         0|            0|            0|  0.00%|    if module:
   227|         0|            0|            0|  0.00%|        module = module + '$'
   228|         0|            0|            0|  0.00%|    if lineno:
   229|         0|            0|            0|  0.00%|        try:
   230|         0|            0|            0|  0.00%|            lineno = int(lineno)
   231|         0|            0|            0|  0.00%|            if lineno < 0:
   232|         0|            0|            0|  0.00%|                raise ValueError
   233|         0|            0|            0|  0.00%|        except (ValueError, OverflowError):
   234|         0|            0|            0|  0.00%|            raise _OptionError("invalid lineno %r" % (lineno,)) from None
   235|         0|            0|            0|  0.00%|    else:
   236|         0|            0|            0|  0.00%|        lineno = 0
   237|         0|            0|            0|  0.00%|    filterwarnings(action, message, category, module, lineno)
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|# Helper for _setoption()
   240|         0|            0|            0|  0.00%|def _getaction(action):
   241|         0|            0|            0|  0.00%|    if not action:
   242|         0|            0|            0|  0.00%|        return "default"
   243|         0|            0|            0|  0.00%|    if action == "all": return "always" # Alias
   244|         0|            0|            0|  0.00%|    for a in ('default', 'always', 'ignore', 'module', 'once', 'error'):
   245|         0|            0|            0|  0.00%|        if a.startswith(action):
   246|         0|            0|            0|  0.00%|            return a
   247|         0|            0|            0|  0.00%|    raise _OptionError("invalid action: %r" % (action,))
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|# Helper for _setoption()
   250|         0|            0|            0|  0.00%|def _getcategory(category):
   251|         0|            0|            0|  0.00%|    import re
   252|         0|            0|            0|  0.00%|    if not category:
   253|         0|            0|            0|  0.00%|        return Warning
   254|         0|            0|            0|  0.00%|    if re.match("^[a-zA-Z0-9_]+$", category):
   255|         0|            0|            0|  0.00%|        try:
   256|         0|            0|            0|  0.00%|            cat = eval(category)
   257|         0|            0|            0|  0.00%|        except NameError:
   258|         0|            0|            0|  0.00%|            raise _OptionError("unknown warning category: %r" % (category,)) from None
   259|         0|            0|            0|  0.00%|    else:
   260|         0|            0|            0|  0.00%|        i = category.rfind(".")
   261|         0|            0|            0|  0.00%|        module = category[:i]
   262|         0|            0|            0|  0.00%|        klass = category[i+1:]
   263|         0|            0|            0|  0.00%|        try:
   264|         0|            0|            0|  0.00%|            m = __import__(module, None, None, [klass])
   265|         0|            0|            0|  0.00%|        except ImportError:
   266|         0|            0|            0|  0.00%|            raise _OptionError("invalid module name: %r" % (module,)) from None
   267|         0|            0|            0|  0.00%|        try:
   268|         0|            0|            0|  0.00%|            cat = getattr(m, klass)
   269|         0|            0|            0|  0.00%|        except AttributeError:
   270|         0|            0|            0|  0.00%|            raise _OptionError("unknown warning category: %r" % (category,)) from None
   271|         0|            0|            0|  0.00%|    if not issubclass(cat, Warning):
   272|         0|            0|            0|  0.00%|        raise _OptionError("invalid warning category: %r" % (category,))
   273|         0|            0|            0|  0.00%|    return cat
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|def _is_internal_frame(frame):
   277|         0|            0|            0|  0.00%|    """Signal whether the frame is an internal CPython implementation detail."""
   278|         0|            0|            0|  0.00%|    filename = frame.f_code.co_filename
   279|         0|            0|            0|  0.00%|    return 'importlib' in filename and '_bootstrap' in filename
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|def _next_external_frame(frame):
   283|         0|            0|            0|  0.00%|    """Find the next frame that doesn't involve CPython internals."""
   284|         0|            0|            0|  0.00%|    frame = frame.f_back
   285|         0|            0|            0|  0.00%|    while frame is not None and _is_internal_frame(frame):
   286|         0|            0|            0|  0.00%|        frame = frame.f_back
   287|         0|            0|            0|  0.00%|    return frame
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|# Code typically replaced by _warnings
   291|         0|            0|            0|  0.00%|def warn(message, category=None, stacklevel=1, source=None):
   292|         0|            0|            0|  0.00%|    """Issue a warning, or maybe ignore it or raise an exception."""
   293|         0|            0|            0|  0.00%|    # Check if message is already a Warning object
   294|         0|            0|            0|  0.00%|    if isinstance(message, Warning):
   295|         0|            0|            0|  0.00%|        category = message.__class__
   296|         0|            0|            0|  0.00%|    # Check category argument
   297|         0|            0|            0|  0.00%|    if category is None:
   298|         0|            0|            0|  0.00%|        category = UserWarning
   299|         0|            0|            0|  0.00%|    if not (isinstance(category, type) and issubclass(category, Warning)):
   300|         0|            0|            0|  0.00%|        raise TypeError("category must be a Warning subclass, "
   301|         0|            0|            0|  0.00%|                        "not '{:s}'".format(type(category).__name__))
   302|         0|            0|            0|  0.00%|    # Get context information
   303|         0|            0|            0|  0.00%|    try:
   304|         0|            0|            0|  0.00%|        if stacklevel <= 1 or _is_internal_frame(sys._getframe(1)):
   305|         0|            0|            0|  0.00%|            # If frame is too small to care or if the warning originated in
   306|         0|            0|            0|  0.00%|            # internal code, then do not try to hide any frames.
   307|         0|            0|            0|  0.00%|            frame = sys._getframe(stacklevel)
   308|         0|            0|            0|  0.00%|        else:
   309|         0|            0|            0|  0.00%|            frame = sys._getframe(1)
   310|         0|            0|            0|  0.00%|            # Look for one frame less since the above line starts us off.
   311|         0|            0|            0|  0.00%|            for x in range(stacklevel-1):
   312|         0|            0|            0|  0.00%|                frame = _next_external_frame(frame)
   313|         0|            0|            0|  0.00%|                if frame is None:
   314|         0|            0|            0|  0.00%|                    raise ValueError
   315|         0|            0|            0|  0.00%|    except ValueError:
   316|         0|            0|            0|  0.00%|        globals = sys.__dict__
   317|         0|            0|            0|  0.00%|        filename = "sys"
   318|         0|            0|            0|  0.00%|        lineno = 1
   319|         0|            0|            0|  0.00%|    else:
   320|         0|            0|            0|  0.00%|        globals = frame.f_globals
   321|         0|            0|            0|  0.00%|        filename = frame.f_code.co_filename
   322|         0|            0|            0|  0.00%|        lineno = frame.f_lineno
   323|         0|            0|            0|  0.00%|    if '__name__' in globals:
   324|         0|            0|            0|  0.00%|        module = globals['__name__']
   325|         0|            0|            0|  0.00%|    else:
   326|         0|            0|            0|  0.00%|        module = "<string>"
   327|         0|            0|            0|  0.00%|    registry = globals.setdefault("__warningregistry__", {})
   328|         0|            0|            0|  0.00%|    warn_explicit(message, category, filename, lineno, module, registry,
   329|         0|            0|            0|  0.00%|                  globals, source)
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|def warn_explicit(message, category, filename, lineno,
   332|         0|            0|            0|  0.00%|                  module=None, registry=None, module_globals=None,
   333|         0|            0|            0|  0.00%|                  source=None):
   334|         0|            0|            0|  0.00%|    lineno = int(lineno)
   335|         0|            0|            0|  0.00%|    if module is None:
   336|         0|            0|            0|  0.00%|        module = filename or "<unknown>"
   337|         0|            0|            0|  0.00%|        if module[-3:].lower() == ".py":
   338|         0|            0|            0|  0.00%|            module = module[:-3] # XXX What about leading pathname?
   339|         0|            0|            0|  0.00%|    if registry is None:
   340|         0|            0|            0|  0.00%|        registry = {}
   341|         0|            0|            0|  0.00%|    if registry.get('version', 0) != _filters_version:
   342|         0|            0|            0|  0.00%|        registry.clear()
   343|         0|            0|            0|  0.00%|        registry['version'] = _filters_version
   344|         0|            0|            0|  0.00%|    if isinstance(message, Warning):
   345|         0|            0|            0|  0.00%|        text = str(message)
   346|         0|            0|            0|  0.00%|        category = message.__class__
   347|         0|            0|            0|  0.00%|    else:
   348|         0|            0|            0|  0.00%|        text = message
   349|         0|            0|            0|  0.00%|        message = category(message)
   350|         0|            0|            0|  0.00%|    key = (text, category, lineno)
   351|         0|            0|            0|  0.00%|    # Quick test for common case
   352|         0|            0|            0|  0.00%|    if registry.get(key):
   353|         0|            0|            0|  0.00%|        return
   354|         0|            0|            0|  0.00%|    # Search the filters
   355|         0|            0|            0|  0.00%|    for item in filters:
   356|         0|            0|            0|  0.00%|        action, msg, cat, mod, ln = item
   357|         0|            0|            0|  0.00%|        if ((msg is None or msg.match(text)) and
   358|         0|            0|            0|  0.00%|            issubclass(category, cat) and
   359|         0|            0|            0|  0.00%|            (mod is None or mod.match(module)) and
   360|         0|            0|            0|  0.00%|            (ln == 0 or lineno == ln)):
   361|         0|            0|            0|  0.00%|            break
   362|         0|            0|            0|  0.00%|    else:
   363|         0|            0|            0|  0.00%|        action = defaultaction
   364|         0|            0|            0|  0.00%|    # Early exit actions
   365|         0|            0|            0|  0.00%|    if action == "ignore":
   366|         0|            0|            0|  0.00%|        return
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|    # Prime the linecache for formatting, in case the
   369|         0|            0|            0|  0.00%|    # "file" is actually in a zipfile or something.
   370|         0|            0|            0|  0.00%|    import linecache
   371|         0|            0|            0|  0.00%|    linecache.getlines(filename, module_globals)
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|    if action == "error":
   374|         0|            0|            0|  0.00%|        raise message
   375|         0|            0|            0|  0.00%|    # Other actions
   376|         0|            0|            0|  0.00%|    if action == "once":
   377|         0|            0|            0|  0.00%|        registry[key] = 1
   378|         0|            0|            0|  0.00%|        oncekey = (text, category)
   379|         0|            0|            0|  0.00%|        if onceregistry.get(oncekey):
   380|         0|            0|            0|  0.00%|            return
   381|         0|            0|            0|  0.00%|        onceregistry[oncekey] = 1
   382|         0|            0|            0|  0.00%|    elif action == "always":
   383|         0|            0|            0|  0.00%|        pass
   384|         0|            0|            0|  0.00%|    elif action == "module":
   385|         0|            0|            0|  0.00%|        registry[key] = 1
   386|         0|            0|            0|  0.00%|        altkey = (text, category, 0)
   387|         0|            0|            0|  0.00%|        if registry.get(altkey):
   388|         0|            0|            0|  0.00%|            return
   389|         0|            0|            0|  0.00%|        registry[altkey] = 1
   390|         0|            0|            0|  0.00%|    elif action == "default":
   391|         0|            0|            0|  0.00%|        registry[key] = 1
   392|         0|            0|            0|  0.00%|    else:
   393|         0|            0|            0|  0.00%|        # Unrecognized actions are errors
   394|         0|            0|            0|  0.00%|        raise RuntimeError(
   395|         0|            0|            0|  0.00%|              "Unrecognized action (%r) in warnings.filters:\n %s" %
   396|         0|            0|            0|  0.00%|              (action, item))
   397|         0|            0|            0|  0.00%|    # Print message and context
   398|         0|            0|            0|  0.00%|    msg = WarningMessage(message, category, filename, lineno, source)
   399|         0|            0|            0|  0.00%|    _showwarnmsg(msg)
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|class WarningMessage(object):
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    _WARNING_DETAILS = ("message", "category", "filename", "lineno", "file",
   405|         0|            0|            0|  0.00%|                        "line", "source")
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|    def __init__(self, message, category, filename, lineno, file=None,
   408|         0|            0|            0|  0.00%|                 line=None, source=None):
   409|         0|            0|            0|  0.00%|        self.message = message
   410|         0|            0|            0|  0.00%|        self.category = category
   411|         0|            0|            0|  0.00%|        self.filename = filename
   412|         0|            0|            0|  0.00%|        self.lineno = lineno
   413|         0|            0|            0|  0.00%|        self.file = file
   414|         0|            0|            0|  0.00%|        self.line = line
   415|         0|            0|            0|  0.00%|        self.source = source
   416|         0|            0|            0|  0.00%|        self._category_name = category.__name__ if category else None
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|    def __str__(self):
   419|         0|            0|            0|  0.00%|        return ("{message : %r, category : %r, filename : %r, lineno : %s, "
   420|         0|            0|            0|  0.00%|                    "line : %r}" % (self.message, self._category_name,
   421|         0|            0|            0|  0.00%|                                    self.filename, self.lineno, self.line))
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|class catch_warnings(object):
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|    """A context manager that copies and restores the warnings filter upon
   427|         0|            0|            0|  0.00%|    exiting the context.
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|    The 'record' argument specifies whether warnings should be captured by a
   430|         0|            0|            0|  0.00%|    custom implementation of warnings.showwarning() and be appended to a list
   431|         0|            0|            0|  0.00%|    returned by the context manager. Otherwise None is returned by the context
   432|         0|            0|            0|  0.00%|    manager. The objects appended to the list are arguments whose attributes
   433|         0|            0|            0|  0.00%|    mirror the arguments to showwarning().
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    The 'module' argument is to specify an alternative module to the module
   436|         0|            0|            0|  0.00%|    named 'warnings' and imported under that name. This argument is only useful
   437|         0|            0|            0|  0.00%|    when testing the warnings module itself.
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|    """
   440|         0|            0|            0|  0.00%|
   441|        24|            0|            0|  0.00%|    def __init__(self, *, record=False, module=None):
   442|         0|            0|            0|  0.00%|        """Specify whether to record warnings and if an alternative module
   443|         0|            0|            0|  0.00%|        should be used other than sys.modules['warnings'].
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|        For compatibility with Python 3.0, please consider all arguments to be
   446|         0|            0|            0|  0.00%|        keyword-only.
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|        """
   449|        24|            0|            0|  0.00%|        self._record = record
   450|        24|            0|            0|  0.00%|        self._module = sys.modules['warnings'] if module is None else module
   451|        24|            0|            0|  0.00%|        self._entered = False
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    def __repr__(self):
   454|         0|            0|            0|  0.00%|        args = []
   455|         0|            0|            0|  0.00%|        if self._record:
   456|         0|            0|            0|  0.00%|            args.append("record=True")
   457|         0|            0|            0|  0.00%|        if self._module is not sys.modules['warnings']:
   458|         0|            0|            0|  0.00%|            args.append("module=%r" % self._module)
   459|         0|            0|            0|  0.00%|        name = type(self).__name__
   460|         0|            0|            0|  0.00%|        return "%s(%s)" % (name, ", ".join(args))
   461|         0|            0|            0|  0.00%|
   462|        24|            0|            0|  0.00%|    def __enter__(self):
   463|        24|            0|            0|  0.00%|        if self._entered:
   464|         0|            0|            0|  0.00%|            raise RuntimeError("Cannot enter %r twice" % self)
   465|        24|  0.000997543|  4.15643e-05|  0.00%|        self._entered = True
   466|        24|            0|            0|  0.00%|        self._filters = self._module.filters
   467|        24|            0|            0|  0.00%|        self._module.filters = self._filters[:]
   468|        24|            0|            0|  0.00%|        self._module._filters_mutated()
   469|        24|            0|            0|  0.00%|        self._showwarning = self._module.showwarning
   470|        24|            0|            0|  0.00%|        self._showwarnmsg_impl = self._module._showwarnmsg_impl
   471|        24|            0|            0|  0.00%|        if self._record:
   472|         0|            0|            0|  0.00%|            log = []
   473|         0|            0|            0|  0.00%|            self._module._showwarnmsg_impl = log.append
   474|         0|            0|            0|  0.00%|            # Reset showwarning() to the default implementation to make sure
   475|         0|            0|            0|  0.00%|            # that _showwarnmsg() calls _showwarnmsg_impl()
   476|         0|            0|            0|  0.00%|            self._module.showwarning = self._module._showwarning_orig
   477|         0|            0|            0|  0.00%|            return log
   478|         0|            0|            0|  0.00%|        else:
   479|        24|            0|            0|  0.00%|            return None
   480|         0|            0|            0|  0.00%|
   481|        24|            0|            0|  0.00%|    def __exit__(self, *exc_info):
   482|        24|            0|            0|  0.00%|        if not self._entered:
   483|         0|            0|            0|  0.00%|            raise RuntimeError("Cannot exit %r without entering first" % self)
   484|        24|  0.000997543|  4.15643e-05|  0.00%|        self._module.filters = self._filters
   485|        24|            0|            0|  0.00%|        self._module._filters_mutated()
   486|        24|            0|            0|  0.00%|        self._module.showwarning = self._showwarning
   487|        24|            0|            0|  0.00%|        self._module._showwarnmsg_impl = self._showwarnmsg_impl
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|# Private utility function called by _PyErr_WarnUnawaitedCoroutine
   491|         0|            0|            0|  0.00%|def _warn_unawaited_coroutine(coro):
   492|         0|            0|            0|  0.00%|    msg_lines = [
   493|         0|            0|            0|  0.00%|        f"coroutine '{coro.__qualname__}' was never awaited\n"
   494|         0|            0|            0|  0.00%|    ]
   495|         0|            0|            0|  0.00%|    if coro.cr_origin is not None:
   496|         0|            0|            0|  0.00%|        import linecache, traceback
   497|         0|            0|            0|  0.00%|        def extract():
   498|         0|            0|            0|  0.00%|            for filename, lineno, funcname in reversed(coro.cr_origin):
   499|         0|            0|            0|  0.00%|                line = linecache.getline(filename, lineno)
   500|         0|            0|            0|  0.00%|                yield (filename, lineno, funcname, line)
   501|         0|            0|            0|  0.00%|        msg_lines.append("Coroutine created at (most recent call last)\n")
   502|         0|            0|            0|  0.00%|        msg_lines += traceback.format_list(list(extract()))
   503|         0|            0|            0|  0.00%|    msg = "".join(msg_lines).rstrip("\n")
   504|         0|            0|            0|  0.00%|    # Passing source= here means that if the user happens to have tracemalloc
   505|         0|            0|            0|  0.00%|    # enabled and tracking where the coroutine was created, the warning will
   506|         0|            0|            0|  0.00%|    # contain that traceback. This does mean that if they have *both*
   507|         0|            0|            0|  0.00%|    # coroutine origin tracking *and* tracemalloc enabled, they'll get two
   508|         0|            0|            0|  0.00%|    # partially-redundant tracebacks. If we wanted to be clever we could
   509|         0|            0|            0|  0.00%|    # probably detect this case and avoid it, but for now we don't bother.
   510|         0|            0|            0|  0.00%|    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|# filters contains a sequence of filter 5-tuples
   514|         0|            0|            0|  0.00%|# The components of the 5-tuple are:
   515|         0|            0|            0|  0.00%|# - an action: error, ignore, always, default, module, or once
   516|         0|            0|            0|  0.00%|# - a compiled regex that must match the warning message
   517|         0|            0|            0|  0.00%|# - a class representing the warning category
   518|         0|            0|            0|  0.00%|# - a compiled regex that must match the module that is being warned
   519|         0|            0|            0|  0.00%|# - a line number for the line being warning, or 0 to mean any line
   520|         0|            0|            0|  0.00%|# If either if the compiled regexs are None, match anything.
   521|         0|            0|            0|  0.00%|try:
   522|         0|            0|            0|  0.00%|    from _warnings import (filters, _defaultaction, _onceregistry,
   523|         0|            0|            0|  0.00%|                           warn, warn_explicit, _filters_mutated)
   524|         0|            0|            0|  0.00%|    defaultaction = _defaultaction
   525|         0|            0|            0|  0.00%|    onceregistry = _onceregistry
   526|         0|            0|            0|  0.00%|    _warnings_defaults = True
   527|         0|            0|            0|  0.00%|except ImportError:
   528|         0|            0|            0|  0.00%|    filters = []
   529|         0|            0|            0|  0.00%|    defaultaction = "default"
   530|         0|            0|            0|  0.00%|    onceregistry = {}
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|    _filters_version = 1
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|    def _filters_mutated():
   535|         0|            0|            0|  0.00%|        global _filters_version
   536|         0|            0|            0|  0.00%|        _filters_version += 1
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|    _warnings_defaults = False
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|# Module initialization
   542|         0|            0|            0|  0.00%|_processoptions(sys.warnoptions)
   543|         0|            0|            0|  0.00%|if not _warnings_defaults:
   544|         0|            0|            0|  0.00%|    # Several warning categories are ignored by default in regular builds
   545|         0|            0|            0|  0.00%|    if not hasattr(sys, 'gettotalrefcount'):
   546|         0|            0|            0|  0.00%|        filterwarnings("default", category=DeprecationWarning,
   547|         0|            0|            0|  0.00%|                       module="__main__", append=1)
   548|         0|            0|            0|  0.00%|        simplefilter("ignore", category=DeprecationWarning, append=1)
   549|         0|            0|            0|  0.00%|        simplefilter("ignore", category=PendingDeprecationWarning, append=1)
   550|         0|            0|            0|  0.00%|        simplefilter("ignore", category=ImportWarning, append=1)
   551|         0|            0|            0|  0.00%|        simplefilter("ignore", category=ResourceWarning, append=1)
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|del _warnings_defaults
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py
File duration: 0.00199389s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|""" A sparse matrix in COOrdinate or 'triplet' format"""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|__docformat__ = "restructuredtext en"
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|__all__ = ['coo_matrix', 'isspmatrix_coo']
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|from warnings import warn
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|import numpy as np
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|from ._sparsetools import coo_tocsr, coo_todense, coo_matvec
    13|         0|            0|            0|  0.00%|from .base import isspmatrix, SparseEfficiencyWarning, spmatrix
    14|         0|            0|            0|  0.00%|from .data import _data_matrix, _minmax_mixin
    15|         0|            0|            0|  0.00%|from .sputils import (upcast, upcast_char, to_native, isshape, getdtype,
    16|         0|            0|            0|  0.00%|                      getdata, get_index_dtype, downcast_intp_index,
    17|         0|            0|            0|  0.00%|                      check_shape, check_reshape_kwargs, matrix)
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|import operator
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|class coo_matrix(_data_matrix, _minmax_mixin):
    23|         0|            0|            0|  0.00%|    """
    24|         0|            0|            0|  0.00%|    A sparse matrix in COOrdinate format.
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|    Also known as the 'ijv' or 'triplet' format.
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|    This can be instantiated in several ways:
    29|         0|            0|            0|  0.00%|        coo_matrix(D)
    30|         0|            0|            0|  0.00%|            with a dense matrix D
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|        coo_matrix(S)
    33|         0|            0|            0|  0.00%|            with another sparse matrix S (equivalent to S.tocoo())
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|        coo_matrix((M, N), [dtype])
    36|         0|            0|            0|  0.00%|            to construct an empty matrix with shape (M, N)
    37|         0|            0|            0|  0.00%|            dtype is optional, defaulting to dtype='d'.
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|        coo_matrix((data, (i, j)), [shape=(M, N)])
    40|         0|            0|            0|  0.00%|            to construct from three arrays:
    41|         0|            0|            0|  0.00%|                1. data[:]   the entries of the matrix, in any order
    42|         0|            0|            0|  0.00%|                2. i[:]      the row indices of the matrix entries
    43|         0|            0|            0|  0.00%|                3. j[:]      the column indices of the matrix entries
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|            Where ``A[i[k], j[k]] = data[k]``.  When shape is not
    46|         0|            0|            0|  0.00%|            specified, it is inferred from the index arrays
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|    Attributes
    49|         0|            0|            0|  0.00%|    ----------
    50|         0|            0|            0|  0.00%|    dtype : dtype
    51|         0|            0|            0|  0.00%|        Data type of the matrix
    52|         0|            0|            0|  0.00%|    shape : 2-tuple
    53|         0|            0|            0|  0.00%|        Shape of the matrix
    54|         0|            0|            0|  0.00%|    ndim : int
    55|         0|            0|            0|  0.00%|        Number of dimensions (this is always 2)
    56|         0|            0|            0|  0.00%|    nnz
    57|         0|            0|            0|  0.00%|        Number of stored values, including explicit zeros
    58|         0|            0|            0|  0.00%|    data
    59|         0|            0|            0|  0.00%|        COO format data array of the matrix
    60|         0|            0|            0|  0.00%|    row
    61|         0|            0|            0|  0.00%|        COO format row index array of the matrix
    62|         0|            0|            0|  0.00%|    col
    63|         0|            0|            0|  0.00%|        COO format column index array of the matrix
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    Notes
    66|         0|            0|            0|  0.00%|    -----
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    Sparse matrices can be used in arithmetic operations: they support
    69|         0|            0|            0|  0.00%|    addition, subtraction, multiplication, division, and matrix power.
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    Advantages of the COO format
    72|         0|            0|            0|  0.00%|        - facilitates fast conversion among sparse formats
    73|         0|            0|            0|  0.00%|        - permits duplicate entries (see example)
    74|         0|            0|            0|  0.00%|        - very fast conversion to and from CSR/CSC formats
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|    Disadvantages of the COO format
    77|         0|            0|            0|  0.00%|        - does not directly support:
    78|         0|            0|            0|  0.00%|            + arithmetic operations
    79|         0|            0|            0|  0.00%|            + slicing
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    Intended Usage
    82|         0|            0|            0|  0.00%|        - COO is a fast format for constructing sparse matrices
    83|         0|            0|            0|  0.00%|        - Once a matrix has been constructed, convert to CSR or
    84|         0|            0|            0|  0.00%|          CSC format for fast arithmetic and matrix vector operations
    85|         0|            0|            0|  0.00%|        - By default when converting to CSR or CSC format, duplicate (i,j)
    86|         0|            0|            0|  0.00%|          entries will be summed together.  This facilitates efficient
    87|         0|            0|            0|  0.00%|          construction of finite element matrices and the like. (see example)
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    Examples
    90|         0|            0|            0|  0.00%|    --------
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|    >>> # Constructing an empty matrix
    93|         0|            0|            0|  0.00%|    >>> from scipy.sparse import coo_matrix
    94|         0|            0|            0|  0.00%|    >>> coo_matrix((3, 4), dtype=np.int8).toarray()
    95|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0],
    96|         0|            0|            0|  0.00%|           [0, 0, 0, 0],
    97|         0|            0|            0|  0.00%|           [0, 0, 0, 0]], dtype=int8)
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    >>> # Constructing a matrix using ijv format
   100|         0|            0|            0|  0.00%|    >>> row  = np.array([0, 3, 1, 0])
   101|         0|            0|            0|  0.00%|    >>> col  = np.array([0, 3, 1, 2])
   102|         0|            0|            0|  0.00%|    >>> data = np.array([4, 5, 7, 9])
   103|         0|            0|            0|  0.00%|    >>> coo_matrix((data, (row, col)), shape=(4, 4)).toarray()
   104|         0|            0|            0|  0.00%|    array([[4, 0, 9, 0],
   105|         0|            0|            0|  0.00%|           [0, 7, 0, 0],
   106|         0|            0|            0|  0.00%|           [0, 0, 0, 0],
   107|         0|            0|            0|  0.00%|           [0, 0, 0, 5]])
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|    >>> # Constructing a matrix with duplicate indices
   110|         0|            0|            0|  0.00%|    >>> row  = np.array([0, 0, 1, 3, 1, 0, 0])
   111|         0|            0|            0|  0.00%|    >>> col  = np.array([0, 2, 1, 3, 1, 0, 0])
   112|         0|            0|            0|  0.00%|    >>> data = np.array([1, 1, 1, 1, 1, 1, 1])
   113|         0|            0|            0|  0.00%|    >>> coo = coo_matrix((data, (row, col)), shape=(4, 4))
   114|         0|            0|            0|  0.00%|    >>> # Duplicate indices are maintained until implicitly or explicitly summed
   115|         0|            0|            0|  0.00%|    >>> np.max(coo.data)
   116|         0|            0|            0|  0.00%|    1
   117|         0|            0|            0|  0.00%|    >>> coo.toarray()
   118|         0|            0|            0|  0.00%|    array([[3, 0, 1, 0],
   119|         0|            0|            0|  0.00%|           [0, 2, 0, 0],
   120|         0|            0|            0|  0.00%|           [0, 0, 0, 0],
   121|         0|            0|            0|  0.00%|           [0, 0, 0, 1]])
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    """
   124|         0|            0|            0|  0.00%|    format = 'coo'
   125|         0|            0|            0|  0.00%|
   126|        12|            0|            0|  0.00%|    def __init__(self, arg1, shape=None, dtype=None, copy=False):
   127|        12|            0|            0|  0.00%|        _data_matrix.__init__(self)
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:20 __init__
   128|         0|            0|            0|  0.00%|
   129|        12|            0|            0|  0.00%|        if isinstance(arg1, tuple):
   130|         8|            0|            0|  0.00%|            if isshape(arg1):
(call)|         8|  0.000997782|  0.000124723|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:220 isshape
   131|         0|            0|            0|  0.00%|                M, N = arg1
   132|         0|            0|            0|  0.00%|                self._shape = check_shape((M, N))
   133|         0|            0|            0|  0.00%|                idx_dtype = get_index_dtype(maxval=max(M, N))
   134|         0|            0|            0|  0.00%|                data_dtype = getdtype(dtype, default=float)
   135|         0|            0|            0|  0.00%|                self.row = np.array([], dtype=idx_dtype)
   136|         0|            0|            0|  0.00%|                self.col = np.array([], dtype=idx_dtype)
   137|         0|            0|            0|  0.00%|                self.data = np.array([], dtype=data_dtype)
   138|         0|            0|            0|  0.00%|                self.has_canonical_format = True
   139|         0|            0|            0|  0.00%|            else:
   140|         8|            0|            0|  0.00%|                try:
   141|         8|            0|            0|  0.00%|                    obj, (row, col) = arg1
   142|         0|            0|            0|  0.00%|                except (TypeError, ValueError) as e:
   143|         0|            0|            0|  0.00%|                    raise TypeError('invalid input format') from e
   144|         0|            0|            0|  0.00%|
   145|         8|            0|            0|  0.00%|                if shape is None:
   146|         0|            0|            0|  0.00%|                    if len(row) == 0 or len(col) == 0:
   147|         0|            0|            0|  0.00%|                        raise ValueError('cannot infer dimensions from zero '
   148|         0|            0|            0|  0.00%|                                         'sized index arrays')
   149|         0|            0|            0|  0.00%|                    M = operator.index(np.max(row)) + 1
   150|         0|            0|            0|  0.00%|                    N = operator.index(np.max(col)) + 1
   151|         0|            0|            0|  0.00%|                    self._shape = check_shape((M, N))
   152|         0|            0|            0|  0.00%|                else:
   153|         0|            0|            0|  0.00%|                    # Use 2 steps to ensure shape has length 2.
   154|         8|            0|            0|  0.00%|                    M, N = shape
   155|         8|            0|            0|  0.00%|                    self._shape = check_shape((M, N))
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:277 check_shape
   156|         0|            0|            0|  0.00%|
   157|         8|            0|            0|  0.00%|                idx_dtype = get_index_dtype(maxval=max(self.shape))
(call)|         8|  0.000997066|  0.000124633|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|         8|  0.000995636|  0.000124454|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:131 get_index_dtype
   158|         8|            0|            0|  0.00%|                self.row = np.array(row, copy=copy, dtype=idx_dtype)
   159|         8|            0|            0|  0.00%|                self.col = np.array(col, copy=copy, dtype=idx_dtype)
   160|         8|            0|            0|  0.00%|                self.data = getdata(obj, copy=copy, dtype=dtype)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:119 getdata
   161|         8|            0|            0|  0.00%|                self.has_canonical_format = False
   162|         0|            0|            0|  0.00%|        else:
   163|         4|            0|            0|  0.00%|            if isspmatrix(arg1):
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:1205 isspmatrix
   164|         4|            0|            0|  0.00%|                if isspmatrix_coo(arg1) and copy:
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:595 isspmatrix_coo
   165|         0|            0|            0|  0.00%|                    self.row = arg1.row.copy()
   166|         0|            0|            0|  0.00%|                    self.col = arg1.col.copy()
   167|         0|            0|            0|  0.00%|                    self.data = arg1.data.copy()
   168|         0|            0|            0|  0.00%|                    self._shape = check_shape(arg1.shape)
   169|         0|            0|            0|  0.00%|                else:
   170|         4|            0|            0|  0.00%|                    coo = arg1.tocoo()
(call)|         4|  0.000996351|  0.000249088|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1023 tocoo
   171|         4|            0|            0|  0.00%|                    self.row = coo.row
   172|         4|            0|            0|  0.00%|                    self.col = coo.col
   173|         4|            0|            0|  0.00%|                    self.data = coo.data
   174|         4|            0|            0|  0.00%|                    self._shape = check_shape(coo.shape)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|         4|  0.000997543|  0.000249386|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:277 check_shape
   175|         4|            0|            0|  0.00%|                self.has_canonical_format = False
   176|         0|            0|            0|  0.00%|            else:
   177|         0|            0|            0|  0.00%|                #dense argument
   178|         0|            0|            0|  0.00%|                M = np.atleast_2d(np.asarray(arg1))
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|                if M.ndim != 2:
   181|         0|            0|            0|  0.00%|                    raise TypeError('expected dimension <= 2 array or matrix')
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|                self._shape = check_shape(M.shape)
   184|         0|            0|            0|  0.00%|                if shape is not None:
   185|         0|            0|            0|  0.00%|                    if check_shape(shape) != self._shape:
   186|         0|            0|            0|  0.00%|                        raise ValueError('inconsistent shapes: %s != %s' %
   187|         0|            0|            0|  0.00%|                                         (shape, self._shape))
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|                self.row, self.col = M.nonzero()
   190|         0|            0|            0|  0.00%|                self.data = M[self.row, self.col]
   191|         0|            0|            0|  0.00%|                self.has_canonical_format = True
   192|         0|            0|            0|  0.00%|
   193|        12|            0|            0|  0.00%|        if dtype is not None:
   194|         8|            0|            0|  0.00%|            self.data = self.data.astype(dtype, copy=False)
   195|         0|            0|            0|  0.00%|
   196|        12|            0|            0|  0.00%|        self._check()
(call)|        12|  0.000996351|  8.30293e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:265 _check
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    def reshape(self, *args, **kwargs):
   199|         0|            0|            0|  0.00%|        shape = check_shape(args, self.shape)
   200|         0|            0|            0|  0.00%|        order, copy = check_reshape_kwargs(kwargs)
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|        # Return early if reshape is not required
   203|         0|            0|            0|  0.00%|        if shape == self.shape:
   204|         0|            0|            0|  0.00%|            if copy:
   205|         0|            0|            0|  0.00%|                return self.copy()
   206|         0|            0|            0|  0.00%|            else:
   207|         0|            0|            0|  0.00%|                return self
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|        nrows, ncols = self.shape
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|        if order == 'C':
   212|         0|            0|            0|  0.00%|            # Upcast to avoid overflows: the coo_matrix constructor
   213|         0|            0|            0|  0.00%|            # below will downcast the results to a smaller dtype, if
   214|         0|            0|            0|  0.00%|            # possible.
   215|         0|            0|            0|  0.00%|            dtype = get_index_dtype(maxval=(ncols * max(0, nrows - 1) + max(0, ncols - 1)))
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|            flat_indices = np.multiply(ncols, self.row, dtype=dtype) + self.col
   218|         0|            0|            0|  0.00%|            new_row, new_col = divmod(flat_indices, shape[1])
   219|         0|            0|            0|  0.00%|        elif order == 'F':
   220|         0|            0|            0|  0.00%|            dtype = get_index_dtype(maxval=(nrows * max(0, ncols - 1) + max(0, nrows - 1)))
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|            flat_indices = np.multiply(nrows, self.col, dtype=dtype) + self.row
   223|         0|            0|            0|  0.00%|            new_col, new_row = divmod(flat_indices, shape[0])
   224|         0|            0|            0|  0.00%|        else:
   225|         0|            0|            0|  0.00%|            raise ValueError("'order' must be 'C' or 'F'")
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|        # Handle copy here rather than passing on to the constructor so that no
   228|         0|            0|            0|  0.00%|        # copy will be made of new_row and new_col regardless
   229|         0|            0|            0|  0.00%|        if copy:
   230|         0|            0|            0|  0.00%|            new_data = self.data.copy()
   231|         0|            0|            0|  0.00%|        else:
   232|         0|            0|            0|  0.00%|            new_data = self.data
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|        return coo_matrix((new_data, (new_row, new_col)),
   235|         0|            0|            0|  0.00%|                          shape=shape, copy=False)
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    reshape.__doc__ = spmatrix.reshape.__doc__
   238|         0|            0|            0|  0.00%|
   239|        24|            0|            0|  0.00%|    def getnnz(self, axis=None):
   240|        24|            0|            0|  0.00%|        if axis is None:
   241|        24|            0|            0|  0.00%|            nnz = len(self.data)
   242|        24|            0|            0|  0.00%|            if nnz != len(self.row) or nnz != len(self.col):
   243|         0|            0|            0|  0.00%|                raise ValueError('row, column, and data array must all be the '
   244|         0|            0|            0|  0.00%|                                 'same length')
   245|         0|            0|            0|  0.00%|
   246|        24|            0|            0|  0.00%|            if self.data.ndim != 1 or self.row.ndim != 1 or \
   247|        24|            0|            0|  0.00%|                    self.col.ndim != 1:
   248|         0|            0|            0|  0.00%|                raise ValueError('row, column, and data arrays must be 1-D')
   249|         0|            0|            0|  0.00%|
   250|        24|            0|            0|  0.00%|            return int(nnz)
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|        if axis < 0:
   253|         0|            0|            0|  0.00%|            axis += 2
   254|         0|            0|            0|  0.00%|        if axis == 0:
   255|         0|            0|            0|  0.00%|            return np.bincount(downcast_intp_index(self.col),
   256|         0|            0|            0|  0.00%|                               minlength=self.shape[1])
   257|         0|            0|            0|  0.00%|        elif axis == 1:
   258|         0|            0|            0|  0.00%|            return np.bincount(downcast_intp_index(self.row),
   259|         0|            0|            0|  0.00%|                               minlength=self.shape[0])
   260|         0|            0|            0|  0.00%|        else:
   261|         0|            0|            0|  0.00%|            raise ValueError('axis out of bounds')
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|    getnnz.__doc__ = spmatrix.getnnz.__doc__
   264|         0|            0|            0|  0.00%|
   265|        12|            0|            0|  0.00%|    def _check(self):
   266|         0|            0|            0|  0.00%|        """ Checks data structure for consistency """
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|        # index arrays should have integer data types
   269|        12|            0|            0|  0.00%|        if self.row.dtype.kind != 'i':
   270|         0|            0|            0|  0.00%|            warn("row index array has non-integer dtype (%s)  "
   271|         0|            0|            0|  0.00%|                    % self.row.dtype.name)
   272|        12|            0|            0|  0.00%|        if self.col.dtype.kind != 'i':
   273|         0|            0|            0|  0.00%|            warn("col index array has non-integer dtype (%s) "
   274|         0|            0|            0|  0.00%|                    % self.col.dtype.name)
   275|         0|            0|            0|  0.00%|
   276|        12|            0|            0|  0.00%|        idx_dtype = get_index_dtype(maxval=max(self.shape))
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|        12|  0.000996351|  8.30293e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:131 get_index_dtype
   277|        12|            0|            0|  0.00%|        self.row = np.asarray(self.row, dtype=idx_dtype)
   278|        12|            0|            0|  0.00%|        self.col = np.asarray(self.col, dtype=idx_dtype)
   279|        12|            0|            0|  0.00%|        self.data = to_native(self.data)
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:91 to_native
   280|         0|            0|            0|  0.00%|
   281|        12|            0|            0|  0.00%|        if self.nnz > 0:
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
   282|        12|            0|            0|  0.00%|            if self.row.max() >= self.shape[0]:
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:38 _amax
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   283|         0|            0|            0|  0.00%|                raise ValueError('row index exceeds matrix dimensions')
   284|        12|            0|            0|  0.00%|            if self.col.max() >= self.shape[1]:
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:38 _amax
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   285|         0|            0|            0|  0.00%|                raise ValueError('column index exceeds matrix dimensions')
   286|        12|            0|            0|  0.00%|            if self.row.min() < 0:
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:42 _amin
   287|         0|            0|            0|  0.00%|                raise ValueError('negative row index found')
   288|        12|            0|            0|  0.00%|            if self.col.min() < 0:
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:42 _amin
   289|         0|            0|            0|  0.00%|                raise ValueError('negative column index found')
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|    def transpose(self, axes=None, copy=False):
   292|         0|            0|            0|  0.00%|        if axes is not None:
   293|         0|            0|            0|  0.00%|            raise ValueError(("Sparse matrices do not support "
   294|         0|            0|            0|  0.00%|                              "an 'axes' parameter because swapping "
   295|         0|            0|            0|  0.00%|                              "dimensions is the only logical permutation."))
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|        M, N = self.shape
   298|         0|            0|            0|  0.00%|        return coo_matrix((self.data, (self.col, self.row)),
   299|         0|            0|            0|  0.00%|                          shape=(N, M), copy=copy)
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    transpose.__doc__ = spmatrix.transpose.__doc__
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|    def resize(self, *shape):
   304|         0|            0|            0|  0.00%|        shape = check_shape(shape)
   305|         0|            0|            0|  0.00%|        new_M, new_N = shape
   306|         0|            0|            0|  0.00%|        M, N = self.shape
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|        if new_M < M or new_N < N:
   309|         0|            0|            0|  0.00%|            mask = np.logical_and(self.row < new_M, self.col < new_N)
   310|         0|            0|            0|  0.00%|            if not mask.all():
   311|         0|            0|            0|  0.00%|                self.row = self.row[mask]
   312|         0|            0|            0|  0.00%|                self.col = self.col[mask]
   313|         0|            0|            0|  0.00%|                self.data = self.data[mask]
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|        self._shape = shape
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    resize.__doc__ = spmatrix.resize.__doc__
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|    def toarray(self, order=None, out=None):
   320|         0|            0|            0|  0.00%|        """See the docstring for `spmatrix.toarray`."""
   321|         0|            0|            0|  0.00%|        B = self._process_toarray_args(order, out)
   322|         0|            0|            0|  0.00%|        fortran = int(B.flags.f_contiguous)
   323|         0|            0|            0|  0.00%|        if not fortran and not B.flags.c_contiguous:
   324|         0|            0|            0|  0.00%|            raise ValueError("Output array must be C or F contiguous")
   325|         0|            0|            0|  0.00%|        M,N = self.shape
   326|         0|            0|            0|  0.00%|        coo_todense(M, N, self.nnz, self.row, self.col, self.data,
   327|         0|            0|            0|  0.00%|                    B.ravel('A'), fortran)
   328|         0|            0|            0|  0.00%|        return B
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|    def tocsc(self, copy=False):
   331|         0|            0|            0|  0.00%|        """Convert this matrix to Compressed Sparse Column format
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|        Duplicate entries will be summed together.
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|        Examples
   336|         0|            0|            0|  0.00%|        --------
   337|         0|            0|            0|  0.00%|        >>> from numpy import array
   338|         0|            0|            0|  0.00%|        >>> from scipy.sparse import coo_matrix
   339|         0|            0|            0|  0.00%|        >>> row  = array([0, 0, 1, 3, 1, 0, 0])
   340|         0|            0|            0|  0.00%|        >>> col  = array([0, 2, 1, 3, 1, 0, 0])
   341|         0|            0|            0|  0.00%|        >>> data = array([1, 1, 1, 1, 1, 1, 1])
   342|         0|            0|            0|  0.00%|        >>> A = coo_matrix((data, (row, col)), shape=(4, 4)).tocsc()
   343|         0|            0|            0|  0.00%|        >>> A.toarray()
   344|         0|            0|            0|  0.00%|        array([[3, 0, 1, 0],
   345|         0|            0|            0|  0.00%|               [0, 2, 0, 0],
   346|         0|            0|            0|  0.00%|               [0, 0, 0, 0],
   347|         0|            0|            0|  0.00%|               [0, 0, 0, 1]])
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|        """
   350|         0|            0|            0|  0.00%|        from .csc import csc_matrix
   351|         0|            0|            0|  0.00%|        if self.nnz == 0:
   352|         0|            0|            0|  0.00%|            return csc_matrix(self.shape, dtype=self.dtype)
   353|         0|            0|            0|  0.00%|        else:
   354|         0|            0|            0|  0.00%|            M,N = self.shape
   355|         0|            0|            0|  0.00%|            idx_dtype = get_index_dtype((self.col, self.row),
   356|         0|            0|            0|  0.00%|                                        maxval=max(self.nnz, M))
   357|         0|            0|            0|  0.00%|            row = self.row.astype(idx_dtype, copy=False)
   358|         0|            0|            0|  0.00%|            col = self.col.astype(idx_dtype, copy=False)
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|            indptr = np.empty(N + 1, dtype=idx_dtype)
   361|         0|            0|            0|  0.00%|            indices = np.empty_like(row, dtype=idx_dtype)
   362|         0|            0|            0|  0.00%|            data = np.empty_like(self.data, dtype=upcast(self.dtype))
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|            coo_tocsr(N, M, self.nnz, col, row, self.data,
   365|         0|            0|            0|  0.00%|                      indptr, indices, data)
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|            x = csc_matrix((data, indices, indptr), shape=self.shape)
   368|         0|            0|            0|  0.00%|            if not self.has_canonical_format:
   369|         0|            0|            0|  0.00%|                x.sum_duplicates()
   370|         0|            0|            0|  0.00%|            return x
   371|         0|            0|            0|  0.00%|
   372|         4|            0|            0|  0.00%|    def tocsr(self, copy=False):
   373|         0|            0|            0|  0.00%|        """Convert this matrix to Compressed Sparse Row format
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|        Duplicate entries will be summed together.
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|        Examples
   378|         0|            0|            0|  0.00%|        --------
   379|         0|            0|            0|  0.00%|        >>> from numpy import array
   380|         0|            0|            0|  0.00%|        >>> from scipy.sparse import coo_matrix
   381|         0|            0|            0|  0.00%|        >>> row  = array([0, 0, 1, 3, 1, 0, 0])
   382|         0|            0|            0|  0.00%|        >>> col  = array([0, 2, 1, 3, 1, 0, 0])
   383|         0|            0|            0|  0.00%|        >>> data = array([1, 1, 1, 1, 1, 1, 1])
   384|         0|            0|            0|  0.00%|        >>> A = coo_matrix((data, (row, col)), shape=(4, 4)).tocsr()
   385|         0|            0|            0|  0.00%|        >>> A.toarray()
   386|         0|            0|            0|  0.00%|        array([[3, 0, 1, 0],
   387|         0|            0|            0|  0.00%|               [0, 2, 0, 0],
   388|         0|            0|            0|  0.00%|               [0, 0, 0, 0],
   389|         0|            0|            0|  0.00%|               [0, 0, 0, 1]])
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|        """
   392|         4|            0|            0|  0.00%|        from .csr import csr_matrix
(call)|         4|            0|            0|  0.00%|# <frozen importlib._bootstrap>:389 parent
   393|         4|            0|            0|  0.00%|        if self.nnz == 0:
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
   394|         0|            0|            0|  0.00%|            return csr_matrix(self.shape, dtype=self.dtype)
   395|         0|            0|            0|  0.00%|        else:
   396|         4|            0|            0|  0.00%|            M,N = self.shape
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   397|         8|            0|            0|  0.00%|            idx_dtype = get_index_dtype((self.row, self.col),
(call)|         4|  0.000998497|  0.000249624|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:131 get_index_dtype
   398|         4|            0|            0|  0.00%|                                        maxval=max(self.nnz, N))
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
   399|         4|            0|            0|  0.00%|            row = self.row.astype(idx_dtype, copy=False)
   400|         4|            0|            0|  0.00%|            col = self.col.astype(idx_dtype, copy=False)
   401|         0|            0|            0|  0.00%|
   402|         4|            0|            0|  0.00%|            indptr = np.empty(M + 1, dtype=idx_dtype)
   403|         4|            0|            0|  0.00%|            indices = np.empty_like(col, dtype=idx_dtype)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 empty_like
   404|         4|            0|            0|  0.00%|            data = np.empty_like(self.data, dtype=upcast(self.dtype))
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
(call)|         4|   0.00100112|   0.00025028|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\sputils.py:20 upcast
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 empty_like
   405|         0|            0|            0|  0.00%|
   406|         8|            0|            0|  0.00%|            coo_tocsr(M, N, self.nnz, row, col, self.data,
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:238 nnz
   407|         4|            0|            0|  0.00%|                      indptr, indices, data)
   408|         0|            0|            0|  0.00%|
   409|         4|            0|            0|  0.00%|            x = csr_matrix((data, indices, indptr), shape=self.shape)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
(call)|         4|   0.00393987|  0.000984967|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:27 __init__
   410|         4|            0|            0|  0.00%|            if not self.has_canonical_format:
   411|         4|            0|            0|  0.00%|                x.sum_duplicates()
(call)|         4|  0.000992298|  0.000248075|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1099 sum_duplicates
   412|         4|            0|            0|  0.00%|            return x
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    def tocoo(self, copy=False):
   415|         0|            0|            0|  0.00%|        if copy:
   416|         0|            0|            0|  0.00%|            return self.copy()
   417|         0|            0|            0|  0.00%|        else:
   418|         0|            0|            0|  0.00%|            return self
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    tocoo.__doc__ = spmatrix.tocoo.__doc__
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    def todia(self, copy=False):
   423|         0|            0|            0|  0.00%|        from .dia import dia_matrix
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|        self.sum_duplicates()
   426|         0|            0|            0|  0.00%|        ks = self.col - self.row  # the diagonal for each nonzero
   427|         0|            0|            0|  0.00%|        diags, diag_idx = np.unique(ks, return_inverse=True)
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|        if len(diags) > 100:
   430|         0|            0|            0|  0.00%|            # probably undesired, should todia() have a maxdiags parameter?
   431|         0|            0|            0|  0.00%|            warn("Constructing a DIA matrix with %d diagonals "
   432|         0|            0|            0|  0.00%|                 "is inefficient" % len(diags), SparseEfficiencyWarning)
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|        #initialize and fill in data array
   435|         0|            0|            0|  0.00%|        if self.data.size == 0:
   436|         0|            0|            0|  0.00%|            data = np.zeros((0, 0), dtype=self.dtype)
   437|         0|            0|            0|  0.00%|        else:
   438|         0|            0|            0|  0.00%|            data = np.zeros((len(diags), self.col.max()+1), dtype=self.dtype)
   439|         0|            0|            0|  0.00%|            data[diag_idx, self.col] = self.data
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|        return dia_matrix((data,diags), shape=self.shape)
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    todia.__doc__ = spmatrix.todia.__doc__
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    def todok(self, copy=False):
   446|         0|            0|            0|  0.00%|        from .dok import dok_matrix
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|        self.sum_duplicates()
   449|         0|            0|            0|  0.00%|        dok = dok_matrix((self.shape), dtype=self.dtype)
   450|         0|            0|            0|  0.00%|        dok._update(zip(zip(self.row,self.col),self.data))
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|        return dok
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|    todok.__doc__ = spmatrix.todok.__doc__
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|    def diagonal(self, k=0):
   457|         0|            0|            0|  0.00%|        rows, cols = self.shape
   458|         0|            0|            0|  0.00%|        if k <= -rows or k >= cols:
   459|         0|            0|            0|  0.00%|            return np.empty(0, dtype=self.data.dtype)
   460|         0|            0|            0|  0.00%|        diag = np.zeros(min(rows + min(k, 0), cols - max(k, 0)),
   461|         0|            0|            0|  0.00%|                        dtype=self.dtype)
   462|         0|            0|            0|  0.00%|        diag_mask = (self.row + k) == self.col
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|        if self.has_canonical_format:
   465|         0|            0|            0|  0.00%|            row = self.row[diag_mask]
   466|         0|            0|            0|  0.00%|            data = self.data[diag_mask]
   467|         0|            0|            0|  0.00%|        else:
   468|         0|            0|            0|  0.00%|            row, _, data = self._sum_duplicates(self.row[diag_mask],
   469|         0|            0|            0|  0.00%|                                                self.col[diag_mask],
   470|         0|            0|            0|  0.00%|                                                self.data[diag_mask])
   471|         0|            0|            0|  0.00%|        diag[row + min(k, 0)] = data
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|        return diag
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|    diagonal.__doc__ = _data_matrix.diagonal.__doc__
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|    def _setdiag(self, values, k):
   478|         0|            0|            0|  0.00%|        M, N = self.shape
   479|         0|            0|            0|  0.00%|        if values.ndim and not len(values):
   480|         0|            0|            0|  0.00%|            return
   481|         0|            0|            0|  0.00%|        idx_dtype = self.row.dtype
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|        # Determine which triples to keep and where to put the new ones.
   484|         0|            0|            0|  0.00%|        full_keep = self.col - self.row != k
   485|         0|            0|            0|  0.00%|        if k < 0:
   486|         0|            0|            0|  0.00%|            max_index = min(M+k, N)
   487|         0|            0|            0|  0.00%|            if values.ndim:
   488|         0|            0|            0|  0.00%|                max_index = min(max_index, len(values))
   489|         0|            0|            0|  0.00%|            keep = np.logical_or(full_keep, self.col >= max_index)
   490|         0|            0|            0|  0.00%|            new_row = np.arange(-k, -k + max_index, dtype=idx_dtype)
   491|         0|            0|            0|  0.00%|            new_col = np.arange(max_index, dtype=idx_dtype)
   492|         0|            0|            0|  0.00%|        else:
   493|         0|            0|            0|  0.00%|            max_index = min(M, N-k)
   494|         0|            0|            0|  0.00%|            if values.ndim:
   495|         0|            0|            0|  0.00%|                max_index = min(max_index, len(values))
   496|         0|            0|            0|  0.00%|            keep = np.logical_or(full_keep, self.row >= max_index)
   497|         0|            0|            0|  0.00%|            new_row = np.arange(max_index, dtype=idx_dtype)
   498|         0|            0|            0|  0.00%|            new_col = np.arange(k, k + max_index, dtype=idx_dtype)
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|        # Define the array of data consisting of the entries to be added.
   501|         0|            0|            0|  0.00%|        if values.ndim:
   502|         0|            0|            0|  0.00%|            new_data = values[:max_index]
   503|         0|            0|            0|  0.00%|        else:
   504|         0|            0|            0|  0.00%|            new_data = np.empty(max_index, dtype=self.dtype)
   505|         0|            0|            0|  0.00%|            new_data[:] = values
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|        # Update the internal structure.
   508|         0|            0|            0|  0.00%|        self.row = np.concatenate((self.row[keep], new_row))
   509|         0|            0|            0|  0.00%|        self.col = np.concatenate((self.col[keep], new_col))
   510|         0|            0|            0|  0.00%|        self.data = np.concatenate((self.data[keep], new_data))
   511|         0|            0|            0|  0.00%|        self.has_canonical_format = False
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|    # needed by _data_matrix
   514|         0|            0|            0|  0.00%|    def _with_data(self,data,copy=True):
   515|         0|            0|            0|  0.00%|        """Returns a matrix with the same sparsity structure as self,
   516|         0|            0|            0|  0.00%|        but with different data.  By default the index arrays
   517|         0|            0|            0|  0.00%|        (i.e. .row and .col) are copied.
   518|         0|            0|            0|  0.00%|        """
   519|         0|            0|            0|  0.00%|        if copy:
   520|         0|            0|            0|  0.00%|            return coo_matrix((data, (self.row.copy(), self.col.copy())),
   521|         0|            0|            0|  0.00%|                                   shape=self.shape, dtype=data.dtype)
   522|         0|            0|            0|  0.00%|        else:
   523|         0|            0|            0|  0.00%|            return coo_matrix((data, (self.row, self.col)),
   524|         0|            0|            0|  0.00%|                                   shape=self.shape, dtype=data.dtype)
   525|         0|            0|            0|  0.00%|
   526|         4|            0|            0|  0.00%|    def sum_duplicates(self):
   527|         0|            0|            0|  0.00%|        """Eliminate duplicate matrix entries by adding them together
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|        This is an *in place* operation
   530|         0|            0|            0|  0.00%|        """
   531|         4|            0|            0|  0.00%|        if self.has_canonical_format:
   532|         0|            0|            0|  0.00%|            return
   533|         4|            0|            0|  0.00%|        summed = self._sum_duplicates(self.row, self.col, self.data)
(call)|         4|   0.00199389|  0.000498474|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:537 _sum_duplicates
   534|         4|            0|            0|  0.00%|        self.row, self.col, self.data = summed
   535|         4|            0|            0|  0.00%|        self.has_canonical_format = True
   536|         0|            0|            0|  0.00%|
   537|         4|            0|            0|  0.00%|    def _sum_duplicates(self, row, col, data):
   538|         0|            0|            0|  0.00%|        # Assumes (data, row, col) not in canonical format.
   539|         4|            0|            0|  0.00%|        if len(data) == 0:
   540|         0|            0|            0|  0.00%|            return row, col, data
   541|         4|  0.000997543|  0.000249386|  0.00%|        order = np.lexsort((row, col))
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 lexsort
   542|         4|            0|            0|  0.00%|        row = row[order]
   543|         4|            0|            0|  0.00%|        col = col[order]
   544|         4|            0|            0|  0.00%|        data = data[order]
   545|         8|  0.000996351|  0.000124544|  0.00%|        unique_mask = ((row[1:] != row[:-1]) |
   546|         4|            0|            0|  0.00%|                       (col[1:] != col[:-1]))
   547|         4|            0|            0|  0.00%|        unique_mask = np.append(True, unique_mask)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 append
   548|         4|            0|            0|  0.00%|        row = row[unique_mask]
   549|         4|            0|            0|  0.00%|        col = col[unique_mask]
   550|         4|            0|            0|  0.00%|        unique_inds, = np.nonzero(unique_mask)
(call)|         4|            0|            0|  0.00%|# <__array_function__ internals>:177 nonzero
   551|         4|            0|            0|  0.00%|        data = np.add.reduceat(data, unique_inds, dtype=self.dtype)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
   552|         4|            0|            0|  0.00%|        return row, col, data
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|    def eliminate_zeros(self):
   555|         0|            0|            0|  0.00%|        """Remove zero entries from the matrix
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|        This is an *in place* operation
   558|         0|            0|            0|  0.00%|        """
   559|         0|            0|            0|  0.00%|        mask = self.data != 0
   560|         0|            0|            0|  0.00%|        self.data = self.data[mask]
   561|         0|            0|            0|  0.00%|        self.row = self.row[mask]
   562|         0|            0|            0|  0.00%|        self.col = self.col[mask]
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|    #######################
   565|         0|            0|            0|  0.00%|    # Arithmetic handlers #
   566|         0|            0|            0|  0.00%|    #######################
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    def _add_dense(self, other):
   569|         0|            0|            0|  0.00%|        if other.shape != self.shape:
   570|         0|            0|            0|  0.00%|            raise ValueError('Incompatible shapes ({} and {})'
   571|         0|            0|            0|  0.00%|                             .format(self.shape, other.shape))
   572|         0|            0|            0|  0.00%|        dtype = upcast_char(self.dtype.char, other.dtype.char)
   573|         0|            0|            0|  0.00%|        result = np.array(other, dtype=dtype, copy=True)
   574|         0|            0|            0|  0.00%|        fortran = int(result.flags.f_contiguous)
   575|         0|            0|            0|  0.00%|        M, N = self.shape
   576|         0|            0|            0|  0.00%|        coo_todense(M, N, self.nnz, self.row, self.col, self.data,
   577|         0|            0|            0|  0.00%|                    result.ravel('A'), fortran)
   578|         0|            0|            0|  0.00%|        return matrix(result, copy=False)
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|    def _mul_vector(self, other):
   581|         0|            0|            0|  0.00%|        #output array
   582|         0|            0|            0|  0.00%|        result = np.zeros(self.shape[0], dtype=upcast_char(self.dtype.char,
   583|         0|            0|            0|  0.00%|                                                            other.dtype.char))
   584|         0|            0|            0|  0.00%|        coo_matvec(self.nnz, self.row, self.col, self.data, other, result)
   585|         0|            0|            0|  0.00%|        return result
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    def _mul_multivector(self, other):
   588|         0|            0|            0|  0.00%|        result = np.zeros((other.shape[1], self.shape[0]),
   589|         0|            0|            0|  0.00%|                          dtype=upcast_char(self.dtype.char, other.dtype.char))
   590|         0|            0|            0|  0.00%|        for i, col in enumerate(other.T):
   591|         0|            0|            0|  0.00%|            coo_matvec(self.nnz, self.row, self.col, self.data, col, result[i])
   592|         0|            0|            0|  0.00%|        return result.T.view(type=type(other))
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|
   595|         4|            0|            0|  0.00%|def isspmatrix_coo(x):
   596|         0|            0|            0|  0.00%|    """Is x of coo_matrix type?
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|    Parameters
   599|         0|            0|            0|  0.00%|    ----------
   600|         0|            0|            0|  0.00%|    x
   601|         0|            0|            0|  0.00%|        object to check for being a coo matrix
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|    Returns
   604|         0|            0|            0|  0.00%|    -------
   605|         0|            0|            0|  0.00%|    bool
   606|         0|            0|            0|  0.00%|        True if x is a coo matrix, False otherwise
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|    Examples
   609|         0|            0|            0|  0.00%|    --------
   610|         0|            0|            0|  0.00%|    >>> from scipy.sparse import coo_matrix, isspmatrix_coo
   611|         0|            0|            0|  0.00%|    >>> isspmatrix_coo(coo_matrix([[5]]))
   612|         0|            0|            0|  0.00%|    True
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|    >>> from scipy.sparse import coo_matrix, csr_matrix, isspmatrix_coo
   615|         0|            0|            0|  0.00%|    >>> isspmatrix_coo(csr_matrix([[5]]))
   616|         0|            0|            0|  0.00%|    False
   617|         0|            0|            0|  0.00%|    """
   618|         4|            0|            0|  0.00%|    return isinstance(x, coo_matrix)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\_compression.py
File duration: 0.0010438s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Internal classes used by the gzip, lzma and bz2 modules"""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import io
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|BUFFER_SIZE = io.DEFAULT_BUFFER_SIZE  # Compressed data read chunk size
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|class BaseStream(io.BufferedIOBase):
    10|         0|            0|            0|  0.00%|    """Mode-checking helper functions."""
    11|         0|            0|            0|  0.00%|
    12|       121|    4.673e-05|  3.86199e-07|  0.00%|    def _check_not_closed(self):
    13|       121|  0.000997066|  8.24022e-06|  0.00%|        if self.closed:
(call)|       121|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\gzip.py:308 closed
    14|         0|            0|            0|  0.00%|            raise ValueError("I/O operation on closed file")
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|    def _check_can_read(self):
    17|         0|            0|            0|  0.00%|        if not self.readable():
    18|         0|            0|            0|  0.00%|            raise io.UnsupportedOperation("File not open for reading")
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|    def _check_can_write(self):
    21|         0|            0|            0|  0.00%|        if not self.writable():
    22|         0|            0|            0|  0.00%|            raise io.UnsupportedOperation("File not open for writing")
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|    def _check_can_seek(self):
    25|         0|            0|            0|  0.00%|        if not self.readable():
    26|         0|            0|            0|  0.00%|            raise io.UnsupportedOperation("Seeking is only supported "
    27|         0|            0|            0|  0.00%|                                          "on files open for reading")
    28|         0|            0|            0|  0.00%|        if not self.seekable():
    29|         0|            0|            0|  0.00%|            raise io.UnsupportedOperation("The underlying file object "
    30|         0|            0|            0|  0.00%|                                          "does not support seeking")
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|class DecompressReader(io.RawIOBase):
    34|         0|            0|            0|  0.00%|    """Adapts the decompressor API to a RawIOBase reader API"""
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    def readable(self):
    37|         0|            0|            0|  0.00%|        return True
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    def __init__(self, fp, decomp_factory, trailing_error=(), **decomp_args):
    40|         0|            0|            0|  0.00%|        self._fp = fp
    41|         0|            0|            0|  0.00%|        self._eof = False
    42|         0|            0|            0|  0.00%|        self._pos = 0  # Current offset in decompressed stream
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|        # Set to size of decompressed stream once it is known, for SEEK_END
    45|         0|            0|            0|  0.00%|        self._size = -1
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|        # Save the decompressor factory and arguments.
    48|         0|            0|            0|  0.00%|        # If the file contains multiple compressed streams, each
    49|         0|            0|            0|  0.00%|        # stream will need a separate decompressor object. A new decompressor
    50|         0|            0|            0|  0.00%|        # object is also needed when implementing a backwards seek().
    51|         0|            0|            0|  0.00%|        self._decomp_factory = decomp_factory
    52|         0|            0|            0|  0.00%|        self._decomp_args = decomp_args
    53|         0|            0|            0|  0.00%|        self._decompressor = self._decomp_factory(**self._decomp_args)
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|        # Exception class to catch from decompressor signifying invalid
    56|         0|            0|            0|  0.00%|        # trailing data to ignore
    57|         0|            0|            0|  0.00%|        self._trailing_error = trailing_error
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|    def close(self):
    60|         0|            0|            0|  0.00%|        self._decompressor = None
    61|         0|            0|            0|  0.00%|        return super().close()
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    def seekable(self):
    64|         0|            0|            0|  0.00%|        return self._fp.seekable()
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    def readinto(self, b):
    67|         0|            0|            0|  0.00%|        with memoryview(b) as view, view.cast("B") as byte_view:
    68|         0|            0|            0|  0.00%|            data = self.read(len(byte_view))
    69|         0|            0|            0|  0.00%|            byte_view[:len(data)] = data
    70|         0|            0|            0|  0.00%|        return len(data)
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|    def read(self, size=-1):
    73|         0|            0|            0|  0.00%|        if size < 0:
    74|         0|            0|            0|  0.00%|            return self.readall()
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|        if not size or self._eof:
    77|         0|            0|            0|  0.00%|            return b""
    78|         0|            0|            0|  0.00%|        data = None  # Default if EOF is encountered
    79|         0|            0|            0|  0.00%|        # Depending on the input data, our call to the decompressor may not
    80|         0|            0|            0|  0.00%|        # return any data. In this case, try again after reading another block.
    81|         0|            0|            0|  0.00%|        while True:
    82|         0|            0|            0|  0.00%|            if self._decompressor.eof:
    83|         0|            0|            0|  0.00%|                rawblock = (self._decompressor.unused_data or
    84|         0|            0|            0|  0.00%|                            self._fp.read(BUFFER_SIZE))
    85|         0|            0|            0|  0.00%|                if not rawblock:
    86|         0|            0|            0|  0.00%|                    break
    87|         0|            0|            0|  0.00%|                # Continue to next stream.
    88|         0|            0|            0|  0.00%|                self._decompressor = self._decomp_factory(
    89|         0|            0|            0|  0.00%|                    **self._decomp_args)
    90|         0|            0|            0|  0.00%|                try:
    91|         0|            0|            0|  0.00%|                    data = self._decompressor.decompress(rawblock, size)
    92|         0|            0|            0|  0.00%|                except self._trailing_error:
    93|         0|            0|            0|  0.00%|                    # Trailing data isn't a valid compressed stream; ignore it.
    94|         0|            0|            0|  0.00%|                    break
    95|         0|            0|            0|  0.00%|            else:
    96|         0|            0|            0|  0.00%|                if self._decompressor.needs_input:
    97|         0|            0|            0|  0.00%|                    rawblock = self._fp.read(BUFFER_SIZE)
    98|         0|            0|            0|  0.00%|                    if not rawblock:
    99|         0|            0|            0|  0.00%|                        raise EOFError("Compressed file ended before the "
   100|         0|            0|            0|  0.00%|                                       "end-of-stream marker was reached")
   101|         0|            0|            0|  0.00%|                else:
   102|         0|            0|            0|  0.00%|                    rawblock = b""
   103|         0|            0|            0|  0.00%|                data = self._decompressor.decompress(rawblock, size)
   104|         0|            0|            0|  0.00%|            if data:
   105|         0|            0|            0|  0.00%|                break
   106|         0|            0|            0|  0.00%|        if not data:
   107|         0|            0|            0|  0.00%|            self._eof = True
   108|         0|            0|            0|  0.00%|            self._size = self._pos
   109|         0|            0|            0|  0.00%|            return b""
   110|         0|            0|            0|  0.00%|        self._pos += len(data)
   111|         0|            0|            0|  0.00%|        return data
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    # Rewind the file to the beginning of the data stream.
   114|         0|            0|            0|  0.00%|    def _rewind(self):
   115|         0|            0|            0|  0.00%|        self._fp.seek(0)
   116|         0|            0|            0|  0.00%|        self._eof = False
   117|         0|            0|            0|  0.00%|        self._pos = 0
   118|         0|            0|            0|  0.00%|        self._decompressor = self._decomp_factory(**self._decomp_args)
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    def seek(self, offset, whence=io.SEEK_SET):
   121|         0|            0|            0|  0.00%|        # Recalculate offset as an absolute file position.
   122|         0|            0|            0|  0.00%|        if whence == io.SEEK_SET:
   123|         0|            0|            0|  0.00%|            pass
   124|         0|            0|            0|  0.00%|        elif whence == io.SEEK_CUR:
   125|         0|            0|            0|  0.00%|            offset = self._pos + offset
   126|         0|            0|            0|  0.00%|        elif whence == io.SEEK_END:
   127|         0|            0|            0|  0.00%|            # Seeking relative to EOF - we need to know the file's size.
   128|         0|            0|            0|  0.00%|            if self._size < 0:
   129|         0|            0|            0|  0.00%|                while self.read(io.DEFAULT_BUFFER_SIZE):
   130|         0|            0|            0|  0.00%|                    pass
   131|         0|            0|            0|  0.00%|            offset = self._size + offset
   132|         0|            0|            0|  0.00%|        else:
   133|         0|            0|            0|  0.00%|            raise ValueError("Invalid value for whence: {}".format(whence))
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|        # Make it so that offset is the number of bytes to skip forward.
   136|         0|            0|            0|  0.00%|        if offset < self._pos:
   137|         0|            0|            0|  0.00%|            self._rewind()
   138|         0|            0|            0|  0.00%|        else:
   139|         0|            0|            0|  0.00%|            offset -= self._pos
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|        # Read and discard data until we reach the desired position.
   142|         0|            0|            0|  0.00%|        while offset > 0:
   143|         0|            0|            0|  0.00%|            data = self.read(min(io.DEFAULT_BUFFER_SIZE, offset))
   144|         0|            0|            0|  0.00%|            if not data:
   145|         0|            0|            0|  0.00%|                break
   146|         0|            0|            0|  0.00%|            offset -= len(data)
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|        return self._pos
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    def tell(self):
   151|         0|            0|            0|  0.00%|        """Return the current file position."""
   152|         0|            0|            0|  0.00%|        return self._pos
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py
File duration: 0.00099802s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Array methods which are called by both the C-code for the method
     3|         0|            0|            0|  0.00%|and the Python code for the NumPy-namespace function
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|import warnings
     7|         0|            0|            0|  0.00%|from contextlib import nullcontext
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from numpy.core import multiarray as mu
    10|         0|            0|            0|  0.00%|from numpy.core import umath as um
    11|         0|            0|            0|  0.00%|from numpy.core.multiarray import asanyarray
    12|         0|            0|            0|  0.00%|from numpy.core import numerictypes as nt
    13|         0|            0|            0|  0.00%|from numpy.core import _exceptions
    14|         0|            0|            0|  0.00%|from numpy._globals import _NoValue
    15|         0|            0|            0|  0.00%|from numpy.compat import pickle, os_fspath
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|# save those O(100) nanoseconds!
    18|         0|            0|            0|  0.00%|umr_maximum = um.maximum.reduce
    19|         0|            0|            0|  0.00%|umr_minimum = um.minimum.reduce
    20|         0|            0|            0|  0.00%|umr_sum = um.add.reduce
    21|         0|            0|            0|  0.00%|umr_prod = um.multiply.reduce
    22|         0|            0|            0|  0.00%|umr_any = um.logical_or.reduce
    23|         0|            0|            0|  0.00%|umr_all = um.logical_and.reduce
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|# Complex types to -> (2,)float view for fast-path computation in _var()
    26|         0|            0|            0|  0.00%|_complex_to_float = {
    27|         0|            0|            0|  0.00%|    nt.dtype(nt.csingle) : nt.dtype(nt.single),
    28|         0|            0|            0|  0.00%|    nt.dtype(nt.cdouble) : nt.dtype(nt.double),
    29|         0|            0|            0|  0.00%|}
    30|         0|            0|            0|  0.00%|# Special case for windows: ensure double takes precedence
    31|         0|            0|            0|  0.00%|if nt.dtype(nt.longdouble) != nt.dtype(nt.double):
    32|         0|            0|            0|  0.00%|    _complex_to_float.update({
    33|         0|            0|            0|  0.00%|        nt.dtype(nt.clongdouble) : nt.dtype(nt.longdouble),
    34|         0|            0|            0|  0.00%|    })
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|# avoid keyword arguments to speed up parsing, saves about 15%-20% for very
    37|         0|            0|            0|  0.00%|# small reductions
    38|        24|            0|            0|  0.00%|def _amax(a, axis=None, out=None, keepdims=False,
    39|         0|            0|            0|  0.00%|          initial=_NoValue, where=True):
    40|        24|            0|            0|  0.00%|    return umr_maximum(a, axis, None, out, keepdims, initial, where)
    41|         0|            0|            0|  0.00%|
    42|        24|            0|            0|  0.00%|def _amin(a, axis=None, out=None, keepdims=False,
    43|         0|            0|            0|  0.00%|          initial=_NoValue, where=True):
    44|        24|            0|            0|  0.00%|    return umr_minimum(a, axis, None, out, keepdims, initial, where)
    45|         0|            0|            0|  0.00%|
    46|        24|            0|            0|  0.00%|def _sum(a, axis=None, dtype=None, out=None, keepdims=False,
    47|         0|            0|            0|  0.00%|         initial=_NoValue, where=True):
    48|        24|   0.00099802|  4.15842e-05|  0.00%|    return umr_sum(a, axis, dtype, out, keepdims, initial, where)
(call)|        12|  0.000997305|  8.31087e-05|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\matrixlib\defmatrix.py:167 __array_finalize__
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|def _prod(a, axis=None, dtype=None, out=None, keepdims=False,
    51|         0|            0|            0|  0.00%|          initial=_NoValue, where=True):
    52|         0|            0|            0|  0.00%|    return umr_prod(a, axis, dtype, out, keepdims, initial, where)
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|def _any(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
    55|         0|            0|            0|  0.00%|    # Parsing keyword arguments is currently fairly slow, so avoid it for now
    56|         0|            0|            0|  0.00%|    if where is True:
    57|         0|            0|            0|  0.00%|        return umr_any(a, axis, dtype, out, keepdims)
    58|         0|            0|            0|  0.00%|    return umr_any(a, axis, dtype, out, keepdims, where=where)
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|def _all(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
    61|         0|            0|            0|  0.00%|    # Parsing keyword arguments is currently fairly slow, so avoid it for now
    62|         0|            0|            0|  0.00%|    if where is True:
    63|         0|            0|            0|  0.00%|        return umr_all(a, axis, dtype, out, keepdims)
    64|         0|            0|            0|  0.00%|    return umr_all(a, axis, dtype, out, keepdims, where=where)
    65|         0|            0|            0|  0.00%|
    66|         4|            0|            0|  0.00%|def _count_reduce_items(arr, axis, keepdims=False, where=True):
    67|         0|            0|            0|  0.00%|    # fast-path for the default case
    68|         4|            0|            0|  0.00%|    if where is True:
    69|         0|            0|            0|  0.00%|        # no boolean mask given, calculate items according to axis
    70|         4|            0|            0|  0.00%|        if axis is None:
    71|         4|            0|            0|  0.00%|            axis = tuple(range(arr.ndim))
    72|         0|            0|            0|  0.00%|        elif not isinstance(axis, tuple):
    73|         0|            0|            0|  0.00%|            axis = (axis,)
    74|         4|            0|            0|  0.00%|        items = nt.intp(1)
    75|         8|            0|            0|  0.00%|        for ax in axis:
    76|         4|            0|            0|  0.00%|            items *= arr.shape[mu.normalize_axis_index(ax, arr.ndim)]
    77|         0|            0|            0|  0.00%|    else:
    78|         0|            0|            0|  0.00%|        # TODO: Optimize case when `where` is broadcast along a non-reduction
    79|         0|            0|            0|  0.00%|        # axis and full sum is more excessive than needed.
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|        # guarded to protect circular imports
    82|         0|            0|            0|  0.00%|        from numpy.lib.stride_tricks import broadcast_to
    83|         0|            0|            0|  0.00%|        # count True values in (potentially broadcasted) boolean mask
    84|         0|            0|            0|  0.00%|        items = umr_sum(broadcast_to(where, arr.shape), axis, nt.intp, None,
    85|         0|            0|            0|  0.00%|                        keepdims)
    86|         4|            0|            0|  0.00%|    return items
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|# Numpy 1.17.0, 2019-02-24
    89|         0|            0|            0|  0.00%|# Various clip behavior deprecations, marked with _clip_dep as a prefix.
    90|         0|            0|            0|  0.00%|
    91|         8|            0|            0|  0.00%|def _clip_dep_is_scalar_nan(a):
    92|         0|            0|            0|  0.00%|    # guarded to protect circular imports
    93|         8|            0|            0|  0.00%|    from numpy.core.fromnumeric import ndim
    94|         8|            0|            0|  0.00%|    if ndim(a) != 0:
(call)|         8|            0|            0|  0.00%|# <__array_function__ internals>:177 ndim
    95|         0|            0|            0|  0.00%|        return False
    96|         8|            0|            0|  0.00%|    try:
    97|         8|            0|            0|  0.00%|        return um.isnan(a)
    98|         4|            0|            0|  0.00%|    except TypeError:
    99|         4|            0|            0|  0.00%|        return False
   100|         0|            0|            0|  0.00%|
   101|         8|            0|            0|  0.00%|def _clip_dep_is_byte_swapped(a):
   102|         8|            0|            0|  0.00%|    if isinstance(a, mu.ndarray):
   103|         4|            0|            0|  0.00%|        return not a.dtype.isnative
   104|         4|            0|            0|  0.00%|    return False
   105|         0|            0|            0|  0.00%|
   106|         4|            0|            0|  0.00%|def _clip_dep_invoke_with_casting(ufunc, *args, out=None, casting=None, **kwargs):
   107|         0|            0|            0|  0.00%|    # normal path
   108|         4|            0|            0|  0.00%|    if casting is not None:
   109|         0|            0|            0|  0.00%|        return ufunc(*args, out=out, casting=casting, **kwargs)
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    # try to deal with broken casting rules
   112|         4|            0|            0|  0.00%|    try:
   113|         4|            0|            0|  0.00%|        return ufunc(*args, out=out, **kwargs)
   114|         0|            0|            0|  0.00%|    except _exceptions._UFuncOutputCastingError as e:
   115|         0|            0|            0|  0.00%|        # Numpy 1.17.0, 2019-02-24
   116|         0|            0|            0|  0.00%|        warnings.warn(
   117|         0|            0|            0|  0.00%|            "Converting the output of clip from {!r} to {!r} is deprecated. "
   118|         0|            0|            0|  0.00%|            "Pass `casting=\"unsafe\"` explicitly to silence this warning, or "
   119|         0|            0|            0|  0.00%|            "correct the type of the variables.".format(e.from_, e.to),
   120|         0|            0|            0|  0.00%|            DeprecationWarning,
   121|         0|            0|            0|  0.00%|            stacklevel=2
   122|         0|            0|            0|  0.00%|        )
   123|         0|            0|            0|  0.00%|        return ufunc(*args, out=out, casting="unsafe", **kwargs)
   124|         0|            0|            0|  0.00%|
   125|         4|            0|            0|  0.00%|def _clip(a, min=None, max=None, out=None, *, casting=None, **kwargs):
   126|         4|            0|            0|  0.00%|    if min is None and max is None:
   127|         0|            0|            0|  0.00%|        raise ValueError("One of max or min must be given")
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    # Numpy 1.17.0, 2019-02-24
   130|         0|            0|            0|  0.00%|    # This deprecation probably incurs a substantial slowdown for small arrays,
   131|         0|            0|            0|  0.00%|    # it will be good to get rid of it.
   132|         4|            0|            0|  0.00%|    if not _clip_dep_is_byte_swapped(a) and not _clip_dep_is_byte_swapped(out):
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:101 _clip_dep_is_byte_swapped
   133|         4|            0|            0|  0.00%|        using_deprecated_nan = False
   134|         4|            0|            0|  0.00%|        if _clip_dep_is_scalar_nan(min):
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:91 _clip_dep_is_scalar_nan
   135|         0|            0|            0|  0.00%|            min = -float('inf')
   136|         0|            0|            0|  0.00%|            using_deprecated_nan = True
   137|         4|            0|            0|  0.00%|        if _clip_dep_is_scalar_nan(max):
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:91 _clip_dep_is_scalar_nan
   138|         0|            0|            0|  0.00%|            max = float('inf')
   139|         0|            0|            0|  0.00%|            using_deprecated_nan = True
   140|         4|            0|            0|  0.00%|        if using_deprecated_nan:
   141|         0|            0|            0|  0.00%|            warnings.warn(
   142|         0|            0|            0|  0.00%|                "Passing `np.nan` to mean no clipping in np.clip has always "
   143|         0|            0|            0|  0.00%|                "been unreliable, and is now deprecated. "
   144|         0|            0|            0|  0.00%|                "In future, this will always return nan, like it already does "
   145|         0|            0|            0|  0.00%|                "when min or max are arrays that contain nan. "
   146|         0|            0|            0|  0.00%|                "To skip a bound, pass either None or an np.inf of an "
   147|         0|            0|            0|  0.00%|                "appropriate sign.",
   148|         0|            0|            0|  0.00%|                DeprecationWarning,
   149|         0|            0|            0|  0.00%|                stacklevel=2
   150|         0|            0|            0|  0.00%|            )
   151|         0|            0|            0|  0.00%|
   152|         4|            0|            0|  0.00%|    if min is None:
   153|         0|            0|            0|  0.00%|        return _clip_dep_invoke_with_casting(
   154|         0|            0|            0|  0.00%|            um.minimum, a, max, out=out, casting=casting, **kwargs)
   155|         4|            0|            0|  0.00%|    elif max is None:
   156|        16|            0|            0|  0.00%|        return _clip_dep_invoke_with_casting(
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:106 _clip_dep_invoke_with_casting
   157|        12|            0|            0|  0.00%|            um.maximum, a, min, out=out, casting=casting, **kwargs)
   158|         0|            0|            0|  0.00%|    else:
   159|         0|            0|            0|  0.00%|        return _clip_dep_invoke_with_casting(
   160|         0|            0|            0|  0.00%|            um.clip, a, min, max, out=out, casting=casting, **kwargs)
   161|         0|            0|            0|  0.00%|
   162|         4|            0|            0|  0.00%|def _mean(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
   163|         4|            0|            0|  0.00%|    arr = asanyarray(a)
   164|         0|            0|            0|  0.00%|
   165|         4|            0|            0|  0.00%|    is_float16_result = False
   166|         0|            0|            0|  0.00%|
   167|         4|            0|            0|  0.00%|    rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\numpy\core\_methods.py:66 _count_reduce_items
   168|         4|            0|            0|  0.00%|    if rcount == 0 if where is True else umr_any(rcount == 0, axis=None):
   169|         0|            0|            0|  0.00%|        warnings.warn("Mean of empty slice.", RuntimeWarning, stacklevel=2)
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    # Cast bool, unsigned int, and int to float64 by default
   172|         4|            0|            0|  0.00%|    if dtype is None:
   173|         4|            0|            0|  0.00%|        if issubclass(arr.dtype.type, (nt.integer, nt.bool_)):
   174|         0|            0|            0|  0.00%|            dtype = mu.dtype('f8')
   175|         4|            0|            0|  0.00%|        elif issubclass(arr.dtype.type, nt.float16):
   176|         0|            0|            0|  0.00%|            dtype = mu.dtype('f4')
   177|         0|            0|            0|  0.00%|            is_float16_result = True
   178|         0|            0|            0|  0.00%|
   179|         4|            0|            0|  0.00%|    ret = umr_sum(arr, axis, dtype, out, keepdims, where=where)
   180|         4|            0|            0|  0.00%|    if isinstance(ret, mu.ndarray):
   181|         0|            0|            0|  0.00%|        ret = um.true_divide(
   182|         0|            0|            0|  0.00%|                ret, rcount, out=ret, casting='unsafe', subok=False)
   183|         0|            0|            0|  0.00%|        if is_float16_result and out is None:
   184|         0|            0|            0|  0.00%|            ret = arr.dtype.type(ret)
   185|         4|            0|            0|  0.00%|    elif hasattr(ret, 'dtype'):
   186|         4|            0|            0|  0.00%|        if is_float16_result:
   187|         0|            0|            0|  0.00%|            ret = arr.dtype.type(ret / rcount)
   188|         0|            0|            0|  0.00%|        else:
   189|         4|            0|            0|  0.00%|            ret = ret.dtype.type(ret / rcount)
   190|         0|            0|            0|  0.00%|    else:
   191|         0|            0|            0|  0.00%|        ret = ret / rcount
   192|         0|            0|            0|  0.00%|
   193|         4|            0|            0|  0.00%|    return ret
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|def _var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *,
   196|         0|            0|            0|  0.00%|         where=True):
   197|         0|            0|            0|  0.00%|    arr = asanyarray(a)
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)
   200|         0|            0|            0|  0.00%|    # Make this warning show up on top.
   201|         0|            0|            0|  0.00%|    if ddof >= rcount if where is True else umr_any(ddof >= rcount, axis=None):
   202|         0|            0|            0|  0.00%|        warnings.warn("Degrees of freedom <= 0 for slice", RuntimeWarning,
   203|         0|            0|            0|  0.00%|                      stacklevel=2)
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|    # Cast bool, unsigned int, and int to float64 by default
   206|         0|            0|            0|  0.00%|    if dtype is None and issubclass(arr.dtype.type, (nt.integer, nt.bool_)):
   207|         0|            0|            0|  0.00%|        dtype = mu.dtype('f8')
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    # Compute the mean.
   210|         0|            0|            0|  0.00%|    # Note that if dtype is not of inexact type then arraymean will
   211|         0|            0|            0|  0.00%|    # not be either.
   212|         0|            0|            0|  0.00%|    arrmean = umr_sum(arr, axis, dtype, keepdims=True, where=where)
   213|         0|            0|            0|  0.00%|    # The shape of rcount has to match arrmean to not change the shape of out
   214|         0|            0|            0|  0.00%|    # in broadcasting. Otherwise, it cannot be stored back to arrmean.
   215|         0|            0|            0|  0.00%|    if rcount.ndim == 0:
   216|         0|            0|            0|  0.00%|        # fast-path for default case when where is True
   217|         0|            0|            0|  0.00%|        div = rcount
   218|         0|            0|            0|  0.00%|    else:
   219|         0|            0|            0|  0.00%|        # matching rcount to arrmean when where is specified as array
   220|         0|            0|            0|  0.00%|        div = rcount.reshape(arrmean.shape)
   221|         0|            0|            0|  0.00%|    if isinstance(arrmean, mu.ndarray):
   222|         0|            0|            0|  0.00%|        arrmean = um.true_divide(arrmean, div, out=arrmean, casting='unsafe',
   223|         0|            0|            0|  0.00%|                                 subok=False)
   224|         0|            0|            0|  0.00%|    elif hasattr(arrmean, "dtype"):
   225|         0|            0|            0|  0.00%|        arrmean = arrmean.dtype.type(arrmean / rcount)
   226|         0|            0|            0|  0.00%|    else:
   227|         0|            0|            0|  0.00%|        arrmean = arrmean / rcount
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|    # Compute sum of squared deviations from mean
   230|         0|            0|            0|  0.00%|    # Note that x may not be inexact and that we need it to be an array,
   231|         0|            0|            0|  0.00%|    # not a scalar.
   232|         0|            0|            0|  0.00%|    x = asanyarray(arr - arrmean)
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    if issubclass(arr.dtype.type, (nt.floating, nt.integer)):
   235|         0|            0|            0|  0.00%|        x = um.multiply(x, x, out=x)
   236|         0|            0|            0|  0.00%|    # Fast-paths for built-in complex types
   237|         0|            0|            0|  0.00%|    elif x.dtype in _complex_to_float:
   238|         0|            0|            0|  0.00%|        xv = x.view(dtype=(_complex_to_float[x.dtype], (2,)))
   239|         0|            0|            0|  0.00%|        um.multiply(xv, xv, out=xv)
   240|         0|            0|            0|  0.00%|        x = um.add(xv[..., 0], xv[..., 1], out=x.real).real
   241|         0|            0|            0|  0.00%|    # Most general case; includes handling object arrays containing imaginary
   242|         0|            0|            0|  0.00%|    # numbers and complex types with non-native byteorder
   243|         0|            0|            0|  0.00%|    else:
   244|         0|            0|            0|  0.00%|        x = um.multiply(x, um.conjugate(x), out=x).real
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|    ret = umr_sum(x, axis, dtype, out, keepdims=keepdims, where=where)
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    # Compute degrees of freedom and make sure it is not negative.
   249|         0|            0|            0|  0.00%|    rcount = um.maximum(rcount - ddof, 0)
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    # divide by degrees of freedom
   252|         0|            0|            0|  0.00%|    if isinstance(ret, mu.ndarray):
   253|         0|            0|            0|  0.00%|        ret = um.true_divide(
   254|         0|            0|            0|  0.00%|                ret, rcount, out=ret, casting='unsafe', subok=False)
   255|         0|            0|            0|  0.00%|    elif hasattr(ret, 'dtype'):
   256|         0|            0|            0|  0.00%|        ret = ret.dtype.type(ret / rcount)
   257|         0|            0|            0|  0.00%|    else:
   258|         0|            0|            0|  0.00%|        ret = ret / rcount
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|    return ret
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|def _std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *,
   263|         0|            0|            0|  0.00%|         where=True):
   264|         0|            0|            0|  0.00%|    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
   265|         0|            0|            0|  0.00%|               keepdims=keepdims, where=where)
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    if isinstance(ret, mu.ndarray):
   268|         0|            0|            0|  0.00%|        ret = um.sqrt(ret, out=ret)
   269|         0|            0|            0|  0.00%|    elif hasattr(ret, 'dtype'):
   270|         0|            0|            0|  0.00%|        ret = ret.dtype.type(um.sqrt(ret))
   271|         0|            0|            0|  0.00%|    else:
   272|         0|            0|            0|  0.00%|        ret = um.sqrt(ret)
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|    return ret
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|def _ptp(a, axis=None, out=None, keepdims=False):
   277|         0|            0|            0|  0.00%|    return um.subtract(
   278|         0|            0|            0|  0.00%|        umr_maximum(a, axis, None, out, keepdims),
   279|         0|            0|            0|  0.00%|        umr_minimum(a, axis, None, None, keepdims),
   280|         0|            0|            0|  0.00%|        out
   281|         0|            0|            0|  0.00%|    )
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|def _dump(self, file, protocol=2):
   284|         0|            0|            0|  0.00%|    if hasattr(file, 'write'):
   285|         0|            0|            0|  0.00%|        ctx = nullcontext(file)
   286|         0|            0|            0|  0.00%|    else:
   287|         0|            0|            0|  0.00%|        ctx = open(os_fspath(file), "wb")
   288|         0|            0|            0|  0.00%|    with ctx as f:
   289|         0|            0|            0|  0.00%|        pickle.dump(self, f, protocol=protocol)
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|def _dumps(self, protocol=2):
   292|         0|            0|            0|  0.00%|    return pickle.dumps(self, protocol=protocol)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\multiclass.py
File duration: 0.00099802s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi
     2|         0|            0|            0|  0.00%|#
     3|         0|            0|            0|  0.00%|# License: BSD 3 clause
     4|         0|            0|            0|  0.00%|"""
     5|         0|            0|            0|  0.00%|Multi-class / multi-label utility function
     6|         0|            0|            0|  0.00%|==========================================
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|"""
     9|         0|            0|            0|  0.00%|from collections.abc import Sequence
    10|         0|            0|            0|  0.00%|from itertools import chain
    11|         0|            0|            0|  0.00%|import warnings
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|from scipy.sparse import issparse
    14|         0|            0|            0|  0.00%|from scipy.sparse.base import spmatrix
    15|         0|            0|            0|  0.00%|from scipy.sparse import dok_matrix
    16|         0|            0|            0|  0.00%|from scipy.sparse import lil_matrix
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|import numpy as np
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|from .validation import check_array, _assert_all_finite
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|def _unique_multiclass(y):
    24|         0|            0|            0|  0.00%|    if hasattr(y, "__array__"):
    25|         0|            0|            0|  0.00%|        return np.unique(np.asarray(y))
    26|         0|            0|            0|  0.00%|    else:
    27|         0|            0|            0|  0.00%|        return set(y)
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|def _unique_indicator(y):
    31|         0|            0|            0|  0.00%|    return np.arange(check_array(y, accept_sparse=["csr", "csc", "coo"]).shape[1])
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|_FN_UNIQUE_LABELS = {
    35|         0|            0|            0|  0.00%|    "binary": _unique_multiclass,
    36|         0|            0|            0|  0.00%|    "multiclass": _unique_multiclass,
    37|         0|            0|            0|  0.00%|    "multilabel-indicator": _unique_indicator,
    38|         0|            0|            0|  0.00%|}
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|def unique_labels(*ys):
    42|         0|            0|            0|  0.00%|    """Extract an ordered array of unique labels.
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    We don't allow:
    45|         0|            0|            0|  0.00%|        - mix of multilabel and multiclass (single label) targets
    46|         0|            0|            0|  0.00%|        - mix of label indicator matrix and anything else,
    47|         0|            0|            0|  0.00%|          because there are no explicit labels)
    48|         0|            0|            0|  0.00%|        - mix of label indicator matrices of different sizes
    49|         0|            0|            0|  0.00%|        - mix of string and integer labels
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    At the moment, we also don't allow "multiclass-multioutput" input type.
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|    Parameters
    54|         0|            0|            0|  0.00%|    ----------
    55|         0|            0|            0|  0.00%|    *ys : array-likes
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    Returns
    58|         0|            0|            0|  0.00%|    -------
    59|         0|            0|            0|  0.00%|    out : ndarray of shape (n_unique_labels,)
    60|         0|            0|            0|  0.00%|        An ordered array of unique labels.
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    Examples
    63|         0|            0|            0|  0.00%|    --------
    64|         0|            0|            0|  0.00%|    >>> from sklearn.utils.multiclass import unique_labels
    65|         0|            0|            0|  0.00%|    >>> unique_labels([3, 5, 5, 5, 7, 7])
    66|         0|            0|            0|  0.00%|    array([3, 5, 7])
    67|         0|            0|            0|  0.00%|    >>> unique_labels([1, 2, 3, 4], [2, 2, 3, 4])
    68|         0|            0|            0|  0.00%|    array([1, 2, 3, 4])
    69|         0|            0|            0|  0.00%|    >>> unique_labels([1, 2, 10], [5, 11])
    70|         0|            0|            0|  0.00%|    array([ 1,  2,  5, 10, 11])
    71|         0|            0|            0|  0.00%|    """
    72|         0|            0|            0|  0.00%|    if not ys:
    73|         0|            0|            0|  0.00%|        raise ValueError("No argument has been passed.")
    74|         0|            0|            0|  0.00%|    # Check that we don't mix label format
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|    ys_types = set(type_of_target(x) for x in ys)
    77|         0|            0|            0|  0.00%|    if ys_types == {"binary", "multiclass"}:
    78|         0|            0|            0|  0.00%|        ys_types = {"multiclass"}
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|    if len(ys_types) > 1:
    81|         0|            0|            0|  0.00%|        raise ValueError("Mix type of y not allowed, got types %s" % ys_types)
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|    label_type = ys_types.pop()
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|    # Check consistency for the indicator format
    86|         0|            0|            0|  0.00%|    if (
    87|         0|            0|            0|  0.00%|        label_type == "multilabel-indicator"
    88|         0|            0|            0|  0.00%|        and len(
    89|         0|            0|            0|  0.00%|            set(
    90|         0|            0|            0|  0.00%|                check_array(y, accept_sparse=["csr", "csc", "coo"]).shape[1] for y in ys
    91|         0|            0|            0|  0.00%|            )
    92|         0|            0|            0|  0.00%|        )
    93|         0|            0|            0|  0.00%|        > 1
    94|         0|            0|            0|  0.00%|    ):
    95|         0|            0|            0|  0.00%|        raise ValueError(
    96|         0|            0|            0|  0.00%|            "Multi-label binary indicator input with different numbers of labels"
    97|         0|            0|            0|  0.00%|        )
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    # Get the unique set of labels
   100|         0|            0|            0|  0.00%|    _unique_labels = _FN_UNIQUE_LABELS.get(label_type, None)
   101|         0|            0|            0|  0.00%|    if not _unique_labels:
   102|         0|            0|            0|  0.00%|        raise ValueError("Unknown label type: %s" % repr(ys))
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    ys_labels = set(chain.from_iterable(_unique_labels(y) for y in ys))
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|    # Check that we don't mix string type with number type
   107|         0|            0|            0|  0.00%|    if len(set(isinstance(label, str) for label in ys_labels)) > 1:
   108|         0|            0|            0|  0.00%|        raise ValueError("Mix of label input types (string and number)")
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|    return np.array(sorted(ys_labels))
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|def _is_integral_float(y):
   114|         0|            0|            0|  0.00%|    return y.dtype.kind == "f" and np.all(y.astype(int) == y)
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         8|            0|            0|  0.00%|def is_multilabel(y):
   118|         0|            0|            0|  0.00%|    """Check if ``y`` is in a multilabel format.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    Parameters
   121|         0|            0|            0|  0.00%|    ----------
   122|         0|            0|            0|  0.00%|    y : ndarray of shape (n_samples,)
   123|         0|            0|            0|  0.00%|        Target values.
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    Returns
   126|         0|            0|            0|  0.00%|    -------
   127|         0|            0|            0|  0.00%|    out : bool
   128|         0|            0|            0|  0.00%|        Return ``True``, if ``y`` is in a multilabel format, else ```False``.
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|    Examples
   131|         0|            0|            0|  0.00%|    --------
   132|         0|            0|            0|  0.00%|    >>> import numpy as np
   133|         0|            0|            0|  0.00%|    >>> from sklearn.utils.multiclass import is_multilabel
   134|         0|            0|            0|  0.00%|    >>> is_multilabel([0, 1, 0, 1])
   135|         0|            0|            0|  0.00%|    False
   136|         0|            0|            0|  0.00%|    >>> is_multilabel([[1], [0, 2], []])
   137|         0|            0|            0|  0.00%|    False
   138|         0|            0|            0|  0.00%|    >>> is_multilabel(np.array([[1, 0], [0, 0]]))
   139|         0|            0|            0|  0.00%|    True
   140|         0|            0|            0|  0.00%|    >>> is_multilabel(np.array([[1], [0], [0]]))
   141|         0|            0|            0|  0.00%|    False
   142|         0|            0|            0|  0.00%|    >>> is_multilabel(np.array([[1, 0, 0]]))
   143|         0|            0|            0|  0.00%|    True
   144|         0|            0|            0|  0.00%|    """
   145|         8|            0|            0|  0.00%|    if hasattr(y, "__array__") or isinstance(y, Sequence):
   146|         0|            0|            0|  0.00%|        # DeprecationWarning will be replaced by ValueError, see NEP 34
   147|         0|            0|            0|  0.00%|        # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html
   148|         8|   0.00099802|  0.000124753|  0.00%|        with warnings.catch_warnings():
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:441 __init__
(call)|         8|  0.000997543|  0.000124693|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:462 __enter__
   149|         8|            0|            0|  0.00%|            warnings.simplefilter("error", np.VisibleDeprecationWarning)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:165 simplefilter
   150|         8|            0|            0|  0.00%|            try:
   151|         8|            0|            0|  0.00%|                y = np.asarray(y)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:481 __exit__
   152|         0|            0|            0|  0.00%|            except np.VisibleDeprecationWarning:
   153|         0|            0|            0|  0.00%|                # dtype=object should be provided explicitly for ragged arrays,
   154|         0|            0|            0|  0.00%|                # see NEP 34
   155|         0|            0|            0|  0.00%|                y = np.array(y, dtype=object)
   156|         0|            0|            0|  0.00%|
   157|         8|            0|            0|  0.00%|    if not (hasattr(y, "shape") and y.ndim == 2 and y.shape[1] > 1):
   158|         8|            0|            0|  0.00%|        return False
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|    if issparse(y):
   161|         0|            0|            0|  0.00%|        if isinstance(y, (dok_matrix, lil_matrix)):
   162|         0|            0|            0|  0.00%|            y = y.tocsr()
   163|         0|            0|            0|  0.00%|        return (
   164|         0|            0|            0|  0.00%|            len(y.data) == 0
   165|         0|            0|            0|  0.00%|            or np.unique(y.data).size == 1
   166|         0|            0|            0|  0.00%|            and (
   167|         0|            0|            0|  0.00%|                y.dtype.kind in "biu"
   168|         0|            0|            0|  0.00%|                or _is_integral_float(np.unique(y.data))  # bool, int, uint
   169|         0|            0|            0|  0.00%|            )
   170|         0|            0|            0|  0.00%|        )
   171|         0|            0|            0|  0.00%|    else:
   172|         0|            0|            0|  0.00%|        labels = np.unique(y)
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|        return len(labels) < 3 and (
   175|         0|            0|            0|  0.00%|            y.dtype.kind in "biu" or _is_integral_float(labels)  # bool, int, uint
   176|         0|            0|            0|  0.00%|        )
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|def check_classification_targets(y):
   180|         0|            0|            0|  0.00%|    """Ensure that target y is of a non-regression type.
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    Only the following target types (as defined in type_of_target) are allowed:
   183|         0|            0|            0|  0.00%|        'binary', 'multiclass', 'multiclass-multioutput',
   184|         0|            0|            0|  0.00%|        'multilabel-indicator', 'multilabel-sequences'
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    Parameters
   187|         0|            0|            0|  0.00%|    ----------
   188|         0|            0|            0|  0.00%|    y : array-like
   189|         0|            0|            0|  0.00%|    """
   190|         0|            0|            0|  0.00%|    y_type = type_of_target(y)
   191|         0|            0|            0|  0.00%|    if y_type not in [
   192|         0|            0|            0|  0.00%|        "binary",
   193|         0|            0|            0|  0.00%|        "multiclass",
   194|         0|            0|            0|  0.00%|        "multiclass-multioutput",
   195|         0|            0|            0|  0.00%|        "multilabel-indicator",
   196|         0|            0|            0|  0.00%|        "multilabel-sequences",
   197|         0|            0|            0|  0.00%|    ]:
   198|         0|            0|            0|  0.00%|        raise ValueError("Unknown label type: %r" % y_type)
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|
   201|         8|            0|            0|  0.00%|def type_of_target(y):
   202|         0|            0|            0|  0.00%|    """Determine the type of data indicated by the target.
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|    Note that this type is the most specific type that can be inferred.
   205|         0|            0|            0|  0.00%|    For example:
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|        * ``binary`` is more specific but compatible with ``multiclass``.
   208|         0|            0|            0|  0.00%|        * ``multiclass`` of integers is more specific but compatible with
   209|         0|            0|            0|  0.00%|          ``continuous``.
   210|         0|            0|            0|  0.00%|        * ``multilabel-indicator`` is more specific but compatible with
   211|         0|            0|            0|  0.00%|          ``multiclass-multioutput``.
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    Parameters
   214|         0|            0|            0|  0.00%|    ----------
   215|         0|            0|            0|  0.00%|    y : array-like
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|    Returns
   218|         0|            0|            0|  0.00%|    -------
   219|         0|            0|            0|  0.00%|    target_type : str
   220|         0|            0|            0|  0.00%|        One of:
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|        * 'continuous': `y` is an array-like of floats that are not all
   223|         0|            0|            0|  0.00%|          integers, and is 1d or a column vector.
   224|         0|            0|            0|  0.00%|        * 'continuous-multioutput': `y` is a 2d array of floats that are
   225|         0|            0|            0|  0.00%|          not all integers, and both dimensions are of size > 1.
   226|         0|            0|            0|  0.00%|        * 'binary': `y` contains <= 2 discrete values and is 1d or a column
   227|         0|            0|            0|  0.00%|          vector.
   228|         0|            0|            0|  0.00%|        * 'multiclass': `y` contains more than two discrete values, is not a
   229|         0|            0|            0|  0.00%|          sequence of sequences, and is 1d or a column vector.
   230|         0|            0|            0|  0.00%|        * 'multiclass-multioutput': `y` is a 2d array that contains more
   231|         0|            0|            0|  0.00%|          than two discrete values, is not a sequence of sequences, and both
   232|         0|            0|            0|  0.00%|          dimensions are of size > 1.
   233|         0|            0|            0|  0.00%|        * 'multilabel-indicator': `y` is a label indicator matrix, an array
   234|         0|            0|            0|  0.00%|          of two dimensions with at least two columns, and at most 2 unique
   235|         0|            0|            0|  0.00%|          values.
   236|         0|            0|            0|  0.00%|        * 'unknown': `y` is array-like but none of the above, such as a 3d
   237|         0|            0|            0|  0.00%|          array, sequence of sequences, or an array of non-sequence objects.
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    Examples
   240|         0|            0|            0|  0.00%|    --------
   241|         0|            0|            0|  0.00%|    >>> from sklearn.utils.multiclass import type_of_target
   242|         0|            0|            0|  0.00%|    >>> import numpy as np
   243|         0|            0|            0|  0.00%|    >>> type_of_target([0.1, 0.6])
   244|         0|            0|            0|  0.00%|    'continuous'
   245|         0|            0|            0|  0.00%|    >>> type_of_target([1, -1, -1, 1])
   246|         0|            0|            0|  0.00%|    'binary'
   247|         0|            0|            0|  0.00%|    >>> type_of_target(['a', 'b', 'a'])
   248|         0|            0|            0|  0.00%|    'binary'
   249|         0|            0|            0|  0.00%|    >>> type_of_target([1.0, 2.0])
   250|         0|            0|            0|  0.00%|    'binary'
   251|         0|            0|            0|  0.00%|    >>> type_of_target([1, 0, 2])
   252|         0|            0|            0|  0.00%|    'multiclass'
   253|         0|            0|            0|  0.00%|    >>> type_of_target([1.0, 0.0, 3.0])
   254|         0|            0|            0|  0.00%|    'multiclass'
   255|         0|            0|            0|  0.00%|    >>> type_of_target(['a', 'b', 'c'])
   256|         0|            0|            0|  0.00%|    'multiclass'
   257|         0|            0|            0|  0.00%|    >>> type_of_target(np.array([[1, 2], [3, 1]]))
   258|         0|            0|            0|  0.00%|    'multiclass-multioutput'
   259|         0|            0|            0|  0.00%|    >>> type_of_target([[1, 2]])
   260|         0|            0|            0|  0.00%|    'multilabel-indicator'
   261|         0|            0|            0|  0.00%|    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))
   262|         0|            0|            0|  0.00%|    'continuous-multioutput'
   263|         0|            0|            0|  0.00%|    >>> type_of_target(np.array([[0, 1], [1, 1]]))
   264|         0|            0|            0|  0.00%|    'multilabel-indicator'
   265|         0|            0|            0|  0.00%|    """
   266|        16|            0|            0|  0.00%|    valid = (
   267|         8|            0|            0|  0.00%|        isinstance(y, (Sequence, spmatrix)) or hasattr(y, "__array__")
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\abc.py:96 __instancecheck__
   268|         8|            0|            0|  0.00%|    ) and not isinstance(y, str)
   269|         0|            0|            0|  0.00%|
   270|         8|            0|            0|  0.00%|    if not valid:
   271|         0|            0|            0|  0.00%|        raise ValueError(
   272|         0|            0|            0|  0.00%|            "Expected array-like (array or non-string sequence), got %r" % y
   273|         0|            0|            0|  0.00%|        )
   274|         0|            0|            0|  0.00%|
   275|         8|            0|            0|  0.00%|    sparse_pandas = y.__class__.__name__ in ["SparseSeries", "SparseArray"]
   276|         8|            0|            0|  0.00%|    if sparse_pandas:
   277|         0|            0|            0|  0.00%|        raise ValueError("y cannot be class 'SparseSeries' or 'SparseArray'")
   278|         0|            0|            0|  0.00%|
   279|         8|            0|            0|  0.00%|    if is_multilabel(y):
(call)|         8|   0.00199556|  0.000249445|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\multiclass.py:117 is_multilabel
   280|         0|            0|            0|  0.00%|        return "multilabel-indicator"
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    # DeprecationWarning will be replaced by ValueError, see NEP 34
   283|         0|            0|            0|  0.00%|    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html
   284|         8|            0|            0|  0.00%|    with warnings.catch_warnings():
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:441 __init__
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:462 __enter__
   285|         8|            0|            0|  0.00%|        warnings.simplefilter("error", np.VisibleDeprecationWarning)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:165 simplefilter
   286|         8|            0|            0|  0.00%|        try:
   287|         8|            0|            0|  0.00%|            y = np.asarray(y)
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\warnings.py:481 __exit__
   288|         0|            0|            0|  0.00%|        except np.VisibleDeprecationWarning:
   289|         0|            0|            0|  0.00%|            # dtype=object should be provided explicitly for ragged arrays,
   290|         0|            0|            0|  0.00%|            # see NEP 34
   291|         0|            0|            0|  0.00%|            y = np.asarray(y, dtype=object)
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    # The old sequence of sequences format
   294|         8|            0|            0|  0.00%|    try:
   295|         8|            0|            0|  0.00%|        if (
   296|         8|            0|            0|  0.00%|            not hasattr(y[0], "__array__")
   297|         0|            0|            0|  0.00%|            and isinstance(y[0], Sequence)
   298|         0|            0|            0|  0.00%|            and not isinstance(y[0], str)
   299|         0|            0|            0|  0.00%|        ):
   300|         0|            0|            0|  0.00%|            raise ValueError(
   301|         0|            0|            0|  0.00%|                "You appear to be using a legacy multi-label data"
   302|         0|            0|            0|  0.00%|                " representation. Sequence of sequences are no"
   303|         0|            0|            0|  0.00%|                " longer supported; use a binary array or sparse"
   304|         0|            0|            0|  0.00%|                " matrix instead - the MultiLabelBinarizer"
   305|         0|            0|            0|  0.00%|                " transformer can convert to this format."
   306|         0|            0|            0|  0.00%|            )
   307|         0|            0|            0|  0.00%|    except IndexError:
   308|         0|            0|            0|  0.00%|        pass
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    # Invalid inputs
   311|         8|            0|            0|  0.00%|    if y.ndim > 2 or (y.dtype == object and len(y) and not isinstance(y.flat[0], str)):
   312|         0|            0|            0|  0.00%|        return "unknown"  # [[[1, 2]]] or [obj_1] and not ["label_1"]
   313|         0|            0|            0|  0.00%|
   314|         8|            0|            0|  0.00%|    if y.ndim == 2 and y.shape[1] == 0:
   315|         0|            0|            0|  0.00%|        return "unknown"  # [[]]
   316|         0|            0|            0|  0.00%|
   317|         8|            0|            0|  0.00%|    if y.ndim == 2 and y.shape[1] > 1:
   318|         0|            0|            0|  0.00%|        suffix = "-multioutput"  # [[1, 2], [1, 2]]
   319|         0|            0|            0|  0.00%|    else:
   320|         8|            0|            0|  0.00%|        suffix = ""  # [1, 2, 3] or [[1], [2], [3]]
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    # check float and contains non-integer float values
   323|         8|            0|            0|  0.00%|    if y.dtype.kind == "f" and np.any(y != y.astype(int)):
   324|         0|            0|            0|  0.00%|        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]
   325|         0|            0|            0|  0.00%|        _assert_all_finite(y)
   326|         0|            0|            0|  0.00%|        return "continuous" + suffix
   327|         0|            0|            0|  0.00%|
   328|         8|            0|            0|  0.00%|    if (len(np.unique(y)) > 2) or (y.ndim >= 2 and len(y[0]) > 1):
(call)|         8|   0.00099802|  0.000124753|  0.00%|# <__array_function__ internals>:177 unique
   329|         2|            0|            0|  0.00%|        return "multiclass" + suffix  # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]
   330|         0|            0|            0|  0.00%|    else:
   331|         6|            0|            0|  0.00%|        return "binary"  # [1, 2] or [["a"], ["b"]]
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|def _check_partial_fit_first_call(clf, classes=None):
   335|         0|            0|            0|  0.00%|    """Private helper function for factorizing common classes param logic.
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|    Estimators that implement the ``partial_fit`` API need to be provided with
   338|         0|            0|            0|  0.00%|    the list of possible classes at the first call to partial_fit.
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|    Subsequent calls to partial_fit should check that ``classes`` is still
   341|         0|            0|            0|  0.00%|    consistent with a previous value of ``clf.classes_`` when provided.
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    This function returns True if it detects that this was the first call to
   344|         0|            0|            0|  0.00%|    ``partial_fit`` on ``clf``. In that case the ``classes_`` attribute is also
   345|         0|            0|            0|  0.00%|    set on ``clf``.
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|    """
   348|         0|            0|            0|  0.00%|    if getattr(clf, "classes_", None) is None and classes is None:
   349|         0|            0|            0|  0.00%|        raise ValueError("classes must be passed on the first call to partial_fit.")
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|    elif classes is not None:
   352|         0|            0|            0|  0.00%|        if getattr(clf, "classes_", None) is not None:
   353|         0|            0|            0|  0.00%|            if not np.array_equal(clf.classes_, unique_labels(classes)):
   354|         0|            0|            0|  0.00%|                raise ValueError(
   355|         0|            0|            0|  0.00%|                    "`classes=%r` is not the same as on last call "
   356|         0|            0|            0|  0.00%|                    "to partial_fit, was: %r" % (classes, clf.classes_)
   357|         0|            0|            0|  0.00%|                )
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|        else:
   360|         0|            0|            0|  0.00%|            # This is the first call to partial_fit
   361|         0|            0|            0|  0.00%|            clf.classes_ = unique_labels(classes)
   362|         0|            0|            0|  0.00%|            return True
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|    # classes is None and clf.classes_ has already previously been set:
   365|         0|            0|            0|  0.00%|    # nothing to do
   366|         0|            0|            0|  0.00%|    return False
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|def class_distribution(y, sample_weight=None):
   370|         0|            0|            0|  0.00%|    """Compute class priors from multioutput-multiclass target data.
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|    Parameters
   373|         0|            0|            0|  0.00%|    ----------
   374|         0|            0|            0|  0.00%|    y : {array-like, sparse matrix} of size (n_samples, n_outputs)
   375|         0|            0|            0|  0.00%|        The labels for each example.
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    sample_weight : array-like of shape (n_samples,), default=None
   378|         0|            0|            0|  0.00%|        Sample weights.
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    Returns
   381|         0|            0|            0|  0.00%|    -------
   382|         0|            0|            0|  0.00%|    classes : list of size n_outputs of ndarray of size (n_classes,)
   383|         0|            0|            0|  0.00%|        List of classes for each column.
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    n_classes : list of int of size n_outputs
   386|         0|            0|            0|  0.00%|        Number of classes in each column.
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|    class_prior : list of size n_outputs of ndarray of size (n_classes,)
   389|         0|            0|            0|  0.00%|        Class distribution of each column.
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    """
   392|         0|            0|            0|  0.00%|    classes = []
   393|         0|            0|            0|  0.00%|    n_classes = []
   394|         0|            0|            0|  0.00%|    class_prior = []
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|    n_samples, n_outputs = y.shape
   397|         0|            0|            0|  0.00%|    if sample_weight is not None:
   398|         0|            0|            0|  0.00%|        sample_weight = np.asarray(sample_weight)
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|    if issparse(y):
   401|         0|            0|            0|  0.00%|        y = y.tocsc()
   402|         0|            0|            0|  0.00%|        y_nnz = np.diff(y.indptr)
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|        for k in range(n_outputs):
   405|         0|            0|            0|  0.00%|            col_nonzero = y.indices[y.indptr[k] : y.indptr[k + 1]]
   406|         0|            0|            0|  0.00%|            # separate sample weights for zero and non-zero elements
   407|         0|            0|            0|  0.00%|            if sample_weight is not None:
   408|         0|            0|            0|  0.00%|                nz_samp_weight = sample_weight[col_nonzero]
   409|         0|            0|            0|  0.00%|                zeros_samp_weight_sum = np.sum(sample_weight) - np.sum(nz_samp_weight)
   410|         0|            0|            0|  0.00%|            else:
   411|         0|            0|            0|  0.00%|                nz_samp_weight = None
   412|         0|            0|            0|  0.00%|                zeros_samp_weight_sum = y.shape[0] - y_nnz[k]
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|            classes_k, y_k = np.unique(
   415|         0|            0|            0|  0.00%|                y.data[y.indptr[k] : y.indptr[k + 1]], return_inverse=True
   416|         0|            0|            0|  0.00%|            )
   417|         0|            0|            0|  0.00%|            class_prior_k = np.bincount(y_k, weights=nz_samp_weight)
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|            # An explicit zero was found, combine its weight with the weight
   420|         0|            0|            0|  0.00%|            # of the implicit zeros
   421|         0|            0|            0|  0.00%|            if 0 in classes_k:
   422|         0|            0|            0|  0.00%|                class_prior_k[classes_k == 0] += zeros_samp_weight_sum
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|            # If an there is an implicit zero and it is not in classes and
   425|         0|            0|            0|  0.00%|            # class_prior, make an entry for it
   426|         0|            0|            0|  0.00%|            if 0 not in classes_k and y_nnz[k] < y.shape[0]:
   427|         0|            0|            0|  0.00%|                classes_k = np.insert(classes_k, 0, 0)
   428|         0|            0|            0|  0.00%|                class_prior_k = np.insert(class_prior_k, 0, zeros_samp_weight_sum)
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|            classes.append(classes_k)
   431|         0|            0|            0|  0.00%|            n_classes.append(classes_k.shape[0])
   432|         0|            0|            0|  0.00%|            class_prior.append(class_prior_k / class_prior_k.sum())
   433|         0|            0|            0|  0.00%|    else:
   434|         0|            0|            0|  0.00%|        for k in range(n_outputs):
   435|         0|            0|            0|  0.00%|            classes_k, y_k = np.unique(y[:, k], return_inverse=True)
   436|         0|            0|            0|  0.00%|            classes.append(classes_k)
   437|         0|            0|            0|  0.00%|            n_classes.append(classes_k.shape[0])
   438|         0|            0|            0|  0.00%|            class_prior_k = np.bincount(y_k, weights=sample_weight)
   439|         0|            0|            0|  0.00%|            class_prior.append(class_prior_k / class_prior_k.sum())
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|    return (classes, n_classes, class_prior)
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|def _ovr_decision_function(predictions, confidences, n_classes):
   445|         0|            0|            0|  0.00%|    """Compute a continuous, tie-breaking OvR decision function from OvO.
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    It is important to include a continuous value, not only votes,
   448|         0|            0|            0|  0.00%|    to make computing AUC or calibration meaningful.
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|    Parameters
   451|         0|            0|            0|  0.00%|    ----------
   452|         0|            0|            0|  0.00%|    predictions : array-like of shape (n_samples, n_classifiers)
   453|         0|            0|            0|  0.00%|        Predicted classes for each binary classifier.
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    confidences : array-like of shape (n_samples, n_classifiers)
   456|         0|            0|            0|  0.00%|        Decision functions or predicted probabilities for positive class
   457|         0|            0|            0|  0.00%|        for each binary classifier.
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    n_classes : int
   460|         0|            0|            0|  0.00%|        Number of classes. n_classifiers must be
   461|         0|            0|            0|  0.00%|        ``n_classes * (n_classes - 1 ) / 2``.
   462|         0|            0|            0|  0.00%|    """
   463|         0|            0|            0|  0.00%|    n_samples = predictions.shape[0]
   464|         0|            0|            0|  0.00%|    votes = np.zeros((n_samples, n_classes))
   465|         0|            0|            0|  0.00%|    sum_of_confidences = np.zeros((n_samples, n_classes))
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|    k = 0
   468|         0|            0|            0|  0.00%|    for i in range(n_classes):
   469|         0|            0|            0|  0.00%|        for j in range(i + 1, n_classes):
   470|         0|            0|            0|  0.00%|            sum_of_confidences[:, i] -= confidences[:, k]
   471|         0|            0|            0|  0.00%|            sum_of_confidences[:, j] += confidences[:, k]
   472|         0|            0|            0|  0.00%|            votes[predictions[:, k] == 0, i] += 1
   473|         0|            0|            0|  0.00%|            votes[predictions[:, k] == 1, j] += 1
   474|         0|            0|            0|  0.00%|            k += 1
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|    # Monotonically transform the sum_of_confidences to (-1/3, 1/3)
   477|         0|            0|            0|  0.00%|    # and add it with votes. The monotonic transformation  is
   478|         0|            0|            0|  0.00%|    # f: x -> x / (3 * (|x| + 1)), it uses 1/3 instead of 1/2
   479|         0|            0|            0|  0.00%|    # to ensure that we won't reach the limits and change vote order.
   480|         0|            0|            0|  0.00%|    # The motivation is to use confidence levels as a way to break ties in
   481|         0|            0|            0|  0.00%|    # the votes without switching any decision made based on a difference
   482|         0|            0|            0|  0.00%|    # of 1 vote.
   483|         0|            0|            0|  0.00%|    transformed_confidences = sum_of_confidences / (
   484|         0|            0|            0|  0.00%|        3 * (np.abs(sum_of_confidences) + 1)
   485|         0|            0|            0|  0.00%|    )
   486|         0|            0|            0|  0.00%|    return votes + transformed_confidences
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csr.py
File duration: 0.000997543s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Compressed Sparse Row matrix format"""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|__docformat__ = "restructuredtext en"
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|__all__ = ['csr_matrix', 'isspmatrix_csr']
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|import numpy as np
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from .base import spmatrix
    10|         0|            0|            0|  0.00%|from ._sparsetools import (csr_tocsc, csr_tobsr, csr_count_blocks,
    11|         0|            0|            0|  0.00%|                           get_csr_submatrix)
    12|         0|            0|            0|  0.00%|from .sputils import upcast, get_index_dtype
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|from .compressed import _cs_matrix
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|class csr_matrix(_cs_matrix):
    18|         0|            0|            0|  0.00%|    """
    19|         0|            0|            0|  0.00%|    Compressed Sparse Row matrix
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|    This can be instantiated in several ways:
    22|         0|            0|            0|  0.00%|        csr_matrix(D)
    23|         0|            0|            0|  0.00%|            with a dense matrix or rank-2 ndarray D
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|        csr_matrix(S)
    26|         0|            0|            0|  0.00%|            with another sparse matrix S (equivalent to S.tocsr())
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|        csr_matrix((M, N), [dtype])
    29|         0|            0|            0|  0.00%|            to construct an empty matrix with shape (M, N)
    30|         0|            0|            0|  0.00%|            dtype is optional, defaulting to dtype='d'.
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|        csr_matrix((data, (row_ind, col_ind)), [shape=(M, N)])
    33|         0|            0|            0|  0.00%|            where ``data``, ``row_ind`` and ``col_ind`` satisfy the
    34|         0|            0|            0|  0.00%|            relationship ``a[row_ind[k], col_ind[k]] = data[k]``.
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|        csr_matrix((data, indices, indptr), [shape=(M, N)])
    37|         0|            0|            0|  0.00%|            is the standard CSR representation where the column indices for
    38|         0|            0|            0|  0.00%|            row i are stored in ``indices[indptr[i]:indptr[i+1]]`` and their
    39|         0|            0|            0|  0.00%|            corresponding values are stored in ``data[indptr[i]:indptr[i+1]]``.
    40|         0|            0|            0|  0.00%|            If the shape parameter is not supplied, the matrix dimensions
    41|         0|            0|            0|  0.00%|            are inferred from the index arrays.
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|    Attributes
    44|         0|            0|            0|  0.00%|    ----------
    45|         0|            0|            0|  0.00%|    dtype : dtype
    46|         0|            0|            0|  0.00%|        Data type of the matrix
    47|         0|            0|            0|  0.00%|    shape : 2-tuple
    48|         0|            0|            0|  0.00%|        Shape of the matrix
    49|         0|            0|            0|  0.00%|    ndim : int
    50|         0|            0|            0|  0.00%|        Number of dimensions (this is always 2)
    51|         0|            0|            0|  0.00%|    nnz
    52|         0|            0|            0|  0.00%|        Number of stored values, including explicit zeros
    53|         0|            0|            0|  0.00%|    data
    54|         0|            0|            0|  0.00%|        CSR format data array of the matrix
    55|         0|            0|            0|  0.00%|    indices
    56|         0|            0|            0|  0.00%|        CSR format index array of the matrix
    57|         0|            0|            0|  0.00%|    indptr
    58|         0|            0|            0|  0.00%|        CSR format index pointer array of the matrix
    59|         0|            0|            0|  0.00%|    has_sorted_indices
    60|         0|            0|            0|  0.00%|        Whether indices are sorted
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    Notes
    63|         0|            0|            0|  0.00%|    -----
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    Sparse matrices can be used in arithmetic operations: they support
    66|         0|            0|            0|  0.00%|    addition, subtraction, multiplication, division, and matrix power.
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    Advantages of the CSR format
    69|         0|            0|            0|  0.00%|      - efficient arithmetic operations CSR + CSR, CSR * CSR, etc.
    70|         0|            0|            0|  0.00%|      - efficient row slicing
    71|         0|            0|            0|  0.00%|      - fast matrix vector products
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|    Disadvantages of the CSR format
    74|         0|            0|            0|  0.00%|      - slow column slicing operations (consider CSC)
    75|         0|            0|            0|  0.00%|      - changes to the sparsity structure are expensive (consider LIL or DOK)
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    Examples
    78|         0|            0|            0|  0.00%|    --------
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|    >>> import numpy as np
    81|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csr_matrix
    82|         0|            0|            0|  0.00%|    >>> csr_matrix((3, 4), dtype=np.int8).toarray()
    83|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0],
    84|         0|            0|            0|  0.00%|           [0, 0, 0, 0],
    85|         0|            0|            0|  0.00%|           [0, 0, 0, 0]], dtype=int8)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|    >>> row = np.array([0, 0, 1, 2, 2, 2])
    88|         0|            0|            0|  0.00%|    >>> col = np.array([0, 2, 2, 0, 1, 2])
    89|         0|            0|            0|  0.00%|    >>> data = np.array([1, 2, 3, 4, 5, 6])
    90|         0|            0|            0|  0.00%|    >>> csr_matrix((data, (row, col)), shape=(3, 3)).toarray()
    91|         0|            0|            0|  0.00%|    array([[1, 0, 2],
    92|         0|            0|            0|  0.00%|           [0, 0, 3],
    93|         0|            0|            0|  0.00%|           [4, 5, 6]])
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|    >>> indptr = np.array([0, 2, 3, 6])
    96|         0|            0|            0|  0.00%|    >>> indices = np.array([0, 2, 2, 0, 1, 2])
    97|         0|            0|            0|  0.00%|    >>> data = np.array([1, 2, 3, 4, 5, 6])
    98|         0|            0|            0|  0.00%|    >>> csr_matrix((data, indices, indptr), shape=(3, 3)).toarray()
    99|         0|            0|            0|  0.00%|    array([[1, 0, 2],
   100|         0|            0|            0|  0.00%|           [0, 0, 3],
   101|         0|            0|            0|  0.00%|           [4, 5, 6]])
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    Duplicate entries are summed together:
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|    >>> row = np.array([0, 1, 2, 0])
   106|         0|            0|            0|  0.00%|    >>> col = np.array([0, 1, 1, 0])
   107|         0|            0|            0|  0.00%|    >>> data = np.array([1, 2, 4, 8])
   108|         0|            0|            0|  0.00%|    >>> csr_matrix((data, (row, col)), shape=(3, 3)).toarray()
   109|         0|            0|            0|  0.00%|    array([[9, 0, 0],
   110|         0|            0|            0|  0.00%|           [0, 2, 0],
   111|         0|            0|            0|  0.00%|           [0, 4, 0]])
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    As an example of how to construct a CSR matrix incrementally,
   114|         0|            0|            0|  0.00%|    the following snippet builds a term-document matrix from texts:
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    >>> docs = [["hello", "world", "hello"], ["goodbye", "cruel", "world"]]
   117|         0|            0|            0|  0.00%|    >>> indptr = [0]
   118|         0|            0|            0|  0.00%|    >>> indices = []
   119|         0|            0|            0|  0.00%|    >>> data = []
   120|         0|            0|            0|  0.00%|    >>> vocabulary = {}
   121|         0|            0|            0|  0.00%|    >>> for d in docs:
   122|         0|            0|            0|  0.00%|    ...     for term in d:
   123|         0|            0|            0|  0.00%|    ...         index = vocabulary.setdefault(term, len(vocabulary))
   124|         0|            0|            0|  0.00%|    ...         indices.append(index)
   125|         0|            0|            0|  0.00%|    ...         data.append(1)
   126|         0|            0|            0|  0.00%|    ...     indptr.append(len(indices))
   127|         0|            0|            0|  0.00%|    ...
   128|         0|            0|            0|  0.00%|    >>> csr_matrix((data, indices, indptr), dtype=int).toarray()
   129|         0|            0|            0|  0.00%|    array([[2, 1, 0, 0],
   130|         0|            0|            0|  0.00%|           [0, 1, 1, 1]])
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|    """
   133|         0|            0|            0|  0.00%|    format = 'csr'
   134|         0|            0|            0|  0.00%|
   135|         4|            0|            0|  0.00%|    def transpose(self, axes=None, copy=False):
   136|         4|            0|            0|  0.00%|        if axes is not None:
   137|         0|            0|            0|  0.00%|            raise ValueError(("Sparse matrices do not support "
   138|         0|            0|            0|  0.00%|                              "an 'axes' parameter because swapping "
   139|         0|            0|            0|  0.00%|                              "dimensions is the only logical permutation."))
   140|         0|            0|            0|  0.00%|
   141|         4|            0|            0|  0.00%|        M, N = self.shape
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:80 get_shape
   142|         0|            0|            0|  0.00%|
   143|         4|            0|            0|  0.00%|        from .csc import csc_matrix
(call)|         4|            0|            0|  0.00%|# <frozen importlib._bootstrap>:389 parent
   144|        12|            0|            0|  0.00%|        return csc_matrix((self.data, self.indices,
(call)|         4|   0.00401998|   0.00100499|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:27 __init__
   145|         8|            0|            0|  0.00%|                           self.indptr), shape=(N, M), copy=copy)
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    transpose.__doc__ = spmatrix.transpose.__doc__
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|    def tolil(self, copy=False):
   150|         0|            0|            0|  0.00%|        from .lil import lil_matrix
   151|         0|            0|            0|  0.00%|        lil = lil_matrix(self.shape,dtype=self.dtype)
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|        self.sum_duplicates()
   154|         0|            0|            0|  0.00%|        ptr,ind,dat = self.indptr,self.indices,self.data
   155|         0|            0|            0|  0.00%|        rows, data = lil.rows, lil.data
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|        for n in range(self.shape[0]):
   158|         0|            0|            0|  0.00%|            start = ptr[n]
   159|         0|            0|            0|  0.00%|            end = ptr[n+1]
   160|         0|            0|            0|  0.00%|            rows[n] = ind[start:end].tolist()
   161|         0|            0|            0|  0.00%|            data[n] = dat[start:end].tolist()
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|        return lil
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    tolil.__doc__ = spmatrix.tolil.__doc__
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|    def tocsr(self, copy=False):
   168|         0|            0|            0|  0.00%|        if copy:
   169|         0|            0|            0|  0.00%|            return self.copy()
   170|         0|            0|            0|  0.00%|        else:
   171|         0|            0|            0|  0.00%|            return self
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    tocsr.__doc__ = spmatrix.tocsr.__doc__
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    def tocsc(self, copy=False):
   176|         0|            0|            0|  0.00%|        idx_dtype = get_index_dtype((self.indptr, self.indices),
   177|         0|            0|            0|  0.00%|                                    maxval=max(self.nnz, self.shape[0]))
   178|         0|            0|            0|  0.00%|        indptr = np.empty(self.shape[1] + 1, dtype=idx_dtype)
   179|         0|            0|            0|  0.00%|        indices = np.empty(self.nnz, dtype=idx_dtype)
   180|         0|            0|            0|  0.00%|        data = np.empty(self.nnz, dtype=upcast(self.dtype))
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|        csr_tocsc(self.shape[0], self.shape[1],
   183|         0|            0|            0|  0.00%|                  self.indptr.astype(idx_dtype),
   184|         0|            0|            0|  0.00%|                  self.indices.astype(idx_dtype),
   185|         0|            0|            0|  0.00%|                  self.data,
   186|         0|            0|            0|  0.00%|                  indptr,
   187|         0|            0|            0|  0.00%|                  indices,
   188|         0|            0|            0|  0.00%|                  data)
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|        from .csc import csc_matrix
   191|         0|            0|            0|  0.00%|        A = csc_matrix((data, indices, indptr), shape=self.shape)
   192|         0|            0|            0|  0.00%|        A.has_sorted_indices = True
   193|         0|            0|            0|  0.00%|        return A
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|    tocsc.__doc__ = spmatrix.tocsc.__doc__
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    def tobsr(self, blocksize=None, copy=True):
   198|         0|            0|            0|  0.00%|        from .bsr import bsr_matrix
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|        if blocksize is None:
   201|         0|            0|            0|  0.00%|            from .spfuncs import estimate_blocksize
   202|         0|            0|            0|  0.00%|            return self.tobsr(blocksize=estimate_blocksize(self))
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|        elif blocksize == (1,1):
   205|         0|            0|            0|  0.00%|            arg1 = (self.data.reshape(-1,1,1),self.indices,self.indptr)
   206|         0|            0|            0|  0.00%|            return bsr_matrix(arg1, shape=self.shape, copy=copy)
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|        else:
   209|         0|            0|            0|  0.00%|            R,C = blocksize
   210|         0|            0|            0|  0.00%|            M,N = self.shape
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|            if R < 1 or C < 1 or M % R != 0 or N % C != 0:
   213|         0|            0|            0|  0.00%|                raise ValueError('invalid blocksize %s' % blocksize)
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|            blks = csr_count_blocks(M,N,R,C,self.indptr,self.indices)
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|            idx_dtype = get_index_dtype((self.indptr, self.indices),
   218|         0|            0|            0|  0.00%|                                        maxval=max(N//C, blks))
   219|         0|            0|            0|  0.00%|            indptr = np.empty(M//R+1, dtype=idx_dtype)
   220|         0|            0|            0|  0.00%|            indices = np.empty(blks, dtype=idx_dtype)
   221|         0|            0|            0|  0.00%|            data = np.zeros((blks,R,C), dtype=self.dtype)
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|            csr_tobsr(M, N, R, C,
   224|         0|            0|            0|  0.00%|                      self.indptr.astype(idx_dtype),
   225|         0|            0|            0|  0.00%|                      self.indices.astype(idx_dtype),
   226|         0|            0|            0|  0.00%|                      self.data,
   227|         0|            0|            0|  0.00%|                      indptr, indices, data.ravel())
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|            return bsr_matrix((data,indices,indptr), shape=self.shape)
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    tobsr.__doc__ = spmatrix.tobsr.__doc__
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|    # these functions are used by the parent class (_cs_matrix)
   234|         0|            0|            0|  0.00%|    # to remove redundancy between csc_matrix and csr_matrix
   235|        60|            0|            0|  0.00%|    def _swap(self, x):
   236|         0|            0|            0|  0.00%|        """swap the members of x if this is a column-oriented matrix
   237|         0|            0|            0|  0.00%|        """
   238|        60|  0.000997543|  1.66257e-05|  0.00%|        return x
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    def __iter__(self):
   241|         0|            0|            0|  0.00%|        indptr = np.zeros(2, dtype=self.indptr.dtype)
   242|         0|            0|            0|  0.00%|        shape = (1, self.shape[1])
   243|         0|            0|            0|  0.00%|        i0 = 0
   244|         0|            0|            0|  0.00%|        for i1 in self.indptr[1:]:
   245|         0|            0|            0|  0.00%|            indptr[1] = i1 - i0
   246|         0|            0|            0|  0.00%|            indices = self.indices[i0:i1]
   247|         0|            0|            0|  0.00%|            data = self.data[i0:i1]
   248|         0|            0|            0|  0.00%|            yield csr_matrix((data, indices, indptr), shape=shape, copy=True)
   249|         0|            0|            0|  0.00%|            i0 = i1
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    def getrow(self, i):
   252|         0|            0|            0|  0.00%|        """Returns a copy of row i of the matrix, as a (1 x n)
   253|         0|            0|            0|  0.00%|        CSR matrix (row vector).
   254|         0|            0|            0|  0.00%|        """
   255|         0|            0|            0|  0.00%|        M, N = self.shape
   256|         0|            0|            0|  0.00%|        i = int(i)
   257|         0|            0|            0|  0.00%|        if i < 0:
   258|         0|            0|            0|  0.00%|            i += M
   259|         0|            0|            0|  0.00%|        if i < 0 or i >= M:
   260|         0|            0|            0|  0.00%|            raise IndexError('index (%d) out of range' % i)
   261|         0|            0|            0|  0.00%|        indptr, indices, data = get_csr_submatrix(
   262|         0|            0|            0|  0.00%|            M, N, self.indptr, self.indices, self.data, i, i + 1, 0, N)
   263|         0|            0|            0|  0.00%|        return csr_matrix((data, indices, indptr), shape=(1, N),
   264|         0|            0|            0|  0.00%|                          dtype=self.dtype, copy=False)
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|    def getcol(self, i):
   267|         0|            0|            0|  0.00%|        """Returns a copy of column i of the matrix, as a (m x 1)
   268|         0|            0|            0|  0.00%|        CSR matrix (column vector).
   269|         0|            0|            0|  0.00%|        """
   270|         0|            0|            0|  0.00%|        M, N = self.shape
   271|         0|            0|            0|  0.00%|        i = int(i)
   272|         0|            0|            0|  0.00%|        if i < 0:
   273|         0|            0|            0|  0.00%|            i += N
   274|         0|            0|            0|  0.00%|        if i < 0 or i >= N:
   275|         0|            0|            0|  0.00%|            raise IndexError('index (%d) out of range' % i)
   276|         0|            0|            0|  0.00%|        indptr, indices, data = get_csr_submatrix(
   277|         0|            0|            0|  0.00%|            M, N, self.indptr, self.indices, self.data, 0, M, i, i + 1)
   278|         0|            0|            0|  0.00%|        return csr_matrix((data, indices, indptr), shape=(M, 1),
   279|         0|            0|            0|  0.00%|                          dtype=self.dtype, copy=False)
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    def _get_intXarray(self, row, col):
   282|         0|            0|            0|  0.00%|        return self.getrow(row)._minor_index_fancy(col)
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    def _get_intXslice(self, row, col):
   285|         0|            0|            0|  0.00%|        if col.step in (1, None):
   286|         0|            0|            0|  0.00%|            return self._get_submatrix(row, col, copy=True)
   287|         0|            0|            0|  0.00%|        # TODO: uncomment this once it's faster:
   288|         0|            0|            0|  0.00%|        # return self.getrow(row)._minor_slice(col)
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|        M, N = self.shape
   291|         0|            0|            0|  0.00%|        start, stop, stride = col.indices(N)
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|        ii, jj = self.indptr[row:row+2]
   294|         0|            0|            0|  0.00%|        row_indices = self.indices[ii:jj]
   295|         0|            0|            0|  0.00%|        row_data = self.data[ii:jj]
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|        if stride > 0:
   298|         0|            0|            0|  0.00%|            ind = (row_indices >= start) & (row_indices < stop)
   299|         0|            0|            0|  0.00%|        else:
   300|         0|            0|            0|  0.00%|            ind = (row_indices <= start) & (row_indices > stop)
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|        if abs(stride) > 1:
   303|         0|            0|            0|  0.00%|            ind &= (row_indices - start) % stride == 0
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|        row_indices = (row_indices[ind] - start) // stride
   306|         0|            0|            0|  0.00%|        row_data = row_data[ind]
   307|         0|            0|            0|  0.00%|        row_indptr = np.array([0, len(row_indices)])
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|        if stride < 0:
   310|         0|            0|            0|  0.00%|            row_data = row_data[::-1]
   311|         0|            0|            0|  0.00%|            row_indices = abs(row_indices[::-1])
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|        shape = (1, max(0, int(np.ceil(float(stop - start) / stride))))
   314|         0|            0|            0|  0.00%|        return csr_matrix((row_data, row_indices, row_indptr), shape=shape,
   315|         0|            0|            0|  0.00%|                          dtype=self.dtype, copy=False)
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    def _get_sliceXint(self, row, col):
   318|         0|            0|            0|  0.00%|        if row.step in (1, None):
   319|         0|            0|            0|  0.00%|            return self._get_submatrix(row, col, copy=True)
   320|         0|            0|            0|  0.00%|        return self._major_slice(row)._get_submatrix(minor=col)
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    def _get_sliceXarray(self, row, col):
   323|         0|            0|            0|  0.00%|        return self._major_slice(row)._minor_index_fancy(col)
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|    def _get_arrayXint(self, row, col):
   326|         0|            0|            0|  0.00%|        return self._major_index_fancy(row)._get_submatrix(minor=col)
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|    def _get_arrayXslice(self, row, col):
   329|         0|            0|            0|  0.00%|        if col.step not in (1, None):
   330|         0|            0|            0|  0.00%|            col = np.arange(*col.indices(self.shape[1]))
   331|         0|            0|            0|  0.00%|            return self._get_arrayXarray(row, col)
   332|         0|            0|            0|  0.00%|        return self._major_index_fancy(row)._get_submatrix(minor=col)
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|def isspmatrix_csr(x):
   336|         0|            0|            0|  0.00%|    """Is x of csr_matrix type?
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    Parameters
   339|         0|            0|            0|  0.00%|    ----------
   340|         0|            0|            0|  0.00%|    x
   341|         0|            0|            0|  0.00%|        object to check for being a csr matrix
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    Returns
   344|         0|            0|            0|  0.00%|    -------
   345|         0|            0|            0|  0.00%|    bool
   346|         0|            0|            0|  0.00%|        True if x is a csr matrix, False otherwise
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    Examples
   349|         0|            0|            0|  0.00%|    --------
   350|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csr_matrix, isspmatrix_csr
   351|         0|            0|            0|  0.00%|    >>> isspmatrix_csr(csr_matrix([[5]]))
   352|         0|            0|            0|  0.00%|    True
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
   355|         0|            0|            0|  0.00%|    >>> isspmatrix_csr(csc_matrix([[5]]))
   356|         0|            0|            0|  0.00%|    False
   357|         0|            0|            0|  0.00%|    """
   358|         0|            0|            0|  0.00%|    return isinstance(x, csr_matrix)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py
File duration: 0.000997305s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Vendoered from
     2|         0|            0|            0|  0.00%|https://github.com/pypa/packaging/blob/main/packaging/version.py
     3|         0|            0|            0|  0.00%|"""
     4|         0|            0|            0|  0.00%|# Copyright (c) Donald Stufft and individual contributors.
     5|         0|            0|            0|  0.00%|# All rights reserved.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|# Redistribution and use in source and binary forms, with or without
     8|         0|            0|            0|  0.00%|# modification, are permitted provided that the following conditions are met:
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|#     1. Redistributions of source code must retain the above copyright notice,
    11|         0|            0|            0|  0.00%|#        this list of conditions and the following disclaimer.
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|#     2. Redistributions in binary form must reproduce the above copyright
    14|         0|            0|            0|  0.00%|#        notice, this list of conditions and the following disclaimer in the
    15|         0|            0|            0|  0.00%|#        documentation and/or other materials provided with the distribution.
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    18|         0|            0|            0|  0.00%|# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    19|         0|            0|            0|  0.00%|# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    20|         0|            0|            0|  0.00%|# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    21|         0|            0|            0|  0.00%|# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    22|         0|            0|            0|  0.00%|# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    23|         0|            0|            0|  0.00%|# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    24|         0|            0|            0|  0.00%|# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    25|         0|            0|            0|  0.00%|# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    26|         0|            0|            0|  0.00%|# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|import collections
    29|         0|            0|            0|  0.00%|import itertools
    30|         0|            0|            0|  0.00%|import re
    31|         0|            0|            0|  0.00%|import warnings
    32|         0|            0|            0|  0.00%|from typing import Callable, Iterator, List, Optional, SupportsInt, Tuple, Union
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|__all__ = ["parse", "Version", "LegacyVersion", "InvalidVersion", "VERSION_PATTERN"]
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|InfiniteTypes = Union[InfinityType, NegativeInfinityType]
    39|         0|            0|            0|  0.00%|PrePostDevType = Union[InfiniteTypes, Tuple[str, int]]
    40|         0|            0|            0|  0.00%|SubLocalType = Union[InfiniteTypes, int, str]
    41|         0|            0|            0|  0.00%|LocalType = Union[
    42|         0|            0|            0|  0.00%|    NegativeInfinityType,
    43|         0|            0|            0|  0.00%|    Tuple[
    44|         0|            0|            0|  0.00%|        Union[
    45|         0|            0|            0|  0.00%|            SubLocalType,
    46|         0|            0|            0|  0.00%|            Tuple[SubLocalType, str],
    47|         0|            0|            0|  0.00%|            Tuple[NegativeInfinityType, SubLocalType],
    48|         0|            0|            0|  0.00%|        ],
    49|         0|            0|            0|  0.00%|        ...,
    50|         0|            0|            0|  0.00%|    ],
    51|         0|            0|            0|  0.00%|]
    52|         0|            0|            0|  0.00%|CmpKey = Tuple[
    53|         0|            0|            0|  0.00%|    int, Tuple[int, ...], PrePostDevType, PrePostDevType, PrePostDevType, LocalType
    54|         0|            0|            0|  0.00%|]
    55|         0|            0|            0|  0.00%|LegacyCmpKey = Tuple[int, Tuple[str, ...]]
    56|         0|            0|            0|  0.00%|VersionComparisonMethod = Callable[
    57|         0|            0|            0|  0.00%|    [Union[CmpKey, LegacyCmpKey], Union[CmpKey, LegacyCmpKey]], bool
    58|         0|            0|            0|  0.00%|]
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|_Version = collections.namedtuple(
    61|         0|            0|            0|  0.00%|    "_Version", ["epoch", "release", "dev", "pre", "post", "local"]
    62|         0|            0|            0|  0.00%|)
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         4|            0|            0|  0.00%|def parse(version: str) -> Union["LegacyVersion", "Version"]:
    66|         0|            0|            0|  0.00%|    """
    67|         0|            0|            0|  0.00%|    Parse the given version string and return either a :class:`Version` object
    68|         0|            0|            0|  0.00%|    or a :class:`LegacyVersion` object depending on if the given version is
    69|         0|            0|            0|  0.00%|    a valid PEP 440 version or a legacy version.
    70|         0|            0|            0|  0.00%|    """
    71|         4|            0|            0|  0.00%|    try:
    72|         4|            0|            0|  0.00%|        return Version(version)
(call)|         4|  0.000997305|  0.000249326|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:284 __init__
    73|         0|            0|            0|  0.00%|    except InvalidVersion:
    74|         0|            0|            0|  0.00%|        return LegacyVersion(version)
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|class InvalidVersion(ValueError):
    78|         0|            0|            0|  0.00%|    """
    79|         0|            0|            0|  0.00%|    An invalid version was found, users should refer to PEP 440.
    80|         0|            0|            0|  0.00%|    """
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|class _BaseVersion:
    84|         0|            0|            0|  0.00%|    _key: Union[CmpKey, LegacyCmpKey]
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    def __hash__(self) -> int:
    87|         0|            0|            0|  0.00%|        return hash(self._key)
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    # Please keep the duplicated `isinstance` check
    90|         0|            0|            0|  0.00%|    # in the six comparisons hereunder
    91|         0|            0|            0|  0.00%|    # unless you find a way to avoid adding overhead function calls.
    92|         0|            0|            0|  0.00%|    def __lt__(self, other: "_BaseVersion") -> bool:
    93|         0|            0|            0|  0.00%|        if not isinstance(other, _BaseVersion):
    94|         0|            0|            0|  0.00%|            return NotImplemented
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|        return self._key < other._key
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    def __le__(self, other: "_BaseVersion") -> bool:
    99|         0|            0|            0|  0.00%|        if not isinstance(other, _BaseVersion):
   100|         0|            0|            0|  0.00%|            return NotImplemented
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|        return self._key <= other._key
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    def __eq__(self, other: object) -> bool:
   105|         0|            0|            0|  0.00%|        if not isinstance(other, _BaseVersion):
   106|         0|            0|            0|  0.00%|            return NotImplemented
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|        return self._key == other._key
   109|         0|            0|            0|  0.00%|
   110|         4|            0|            0|  0.00%|    def __ge__(self, other: "_BaseVersion") -> bool:
   111|         4|            0|            0|  0.00%|        if not isinstance(other, _BaseVersion):
   112|         0|            0|            0|  0.00%|            return NotImplemented
   113|         0|            0|            0|  0.00%|
   114|         4|            0|            0|  0.00%|        return self._key >= other._key
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    def __gt__(self, other: "_BaseVersion") -> bool:
   117|         0|            0|            0|  0.00%|        if not isinstance(other, _BaseVersion):
   118|         0|            0|            0|  0.00%|            return NotImplemented
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|        return self._key > other._key
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|    def __ne__(self, other: object) -> bool:
   123|         0|            0|            0|  0.00%|        if not isinstance(other, _BaseVersion):
   124|         0|            0|            0|  0.00%|            return NotImplemented
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|        return self._key != other._key
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|class LegacyVersion(_BaseVersion):
   130|         0|            0|            0|  0.00%|    def __init__(self, version: str) -> None:
   131|         0|            0|            0|  0.00%|        self._version = str(version)
   132|         0|            0|            0|  0.00%|        self._key = _legacy_cmpkey(self._version)
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|        warnings.warn(
   135|         0|            0|            0|  0.00%|            "Creating a LegacyVersion has been deprecated and will be "
   136|         0|            0|            0|  0.00%|            "removed in the next major release",
   137|         0|            0|            0|  0.00%|            DeprecationWarning,
   138|         0|            0|            0|  0.00%|        )
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    def __str__(self) -> str:
   141|         0|            0|            0|  0.00%|        return self._version
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   144|         0|            0|            0|  0.00%|        return f"<LegacyVersion('{self}')>"
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    @property
   147|         0|            0|            0|  0.00%|    def public(self) -> str:
   148|         0|            0|            0|  0.00%|        return self._version
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    @property
   151|         0|            0|            0|  0.00%|    def base_version(self) -> str:
   152|         0|            0|            0|  0.00%|        return self._version
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|    @property
   155|         0|            0|            0|  0.00%|    def epoch(self) -> int:
   156|         0|            0|            0|  0.00%|        return -1
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|    @property
   159|         0|            0|            0|  0.00%|    def release(self) -> None:
   160|         0|            0|            0|  0.00%|        return None
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|    @property
   163|         0|            0|            0|  0.00%|    def pre(self) -> None:
   164|         0|            0|            0|  0.00%|        return None
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    @property
   167|         0|            0|            0|  0.00%|    def post(self) -> None:
   168|         0|            0|            0|  0.00%|        return None
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    @property
   171|         0|            0|            0|  0.00%|    def dev(self) -> None:
   172|         0|            0|            0|  0.00%|        return None
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|    @property
   175|         0|            0|            0|  0.00%|    def local(self) -> None:
   176|         0|            0|            0|  0.00%|        return None
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    @property
   179|         0|            0|            0|  0.00%|    def is_prerelease(self) -> bool:
   180|         0|            0|            0|  0.00%|        return False
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    @property
   183|         0|            0|            0|  0.00%|    def is_postrelease(self) -> bool:
   184|         0|            0|            0|  0.00%|        return False
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    @property
   187|         0|            0|            0|  0.00%|    def is_devrelease(self) -> bool:
   188|         0|            0|            0|  0.00%|        return False
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|_legacy_version_component_re = re.compile(r"(\d+ | [a-z]+ | \.| -)", re.VERBOSE)
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|_legacy_version_replacement_map = {
   194|         0|            0|            0|  0.00%|    "pre": "c",
   195|         0|            0|            0|  0.00%|    "preview": "c",
   196|         0|            0|            0|  0.00%|    "-": "final-",
   197|         0|            0|            0|  0.00%|    "rc": "c",
   198|         0|            0|            0|  0.00%|    "dev": "@",
   199|         0|            0|            0|  0.00%|}
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|def _parse_version_parts(s: str) -> Iterator[str]:
   203|         0|            0|            0|  0.00%|    for part in _legacy_version_component_re.split(s):
   204|         0|            0|            0|  0.00%|        part = _legacy_version_replacement_map.get(part, part)
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|        if not part or part == ".":
   207|         0|            0|            0|  0.00%|            continue
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|        if part[:1] in "0123456789":
   210|         0|            0|            0|  0.00%|            # pad for numeric comparison
   211|         0|            0|            0|  0.00%|            yield part.zfill(8)
   212|         0|            0|            0|  0.00%|        else:
   213|         0|            0|            0|  0.00%|            yield "*" + part
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    # ensure that alpha/beta/candidate are before final
   216|         0|            0|            0|  0.00%|    yield "*final"
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|def _legacy_cmpkey(version: str) -> LegacyCmpKey:
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|    # We hardcode an epoch of -1 here. A PEP 440 version can only have a epoch
   222|         0|            0|            0|  0.00%|    # greater than or equal to 0. This will effectively put the LegacyVersion,
   223|         0|            0|            0|  0.00%|    # which uses the defacto standard originally implemented by setuptools,
   224|         0|            0|            0|  0.00%|    # as before all PEP 440 versions.
   225|         0|            0|            0|  0.00%|    epoch = -1
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    # This scheme is taken from pkg_resources.parse_version setuptools prior to
   228|         0|            0|            0|  0.00%|    # it's adoption of the packaging library.
   229|         0|            0|            0|  0.00%|    parts: List[str] = []
   230|         0|            0|            0|  0.00%|    for part in _parse_version_parts(version.lower()):
   231|         0|            0|            0|  0.00%|        if part.startswith("*"):
   232|         0|            0|            0|  0.00%|            # remove "-" before a prerelease tag
   233|         0|            0|            0|  0.00%|            if part < "*final":
   234|         0|            0|            0|  0.00%|                while parts and parts[-1] == "*final-":
   235|         0|            0|            0|  0.00%|                    parts.pop()
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|            # remove trailing zeros from each series of numeric parts
   238|         0|            0|            0|  0.00%|            while parts and parts[-1] == "00000000":
   239|         0|            0|            0|  0.00%|                parts.pop()
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|        parts.append(part)
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    return epoch, tuple(parts)
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|# Deliberately not anchored to the start and end of the string, to make it
   247|         0|            0|            0|  0.00%|# easier for 3rd party code to reuse
   248|         0|            0|            0|  0.00%|VERSION_PATTERN = r"""
   249|         0|            0|            0|  0.00%|    v?
   250|         0|            0|            0|  0.00%|    (?:
   251|         0|            0|            0|  0.00%|        (?:(?P<epoch>[0-9]+)!)?                           # epoch
   252|         0|            0|            0|  0.00%|        (?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment
   253|         0|            0|            0|  0.00%|        (?P<pre>                                          # pre-release
   254|         0|            0|            0|  0.00%|            [-_\.]?
   255|         0|            0|            0|  0.00%|            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))
   256|         0|            0|            0|  0.00%|            [-_\.]?
   257|         0|            0|            0|  0.00%|            (?P<pre_n>[0-9]+)?
   258|         0|            0|            0|  0.00%|        )?
   259|         0|            0|            0|  0.00%|        (?P<post>                                         # post release
   260|         0|            0|            0|  0.00%|            (?:-(?P<post_n1>[0-9]+))
   261|         0|            0|            0|  0.00%|            |
   262|         0|            0|            0|  0.00%|            (?:
   263|         0|            0|            0|  0.00%|                [-_\.]?
   264|         0|            0|            0|  0.00%|                (?P<post_l>post|rev|r)
   265|         0|            0|            0|  0.00%|                [-_\.]?
   266|         0|            0|            0|  0.00%|                (?P<post_n2>[0-9]+)?
   267|         0|            0|            0|  0.00%|            )
   268|         0|            0|            0|  0.00%|        )?
   269|         0|            0|            0|  0.00%|        (?P<dev>                                          # dev release
   270|         0|            0|            0|  0.00%|            [-_\.]?
   271|         0|            0|            0|  0.00%|            (?P<dev_l>dev)
   272|         0|            0|            0|  0.00%|            [-_\.]?
   273|         0|            0|            0|  0.00%|            (?P<dev_n>[0-9]+)?
   274|         0|            0|            0|  0.00%|        )?
   275|         0|            0|            0|  0.00%|    )
   276|         0|            0|            0|  0.00%|    (?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version
   277|         0|            0|            0|  0.00%|"""
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|class Version(_BaseVersion):
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    _regex = re.compile(r"^\s*" + VERSION_PATTERN + r"\s*$", re.VERBOSE | re.IGNORECASE)
   283|         0|            0|            0|  0.00%|
   284|         4|            0|            0|  0.00%|    def __init__(self, version: str) -> None:
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|        # Validate the version and parse it into pieces
   287|         4|            0|            0|  0.00%|        match = self._regex.search(version)
   288|         4|            0|            0|  0.00%|        if not match:
   289|         0|            0|            0|  0.00%|            raise InvalidVersion(f"Invalid version: '{version}'")
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        # Store the parsed out pieces of the version
   292|         8|            0|            0|  0.00%|        self._version = _Version(
(call)|         4|            0|            0|  0.00%|# <string>:1 __new__
   293|         4|            0|            0|  0.00%|            epoch=int(match.group("epoch")) if match.group("epoch") else 0,
   294|        28|  0.000997305|   3.5618e-05|  0.00%|            release=tuple(int(i) for i in match.group("release").split(".")),
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:294 <genexpr>
   295|         4|            0|            0|  0.00%|            pre=_parse_letter_version(match.group("pre_l"), match.group("pre_n")),
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:416 _parse_letter_version
   296|         8|            0|            0|  0.00%|            post=_parse_letter_version(
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:416 _parse_letter_version
   297|         4|            0|            0|  0.00%|                match.group("post_l"), match.group("post_n1") or match.group("post_n2")
   298|         0|            0|            0|  0.00%|            ),
   299|         4|            0|            0|  0.00%|            dev=_parse_letter_version(match.group("dev_l"), match.group("dev_n")),
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:416 _parse_letter_version
   300|         4|            0|            0|  0.00%|            local=_parse_local_version(match.group("local")),
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:455 _parse_local_version
   301|         0|            0|            0|  0.00%|        )
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|        # Generate a key which will be used for sorting
   304|         8|            0|            0|  0.00%|        self._key = _cmpkey(
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:467 _cmpkey
   305|         4|            0|            0|  0.00%|            self._version.epoch,
   306|         4|            0|            0|  0.00%|            self._version.release,
   307|         4|            0|            0|  0.00%|            self._version.pre,
   308|         4|            0|            0|  0.00%|            self._version.post,
   309|         4|            0|            0|  0.00%|            self._version.dev,
   310|         4|            0|            0|  0.00%|            self._version.local,
   311|         0|            0|            0|  0.00%|        )
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   314|         0|            0|            0|  0.00%|        return f"<Version('{self}')>"
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    def __str__(self) -> str:
   317|         0|            0|            0|  0.00%|        parts = []
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|        # Epoch
   320|         0|            0|            0|  0.00%|        if self.epoch != 0:
   321|         0|            0|            0|  0.00%|            parts.append(f"{self.epoch}!")
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|        # Release segment
   324|         0|            0|            0|  0.00%|        parts.append(".".join(str(x) for x in self.release))
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|        # Pre-release
   327|         0|            0|            0|  0.00%|        if self.pre is not None:
   328|         0|            0|            0|  0.00%|            parts.append("".join(str(x) for x in self.pre))
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|        # Post-release
   331|         0|            0|            0|  0.00%|        if self.post is not None:
   332|         0|            0|            0|  0.00%|            parts.append(f".post{self.post}")
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|        # Development release
   335|         0|            0|            0|  0.00%|        if self.dev is not None:
   336|         0|            0|            0|  0.00%|            parts.append(f".dev{self.dev}")
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|        # Local version segment
   339|         0|            0|            0|  0.00%|        if self.local is not None:
   340|         0|            0|            0|  0.00%|            parts.append(f"+{self.local}")
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|        return "".join(parts)
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|    @property
   345|         0|            0|            0|  0.00%|    def epoch(self) -> int:
   346|         0|            0|            0|  0.00%|        _epoch: int = self._version.epoch
   347|         0|            0|            0|  0.00%|        return _epoch
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|    @property
   350|         0|            0|            0|  0.00%|    def release(self) -> Tuple[int, ...]:
   351|         0|            0|            0|  0.00%|        _release: Tuple[int, ...] = self._version.release
   352|         0|            0|            0|  0.00%|        return _release
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    @property
   355|         0|            0|            0|  0.00%|    def pre(self) -> Optional[Tuple[str, int]]:
   356|         0|            0|            0|  0.00%|        _pre: Optional[Tuple[str, int]] = self._version.pre
   357|         0|            0|            0|  0.00%|        return _pre
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|    @property
   360|         0|            0|            0|  0.00%|    def post(self) -> Optional[int]:
   361|         0|            0|            0|  0.00%|        return self._version.post[1] if self._version.post else None
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    @property
   364|         0|            0|            0|  0.00%|    def dev(self) -> Optional[int]:
   365|         0|            0|            0|  0.00%|        return self._version.dev[1] if self._version.dev else None
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|    @property
   368|         0|            0|            0|  0.00%|    def local(self) -> Optional[str]:
   369|         0|            0|            0|  0.00%|        if self._version.local:
   370|         0|            0|            0|  0.00%|            return ".".join(str(x) for x in self._version.local)
   371|         0|            0|            0|  0.00%|        else:
   372|         0|            0|            0|  0.00%|            return None
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    @property
   375|         0|            0|            0|  0.00%|    def public(self) -> str:
   376|         0|            0|            0|  0.00%|        return str(self).split("+", 1)[0]
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|    @property
   379|         0|            0|            0|  0.00%|    def base_version(self) -> str:
   380|         0|            0|            0|  0.00%|        parts = []
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|        # Epoch
   383|         0|            0|            0|  0.00%|        if self.epoch != 0:
   384|         0|            0|            0|  0.00%|            parts.append(f"{self.epoch}!")
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|        # Release segment
   387|         0|            0|            0|  0.00%|        parts.append(".".join(str(x) for x in self.release))
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|        return "".join(parts)
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    @property
   392|         0|            0|            0|  0.00%|    def is_prerelease(self) -> bool:
   393|         0|            0|            0|  0.00%|        return self.dev is not None or self.pre is not None
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    @property
   396|         0|            0|            0|  0.00%|    def is_postrelease(self) -> bool:
   397|         0|            0|            0|  0.00%|        return self.post is not None
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    @property
   400|         0|            0|            0|  0.00%|    def is_devrelease(self) -> bool:
   401|         0|            0|            0|  0.00%|        return self.dev is not None
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|    @property
   404|         0|            0|            0|  0.00%|    def major(self) -> int:
   405|         0|            0|            0|  0.00%|        return self.release[0] if len(self.release) >= 1 else 0
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|    @property
   408|         0|            0|            0|  0.00%|    def minor(self) -> int:
   409|         0|            0|            0|  0.00%|        return self.release[1] if len(self.release) >= 2 else 0
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    @property
   412|         0|            0|            0|  0.00%|    def micro(self) -> int:
   413|         0|            0|            0|  0.00%|        return self.release[2] if len(self.release) >= 3 else 0
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|
   416|        12|            0|            0|  0.00%|def _parse_letter_version(
   417|         0|            0|            0|  0.00%|    letter: str, number: Union[str, bytes, SupportsInt]
   418|         0|            0|            0|  0.00%|) -> Optional[Tuple[str, int]]:
   419|         0|            0|            0|  0.00%|
   420|        12|            0|            0|  0.00%|    if letter:
   421|         0|            0|            0|  0.00%|        # We consider there to be an implicit 0 in a pre-release if there is
   422|         0|            0|            0|  0.00%|        # not a numeral associated with it.
   423|         0|            0|            0|  0.00%|        if number is None:
   424|         0|            0|            0|  0.00%|            number = 0
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|        # We normalize any letters to their lower case form
   427|         0|            0|            0|  0.00%|        letter = letter.lower()
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|        # We consider some words to be alternate spellings of other words and
   430|         0|            0|            0|  0.00%|        # in those cases we want to normalize the spellings to our preferred
   431|         0|            0|            0|  0.00%|        # spelling.
   432|         0|            0|            0|  0.00%|        if letter == "alpha":
   433|         0|            0|            0|  0.00%|            letter = "a"
   434|         0|            0|            0|  0.00%|        elif letter == "beta":
   435|         0|            0|            0|  0.00%|            letter = "b"
   436|         0|            0|            0|  0.00%|        elif letter in ["c", "pre", "preview"]:
   437|         0|            0|            0|  0.00%|            letter = "rc"
   438|         0|            0|            0|  0.00%|        elif letter in ["rev", "r"]:
   439|         0|            0|            0|  0.00%|            letter = "post"
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|        return letter, int(number)
   442|        12|            0|            0|  0.00%|    if not letter and number:
   443|         0|            0|            0|  0.00%|        # We assume if we are given a number, but we are not given a letter
   444|         0|            0|            0|  0.00%|        # then this is using the implicit post release syntax (e.g. 1.0-1)
   445|         0|            0|            0|  0.00%|        letter = "post"
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|        return letter, int(number)
   448|         0|            0|            0|  0.00%|
   449|        12|            0|            0|  0.00%|    return None
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|_local_version_separators = re.compile(r"[\._-]")
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|
   455|         4|            0|            0|  0.00%|def _parse_local_version(local: str) -> Optional[LocalType]:
   456|         0|            0|            0|  0.00%|    """
   457|         0|            0|            0|  0.00%|    Takes a string like abc.1.twelve and turns it into ("abc", 1, "twelve").
   458|         0|            0|            0|  0.00%|    """
   459|         4|            0|            0|  0.00%|    if local is not None:
   460|         0|            0|            0|  0.00%|        return tuple(
   461|         0|            0|            0|  0.00%|            part.lower() if not part.isdigit() else int(part)
   462|         0|            0|            0|  0.00%|            for part in _local_version_separators.split(local)
   463|         0|            0|            0|  0.00%|        )
   464|         4|            0|            0|  0.00%|    return None
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         4|            0|            0|  0.00%|def _cmpkey(
   468|         0|            0|            0|  0.00%|    epoch: int,
   469|         0|            0|            0|  0.00%|    release: Tuple[int, ...],
   470|         0|            0|            0|  0.00%|    pre: Optional[Tuple[str, int]],
   471|         0|            0|            0|  0.00%|    post: Optional[Tuple[str, int]],
   472|         0|            0|            0|  0.00%|    dev: Optional[Tuple[str, int]],
   473|         0|            0|            0|  0.00%|    local: Optional[Tuple[SubLocalType]],
   474|         0|            0|            0|  0.00%|) -> CmpKey:
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|    # When we compare a release version, we want to compare it with all of the
   477|         0|            0|            0|  0.00%|    # trailing zeros removed. So we'll use a reverse the list, drop all the now
   478|         0|            0|            0|  0.00%|    # leading zeros until we come to something non zero, then take the rest
   479|         0|            0|            0|  0.00%|    # re-reverse it back into the correct order and make it a tuple and use
   480|         0|            0|            0|  0.00%|    # that for our sorting key.
   481|         8|            0|            0|  0.00%|    _release = tuple(
   482|        12|            0|            0|  0.00%|        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:482 <lambda>
   483|         0|            0|            0|  0.00%|    )
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|    # We need to "trick" the sorting algorithm to put 1.0.dev0 before 1.0a0.
   486|         0|            0|            0|  0.00%|    # We'll do this by abusing the pre segment, but we _only_ want to do this
   487|         0|            0|            0|  0.00%|    # if there is not a pre or a post segment. If we have one of those then
   488|         0|            0|            0|  0.00%|    # the normal sorting rules will handle this case correctly.
   489|         4|            0|            0|  0.00%|    if pre is None and post is None and dev is not None:
   490|         0|            0|            0|  0.00%|        _pre: PrePostDevType = NegativeInfinity
   491|         0|            0|            0|  0.00%|    # Versions without a pre-release (except as noted above) should sort after
   492|         0|            0|            0|  0.00%|    # those with one.
   493|         4|            0|            0|  0.00%|    elif pre is None:
   494|         4|            0|            0|  0.00%|        _pre = Infinity
   495|         0|            0|            0|  0.00%|    else:
   496|         0|            0|            0|  0.00%|        _pre = pre
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|    # Versions without a post segment should sort before those with one.
   499|         4|            0|            0|  0.00%|    if post is None:
   500|         4|            0|            0|  0.00%|        _post: PrePostDevType = NegativeInfinity
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    else:
   503|         0|            0|            0|  0.00%|        _post = post
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|    # Versions without a development segment should sort after those with one.
   506|         4|            0|            0|  0.00%|    if dev is None:
   507|         4|            0|            0|  0.00%|        _dev: PrePostDevType = Infinity
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    else:
   510|         0|            0|            0|  0.00%|        _dev = dev
   511|         0|            0|            0|  0.00%|
   512|         4|            0|            0|  0.00%|    if local is None:
   513|         0|            0|            0|  0.00%|        # Versions without a local segment should sort before those with one.
   514|         4|            0|            0|  0.00%|        _local: LocalType = NegativeInfinity
   515|         0|            0|            0|  0.00%|    else:
   516|         0|            0|            0|  0.00%|        # Versions with a local segment need that segment parsed to implement
   517|         0|            0|            0|  0.00%|        # the sorting rules in PEP440.
   518|         0|            0|            0|  0.00%|        # - Alpha numeric segments sort before numeric segments
   519|         0|            0|            0|  0.00%|        # - Alpha numeric segments sort lexicographically
   520|         0|            0|            0|  0.00%|        # - Numeric segments sort numerically
   521|         0|            0|            0|  0.00%|        # - Shorter versions sort before longer versions when the prefixes
   522|         0|            0|            0|  0.00%|        #   match exactly
   523|         0|            0|            0|  0.00%|        _local = tuple(
   524|         0|            0|            0|  0.00%|            (i, "") if isinstance(i, int) else (NegativeInfinity, i) for i in local
   525|         0|            0|            0|  0.00%|        )
   526|         0|            0|            0|  0.00%|
   527|         4|            0|            0|  0.00%|    return epoch, _release, _pre, _post, _dev, _local
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py
File duration: 0.000968695s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Base class for sparse matrice with a .data attribute
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|    subclasses must provide a _with_data() method that
     4|         0|            0|            0|  0.00%|    creates a new matrix with the same sparsity pattern
     5|         0|            0|            0|  0.00%|    as self but with a different data array
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|"""
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|import numpy as np
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|from .base import spmatrix, _ufuncs_with_fixed_point_at_zero
    12|         0|            0|            0|  0.00%|from .sputils import isscalarlike, validateaxis, matrix
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|__all__ = []
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|# TODO implement all relevant operations
    18|         0|            0|            0|  0.00%|# use .data.__methods__() instead of /=, *=, etc.
    19|         0|            0|            0|  0.00%|class _data_matrix(spmatrix):
    20|        28|            0|            0|  0.00%|    def __init__(self):
    21|        28|            0|            0|  0.00%|        spmatrix.__init__(self)
(call)|        28|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\base.py:66 __init__
    22|         0|            0|            0|  0.00%|
    23|        64|            0|            0|  0.00%|    def _get_dtype(self):
    24|        64|  0.000968695|  1.51359e-05|  0.00%|        return self.data.dtype
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|    def _set_dtype(self, newtype):
    27|         0|            0|            0|  0.00%|        self.data.dtype = newtype
    28|         0|            0|            0|  0.00%|    dtype = property(fget=_get_dtype, fset=_set_dtype)
    29|         0|            0|            0|  0.00%|
    30|         8|            0|            0|  0.00%|    def _deduped_data(self):
    31|         8|            0|            0|  0.00%|        if hasattr(self, 'sum_duplicates'):
    32|         8|            0|            0|  0.00%|            self.sum_duplicates()
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1099 sum_duplicates
    33|         8|            0|            0|  0.00%|        return self.data
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|    def __abs__(self):
    36|         0|            0|            0|  0.00%|        return self._with_data(abs(self._deduped_data()))
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|    def __round__(self, ndigits=0):
    39|         0|            0|            0|  0.00%|        return self._with_data(np.around(self._deduped_data(), decimals=ndigits))
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|    def _real(self):
    42|         0|            0|            0|  0.00%|        return self._with_data(self.data.real)
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    def _imag(self):
    45|         0|            0|            0|  0.00%|        return self._with_data(self.data.imag)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    def __neg__(self):
    48|         0|            0|            0|  0.00%|        if self.dtype.kind == 'b':
    49|         0|            0|            0|  0.00%|            raise NotImplementedError('negating a sparse boolean '
    50|         0|            0|            0|  0.00%|                                      'matrix is not supported')
    51|         0|            0|            0|  0.00%|        return self._with_data(-self.data)
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|    def __imul__(self, other):  # self *= other
    54|         0|            0|            0|  0.00%|        if isscalarlike(other):
    55|         0|            0|            0|  0.00%|            self.data *= other
    56|         0|            0|            0|  0.00%|            return self
    57|         0|            0|            0|  0.00%|        else:
    58|         0|            0|            0|  0.00%|            return NotImplemented
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    def __itruediv__(self, other):  # self /= other
    61|         0|            0|            0|  0.00%|        if isscalarlike(other):
    62|         0|            0|            0|  0.00%|            recip = 1.0 / other
    63|         0|            0|            0|  0.00%|            self.data *= recip
    64|         0|            0|            0|  0.00%|            return self
    65|         0|            0|            0|  0.00%|        else:
    66|         0|            0|            0|  0.00%|            return NotImplemented
    67|         0|            0|            0|  0.00%|
    68|         8|            0|            0|  0.00%|    def astype(self, dtype, casting='unsafe', copy=True):
    69|         8|            0|            0|  0.00%|        dtype = np.dtype(dtype)
    70|         8|            0|            0|  0.00%|        if self.dtype != dtype:
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:23 _get_dtype
    71|        16|            0|            0|  0.00%|            return self._with_data(
(call)|         8|   0.00509953|  0.000637442|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\compressed.py:1212 _with_data
    72|         8|            0|            0|  0.00%|                self._deduped_data().astype(dtype, casting=casting, copy=copy),
(call)|         8|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\data.py:30 _deduped_data
    73|         8|            0|            0|  0.00%|                copy=copy)
    74|         0|            0|            0|  0.00%|        elif copy:
    75|         0|            0|            0|  0.00%|            return self.copy()
    76|         0|            0|            0|  0.00%|        else:
    77|         0|            0|            0|  0.00%|            return self
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    astype.__doc__ = spmatrix.astype.__doc__
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    def conj(self, copy=True):
    82|         0|            0|            0|  0.00%|        if np.issubdtype(self.dtype, np.complexfloating):
    83|         0|            0|            0|  0.00%|            return self._with_data(self.data.conj(), copy=copy)
    84|         0|            0|            0|  0.00%|        elif copy:
    85|         0|            0|            0|  0.00%|            return self.copy()
    86|         0|            0|            0|  0.00%|        else:
    87|         0|            0|            0|  0.00%|            return self
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    conj.__doc__ = spmatrix.conj.__doc__
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|    def copy(self):
    92|         0|            0|            0|  0.00%|        return self._with_data(self.data.copy(), copy=True)
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|    copy.__doc__ = spmatrix.copy.__doc__
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    def count_nonzero(self):
    97|         0|            0|            0|  0.00%|        return np.count_nonzero(self._deduped_data())
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    count_nonzero.__doc__ = spmatrix.count_nonzero.__doc__
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    def power(self, n, dtype=None):
   102|         0|            0|            0|  0.00%|        """
   103|         0|            0|            0|  0.00%|        This function performs element-wise power.
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|        Parameters
   106|         0|            0|            0|  0.00%|        ----------
   107|         0|            0|            0|  0.00%|        n : n is a scalar
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|        dtype : If dtype is not specified, the current dtype will be preserved.
   110|         0|            0|            0|  0.00%|        """
   111|         0|            0|            0|  0.00%|        if not isscalarlike(n):
   112|         0|            0|            0|  0.00%|            raise NotImplementedError("input is not scalar")
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|        data = self._deduped_data()
   115|         0|            0|            0|  0.00%|        if dtype is not None:
   116|         0|            0|            0|  0.00%|            data = data.astype(dtype)
   117|         0|            0|            0|  0.00%|        return self._with_data(data ** n)
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|    ###########################
   120|         0|            0|            0|  0.00%|    # Multiplication handlers #
   121|         0|            0|            0|  0.00%|    ###########################
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    def _mul_scalar(self, other):
   124|         0|            0|            0|  0.00%|        return self._with_data(self.data * other)
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|# Add the numpy unary ufuncs for which func(0) = 0 to _data_matrix.
   128|         0|            0|            0|  0.00%|for npfunc in _ufuncs_with_fixed_point_at_zero:
   129|         0|            0|            0|  0.00%|    name = npfunc.__name__
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|    def _create_method(op):
   132|         0|            0|            0|  0.00%|        def method(self):
   133|         0|            0|            0|  0.00%|            result = op(self._deduped_data())
   134|         0|            0|            0|  0.00%|            return self._with_data(result, copy=True)
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|        method.__doc__ = ("Element-wise %s.\n\n"
   137|         0|            0|            0|  0.00%|                          "See `numpy.%s` for more information." % (name, name))
   138|         0|            0|            0|  0.00%|        method.__name__ = name
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|        return method
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|    setattr(_data_matrix, name, _create_method(npfunc))
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|def _find_missing_index(ind, n):
   146|         0|            0|            0|  0.00%|    for k, a in enumerate(ind):
   147|         0|            0|            0|  0.00%|        if k != a:
   148|         0|            0|            0|  0.00%|            return k
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    k += 1
   151|         0|            0|            0|  0.00%|    if k < n:
   152|         0|            0|            0|  0.00%|        return k
   153|         0|            0|            0|  0.00%|    else:
   154|         0|            0|            0|  0.00%|        return -1
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|class _minmax_mixin:
   158|         0|            0|            0|  0.00%|    """Mixin for min and max methods.
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|    These are not implemented for dia_matrix, hence the separate class.
   161|         0|            0|            0|  0.00%|    """
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|    def _min_or_max_axis(self, axis, min_or_max):
   164|         0|            0|            0|  0.00%|        N = self.shape[axis]
   165|         0|            0|            0|  0.00%|        if N == 0:
   166|         0|            0|            0|  0.00%|            raise ValueError("zero-size array to reduction operation")
   167|         0|            0|            0|  0.00%|        M = self.shape[1 - axis]
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|        mat = self.tocsc() if axis == 0 else self.tocsr()
   170|         0|            0|            0|  0.00%|        mat.sum_duplicates()
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|        major_index, value = mat._minor_reduce(min_or_max)
   173|         0|            0|            0|  0.00%|        not_full = np.diff(mat.indptr)[major_index] < N
   174|         0|            0|            0|  0.00%|        value[not_full] = min_or_max(value[not_full], 0)
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|        mask = value != 0
   177|         0|            0|            0|  0.00%|        major_index = np.compress(mask, major_index)
   178|         0|            0|            0|  0.00%|        value = np.compress(mask, value)
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|        from . import coo_matrix
   181|         0|            0|            0|  0.00%|        if axis == 0:
   182|         0|            0|            0|  0.00%|            return coo_matrix((value, (np.zeros(len(value)), major_index)),
   183|         0|            0|            0|  0.00%|                              dtype=self.dtype, shape=(1, M))
   184|         0|            0|            0|  0.00%|        else:
   185|         0|            0|            0|  0.00%|            return coo_matrix((value, (major_index, np.zeros(len(value)))),
   186|         0|            0|            0|  0.00%|                              dtype=self.dtype, shape=(M, 1))
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    def _min_or_max(self, axis, out, min_or_max):
   189|         0|            0|            0|  0.00%|        if out is not None:
   190|         0|            0|            0|  0.00%|            raise ValueError(("Sparse matrices do not support "
   191|         0|            0|            0|  0.00%|                              "an 'out' parameter."))
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|        validateaxis(axis)
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|        if axis is None:
   196|         0|            0|            0|  0.00%|            if 0 in self.shape:
   197|         0|            0|            0|  0.00%|                raise ValueError("zero-size array to reduction operation")
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|            zero = self.dtype.type(0)
   200|         0|            0|            0|  0.00%|            if self.nnz == 0:
   201|         0|            0|            0|  0.00%|                return zero
   202|         0|            0|            0|  0.00%|            m = min_or_max.reduce(self._deduped_data().ravel())
   203|         0|            0|            0|  0.00%|            if self.nnz != np.prod(self.shape):
   204|         0|            0|            0|  0.00%|                m = min_or_max(zero, m)
   205|         0|            0|            0|  0.00%|            return m
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|        if axis < 0:
   208|         0|            0|            0|  0.00%|            axis += 2
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|        if (axis == 0) or (axis == 1):
   211|         0|            0|            0|  0.00%|            return self._min_or_max_axis(axis, min_or_max)
   212|         0|            0|            0|  0.00%|        else:
   213|         0|            0|            0|  0.00%|            raise ValueError("axis out of range")
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    def _arg_min_or_max_axis(self, axis, op, compare):
   216|         0|            0|            0|  0.00%|        if self.shape[axis] == 0:
   217|         0|            0|            0|  0.00%|            raise ValueError("Can't apply the operation along a zero-sized "
   218|         0|            0|            0|  0.00%|                             "dimension.")
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|        if axis < 0:
   221|         0|            0|            0|  0.00%|            axis += 2
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|        zero = self.dtype.type(0)
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|        mat = self.tocsc() if axis == 0 else self.tocsr()
   226|         0|            0|            0|  0.00%|        mat.sum_duplicates()
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|        ret_size, line_size = mat._swap(mat.shape)
   229|         0|            0|            0|  0.00%|        ret = np.zeros(ret_size, dtype=int)
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|        nz_lines, = np.nonzero(np.diff(mat.indptr))
   232|         0|            0|            0|  0.00%|        for i in nz_lines:
   233|         0|            0|            0|  0.00%|            p, q = mat.indptr[i:i + 2]
   234|         0|            0|            0|  0.00%|            data = mat.data[p:q]
   235|         0|            0|            0|  0.00%|            indices = mat.indices[p:q]
   236|         0|            0|            0|  0.00%|            am = op(data)
   237|         0|            0|            0|  0.00%|            m = data[am]
   238|         0|            0|            0|  0.00%|            if compare(m, zero) or q - p == line_size:
   239|         0|            0|            0|  0.00%|                ret[i] = indices[am]
   240|         0|            0|            0|  0.00%|            else:
   241|         0|            0|            0|  0.00%|                zero_ind = _find_missing_index(indices, line_size)
   242|         0|            0|            0|  0.00%|                if m == zero:
   243|         0|            0|            0|  0.00%|                    ret[i] = min(am, zero_ind)
   244|         0|            0|            0|  0.00%|                else:
   245|         0|            0|            0|  0.00%|                    ret[i] = zero_ind
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|        if axis == 1:
   248|         0|            0|            0|  0.00%|            ret = ret.reshape(-1, 1)
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|        return matrix(ret)
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    def _arg_min_or_max(self, axis, out, op, compare):
   253|         0|            0|            0|  0.00%|        if out is not None:
   254|         0|            0|            0|  0.00%|            raise ValueError("Sparse matrices do not support "
   255|         0|            0|            0|  0.00%|                             "an 'out' parameter.")
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|        validateaxis(axis)
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|        if axis is None:
   260|         0|            0|            0|  0.00%|            if 0 in self.shape:
   261|         0|            0|            0|  0.00%|                raise ValueError("Can't apply the operation to "
   262|         0|            0|            0|  0.00%|                                 "an empty matrix.")
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|            if self.nnz == 0:
   265|         0|            0|            0|  0.00%|                return 0
   266|         0|            0|            0|  0.00%|            else:
   267|         0|            0|            0|  0.00%|                zero = self.dtype.type(0)
   268|         0|            0|            0|  0.00%|                mat = self.tocoo()
   269|         0|            0|            0|  0.00%|                mat.sum_duplicates()
   270|         0|            0|            0|  0.00%|                am = op(mat.data)
   271|         0|            0|            0|  0.00%|                m = mat.data[am]
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|                if compare(m, zero):
   274|         0|            0|            0|  0.00%|                    # cast to Python int to avoid overflow
   275|         0|            0|            0|  0.00%|                    # and RuntimeError
   276|         0|            0|            0|  0.00%|                    return int(mat.row[am])*mat.shape[1] + int(mat.col[am])
   277|         0|            0|            0|  0.00%|                else:
   278|         0|            0|            0|  0.00%|                    size = np.prod(mat.shape)
   279|         0|            0|            0|  0.00%|                    if size == mat.nnz:
   280|         0|            0|            0|  0.00%|                        return am
   281|         0|            0|            0|  0.00%|                    else:
   282|         0|            0|            0|  0.00%|                        ind = mat.row * mat.shape[1] + mat.col
   283|         0|            0|            0|  0.00%|                        zero_ind = _find_missing_index(ind, size)
   284|         0|            0|            0|  0.00%|                        if m == zero:
   285|         0|            0|            0|  0.00%|                            return min(zero_ind, am)
   286|         0|            0|            0|  0.00%|                        else:
   287|         0|            0|            0|  0.00%|                            return zero_ind
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|        return self._arg_min_or_max_axis(axis, op, compare)
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|    def max(self, axis=None, out=None):
   292|         0|            0|            0|  0.00%|        """
   293|         0|            0|            0|  0.00%|        Return the maximum of the matrix or maximum along an axis.
   294|         0|            0|            0|  0.00%|        This takes all elements into account, not just the non-zero ones.
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|        Parameters
   297|         0|            0|            0|  0.00%|        ----------
   298|         0|            0|            0|  0.00%|        axis : {-2, -1, 0, 1, None} optional
   299|         0|            0|            0|  0.00%|            Axis along which the sum is computed. The default is to
   300|         0|            0|            0|  0.00%|            compute the maximum over all the matrix elements, returning
   301|         0|            0|            0|  0.00%|            a scalar (i.e., `axis` = `None`).
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|        out : None, optional
   304|         0|            0|            0|  0.00%|            This argument is in the signature *solely* for NumPy
   305|         0|            0|            0|  0.00%|            compatibility reasons. Do not pass in anything except
   306|         0|            0|            0|  0.00%|            for the default value, as this argument is not used.
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|        Returns
   309|         0|            0|            0|  0.00%|        -------
   310|         0|            0|            0|  0.00%|        amax : coo_matrix or scalar
   311|         0|            0|            0|  0.00%|            Maximum of `a`. If `axis` is None, the result is a scalar value.
   312|         0|            0|            0|  0.00%|            If `axis` is given, the result is a sparse.coo_matrix of dimension
   313|         0|            0|            0|  0.00%|            ``a.ndim - 1``.
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|        See Also
   316|         0|            0|            0|  0.00%|        --------
   317|         0|            0|            0|  0.00%|        min : The minimum value of a sparse matrix along a given axis.
   318|         0|            0|            0|  0.00%|        numpy.matrix.max : NumPy's implementation of 'max' for matrices
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|        """
   321|         0|            0|            0|  0.00%|        return self._min_or_max(axis, out, np.maximum)
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    def min(self, axis=None, out=None):
   324|         0|            0|            0|  0.00%|        """
   325|         0|            0|            0|  0.00%|        Return the minimum of the matrix or maximum along an axis.
   326|         0|            0|            0|  0.00%|        This takes all elements into account, not just the non-zero ones.
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|        Parameters
   329|         0|            0|            0|  0.00%|        ----------
   330|         0|            0|            0|  0.00%|        axis : {-2, -1, 0, 1, None} optional
   331|         0|            0|            0|  0.00%|            Axis along which the sum is computed. The default is to
   332|         0|            0|            0|  0.00%|            compute the minimum over all the matrix elements, returning
   333|         0|            0|            0|  0.00%|            a scalar (i.e., `axis` = `None`).
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|        out : None, optional
   336|         0|            0|            0|  0.00%|            This argument is in the signature *solely* for NumPy
   337|         0|            0|            0|  0.00%|            compatibility reasons. Do not pass in anything except for
   338|         0|            0|            0|  0.00%|            the default value, as this argument is not used.
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|        Returns
   341|         0|            0|            0|  0.00%|        -------
   342|         0|            0|            0|  0.00%|        amin : coo_matrix or scalar
   343|         0|            0|            0|  0.00%|            Minimum of `a`. If `axis` is None, the result is a scalar value.
   344|         0|            0|            0|  0.00%|            If `axis` is given, the result is a sparse.coo_matrix of dimension
   345|         0|            0|            0|  0.00%|            ``a.ndim - 1``.
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|        See Also
   348|         0|            0|            0|  0.00%|        --------
   349|         0|            0|            0|  0.00%|        max : The maximum value of a sparse matrix along a given axis.
   350|         0|            0|            0|  0.00%|        numpy.matrix.min : NumPy's implementation of 'min' for matrices
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|        """
   353|         0|            0|            0|  0.00%|        return self._min_or_max(axis, out, np.minimum)
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|    def argmax(self, axis=None, out=None):
   356|         0|            0|            0|  0.00%|        """Return indices of maximum elements along an axis.
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|        Implicit zero elements are also taken into account. If there are
   359|         0|            0|            0|  0.00%|        several maximum values, the index of the first occurrence is returned.
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|        Parameters
   362|         0|            0|            0|  0.00%|        ----------
   363|         0|            0|            0|  0.00%|        axis : {-2, -1, 0, 1, None}, optional
   364|         0|            0|            0|  0.00%|            Axis along which the argmax is computed. If None (default), index
   365|         0|            0|            0|  0.00%|            of the maximum element in the flatten data is returned.
   366|         0|            0|            0|  0.00%|        out : None, optional
   367|         0|            0|            0|  0.00%|            This argument is in the signature *solely* for NumPy
   368|         0|            0|            0|  0.00%|            compatibility reasons. Do not pass in anything except for
   369|         0|            0|            0|  0.00%|            the default value, as this argument is not used.
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|        Returns
   372|         0|            0|            0|  0.00%|        -------
   373|         0|            0|            0|  0.00%|        ind : numpy.matrix or int
   374|         0|            0|            0|  0.00%|            Indices of maximum elements. If matrix, its size along `axis` is 1.
   375|         0|            0|            0|  0.00%|        """
   376|         0|            0|            0|  0.00%|        return self._arg_min_or_max(axis, out, np.argmax, np.greater)
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|    def argmin(self, axis=None, out=None):
   379|         0|            0|            0|  0.00%|        """Return indices of minimum elements along an axis.
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|        Implicit zero elements are also taken into account. If there are
   382|         0|            0|            0|  0.00%|        several minimum values, the index of the first occurrence is returned.
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|        Parameters
   385|         0|            0|            0|  0.00%|        ----------
   386|         0|            0|            0|  0.00%|        axis : {-2, -1, 0, 1, None}, optional
   387|         0|            0|            0|  0.00%|            Axis along which the argmin is computed. If None (default), index
   388|         0|            0|            0|  0.00%|            of the minimum element in the flatten data is returned.
   389|         0|            0|            0|  0.00%|        out : None, optional
   390|         0|            0|            0|  0.00%|            This argument is in the signature *solely* for NumPy
   391|         0|            0|            0|  0.00%|            compatibility reasons. Do not pass in anything except for
   392|         0|            0|            0|  0.00%|            the default value, as this argument is not used.
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|        Returns
   395|         0|            0|            0|  0.00%|        -------
   396|         0|            0|            0|  0.00%|         ind : numpy.matrix or int
   397|         0|            0|            0|  0.00%|            Indices of minimum elements. If matrix, its size along `axis` is 1.
   398|         0|            0|            0|  0.00%|        """
   399|         0|            0|            0|  0.00%|        return self._arg_min_or_max(axis, out, np.argmin, np.less)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\abc.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# Copyright 2007 Google, Inc. All Rights Reserved.
     2|         0|            0|            0|  0.00%|# Licensed to PSF under a Contributor Agreement.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|"""Abstract Base Classes (ABCs) according to PEP 3119."""
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|def abstractmethod(funcobj):
     8|         0|            0|            0|  0.00%|    """A decorator indicating abstract methods.
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|    Requires that the metaclass is ABCMeta or derived from it.  A
    11|         0|            0|            0|  0.00%|    class that has a metaclass derived from ABCMeta cannot be
    12|         0|            0|            0|  0.00%|    instantiated unless all of its abstract methods are overridden.
    13|         0|            0|            0|  0.00%|    The abstract methods can be called using any of the normal
    14|         0|            0|            0|  0.00%|    'super' call mechanisms.  abstractmethod() may be used to declare
    15|         0|            0|            0|  0.00%|    abstract methods for properties and descriptors.
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|    Usage:
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|        class C(metaclass=ABCMeta):
    20|         0|            0|            0|  0.00%|            @abstractmethod
    21|         0|            0|            0|  0.00%|            def my_abstract_method(self, ...):
    22|         0|            0|            0|  0.00%|                ...
    23|         0|            0|            0|  0.00%|    """
    24|         0|            0|            0|  0.00%|    funcobj.__isabstractmethod__ = True
    25|         0|            0|            0|  0.00%|    return funcobj
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|class abstractclassmethod(classmethod):
    29|         0|            0|            0|  0.00%|    """A decorator indicating abstract classmethods.
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|    Deprecated, use 'classmethod' with 'abstractmethod' instead.
    32|         0|            0|            0|  0.00%|    """
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|    __isabstractmethod__ = True
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    def __init__(self, callable):
    37|         0|            0|            0|  0.00%|        callable.__isabstractmethod__ = True
    38|         0|            0|            0|  0.00%|        super().__init__(callable)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|class abstractstaticmethod(staticmethod):
    42|         0|            0|            0|  0.00%|    """A decorator indicating abstract staticmethods.
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    Deprecated, use 'staticmethod' with 'abstractmethod' instead.
    45|         0|            0|            0|  0.00%|    """
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    __isabstractmethod__ = True
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|    def __init__(self, callable):
    50|         0|            0|            0|  0.00%|        callable.__isabstractmethod__ = True
    51|         0|            0|            0|  0.00%|        super().__init__(callable)
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|class abstractproperty(property):
    55|         0|            0|            0|  0.00%|    """A decorator indicating abstract properties.
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    Deprecated, use 'property' with 'abstractmethod' instead.
    58|         0|            0|            0|  0.00%|    """
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    __isabstractmethod__ = True
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|try:
    64|         0|            0|            0|  0.00%|    from _abc import (get_cache_token, _abc_init, _abc_register,
    65|         0|            0|            0|  0.00%|                      _abc_instancecheck, _abc_subclasscheck, _get_dump,
    66|         0|            0|            0|  0.00%|                      _reset_registry, _reset_caches)
    67|         0|            0|            0|  0.00%|except ImportError:
    68|         0|            0|            0|  0.00%|    from _py_abc import ABCMeta, get_cache_token
    69|         0|            0|            0|  0.00%|    ABCMeta.__module__ = 'abc'
    70|         0|            0|            0|  0.00%|else:
    71|         0|            0|            0|  0.00%|    class ABCMeta(type):
    72|         0|            0|            0|  0.00%|        """Metaclass for defining Abstract Base Classes (ABCs).
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|        Use this metaclass to create an ABC.  An ABC can be subclassed
    75|         0|            0|            0|  0.00%|        directly, and then acts as a mix-in class.  You can also register
    76|         0|            0|            0|  0.00%|        unrelated concrete classes (even built-in classes) and unrelated
    77|         0|            0|            0|  0.00%|        ABCs as 'virtual subclasses' -- these and their descendants will
    78|         0|            0|            0|  0.00%|        be considered subclasses of the registering ABC by the built-in
    79|         0|            0|            0|  0.00%|        issubclass() function, but the registering ABC won't show up in
    80|         0|            0|            0|  0.00%|        their MRO (Method Resolution Order) nor will method
    81|         0|            0|            0|  0.00%|        implementations defined by the registering ABC be callable (not
    82|         0|            0|            0|  0.00%|        even via super()).
    83|         0|            0|            0|  0.00%|        """
    84|         0|            0|            0|  0.00%|        def __new__(mcls, name, bases, namespace, **kwargs):
    85|         0|            0|            0|  0.00%|            cls = super().__new__(mcls, name, bases, namespace, **kwargs)
    86|         0|            0|            0|  0.00%|            _abc_init(cls)
    87|         0|            0|            0|  0.00%|            return cls
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|        def register(cls, subclass):
    90|         0|            0|            0|  0.00%|            """Register a virtual subclass of an ABC.
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|            Returns the subclass, to allow usage as a class decorator.
    93|         0|            0|            0|  0.00%|            """
    94|         0|            0|            0|  0.00%|            return _abc_register(cls, subclass)
    95|         0|            0|            0|  0.00%|
    96|        36|            0|            0|  0.00%|        def __instancecheck__(cls, instance):
    97|         0|            0|            0|  0.00%|            """Override for isinstance(instance, cls)."""
    98|        36|            0|            0|  0.00%|            return _abc_instancecheck(cls, instance)
(call)|        15|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\abc.py:100 __subclasscheck__
    99|         0|            0|            0|  0.00%|
   100|        35|            0|            0|  0.00%|        def __subclasscheck__(cls, subclass):
   101|         0|            0|            0|  0.00%|            """Override for issubclass(subclass, cls)."""
   102|        35|            0|            0|  0.00%|            return _abc_subclasscheck(cls, subclass)
(call)|        11|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\_collections_abc.py:302 __subclasshook__
(call)|        20|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\abc.py:100 __subclasscheck__
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|        def _dump_registry(cls, file=None):
   105|         0|            0|            0|  0.00%|            """Debug helper to print the ABC registry."""
   106|         0|            0|            0|  0.00%|            print(f"Class: {cls.__module__}.{cls.__qualname__}", file=file)
   107|         0|            0|            0|  0.00%|            print(f"Inv. counter: {get_cache_token()}", file=file)
   108|         0|            0|            0|  0.00%|            (_abc_registry, _abc_cache, _abc_negative_cache,
   109|         0|            0|            0|  0.00%|             _abc_negative_cache_version) = _get_dump(cls)
   110|         0|            0|            0|  0.00%|            print(f"_abc_registry: {_abc_registry!r}", file=file)
   111|         0|            0|            0|  0.00%|            print(f"_abc_cache: {_abc_cache!r}", file=file)
   112|         0|            0|            0|  0.00%|            print(f"_abc_negative_cache: {_abc_negative_cache!r}", file=file)
   113|         0|            0|            0|  0.00%|            print(f"_abc_negative_cache_version: {_abc_negative_cache_version!r}",
   114|         0|            0|            0|  0.00%|                  file=file)
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|        def _abc_registry_clear(cls):
   117|         0|            0|            0|  0.00%|            """Clear the registry (for debugging or testing)."""
   118|         0|            0|            0|  0.00%|            _reset_registry(cls)
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|        def _abc_caches_clear(cls):
   121|         0|            0|            0|  0.00%|            """Clear the caches (for debugging or testing)."""
   122|         0|            0|            0|  0.00%|            _reset_caches(cls)
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|class ABC(metaclass=ABCMeta):
   126|         0|            0|            0|  0.00%|    """Helper class that provides a standard way to create an ABC using
   127|         0|            0|            0|  0.00%|    inheritance.
   128|         0|            0|            0|  0.00%|    """
   129|         0|            0|            0|  0.00%|    __slots__ = ()
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\_lib\_util.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from contextlib import contextmanager
     2|         0|            0|            0|  0.00%|import functools
     3|         0|            0|            0|  0.00%|import operator
     4|         0|            0|            0|  0.00%|import sys
     5|         0|            0|            0|  0.00%|import warnings
     6|         0|            0|            0|  0.00%|import numbers
     7|         0|            0|            0|  0.00%|from collections import namedtuple
     8|         0|            0|            0|  0.00%|import inspect
     9|         0|            0|            0|  0.00%|import math
    10|         0|            0|            0|  0.00%|from typing import (
    11|         0|            0|            0|  0.00%|    Optional,
    12|         0|            0|            0|  0.00%|    Union,
    13|         0|            0|            0|  0.00%|    TYPE_CHECKING,
    14|         0|            0|            0|  0.00%|    TypeVar,
    15|         0|            0|            0|  0.00%|)
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|import numpy as np
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|IntNumber = Union[int, np.integer]
    20|         0|            0|            0|  0.00%|DecimalNumber = Union[float, np.floating, np.integer]
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|# Since Generator was introduced in numpy 1.17, the following condition is needed for
    23|         0|            0|            0|  0.00%|# backward compatibility
    24|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    25|         0|            0|            0|  0.00%|    SeedType = Optional[Union[IntNumber, np.random.Generator,
    26|         0|            0|            0|  0.00%|                              np.random.RandomState]]
    27|         0|            0|            0|  0.00%|    GeneratorType = TypeVar("GeneratorType", bound=Union[np.random.Generator,
    28|         0|            0|            0|  0.00%|                                                         np.random.RandomState])
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|try:
    31|         0|            0|            0|  0.00%|    from numpy.random import Generator as Generator
    32|         0|            0|            0|  0.00%|except ImportError:
    33|         0|            0|            0|  0.00%|    class Generator():  # type: ignore[no-redef]
    34|         0|            0|            0|  0.00%|        pass
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|def _lazywhere(cond, arrays, f, fillvalue=None, f2=None):
    38|         0|            0|            0|  0.00%|    """
    39|         0|            0|            0|  0.00%|    np.where(cond, x, fillvalue) always evaluates x even where cond is False.
    40|         0|            0|            0|  0.00%|    This one only evaluates f(arr1[cond], arr2[cond], ...).
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    Examples
    43|         0|            0|            0|  0.00%|    --------
    44|         0|            0|            0|  0.00%|    >>> a, b = np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])
    45|         0|            0|            0|  0.00%|    >>> def f(a, b):
    46|         0|            0|            0|  0.00%|    ...     return a*b
    47|         0|            0|            0|  0.00%|    >>> _lazywhere(a > 2, (a, b), f, np.nan)
    48|         0|            0|            0|  0.00%|    array([ nan,  nan,  21.,  32.])
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|    Notice, it assumes that all `arrays` are of the same shape, or can be
    51|         0|            0|            0|  0.00%|    broadcasted together.
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|    """
    54|         0|            0|            0|  0.00%|    cond = np.asarray(cond)
    55|         0|            0|            0|  0.00%|    if fillvalue is None:
    56|         0|            0|            0|  0.00%|        if f2 is None:
    57|         0|            0|            0|  0.00%|            raise ValueError("One of (fillvalue, f2) must be given.")
    58|         0|            0|            0|  0.00%|        else:
    59|         0|            0|            0|  0.00%|            fillvalue = np.nan
    60|         0|            0|            0|  0.00%|    else:
    61|         0|            0|            0|  0.00%|        if f2 is not None:
    62|         0|            0|            0|  0.00%|            raise ValueError("Only one of (fillvalue, f2) can be given.")
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    args = np.broadcast_arrays(cond, *arrays)
    65|         0|            0|            0|  0.00%|    cond,  arrays = args[0], args[1:]
    66|         0|            0|            0|  0.00%|    temp = tuple(np.extract(cond, arr) for arr in arrays)
    67|         0|            0|            0|  0.00%|    tcode = np.mintypecode([a.dtype.char for a in arrays])
    68|         0|            0|            0|  0.00%|    out = np.full(np.shape(arrays[0]), fill_value=fillvalue, dtype=tcode)
    69|         0|            0|            0|  0.00%|    np.place(out, cond, f(*temp))
    70|         0|            0|            0|  0.00%|    if f2 is not None:
    71|         0|            0|            0|  0.00%|        temp = tuple(np.extract(~cond, arr) for arr in arrays)
    72|         0|            0|            0|  0.00%|        np.place(out, ~cond, f2(*temp))
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|    return out
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|def _lazyselect(condlist, choicelist, arrays, default=0):
    78|         0|            0|            0|  0.00%|    """
    79|         0|            0|            0|  0.00%|    Mimic `np.select(condlist, choicelist)`.
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    Notice, it assumes that all `arrays` are of the same shape or can be
    82|         0|            0|            0|  0.00%|    broadcasted together.
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    All functions in `choicelist` must accept array arguments in the order
    85|         0|            0|            0|  0.00%|    given in `arrays` and must return an array of the same shape as broadcasted
    86|         0|            0|            0|  0.00%|    `arrays`.
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|    Examples
    89|         0|            0|            0|  0.00%|    --------
    90|         0|            0|            0|  0.00%|    >>> x = np.arange(6)
    91|         0|            0|            0|  0.00%|    >>> np.select([x <3, x > 3], [x**2, x**3], default=0)
    92|         0|            0|            0|  0.00%|    array([  0,   1,   4,   0,  64, 125])
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|    >>> _lazyselect([x < 3, x > 3], [lambda x: x**2, lambda x: x**3], (x,))
    95|         0|            0|            0|  0.00%|    array([   0.,    1.,    4.,   0.,   64.,  125.])
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|    >>> a = -np.ones_like(x)
    98|         0|            0|            0|  0.00%|    >>> _lazyselect([x < 3, x > 3],
    99|         0|            0|            0|  0.00%|    ...             [lambda x, a: x**2, lambda x, a: a * x**3],
   100|         0|            0|            0|  0.00%|    ...             (x, a), default=np.nan)
   101|         0|            0|            0|  0.00%|    array([   0.,    1.,    4.,   nan,  -64., -125.])
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    """
   104|         0|            0|            0|  0.00%|    arrays = np.broadcast_arrays(*arrays)
   105|         0|            0|            0|  0.00%|    tcode = np.mintypecode([a.dtype.char for a in arrays])
   106|         0|            0|            0|  0.00%|    out = np.full(np.shape(arrays[0]), fill_value=default, dtype=tcode)
   107|         0|            0|            0|  0.00%|    for index in range(len(condlist)):
   108|         0|            0|            0|  0.00%|        func, cond = choicelist[index], condlist[index]
   109|         0|            0|            0|  0.00%|        if np.all(cond is False):
   110|         0|            0|            0|  0.00%|            continue
   111|         0|            0|            0|  0.00%|        cond, _ = np.broadcast_arrays(cond, arrays[0])
   112|         0|            0|            0|  0.00%|        temp = tuple(np.extract(cond, arr) for arr in arrays)
   113|         0|            0|            0|  0.00%|        np.place(out, cond, func(*temp))
   114|         0|            0|            0|  0.00%|    return out
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|def _aligned_zeros(shape, dtype=float, order="C", align=None):
   118|         0|            0|            0|  0.00%|    """Allocate a new ndarray with aligned memory.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    Primary use case for this currently is working around a f2py issue
   121|         0|            0|            0|  0.00%|    in NumPy 1.9.1, where dtype.alignment is such that np.zeros() does
   122|         0|            0|            0|  0.00%|    not necessarily create arrays aligned up to it.
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    """
   125|         0|            0|            0|  0.00%|    dtype = np.dtype(dtype)
   126|         0|            0|            0|  0.00%|    if align is None:
   127|         0|            0|            0|  0.00%|        align = dtype.alignment
   128|         0|            0|            0|  0.00%|    if not hasattr(shape, '__len__'):
   129|         0|            0|            0|  0.00%|        shape = (shape,)
   130|         0|            0|            0|  0.00%|    size = functools.reduce(operator.mul, shape) * dtype.itemsize
   131|         0|            0|            0|  0.00%|    buf = np.empty(size + align + 1, np.uint8)
   132|         0|            0|            0|  0.00%|    offset = buf.__array_interface__['data'][0] % align
   133|         0|            0|            0|  0.00%|    if offset != 0:
   134|         0|            0|            0|  0.00%|        offset = align - offset
   135|         0|            0|            0|  0.00%|    # Note: slices producing 0-size arrays do not necessarily change
   136|         0|            0|            0|  0.00%|    # data pointer --- so we use and allocate size+1
   137|         0|            0|            0|  0.00%|    buf = buf[offset:offset+size+1][:-1]
   138|         0|            0|            0|  0.00%|    data = np.ndarray(shape, dtype, buf, order=order)
   139|         0|            0|            0|  0.00%|    data.fill(0)
   140|         0|            0|            0|  0.00%|    return data
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|
   143|        36|            0|            0|  0.00%|def _prune_array(array):
   144|         0|            0|            0|  0.00%|    """Return an array equivalent to the input array. If the input
   145|         0|            0|            0|  0.00%|    array is a view of a much larger array, copy its contents to a
   146|         0|            0|            0|  0.00%|    newly allocated array. Otherwise, return the input unchanged.
   147|         0|            0|            0|  0.00%|    """
   148|        36|            0|            0|  0.00%|    if array.base is not None and array.size < array.base.size // 2:
   149|         4|            0|            0|  0.00%|        return array.copy()
   150|        32|            0|            0|  0.00%|    return array
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|def prod(iterable):
   154|         0|            0|            0|  0.00%|    """
   155|         0|            0|            0|  0.00%|    Product of a sequence of numbers.
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    Faster than np.prod for short lists like array shapes, and does
   158|         0|            0|            0|  0.00%|    not overflow if using Python integers.
   159|         0|            0|            0|  0.00%|    """
   160|         0|            0|            0|  0.00%|    product = 1
   161|         0|            0|            0|  0.00%|    for x in iterable:
   162|         0|            0|            0|  0.00%|        product *= x
   163|         0|            0|            0|  0.00%|    return product
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|def float_factorial(n: int) -> float:
   167|         0|            0|            0|  0.00%|    """Compute the factorial and return as a float
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|    Returns infinity when result is too large for a double
   170|         0|            0|            0|  0.00%|    """
   171|         0|            0|            0|  0.00%|    return float(math.factorial(n)) if n < 171 else np.inf
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|class DeprecatedImport:
   175|         0|            0|            0|  0.00%|    """
   176|         0|            0|            0|  0.00%|    Deprecated import with redirection and warning.
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    Examples
   179|         0|            0|            0|  0.00%|    --------
   180|         0|            0|            0|  0.00%|    Suppose you previously had in some module::
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|        from foo import spam
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|    If this has to be deprecated, do::
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|        spam = DeprecatedImport("foo.spam", "baz")
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    to redirect users to use "baz" module instead.
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    """
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|    def __init__(self, old_module_name, new_module_name):
   193|         0|            0|            0|  0.00%|        self._old_name = old_module_name
   194|         0|            0|            0|  0.00%|        self._new_name = new_module_name
   195|         0|            0|            0|  0.00%|        __import__(self._new_name)
   196|         0|            0|            0|  0.00%|        self._mod = sys.modules[self._new_name]
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    def __dir__(self):
   199|         0|            0|            0|  0.00%|        return dir(self._mod)
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    def __getattr__(self, name):
   202|         0|            0|            0|  0.00%|        warnings.warn("Module %s is deprecated, use %s instead"
   203|         0|            0|            0|  0.00%|                      % (self._old_name, self._new_name),
   204|         0|            0|            0|  0.00%|                      DeprecationWarning)
   205|         0|            0|            0|  0.00%|        return getattr(self._mod, name)
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|# copy-pasted from scikit-learn utils/validation.py
   209|         0|            0|            0|  0.00%|# change this to scipy.stats._qmc.check_random_state once numpy 1.16 is dropped
   210|         0|            0|            0|  0.00%|def check_random_state(seed):
   211|         0|            0|            0|  0.00%|    """Turn `seed` into a `np.random.RandomState` instance.
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    Parameters
   214|         0|            0|            0|  0.00%|    ----------
   215|         0|            0|            0|  0.00%|    seed : {None, int, `numpy.random.Generator`,
   216|         0|            0|            0|  0.00%|            `numpy.random.RandomState`}, optional
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|        If `seed` is None (or `np.random`), the `numpy.random.RandomState`
   219|         0|            0|            0|  0.00%|        singleton is used.
   220|         0|            0|            0|  0.00%|        If `seed` is an int, a new ``RandomState`` instance is used,
   221|         0|            0|            0|  0.00%|        seeded with `seed`.
   222|         0|            0|            0|  0.00%|        If `seed` is already a ``Generator`` or ``RandomState`` instance then
   223|         0|            0|            0|  0.00%|        that instance is used.
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|    Returns
   226|         0|            0|            0|  0.00%|    -------
   227|         0|            0|            0|  0.00%|    seed : {`numpy.random.Generator`, `numpy.random.RandomState`}
   228|         0|            0|            0|  0.00%|        Random number generator.
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|    """
   231|         0|            0|            0|  0.00%|    if seed is None or seed is np.random:
   232|         0|            0|            0|  0.00%|        return np.random.mtrand._rand
   233|         0|            0|            0|  0.00%|    if isinstance(seed, (numbers.Integral, np.integer)):
   234|         0|            0|            0|  0.00%|        return np.random.RandomState(seed)
   235|         0|            0|            0|  0.00%|    if isinstance(seed, np.random.RandomState):
   236|         0|            0|            0|  0.00%|        return seed
   237|         0|            0|            0|  0.00%|    try:
   238|         0|            0|            0|  0.00%|        # Generator is only available in numpy >= 1.17
   239|         0|            0|            0|  0.00%|        if isinstance(seed, np.random.Generator):
   240|         0|            0|            0|  0.00%|            return seed
   241|         0|            0|            0|  0.00%|    except AttributeError:
   242|         0|            0|            0|  0.00%|        pass
   243|         0|            0|            0|  0.00%|    raise ValueError('%r cannot be used to seed a numpy.random.RandomState'
   244|         0|            0|            0|  0.00%|                     ' instance' % seed)
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|def _asarray_validated(a, check_finite=True,
   248|         0|            0|            0|  0.00%|                       sparse_ok=False, objects_ok=False, mask_ok=False,
   249|         0|            0|            0|  0.00%|                       as_inexact=False):
   250|         0|            0|            0|  0.00%|    """
   251|         0|            0|            0|  0.00%|    Helper function for SciPy argument validation.
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|    Many SciPy linear algebra functions do support arbitrary array-like
   254|         0|            0|            0|  0.00%|    input arguments. Examples of commonly unsupported inputs include
   255|         0|            0|            0|  0.00%|    matrices containing inf/nan, sparse matrix representations, and
   256|         0|            0|            0|  0.00%|    matrices with complicated elements.
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|    Parameters
   259|         0|            0|            0|  0.00%|    ----------
   260|         0|            0|            0|  0.00%|    a : array_like
   261|         0|            0|            0|  0.00%|        The array-like input.
   262|         0|            0|            0|  0.00%|    check_finite : bool, optional
   263|         0|            0|            0|  0.00%|        Whether to check that the input matrices contain only finite numbers.
   264|         0|            0|            0|  0.00%|        Disabling may give a performance gain, but may result in problems
   265|         0|            0|            0|  0.00%|        (crashes, non-termination) if the inputs do contain infinities or NaNs.
   266|         0|            0|            0|  0.00%|        Default: True
   267|         0|            0|            0|  0.00%|    sparse_ok : bool, optional
   268|         0|            0|            0|  0.00%|        True if scipy sparse matrices are allowed.
   269|         0|            0|            0|  0.00%|    objects_ok : bool, optional
   270|         0|            0|            0|  0.00%|        True if arrays with dype('O') are allowed.
   271|         0|            0|            0|  0.00%|    mask_ok : bool, optional
   272|         0|            0|            0|  0.00%|        True if masked arrays are allowed.
   273|         0|            0|            0|  0.00%|    as_inexact : bool, optional
   274|         0|            0|            0|  0.00%|        True to convert the input array to a np.inexact dtype.
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    Returns
   277|         0|            0|            0|  0.00%|    -------
   278|         0|            0|            0|  0.00%|    ret : ndarray
   279|         0|            0|            0|  0.00%|        The converted validated array.
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    """
   282|         0|            0|            0|  0.00%|    if not sparse_ok:
   283|         0|            0|            0|  0.00%|        import scipy.sparse
   284|         0|            0|            0|  0.00%|        if scipy.sparse.issparse(a):
   285|         0|            0|            0|  0.00%|            msg = ('Sparse matrices are not supported by this function. '
   286|         0|            0|            0|  0.00%|                   'Perhaps one of the scipy.sparse.linalg functions '
   287|         0|            0|            0|  0.00%|                   'would work instead.')
   288|         0|            0|            0|  0.00%|            raise ValueError(msg)
   289|         0|            0|            0|  0.00%|    if not mask_ok:
   290|         0|            0|            0|  0.00%|        if np.ma.isMaskedArray(a):
   291|         0|            0|            0|  0.00%|            raise ValueError('masked arrays are not supported')
   292|         0|            0|            0|  0.00%|    toarray = np.asarray_chkfinite if check_finite else np.asarray
   293|         0|            0|            0|  0.00%|    a = toarray(a)
   294|         0|            0|            0|  0.00%|    if not objects_ok:
   295|         0|            0|            0|  0.00%|        if a.dtype is np.dtype('O'):
   296|         0|            0|            0|  0.00%|            raise ValueError('object arrays are not supported')
   297|         0|            0|            0|  0.00%|    if as_inexact:
   298|         0|            0|            0|  0.00%|        if not np.issubdtype(a.dtype, np.inexact):
   299|         0|            0|            0|  0.00%|            a = toarray(a, dtype=np.float_)
   300|         0|            0|            0|  0.00%|    return a
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|def _validate_int(k, name, minimum=None):
   304|         0|            0|            0|  0.00%|    """
   305|         0|            0|            0|  0.00%|    Validate a scalar integer.
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    This functon can be used to validate an argument to a function
   308|         0|            0|            0|  0.00%|    that expects the value to be an integer.  It uses `operator.index`
   309|         0|            0|            0|  0.00%|    to validate the value (so, for example, k=2.0 results in a
   310|         0|            0|            0|  0.00%|    TypeError).
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    Parameters
   313|         0|            0|            0|  0.00%|    ----------
   314|         0|            0|            0|  0.00%|    k : int
   315|         0|            0|            0|  0.00%|        The value to be validated.
   316|         0|            0|            0|  0.00%|    name : str
   317|         0|            0|            0|  0.00%|        The name of the parameter.
   318|         0|            0|            0|  0.00%|    minimum : int, optional
   319|         0|            0|            0|  0.00%|        An optional lower bound.
   320|         0|            0|            0|  0.00%|    """
   321|         0|            0|            0|  0.00%|    try:
   322|         0|            0|            0|  0.00%|        k = operator.index(k)
   323|         0|            0|            0|  0.00%|    except TypeError:
   324|         0|            0|            0|  0.00%|        raise TypeError(f'{name} must be an integer.') from None
   325|         0|            0|            0|  0.00%|    if minimum is not None and k < minimum:
   326|         0|            0|            0|  0.00%|        raise ValueError(f'{name} must be an integer not less '
   327|         0|            0|            0|  0.00%|                         f'than {minimum}') from None
   328|         0|            0|            0|  0.00%|    return k
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|# Add a replacement for inspect.getfullargspec()/
   332|         0|            0|            0|  0.00%|# The version below is borrowed from Django,
   333|         0|            0|            0|  0.00%|# https://github.com/django/django/pull/4846.
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|# Note an inconsistency between inspect.getfullargspec(func) and
   336|         0|            0|            0|  0.00%|# inspect.signature(func). If `func` is a bound method, the latter does *not*
   337|         0|            0|            0|  0.00%|# list `self` as a first argument, while the former *does*.
   338|         0|            0|            0|  0.00%|# Hence, cook up a common ground replacement: `getfullargspec_no_self` which
   339|         0|            0|            0|  0.00%|# mimics `inspect.getfullargspec` but does not list `self`.
   340|         0|            0|            0|  0.00%|#
   341|         0|            0|            0|  0.00%|# This way, the caller code does not need to know whether it uses a legacy
   342|         0|            0|            0|  0.00%|# .getfullargspec or a bright and shiny .signature.
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|FullArgSpec = namedtuple('FullArgSpec',
   345|         0|            0|            0|  0.00%|                         ['args', 'varargs', 'varkw', 'defaults',
   346|         0|            0|            0|  0.00%|                          'kwonlyargs', 'kwonlydefaults', 'annotations'])
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|def getfullargspec_no_self(func):
   350|         0|            0|            0|  0.00%|    """inspect.getfullargspec replacement using inspect.signature.
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    If func is a bound method, do not list the 'self' parameter.
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    Parameters
   355|         0|            0|            0|  0.00%|    ----------
   356|         0|            0|            0|  0.00%|    func : callable
   357|         0|            0|            0|  0.00%|        A callable to inspect
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|    Returns
   360|         0|            0|            0|  0.00%|    -------
   361|         0|            0|            0|  0.00%|    fullargspec : FullArgSpec(args, varargs, varkw, defaults, kwonlyargs,
   362|         0|            0|            0|  0.00%|                              kwonlydefaults, annotations)
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|        NOTE: if the first argument of `func` is self, it is *not*, I repeat
   365|         0|            0|            0|  0.00%|        *not*, included in fullargspec.args.
   366|         0|            0|            0|  0.00%|        This is done for consistency between inspect.getargspec() under
   367|         0|            0|            0|  0.00%|        Python 2.x, and inspect.signature() under Python 3.x.
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|    """
   370|         0|            0|            0|  0.00%|    sig = inspect.signature(func)
   371|         0|            0|            0|  0.00%|    args = [
   372|         0|            0|            0|  0.00%|        p.name for p in sig.parameters.values()
   373|         0|            0|            0|  0.00%|        if p.kind in [inspect.Parameter.POSITIONAL_OR_KEYWORD,
   374|         0|            0|            0|  0.00%|                      inspect.Parameter.POSITIONAL_ONLY]
   375|         0|            0|            0|  0.00%|    ]
   376|         0|            0|            0|  0.00%|    varargs = [
   377|         0|            0|            0|  0.00%|        p.name for p in sig.parameters.values()
   378|         0|            0|            0|  0.00%|        if p.kind == inspect.Parameter.VAR_POSITIONAL
   379|         0|            0|            0|  0.00%|    ]
   380|         0|            0|            0|  0.00%|    varargs = varargs[0] if varargs else None
   381|         0|            0|            0|  0.00%|    varkw = [
   382|         0|            0|            0|  0.00%|        p.name for p in sig.parameters.values()
   383|         0|            0|            0|  0.00%|        if p.kind == inspect.Parameter.VAR_KEYWORD
   384|         0|            0|            0|  0.00%|    ]
   385|         0|            0|            0|  0.00%|    varkw = varkw[0] if varkw else None
   386|         0|            0|            0|  0.00%|    defaults = tuple(
   387|         0|            0|            0|  0.00%|        p.default for p in sig.parameters.values()
   388|         0|            0|            0|  0.00%|        if (p.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD and
   389|         0|            0|            0|  0.00%|            p.default is not p.empty)
   390|         0|            0|            0|  0.00%|    ) or None
   391|         0|            0|            0|  0.00%|    kwonlyargs = [
   392|         0|            0|            0|  0.00%|        p.name for p in sig.parameters.values()
   393|         0|            0|            0|  0.00%|        if p.kind == inspect.Parameter.KEYWORD_ONLY
   394|         0|            0|            0|  0.00%|    ]
   395|         0|            0|            0|  0.00%|    kwdefaults = {p.name: p.default for p in sig.parameters.values()
   396|         0|            0|            0|  0.00%|                  if p.kind == inspect.Parameter.KEYWORD_ONLY and
   397|         0|            0|            0|  0.00%|                  p.default is not p.empty}
   398|         0|            0|            0|  0.00%|    annotations = {p.name: p.annotation for p in sig.parameters.values()
   399|         0|            0|            0|  0.00%|                   if p.annotation is not p.empty}
   400|         0|            0|            0|  0.00%|    return FullArgSpec(args, varargs, varkw, defaults, kwonlyargs,
   401|         0|            0|            0|  0.00%|                       kwdefaults or None, annotations)
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|class MapWrapper:
   405|         0|            0|            0|  0.00%|    """
   406|         0|            0|            0|  0.00%|    Parallelisation wrapper for working with map-like callables, such as
   407|         0|            0|            0|  0.00%|    `multiprocessing.Pool.map`.
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    Parameters
   410|         0|            0|            0|  0.00%|    ----------
   411|         0|            0|            0|  0.00%|    pool : int or map-like callable
   412|         0|            0|            0|  0.00%|        If `pool` is an integer, then it specifies the number of threads to
   413|         0|            0|            0|  0.00%|        use for parallelization. If ``int(pool) == 1``, then no parallel
   414|         0|            0|            0|  0.00%|        processing is used and the map builtin is used.
   415|         0|            0|            0|  0.00%|        If ``pool == -1``, then the pool will utilize all available CPUs.
   416|         0|            0|            0|  0.00%|        If `pool` is a map-like callable that follows the same
   417|         0|            0|            0|  0.00%|        calling sequence as the built-in map function, then this callable is
   418|         0|            0|            0|  0.00%|        used for parallelization.
   419|         0|            0|            0|  0.00%|    """
   420|         0|            0|            0|  0.00%|    def __init__(self, pool=1):
   421|         0|            0|            0|  0.00%|        self.pool = None
   422|         0|            0|            0|  0.00%|        self._mapfunc = map
   423|         0|            0|            0|  0.00%|        self._own_pool = False
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|        if callable(pool):
   426|         0|            0|            0|  0.00%|            self.pool = pool
   427|         0|            0|            0|  0.00%|            self._mapfunc = self.pool
   428|         0|            0|            0|  0.00%|        else:
   429|         0|            0|            0|  0.00%|            from multiprocessing import Pool
   430|         0|            0|            0|  0.00%|            # user supplies a number
   431|         0|            0|            0|  0.00%|            if int(pool) == -1:
   432|         0|            0|            0|  0.00%|                # use as many processors as possible
   433|         0|            0|            0|  0.00%|                self.pool = Pool()
   434|         0|            0|            0|  0.00%|                self._mapfunc = self.pool.map
   435|         0|            0|            0|  0.00%|                self._own_pool = True
   436|         0|            0|            0|  0.00%|            elif int(pool) == 1:
   437|         0|            0|            0|  0.00%|                pass
   438|         0|            0|            0|  0.00%|            elif int(pool) > 1:
   439|         0|            0|            0|  0.00%|                # use the number of processors requested
   440|         0|            0|            0|  0.00%|                self.pool = Pool(processes=int(pool))
   441|         0|            0|            0|  0.00%|                self._mapfunc = self.pool.map
   442|         0|            0|            0|  0.00%|                self._own_pool = True
   443|         0|            0|            0|  0.00%|            else:
   444|         0|            0|            0|  0.00%|                raise RuntimeError("Number of workers specified must be -1,"
   445|         0|            0|            0|  0.00%|                                   " an int >= 1, or an object with a 'map' "
   446|         0|            0|            0|  0.00%|                                   "method")
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|    def __enter__(self):
   449|         0|            0|            0|  0.00%|        return self
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|    def terminate(self):
   452|         0|            0|            0|  0.00%|        if self._own_pool:
   453|         0|            0|            0|  0.00%|            self.pool.terminate()
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    def join(self):
   456|         0|            0|            0|  0.00%|        if self._own_pool:
   457|         0|            0|            0|  0.00%|            self.pool.join()
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    def close(self):
   460|         0|            0|            0|  0.00%|        if self._own_pool:
   461|         0|            0|            0|  0.00%|            self.pool.close()
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|    def __exit__(self, exc_type, exc_value, traceback):
   464|         0|            0|            0|  0.00%|        if self._own_pool:
   465|         0|            0|            0|  0.00%|            self.pool.close()
   466|         0|            0|            0|  0.00%|            self.pool.terminate()
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|    def __call__(self, func, iterable):
   469|         0|            0|            0|  0.00%|        # only accept one iterable because that's all Pool.map accepts
   470|         0|            0|            0|  0.00%|        try:
   471|         0|            0|            0|  0.00%|            return self._mapfunc(func, iterable)
   472|         0|            0|            0|  0.00%|        except TypeError as e:
   473|         0|            0|            0|  0.00%|            # wrong number of arguments
   474|         0|            0|            0|  0.00%|            raise TypeError("The map-like callable must be of the"
   475|         0|            0|            0|  0.00%|                            " form f(func, iterable)") from e
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|def rng_integers(gen, low, high=None, size=None, dtype='int64',
   479|         0|            0|            0|  0.00%|                 endpoint=False):
   480|         0|            0|            0|  0.00%|    """
   481|         0|            0|            0|  0.00%|    Return random integers from low (inclusive) to high (exclusive), or if
   482|         0|            0|            0|  0.00%|    endpoint=True, low (inclusive) to high (inclusive). Replaces
   483|         0|            0|            0|  0.00%|    `RandomState.randint` (with endpoint=False) and
   484|         0|            0|            0|  0.00%|    `RandomState.random_integers` (with endpoint=True).
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|    Return random integers from the "discrete uniform" distribution of the
   487|         0|            0|            0|  0.00%|    specified dtype. If high is None (the default), then results are from
   488|         0|            0|            0|  0.00%|    0 to low.
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|    Parameters
   491|         0|            0|            0|  0.00%|    ----------
   492|         0|            0|            0|  0.00%|    gen : {None, np.random.RandomState, np.random.Generator}
   493|         0|            0|            0|  0.00%|        Random number generator. If None, then the np.random.RandomState
   494|         0|            0|            0|  0.00%|        singleton is used.
   495|         0|            0|            0|  0.00%|    low : int or array-like of ints
   496|         0|            0|            0|  0.00%|        Lowest (signed) integers to be drawn from the distribution (unless
   497|         0|            0|            0|  0.00%|        high=None, in which case this parameter is 0 and this value is used
   498|         0|            0|            0|  0.00%|        for high).
   499|         0|            0|            0|  0.00%|    high : int or array-like of ints
   500|         0|            0|            0|  0.00%|        If provided, one above the largest (signed) integer to be drawn from
   501|         0|            0|            0|  0.00%|        the distribution (see above for behavior if high=None). If array-like,
   502|         0|            0|            0|  0.00%|        must contain integer values.
   503|         0|            0|            0|  0.00%|    size : array-like of ints, optional
   504|         0|            0|            0|  0.00%|        Output shape. If the given shape is, e.g., (m, n, k), then m * n * k
   505|         0|            0|            0|  0.00%|        samples are drawn. Default is None, in which case a single value is
   506|         0|            0|            0|  0.00%|        returned.
   507|         0|            0|            0|  0.00%|    dtype : {str, dtype}, optional
   508|         0|            0|            0|  0.00%|        Desired dtype of the result. All dtypes are determined by their name,
   509|         0|            0|            0|  0.00%|        i.e., 'int64', 'int', etc, so byteorder is not available and a specific
   510|         0|            0|            0|  0.00%|        precision may have different C types depending on the platform.
   511|         0|            0|            0|  0.00%|        The default value is np.int_.
   512|         0|            0|            0|  0.00%|    endpoint : bool, optional
   513|         0|            0|            0|  0.00%|        If True, sample from the interval [low, high] instead of the default
   514|         0|            0|            0|  0.00%|        [low, high) Defaults to False.
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    Returns
   517|         0|            0|            0|  0.00%|    -------
   518|         0|            0|            0|  0.00%|    out: int or ndarray of ints
   519|         0|            0|            0|  0.00%|        size-shaped array of random integers from the appropriate distribution,
   520|         0|            0|            0|  0.00%|        or a single such random int if size not provided.
   521|         0|            0|            0|  0.00%|    """
   522|         0|            0|            0|  0.00%|    if isinstance(gen, Generator):
   523|         0|            0|            0|  0.00%|        return gen.integers(low, high=high, size=size, dtype=dtype,
   524|         0|            0|            0|  0.00%|                            endpoint=endpoint)
   525|         0|            0|            0|  0.00%|    else:
   526|         0|            0|            0|  0.00%|        if gen is None:
   527|         0|            0|            0|  0.00%|            # default is RandomState singleton used by np.random.
   528|         0|            0|            0|  0.00%|            gen = np.random.mtrand._rand
   529|         0|            0|            0|  0.00%|        if endpoint:
   530|         0|            0|            0|  0.00%|            # inclusive of endpoint
   531|         0|            0|            0|  0.00%|            # remember that low and high can be arrays, so don't modify in
   532|         0|            0|            0|  0.00%|            # place
   533|         0|            0|            0|  0.00%|            if high is None:
   534|         0|            0|            0|  0.00%|                return gen.randint(low + 1, size=size, dtype=dtype)
   535|         0|            0|            0|  0.00%|            if high is not None:
   536|         0|            0|            0|  0.00%|                return gen.randint(low, high=high + 1, size=size, dtype=dtype)
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|        # exclusive
   539|         0|            0|            0|  0.00%|        return gen.randint(low, high=high, size=size, dtype=dtype)
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|@contextmanager
   543|         0|            0|            0|  0.00%|def _fixed_default_rng(seed=1638083107694713882823079058616272161):
   544|         0|            0|            0|  0.00%|    """Context with a fixed np.random.default_rng seed."""
   545|         0|            0|            0|  0.00%|    orig_fun = np.random.default_rng
   546|         0|            0|            0|  0.00%|    np.random.default_rng = lambda seed=seed: orig_fun(seed)
   547|         0|            0|            0|  0.00%|    try:
   548|         0|            0|            0|  0.00%|        yield
   549|         0|            0|            0|  0.00%|    finally:
   550|         0|            0|            0|  0.00%|        np.random.default_rng = orig_fun
File: <frozen importlib._bootstrap>
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|
   389|        24|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|
   392|        24|            0|            0|  0.00%|
   393|        24|            0|            0|  0.00%|
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\_config.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Global configuration state and functions for management
     2|         0|            0|            0|  0.00%|"""
     3|         0|            0|            0|  0.00%|import os
     4|         0|            0|            0|  0.00%|from contextlib import contextmanager as contextmanager
     5|         0|            0|            0|  0.00%|import threading
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|_global_config = {
     8|         0|            0|            0|  0.00%|    "assume_finite": bool(os.environ.get("SKLEARN_ASSUME_FINITE", False)),
     9|         0|            0|            0|  0.00%|    "working_memory": int(os.environ.get("SKLEARN_WORKING_MEMORY", 1024)),
    10|         0|            0|            0|  0.00%|    "print_changed_only": True,
    11|         0|            0|            0|  0.00%|    "display": "text",
    12|         0|            0|            0|  0.00%|}
    13|         0|            0|            0|  0.00%|_threadlocal = threading.local()
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|        12|            0|            0|  0.00%|def _get_threadlocal_config():
    17|         0|            0|            0|  0.00%|    """Get a threadlocal **mutable** configuration. If the configuration
    18|         0|            0|            0|  0.00%|    does not exist, copy the default global configuration."""
    19|        12|            0|            0|  0.00%|    if not hasattr(_threadlocal, "global_config"):
    20|         1|            0|            0|  0.00%|        _threadlocal.global_config = _global_config.copy()
    21|        12|            0|            0|  0.00%|    return _threadlocal.global_config
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|        12|            0|            0|  0.00%|def get_config():
    25|         0|            0|            0|  0.00%|    """Retrieve current values for configuration set by :func:`set_config`
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    Returns
    28|         0|            0|            0|  0.00%|    -------
    29|         0|            0|            0|  0.00%|    config : dict
    30|         0|            0|            0|  0.00%|        Keys are parameter names that can be passed to :func:`set_config`.
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|    See Also
    33|         0|            0|            0|  0.00%|    --------
    34|         0|            0|            0|  0.00%|    config_context : Context manager for global scikit-learn configuration.
    35|         0|            0|            0|  0.00%|    set_config : Set global scikit-learn configuration.
    36|         0|            0|            0|  0.00%|    """
    37|         0|            0|            0|  0.00%|    # Return a copy of the threadlocal configuration so that users will
    38|         0|            0|            0|  0.00%|    # not be able to modify the configuration with the returned dict.
    39|        12|            0|            0|  0.00%|    return _get_threadlocal_config().copy()
(call)|        12|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\_config.py:16 _get_threadlocal_config
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|def set_config(
    43|         0|            0|            0|  0.00%|    assume_finite=None, working_memory=None, print_changed_only=None, display=None
    44|         0|            0|            0|  0.00%|):
    45|         0|            0|            0|  0.00%|    """Set global scikit-learn configuration
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    .. versionadded:: 0.19
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|    Parameters
    50|         0|            0|            0|  0.00%|    ----------
    51|         0|            0|            0|  0.00%|    assume_finite : bool, default=None
    52|         0|            0|            0|  0.00%|        If True, validation for finiteness will be skipped,
    53|         0|            0|            0|  0.00%|        saving time, but leading to potential crashes. If
    54|         0|            0|            0|  0.00%|        False, validation for finiteness will be performed,
    55|         0|            0|            0|  0.00%|        avoiding error.  Global default: False.
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|        .. versionadded:: 0.19
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|    working_memory : int, default=None
    60|         0|            0|            0|  0.00%|        If set, scikit-learn will attempt to limit the size of temporary arrays
    61|         0|            0|            0|  0.00%|        to this number of MiB (per job when parallelised), often saving both
    62|         0|            0|            0|  0.00%|        computation time and memory on expensive operations that can be
    63|         0|            0|            0|  0.00%|        performed in chunks. Global default: 1024.
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|        .. versionadded:: 0.20
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|    print_changed_only : bool, default=None
    68|         0|            0|            0|  0.00%|        If True, only the parameters that were set to non-default
    69|         0|            0|            0|  0.00%|        values will be printed when printing an estimator. For example,
    70|         0|            0|            0|  0.00%|        ``print(SVC())`` while True will only print 'SVC()' while the default
    71|         0|            0|            0|  0.00%|        behaviour would be to print 'SVC(C=1.0, cache_size=200, ...)' with
    72|         0|            0|            0|  0.00%|        all the non-changed parameters.
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|        .. versionadded:: 0.21
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|    display : {'text', 'diagram'}, default=None
    77|         0|            0|            0|  0.00%|        If 'diagram', estimators will be displayed as a diagram in a Jupyter
    78|         0|            0|            0|  0.00%|        lab or notebook context. If 'text', estimators will be displayed as
    79|         0|            0|            0|  0.00%|        text. Default is 'text'.
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|        .. versionadded:: 0.23
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|    See Also
    84|         0|            0|            0|  0.00%|    --------
    85|         0|            0|            0|  0.00%|    config_context : Context manager for global scikit-learn configuration.
    86|         0|            0|            0|  0.00%|    get_config : Retrieve current values of the global configuration.
    87|         0|            0|            0|  0.00%|    """
    88|         0|            0|            0|  0.00%|    local_config = _get_threadlocal_config()
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    if assume_finite is not None:
    91|         0|            0|            0|  0.00%|        local_config["assume_finite"] = assume_finite
    92|         0|            0|            0|  0.00%|    if working_memory is not None:
    93|         0|            0|            0|  0.00%|        local_config["working_memory"] = working_memory
    94|         0|            0|            0|  0.00%|    if print_changed_only is not None:
    95|         0|            0|            0|  0.00%|        local_config["print_changed_only"] = print_changed_only
    96|         0|            0|            0|  0.00%|    if display is not None:
    97|         0|            0|            0|  0.00%|        local_config["display"] = display
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|@contextmanager
   101|         0|            0|            0|  0.00%|def config_context(**new_config):
   102|         0|            0|            0|  0.00%|    """Context manager for global scikit-learn configuration
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    Parameters
   105|         0|            0|            0|  0.00%|    ----------
   106|         0|            0|            0|  0.00%|    assume_finite : bool, default=False
   107|         0|            0|            0|  0.00%|        If True, validation for finiteness will be skipped,
   108|         0|            0|            0|  0.00%|        saving time, but leading to potential crashes. If
   109|         0|            0|            0|  0.00%|        False, validation for finiteness will be performed,
   110|         0|            0|            0|  0.00%|        avoiding error.  Global default: False.
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|    working_memory : int, default=1024
   113|         0|            0|            0|  0.00%|        If set, scikit-learn will attempt to limit the size of temporary arrays
   114|         0|            0|            0|  0.00%|        to this number of MiB (per job when parallelised), often saving both
   115|         0|            0|            0|  0.00%|        computation time and memory on expensive operations that can be
   116|         0|            0|            0|  0.00%|        performed in chunks. Global default: 1024.
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    print_changed_only : bool, default=True
   119|         0|            0|            0|  0.00%|        If True, only the parameters that were set to non-default
   120|         0|            0|            0|  0.00%|        values will be printed when printing an estimator. For example,
   121|         0|            0|            0|  0.00%|        ``print(SVC())`` while True will only print 'SVC()', but would print
   122|         0|            0|            0|  0.00%|        'SVC(C=1.0, cache_size=200, ...)' with all the non-changed parameters
   123|         0|            0|            0|  0.00%|        when False. Default is True.
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|        .. versionchanged:: 0.23
   126|         0|            0|            0|  0.00%|           Default changed from False to True.
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|    display : {'text', 'diagram'}, default='text'
   129|         0|            0|            0|  0.00%|        If 'diagram', estimators will be displayed as a diagram in a Jupyter
   130|         0|            0|            0|  0.00%|        lab or notebook context. If 'text', estimators will be displayed as
   131|         0|            0|            0|  0.00%|        text. Default is 'text'.
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|        .. versionadded:: 0.23
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|    Notes
   136|         0|            0|            0|  0.00%|    -----
   137|         0|            0|            0|  0.00%|    All settings, not just those presently modified, will be returned to
   138|         0|            0|            0|  0.00%|    their previous values when the context manager is exited.
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    Examples
   141|         0|            0|            0|  0.00%|    --------
   142|         0|            0|            0|  0.00%|    >>> import sklearn
   143|         0|            0|            0|  0.00%|    >>> from sklearn.utils.validation import assert_all_finite
   144|         0|            0|            0|  0.00%|    >>> with sklearn.config_context(assume_finite=True):
   145|         0|            0|            0|  0.00%|    ...     assert_all_finite([float('nan')])
   146|         0|            0|            0|  0.00%|    >>> with sklearn.config_context(assume_finite=True):
   147|         0|            0|            0|  0.00%|    ...     with sklearn.config_context(assume_finite=False):
   148|         0|            0|            0|  0.00%|    ...         assert_all_finite([float('nan')])
   149|         0|            0|            0|  0.00%|    Traceback (most recent call last):
   150|         0|            0|            0|  0.00%|    ...
   151|         0|            0|            0|  0.00%|    ValueError: Input contains NaN, ...
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    See Also
   154|         0|            0|            0|  0.00%|    --------
   155|         0|            0|            0|  0.00%|    set_config : Set global scikit-learn configuration.
   156|         0|            0|            0|  0.00%|    get_config : Retrieve current values of the global configuration.
   157|         0|            0|            0|  0.00%|    """
   158|         0|            0|            0|  0.00%|    old_config = get_config()
   159|         0|            0|            0|  0.00%|    set_config(**new_config)
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|    try:
   162|         0|            0|            0|  0.00%|        yield
   163|         0|            0|            0|  0.00%|    finally:
   164|         0|            0|            0|  0.00%|        set_config(**old_config)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\_collections_abc.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# Copyright 2007 Google, Inc. All Rights Reserved.
     2|         0|            0|            0|  0.00%|# Licensed to PSF under a Contributor Agreement.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|"""Abstract Base Classes (ABCs) for collections, according to PEP 3119.
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|Unit tests are in test_collections.
     7|         0|            0|            0|  0.00%|"""
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from abc import ABCMeta, abstractmethod
    10|         0|            0|            0|  0.00%|import sys
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|__all__ = ["Awaitable", "Coroutine",
    13|         0|            0|            0|  0.00%|           "AsyncIterable", "AsyncIterator", "AsyncGenerator",
    14|         0|            0|            0|  0.00%|           "Hashable", "Iterable", "Iterator", "Generator", "Reversible",
    15|         0|            0|            0|  0.00%|           "Sized", "Container", "Callable", "Collection",
    16|         0|            0|            0|  0.00%|           "Set", "MutableSet",
    17|         0|            0|            0|  0.00%|           "Mapping", "MutableMapping",
    18|         0|            0|            0|  0.00%|           "MappingView", "KeysView", "ItemsView", "ValuesView",
    19|         0|            0|            0|  0.00%|           "Sequence", "MutableSequence",
    20|         0|            0|            0|  0.00%|           "ByteString",
    21|         0|            0|            0|  0.00%|           ]
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|# This module has been renamed from collections.abc to _collections_abc to
    24|         0|            0|            0|  0.00%|# speed up interpreter startup. Some of the types such as MutableMapping are
    25|         0|            0|            0|  0.00%|# required early but collections module imports a lot of other modules.
    26|         0|            0|            0|  0.00%|# See issue #19218
    27|         0|            0|            0|  0.00%|__name__ = "collections.abc"
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|# Private list of types that we want to register with the various ABCs
    30|         0|            0|            0|  0.00%|# so that they will pass tests like:
    31|         0|            0|            0|  0.00%|#       it = iter(somebytearray)
    32|         0|            0|            0|  0.00%|#       assert isinstance(it, Iterable)
    33|         0|            0|            0|  0.00%|# Note:  in other implementations, these types might not be distinct
    34|         0|            0|            0|  0.00%|# and they may have their own implementation specific types that
    35|         0|            0|            0|  0.00%|# are not included on this list.
    36|         0|            0|            0|  0.00%|bytes_iterator = type(iter(b''))
    37|         0|            0|            0|  0.00%|bytearray_iterator = type(iter(bytearray()))
    38|         0|            0|            0|  0.00%|#callable_iterator = ???
    39|         0|            0|            0|  0.00%|dict_keyiterator = type(iter({}.keys()))
    40|         0|            0|            0|  0.00%|dict_valueiterator = type(iter({}.values()))
    41|         0|            0|            0|  0.00%|dict_itemiterator = type(iter({}.items()))
    42|         0|            0|            0|  0.00%|list_iterator = type(iter([]))
    43|         0|            0|            0|  0.00%|list_reverseiterator = type(iter(reversed([])))
    44|         0|            0|            0|  0.00%|range_iterator = type(iter(range(0)))
    45|         0|            0|            0|  0.00%|longrange_iterator = type(iter(range(1 << 1000)))
    46|         0|            0|            0|  0.00%|set_iterator = type(iter(set()))
    47|         0|            0|            0|  0.00%|str_iterator = type(iter(""))
    48|         0|            0|            0|  0.00%|tuple_iterator = type(iter(()))
    49|         0|            0|            0|  0.00%|zip_iterator = type(iter(zip()))
    50|         0|            0|            0|  0.00%|## views ##
    51|         0|            0|            0|  0.00%|dict_keys = type({}.keys())
    52|         0|            0|            0|  0.00%|dict_values = type({}.values())
    53|         0|            0|            0|  0.00%|dict_items = type({}.items())
    54|         0|            0|            0|  0.00%|## misc ##
    55|         0|            0|            0|  0.00%|mappingproxy = type(type.__dict__)
    56|         0|            0|            0|  0.00%|generator = type((lambda: (yield))())
    57|         0|            0|            0|  0.00%|## coroutine ##
    58|         0|            0|            0|  0.00%|async def _coro(): pass
    59|         0|            0|            0|  0.00%|_coro = _coro()
    60|         0|            0|            0|  0.00%|coroutine = type(_coro)
    61|         0|            0|            0|  0.00%|_coro.close()  # Prevent ResourceWarning
    62|         0|            0|            0|  0.00%|del _coro
    63|         0|            0|            0|  0.00%|## asynchronous generator ##
    64|         0|            0|            0|  0.00%|async def _ag(): yield
    65|         0|            0|            0|  0.00%|_ag = _ag()
    66|         0|            0|            0|  0.00%|async_generator = type(_ag)
    67|         0|            0|            0|  0.00%|del _ag
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|### ONE-TRICK PONIES ###
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|def _check_methods(C, *methods):
    73|         0|            0|            0|  0.00%|    mro = C.__mro__
    74|         0|            0|            0|  0.00%|    for method in methods:
    75|         0|            0|            0|  0.00%|        for B in mro:
    76|         0|            0|            0|  0.00%|            if method in B.__dict__:
    77|         0|            0|            0|  0.00%|                if B.__dict__[method] is None:
    78|         0|            0|            0|  0.00%|                    return NotImplemented
    79|         0|            0|            0|  0.00%|                break
    80|         0|            0|            0|  0.00%|        else:
    81|         0|            0|            0|  0.00%|            return NotImplemented
    82|         0|            0|            0|  0.00%|    return True
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|class Hashable(metaclass=ABCMeta):
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    __slots__ = ()
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|    @abstractmethod
    89|         0|            0|            0|  0.00%|    def __hash__(self):
    90|         0|            0|            0|  0.00%|        return 0
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|    @classmethod
    93|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
    94|         0|            0|            0|  0.00%|        if cls is Hashable:
    95|         0|            0|            0|  0.00%|            return _check_methods(C, "__hash__")
    96|         0|            0|            0|  0.00%|        return NotImplemented
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|class Awaitable(metaclass=ABCMeta):
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    __slots__ = ()
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    @abstractmethod
   104|         0|            0|            0|  0.00%|    def __await__(self):
   105|         0|            0|            0|  0.00%|        yield
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|    @classmethod
   108|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   109|         0|            0|            0|  0.00%|        if cls is Awaitable:
   110|         0|            0|            0|  0.00%|            return _check_methods(C, "__await__")
   111|         0|            0|            0|  0.00%|        return NotImplemented
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|class Coroutine(Awaitable):
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    __slots__ = ()
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    @abstractmethod
   119|         0|            0|            0|  0.00%|    def send(self, value):
   120|         0|            0|            0|  0.00%|        """Send a value into the coroutine.
   121|         0|            0|            0|  0.00%|        Return next yielded value or raise StopIteration.
   122|         0|            0|            0|  0.00%|        """
   123|         0|            0|            0|  0.00%|        raise StopIteration
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    @abstractmethod
   126|         0|            0|            0|  0.00%|    def throw(self, typ, val=None, tb=None):
   127|         0|            0|            0|  0.00%|        """Raise an exception in the coroutine.
   128|         0|            0|            0|  0.00%|        Return next yielded value or raise StopIteration.
   129|         0|            0|            0|  0.00%|        """
   130|         0|            0|            0|  0.00%|        if val is None:
   131|         0|            0|            0|  0.00%|            if tb is None:
   132|         0|            0|            0|  0.00%|                raise typ
   133|         0|            0|            0|  0.00%|            val = typ()
   134|         0|            0|            0|  0.00%|        if tb is not None:
   135|         0|            0|            0|  0.00%|            val = val.with_traceback(tb)
   136|         0|            0|            0|  0.00%|        raise val
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    def close(self):
   139|         0|            0|            0|  0.00%|        """Raise GeneratorExit inside coroutine.
   140|         0|            0|            0|  0.00%|        """
   141|         0|            0|            0|  0.00%|        try:
   142|         0|            0|            0|  0.00%|            self.throw(GeneratorExit)
   143|         0|            0|            0|  0.00%|        except (GeneratorExit, StopIteration):
   144|         0|            0|            0|  0.00%|            pass
   145|         0|            0|            0|  0.00%|        else:
   146|         0|            0|            0|  0.00%|            raise RuntimeError("coroutine ignored GeneratorExit")
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    @classmethod
   149|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   150|         0|            0|            0|  0.00%|        if cls is Coroutine:
   151|         0|            0|            0|  0.00%|            return _check_methods(C, '__await__', 'send', 'throw', 'close')
   152|         0|            0|            0|  0.00%|        return NotImplemented
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|Coroutine.register(coroutine)
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|class AsyncIterable(metaclass=ABCMeta):
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|    __slots__ = ()
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|    @abstractmethod
   163|         0|            0|            0|  0.00%|    def __aiter__(self):
   164|         0|            0|            0|  0.00%|        return AsyncIterator()
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    @classmethod
   167|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   168|         0|            0|            0|  0.00%|        if cls is AsyncIterable:
   169|         0|            0|            0|  0.00%|            return _check_methods(C, "__aiter__")
   170|         0|            0|            0|  0.00%|        return NotImplemented
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|class AsyncIterator(AsyncIterable):
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    __slots__ = ()
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|    @abstractmethod
   178|         0|            0|            0|  0.00%|    async def __anext__(self):
   179|         0|            0|            0|  0.00%|        """Return the next item or raise StopAsyncIteration when exhausted."""
   180|         0|            0|            0|  0.00%|        raise StopAsyncIteration
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    def __aiter__(self):
   183|         0|            0|            0|  0.00%|        return self
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    @classmethod
   186|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   187|         0|            0|            0|  0.00%|        if cls is AsyncIterator:
   188|         0|            0|            0|  0.00%|            return _check_methods(C, "__anext__", "__aiter__")
   189|         0|            0|            0|  0.00%|        return NotImplemented
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|class AsyncGenerator(AsyncIterator):
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|    __slots__ = ()
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|    async def __anext__(self):
   197|         0|            0|            0|  0.00%|        """Return the next item from the asynchronous generator.
   198|         0|            0|            0|  0.00%|        When exhausted, raise StopAsyncIteration.
   199|         0|            0|            0|  0.00%|        """
   200|         0|            0|            0|  0.00%|        return await self.asend(None)
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    @abstractmethod
   203|         0|            0|            0|  0.00%|    async def asend(self, value):
   204|         0|            0|            0|  0.00%|        """Send a value into the asynchronous generator.
   205|         0|            0|            0|  0.00%|        Return next yielded value or raise StopAsyncIteration.
   206|         0|            0|            0|  0.00%|        """
   207|         0|            0|            0|  0.00%|        raise StopAsyncIteration
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    @abstractmethod
   210|         0|            0|            0|  0.00%|    async def athrow(self, typ, val=None, tb=None):
   211|         0|            0|            0|  0.00%|        """Raise an exception in the asynchronous generator.
   212|         0|            0|            0|  0.00%|        Return next yielded value or raise StopAsyncIteration.
   213|         0|            0|            0|  0.00%|        """
   214|         0|            0|            0|  0.00%|        if val is None:
   215|         0|            0|            0|  0.00%|            if tb is None:
   216|         0|            0|            0|  0.00%|                raise typ
   217|         0|            0|            0|  0.00%|            val = typ()
   218|         0|            0|            0|  0.00%|        if tb is not None:
   219|         0|            0|            0|  0.00%|            val = val.with_traceback(tb)
   220|         0|            0|            0|  0.00%|        raise val
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|    async def aclose(self):
   223|         0|            0|            0|  0.00%|        """Raise GeneratorExit inside coroutine.
   224|         0|            0|            0|  0.00%|        """
   225|         0|            0|            0|  0.00%|        try:
   226|         0|            0|            0|  0.00%|            await self.athrow(GeneratorExit)
   227|         0|            0|            0|  0.00%|        except (GeneratorExit, StopAsyncIteration):
   228|         0|            0|            0|  0.00%|            pass
   229|         0|            0|            0|  0.00%|        else:
   230|         0|            0|            0|  0.00%|            raise RuntimeError("asynchronous generator ignored GeneratorExit")
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    @classmethod
   233|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   234|         0|            0|            0|  0.00%|        if cls is AsyncGenerator:
   235|         0|            0|            0|  0.00%|            return _check_methods(C, '__aiter__', '__anext__',
   236|         0|            0|            0|  0.00%|                                  'asend', 'athrow', 'aclose')
   237|         0|            0|            0|  0.00%|        return NotImplemented
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|AsyncGenerator.register(async_generator)
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|class Iterable(metaclass=ABCMeta):
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|    __slots__ = ()
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    @abstractmethod
   248|         0|            0|            0|  0.00%|    def __iter__(self):
   249|         0|            0|            0|  0.00%|        while False:
   250|         0|            0|            0|  0.00%|            yield None
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    @classmethod
   253|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   254|         0|            0|            0|  0.00%|        if cls is Iterable:
   255|         0|            0|            0|  0.00%|            return _check_methods(C, "__iter__")
   256|         0|            0|            0|  0.00%|        return NotImplemented
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|class Iterator(Iterable):
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    __slots__ = ()
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|    @abstractmethod
   264|         0|            0|            0|  0.00%|    def __next__(self):
   265|         0|            0|            0|  0.00%|        'Return the next item from the iterator. When exhausted, raise StopIteration'
   266|         0|            0|            0|  0.00%|        raise StopIteration
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|    def __iter__(self):
   269|         0|            0|            0|  0.00%|        return self
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    @classmethod
   272|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   273|         0|            0|            0|  0.00%|        if cls is Iterator:
   274|         0|            0|            0|  0.00%|            return _check_methods(C, '__iter__', '__next__')
   275|         0|            0|            0|  0.00%|        return NotImplemented
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|Iterator.register(bytes_iterator)
   278|         0|            0|            0|  0.00%|Iterator.register(bytearray_iterator)
   279|         0|            0|            0|  0.00%|#Iterator.register(callable_iterator)
   280|         0|            0|            0|  0.00%|Iterator.register(dict_keyiterator)
   281|         0|            0|            0|  0.00%|Iterator.register(dict_valueiterator)
   282|         0|            0|            0|  0.00%|Iterator.register(dict_itemiterator)
   283|         0|            0|            0|  0.00%|Iterator.register(list_iterator)
   284|         0|            0|            0|  0.00%|Iterator.register(list_reverseiterator)
   285|         0|            0|            0|  0.00%|Iterator.register(range_iterator)
   286|         0|            0|            0|  0.00%|Iterator.register(longrange_iterator)
   287|         0|            0|            0|  0.00%|Iterator.register(set_iterator)
   288|         0|            0|            0|  0.00%|Iterator.register(str_iterator)
   289|         0|            0|            0|  0.00%|Iterator.register(tuple_iterator)
   290|         0|            0|            0|  0.00%|Iterator.register(zip_iterator)
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|class Reversible(Iterable):
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    __slots__ = ()
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|    @abstractmethod
   298|         0|            0|            0|  0.00%|    def __reversed__(self):
   299|         0|            0|            0|  0.00%|        while False:
   300|         0|            0|            0|  0.00%|            yield None
   301|         0|            0|            0|  0.00%|
   302|        11|            0|            0|  0.00%|    @classmethod
   303|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   304|        11|            0|            0|  0.00%|        if cls is Reversible:
   305|         0|            0|            0|  0.00%|            return _check_methods(C, "__reversed__", "__iter__")
   306|        11|            0|            0|  0.00%|        return NotImplemented
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|class Generator(Iterator):
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    __slots__ = ()
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|    def __next__(self):
   314|         0|            0|            0|  0.00%|        """Return the next item from the generator.
   315|         0|            0|            0|  0.00%|        When exhausted, raise StopIteration.
   316|         0|            0|            0|  0.00%|        """
   317|         0|            0|            0|  0.00%|        return self.send(None)
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|    @abstractmethod
   320|         0|            0|            0|  0.00%|    def send(self, value):
   321|         0|            0|            0|  0.00%|        """Send a value into the generator.
   322|         0|            0|            0|  0.00%|        Return next yielded value or raise StopIteration.
   323|         0|            0|            0|  0.00%|        """
   324|         0|            0|            0|  0.00%|        raise StopIteration
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    @abstractmethod
   327|         0|            0|            0|  0.00%|    def throw(self, typ, val=None, tb=None):
   328|         0|            0|            0|  0.00%|        """Raise an exception in the generator.
   329|         0|            0|            0|  0.00%|        Return next yielded value or raise StopIteration.
   330|         0|            0|            0|  0.00%|        """
   331|         0|            0|            0|  0.00%|        if val is None:
   332|         0|            0|            0|  0.00%|            if tb is None:
   333|         0|            0|            0|  0.00%|                raise typ
   334|         0|            0|            0|  0.00%|            val = typ()
   335|         0|            0|            0|  0.00%|        if tb is not None:
   336|         0|            0|            0|  0.00%|            val = val.with_traceback(tb)
   337|         0|            0|            0|  0.00%|        raise val
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|    def close(self):
   340|         0|            0|            0|  0.00%|        """Raise GeneratorExit inside generator.
   341|         0|            0|            0|  0.00%|        """
   342|         0|            0|            0|  0.00%|        try:
   343|         0|            0|            0|  0.00%|            self.throw(GeneratorExit)
   344|         0|            0|            0|  0.00%|        except (GeneratorExit, StopIteration):
   345|         0|            0|            0|  0.00%|            pass
   346|         0|            0|            0|  0.00%|        else:
   347|         0|            0|            0|  0.00%|            raise RuntimeError("generator ignored GeneratorExit")
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|    @classmethod
   350|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   351|         0|            0|            0|  0.00%|        if cls is Generator:
   352|         0|            0|            0|  0.00%|            return _check_methods(C, '__iter__', '__next__',
   353|         0|            0|            0|  0.00%|                                  'send', 'throw', 'close')
   354|         0|            0|            0|  0.00%|        return NotImplemented
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|Generator.register(generator)
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|class Sized(metaclass=ABCMeta):
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    __slots__ = ()
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    @abstractmethod
   364|         0|            0|            0|  0.00%|    def __len__(self):
   365|         0|            0|            0|  0.00%|        return 0
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|    @classmethod
   368|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   369|         0|            0|            0|  0.00%|        if cls is Sized:
   370|         0|            0|            0|  0.00%|            return _check_methods(C, "__len__")
   371|         0|            0|            0|  0.00%|        return NotImplemented
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|class Container(metaclass=ABCMeta):
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    __slots__ = ()
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|    @abstractmethod
   379|         0|            0|            0|  0.00%|    def __contains__(self, x):
   380|         0|            0|            0|  0.00%|        return False
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|    @classmethod
   383|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   384|         0|            0|            0|  0.00%|        if cls is Container:
   385|         0|            0|            0|  0.00%|            return _check_methods(C, "__contains__")
   386|         0|            0|            0|  0.00%|        return NotImplemented
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|class Collection(Sized, Iterable, Container):
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|    __slots__ = ()
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|    @classmethod
   393|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   394|         0|            0|            0|  0.00%|        if cls is Collection:
   395|         0|            0|            0|  0.00%|            return _check_methods(C,  "__len__", "__iter__", "__contains__")
   396|         0|            0|            0|  0.00%|        return NotImplemented
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|class Callable(metaclass=ABCMeta):
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|    __slots__ = ()
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|    @abstractmethod
   403|         0|            0|            0|  0.00%|    def __call__(self, *args, **kwds):
   404|         0|            0|            0|  0.00%|        return False
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|    @classmethod
   407|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
   408|         0|            0|            0|  0.00%|        if cls is Callable:
   409|         0|            0|            0|  0.00%|            return _check_methods(C, "__call__")
   410|         0|            0|            0|  0.00%|        return NotImplemented
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|### SETS ###
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|class Set(Collection):
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|    """A set is a finite, iterable container.
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    This class provides concrete generic implementations of all
   421|         0|            0|            0|  0.00%|    methods except for __contains__, __iter__ and __len__.
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    To override the comparisons (presumably for speed, as the
   424|         0|            0|            0|  0.00%|    semantics are fixed), redefine __le__ and __ge__,
   425|         0|            0|            0|  0.00%|    then the other operations will automatically follow suit.
   426|         0|            0|            0|  0.00%|    """
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|    __slots__ = ()
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|    def __le__(self, other):
   431|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   432|         0|            0|            0|  0.00%|            return NotImplemented
   433|         0|            0|            0|  0.00%|        if len(self) > len(other):
   434|         0|            0|            0|  0.00%|            return False
   435|         0|            0|            0|  0.00%|        for elem in self:
   436|         0|            0|            0|  0.00%|            if elem not in other:
   437|         0|            0|            0|  0.00%|                return False
   438|         0|            0|            0|  0.00%|        return True
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|    def __lt__(self, other):
   441|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   442|         0|            0|            0|  0.00%|            return NotImplemented
   443|         0|            0|            0|  0.00%|        return len(self) < len(other) and self.__le__(other)
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    def __gt__(self, other):
   446|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   447|         0|            0|            0|  0.00%|            return NotImplemented
   448|         0|            0|            0|  0.00%|        return len(self) > len(other) and self.__ge__(other)
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|    def __ge__(self, other):
   451|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   452|         0|            0|            0|  0.00%|            return NotImplemented
   453|         0|            0|            0|  0.00%|        if len(self) < len(other):
   454|         0|            0|            0|  0.00%|            return False
   455|         0|            0|            0|  0.00%|        for elem in other:
   456|         0|            0|            0|  0.00%|            if elem not in self:
   457|         0|            0|            0|  0.00%|                return False
   458|         0|            0|            0|  0.00%|        return True
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|    def __eq__(self, other):
   461|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   462|         0|            0|            0|  0.00%|            return NotImplemented
   463|         0|            0|            0|  0.00%|        return len(self) == len(other) and self.__le__(other)
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    @classmethod
   466|         0|            0|            0|  0.00%|    def _from_iterable(cls, it):
   467|         0|            0|            0|  0.00%|        '''Construct an instance of the class from any iterable input.
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|        Must override this method if the class constructor signature
   470|         0|            0|            0|  0.00%|        does not accept an iterable for an input.
   471|         0|            0|            0|  0.00%|        '''
   472|         0|            0|            0|  0.00%|        return cls(it)
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|    def __and__(self, other):
   475|         0|            0|            0|  0.00%|        if not isinstance(other, Iterable):
   476|         0|            0|            0|  0.00%|            return NotImplemented
   477|         0|            0|            0|  0.00%|        return self._from_iterable(value for value in other if value in self)
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|    __rand__ = __and__
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|    def isdisjoint(self, other):
   482|         0|            0|            0|  0.00%|        'Return True if two sets have a null intersection.'
   483|         0|            0|            0|  0.00%|        for value in other:
   484|         0|            0|            0|  0.00%|            if value in self:
   485|         0|            0|            0|  0.00%|                return False
   486|         0|            0|            0|  0.00%|        return True
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|    def __or__(self, other):
   489|         0|            0|            0|  0.00%|        if not isinstance(other, Iterable):
   490|         0|            0|            0|  0.00%|            return NotImplemented
   491|         0|            0|            0|  0.00%|        chain = (e for s in (self, other) for e in s)
   492|         0|            0|            0|  0.00%|        return self._from_iterable(chain)
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    __ror__ = __or__
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    def __sub__(self, other):
   497|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   498|         0|            0|            0|  0.00%|            if not isinstance(other, Iterable):
   499|         0|            0|            0|  0.00%|                return NotImplemented
   500|         0|            0|            0|  0.00%|            other = self._from_iterable(other)
   501|         0|            0|            0|  0.00%|        return self._from_iterable(value for value in self
   502|         0|            0|            0|  0.00%|                                   if value not in other)
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    def __rsub__(self, other):
   505|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   506|         0|            0|            0|  0.00%|            if not isinstance(other, Iterable):
   507|         0|            0|            0|  0.00%|                return NotImplemented
   508|         0|            0|            0|  0.00%|            other = self._from_iterable(other)
   509|         0|            0|            0|  0.00%|        return self._from_iterable(value for value in other
   510|         0|            0|            0|  0.00%|                                   if value not in self)
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    def __xor__(self, other):
   513|         0|            0|            0|  0.00%|        if not isinstance(other, Set):
   514|         0|            0|            0|  0.00%|            if not isinstance(other, Iterable):
   515|         0|            0|            0|  0.00%|                return NotImplemented
   516|         0|            0|            0|  0.00%|            other = self._from_iterable(other)
   517|         0|            0|            0|  0.00%|        return (self - other) | (other - self)
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|    __rxor__ = __xor__
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|    def _hash(self):
   522|         0|            0|            0|  0.00%|        """Compute the hash value of a set.
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|        Note that we don't define __hash__: not all sets are hashable.
   525|         0|            0|            0|  0.00%|        But if you define a hashable set type, its __hash__ should
   526|         0|            0|            0|  0.00%|        call this function.
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|        This must be compatible __eq__.
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|        All sets ought to compare equal if they contain the same
   531|         0|            0|            0|  0.00%|        elements, regardless of how they are implemented, and
   532|         0|            0|            0|  0.00%|        regardless of the order of the elements; so there's not much
   533|         0|            0|            0|  0.00%|        freedom for __eq__ or __hash__.  We match the algorithm used
   534|         0|            0|            0|  0.00%|        by the built-in frozenset type.
   535|         0|            0|            0|  0.00%|        """
   536|         0|            0|            0|  0.00%|        MAX = sys.maxsize
   537|         0|            0|            0|  0.00%|        MASK = 2 * MAX + 1
   538|         0|            0|            0|  0.00%|        n = len(self)
   539|         0|            0|            0|  0.00%|        h = 1927868237 * (n + 1)
   540|         0|            0|            0|  0.00%|        h &= MASK
   541|         0|            0|            0|  0.00%|        for x in self:
   542|         0|            0|            0|  0.00%|            hx = hash(x)
   543|         0|            0|            0|  0.00%|            h ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167
   544|         0|            0|            0|  0.00%|            h &= MASK
   545|         0|            0|            0|  0.00%|        h = h * 69069 + 907133923
   546|         0|            0|            0|  0.00%|        h &= MASK
   547|         0|            0|            0|  0.00%|        if h > MAX:
   548|         0|            0|            0|  0.00%|            h -= MASK + 1
   549|         0|            0|            0|  0.00%|        if h == -1:
   550|         0|            0|            0|  0.00%|            h = 590923713
   551|         0|            0|            0|  0.00%|        return h
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|Set.register(frozenset)
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|class MutableSet(Set):
   557|         0|            0|            0|  0.00%|    """A mutable set is a finite, iterable container.
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|    This class provides concrete generic implementations of all
   560|         0|            0|            0|  0.00%|    methods except for __contains__, __iter__, __len__,
   561|         0|            0|            0|  0.00%|    add(), and discard().
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|    To override the comparisons (presumably for speed, as the
   564|         0|            0|            0|  0.00%|    semantics are fixed), all you have to do is redefine __le__ and
   565|         0|            0|            0|  0.00%|    then the other operations will automatically follow suit.
   566|         0|            0|            0|  0.00%|    """
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    __slots__ = ()
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|    @abstractmethod
   571|         0|            0|            0|  0.00%|    def add(self, value):
   572|         0|            0|            0|  0.00%|        """Add an element."""
   573|         0|            0|            0|  0.00%|        raise NotImplementedError
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|    @abstractmethod
   576|         0|            0|            0|  0.00%|    def discard(self, value):
   577|         0|            0|            0|  0.00%|        """Remove an element.  Do not raise an exception if absent."""
   578|         0|            0|            0|  0.00%|        raise NotImplementedError
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|    def remove(self, value):
   581|         0|            0|            0|  0.00%|        """Remove an element. If not a member, raise a KeyError."""
   582|         0|            0|            0|  0.00%|        if value not in self:
   583|         0|            0|            0|  0.00%|            raise KeyError(value)
   584|         0|            0|            0|  0.00%|        self.discard(value)
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|    def pop(self):
   587|         0|            0|            0|  0.00%|        """Return the popped value.  Raise KeyError if empty."""
   588|         0|            0|            0|  0.00%|        it = iter(self)
   589|         0|            0|            0|  0.00%|        try:
   590|         0|            0|            0|  0.00%|            value = next(it)
   591|         0|            0|            0|  0.00%|        except StopIteration:
   592|         0|            0|            0|  0.00%|            raise KeyError from None
   593|         0|            0|            0|  0.00%|        self.discard(value)
   594|         0|            0|            0|  0.00%|        return value
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|    def clear(self):
   597|         0|            0|            0|  0.00%|        """This is slow (creates N new iterators!) but effective."""
   598|         0|            0|            0|  0.00%|        try:
   599|         0|            0|            0|  0.00%|            while True:
   600|         0|            0|            0|  0.00%|                self.pop()
   601|         0|            0|            0|  0.00%|        except KeyError:
   602|         0|            0|            0|  0.00%|            pass
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|    def __ior__(self, it):
   605|         0|            0|            0|  0.00%|        for value in it:
   606|         0|            0|            0|  0.00%|            self.add(value)
   607|         0|            0|            0|  0.00%|        return self
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|    def __iand__(self, it):
   610|         0|            0|            0|  0.00%|        for value in (self - it):
   611|         0|            0|            0|  0.00%|            self.discard(value)
   612|         0|            0|            0|  0.00%|        return self
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|    def __ixor__(self, it):
   615|         0|            0|            0|  0.00%|        if it is self:
   616|         0|            0|            0|  0.00%|            self.clear()
   617|         0|            0|            0|  0.00%|        else:
   618|         0|            0|            0|  0.00%|            if not isinstance(it, Set):
   619|         0|            0|            0|  0.00%|                it = self._from_iterable(it)
   620|         0|            0|            0|  0.00%|            for value in it:
   621|         0|            0|            0|  0.00%|                if value in self:
   622|         0|            0|            0|  0.00%|                    self.discard(value)
   623|         0|            0|            0|  0.00%|                else:
   624|         0|            0|            0|  0.00%|                    self.add(value)
   625|         0|            0|            0|  0.00%|        return self
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|    def __isub__(self, it):
   628|         0|            0|            0|  0.00%|        if it is self:
   629|         0|            0|            0|  0.00%|            self.clear()
   630|         0|            0|            0|  0.00%|        else:
   631|         0|            0|            0|  0.00%|            for value in it:
   632|         0|            0|            0|  0.00%|                self.discard(value)
   633|         0|            0|            0|  0.00%|        return self
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|MutableSet.register(set)
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|### MAPPINGS ###
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|class Mapping(Collection):
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    __slots__ = ()
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    """A Mapping is a generic container for associating key/value
   646|         0|            0|            0|  0.00%|    pairs.
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|    This class provides concrete generic implementations of all
   649|         0|            0|            0|  0.00%|    methods except for __getitem__, __iter__, and __len__.
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|    """
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|    @abstractmethod
   654|         0|            0|            0|  0.00%|    def __getitem__(self, key):
   655|         0|            0|            0|  0.00%|        raise KeyError
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|    def get(self, key, default=None):
   658|         0|            0|            0|  0.00%|        'D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.'
   659|         0|            0|            0|  0.00%|        try:
   660|         0|            0|            0|  0.00%|            return self[key]
   661|         0|            0|            0|  0.00%|        except KeyError:
   662|         0|            0|            0|  0.00%|            return default
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|    def __contains__(self, key):
   665|         0|            0|            0|  0.00%|        try:
   666|         0|            0|            0|  0.00%|            self[key]
   667|         0|            0|            0|  0.00%|        except KeyError:
   668|         0|            0|            0|  0.00%|            return False
   669|         0|            0|            0|  0.00%|        else:
   670|         0|            0|            0|  0.00%|            return True
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    def keys(self):
   673|         0|            0|            0|  0.00%|        "D.keys() -> a set-like object providing a view on D's keys"
   674|         0|            0|            0|  0.00%|        return KeysView(self)
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|    def items(self):
   677|         0|            0|            0|  0.00%|        "D.items() -> a set-like object providing a view on D's items"
   678|         0|            0|            0|  0.00%|        return ItemsView(self)
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|    def values(self):
   681|         0|            0|            0|  0.00%|        "D.values() -> an object providing a view on D's values"
   682|         0|            0|            0|  0.00%|        return ValuesView(self)
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|    def __eq__(self, other):
   685|         0|            0|            0|  0.00%|        if not isinstance(other, Mapping):
   686|         0|            0|            0|  0.00%|            return NotImplemented
   687|         0|            0|            0|  0.00%|        return dict(self.items()) == dict(other.items())
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    __reversed__ = None
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|Mapping.register(mappingproxy)
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|class MappingView(Sized):
   695|         0|            0|            0|  0.00%|
   696|         0|            0|            0|  0.00%|    __slots__ = '_mapping',
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    def __init__(self, mapping):
   699|         0|            0|            0|  0.00%|        self._mapping = mapping
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|    def __len__(self):
   702|         0|            0|            0|  0.00%|        return len(self._mapping)
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|    def __repr__(self):
   705|         0|            0|            0|  0.00%|        return '{0.__class__.__name__}({0._mapping!r})'.format(self)
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|class KeysView(MappingView, Set):
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|    __slots__ = ()
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|    @classmethod
   713|         0|            0|            0|  0.00%|    def _from_iterable(self, it):
   714|         0|            0|            0|  0.00%|        return set(it)
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|    def __contains__(self, key):
   717|         0|            0|            0|  0.00%|        return key in self._mapping
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    def __iter__(self):
   720|         0|            0|            0|  0.00%|        yield from self._mapping
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|KeysView.register(dict_keys)
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|class ItemsView(MappingView, Set):
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|    __slots__ = ()
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|    @classmethod
   730|         0|            0|            0|  0.00%|    def _from_iterable(self, it):
   731|         0|            0|            0|  0.00%|        return set(it)
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|    def __contains__(self, item):
   734|         0|            0|            0|  0.00%|        key, value = item
   735|         0|            0|            0|  0.00%|        try:
   736|         0|            0|            0|  0.00%|            v = self._mapping[key]
   737|         0|            0|            0|  0.00%|        except KeyError:
   738|         0|            0|            0|  0.00%|            return False
   739|         0|            0|            0|  0.00%|        else:
   740|         0|            0|            0|  0.00%|            return v is value or v == value
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|    def __iter__(self):
   743|         0|            0|            0|  0.00%|        for key in self._mapping:
   744|         0|            0|            0|  0.00%|            yield (key, self._mapping[key])
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|ItemsView.register(dict_items)
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|class ValuesView(MappingView, Collection):
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|    __slots__ = ()
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|    def __contains__(self, value):
   754|         0|            0|            0|  0.00%|        for key in self._mapping:
   755|         0|            0|            0|  0.00%|            v = self._mapping[key]
   756|         0|            0|            0|  0.00%|            if v is value or v == value:
   757|         0|            0|            0|  0.00%|                return True
   758|         0|            0|            0|  0.00%|        return False
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|    def __iter__(self):
   761|         0|            0|            0|  0.00%|        for key in self._mapping:
   762|         0|            0|            0|  0.00%|            yield self._mapping[key]
   763|         0|            0|            0|  0.00%|
   764|         0|            0|            0|  0.00%|ValuesView.register(dict_values)
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|class MutableMapping(Mapping):
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|    __slots__ = ()
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|    """A MutableMapping is a generic container for associating
   772|         0|            0|            0|  0.00%|    key/value pairs.
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    This class provides concrete generic implementations of all
   775|         0|            0|            0|  0.00%|    methods except for __getitem__, __setitem__, __delitem__,
   776|         0|            0|            0|  0.00%|    __iter__, and __len__.
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|    """
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|    @abstractmethod
   781|         0|            0|            0|  0.00%|    def __setitem__(self, key, value):
   782|         0|            0|            0|  0.00%|        raise KeyError
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|    @abstractmethod
   785|         0|            0|            0|  0.00%|    def __delitem__(self, key):
   786|         0|            0|            0|  0.00%|        raise KeyError
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|    __marker = object()
   789|         0|            0|            0|  0.00%|
   790|         0|            0|            0|  0.00%|    def pop(self, key, default=__marker):
   791|         0|            0|            0|  0.00%|        '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
   792|         0|            0|            0|  0.00%|          If key is not found, d is returned if given, otherwise KeyError is raised.
   793|         0|            0|            0|  0.00%|        '''
   794|         0|            0|            0|  0.00%|        try:
   795|         0|            0|            0|  0.00%|            value = self[key]
   796|         0|            0|            0|  0.00%|        except KeyError:
   797|         0|            0|            0|  0.00%|            if default is self.__marker:
   798|         0|            0|            0|  0.00%|                raise
   799|         0|            0|            0|  0.00%|            return default
   800|         0|            0|            0|  0.00%|        else:
   801|         0|            0|            0|  0.00%|            del self[key]
   802|         0|            0|            0|  0.00%|            return value
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|    def popitem(self):
   805|         0|            0|            0|  0.00%|        '''D.popitem() -> (k, v), remove and return some (key, value) pair
   806|         0|            0|            0|  0.00%|           as a 2-tuple; but raise KeyError if D is empty.
   807|         0|            0|            0|  0.00%|        '''
   808|         0|            0|            0|  0.00%|        try:
   809|         0|            0|            0|  0.00%|            key = next(iter(self))
   810|         0|            0|            0|  0.00%|        except StopIteration:
   811|         0|            0|            0|  0.00%|            raise KeyError from None
   812|         0|            0|            0|  0.00%|        value = self[key]
   813|         0|            0|            0|  0.00%|        del self[key]
   814|         0|            0|            0|  0.00%|        return key, value
   815|         0|            0|            0|  0.00%|
   816|         0|            0|            0|  0.00%|    def clear(self):
   817|         0|            0|            0|  0.00%|        'D.clear() -> None.  Remove all items from D.'
   818|         0|            0|            0|  0.00%|        try:
   819|         0|            0|            0|  0.00%|            while True:
   820|         0|            0|            0|  0.00%|                self.popitem()
   821|         0|            0|            0|  0.00%|        except KeyError:
   822|         0|            0|            0|  0.00%|            pass
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|    def update(self, other=(), /, **kwds):
   825|         0|            0|            0|  0.00%|        ''' D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
   826|         0|            0|            0|  0.00%|            If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
   827|         0|            0|            0|  0.00%|            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
   828|         0|            0|            0|  0.00%|            In either case, this is followed by: for k, v in F.items(): D[k] = v
   829|         0|            0|            0|  0.00%|        '''
   830|         0|            0|            0|  0.00%|        if isinstance(other, Mapping):
   831|         0|            0|            0|  0.00%|            for key in other:
   832|         0|            0|            0|  0.00%|                self[key] = other[key]
   833|         0|            0|            0|  0.00%|        elif hasattr(other, "keys"):
   834|         0|            0|            0|  0.00%|            for key in other.keys():
   835|         0|            0|            0|  0.00%|                self[key] = other[key]
   836|         0|            0|            0|  0.00%|        else:
   837|         0|            0|            0|  0.00%|            for key, value in other:
   838|         0|            0|            0|  0.00%|                self[key] = value
   839|         0|            0|            0|  0.00%|        for key, value in kwds.items():
   840|         0|            0|            0|  0.00%|            self[key] = value
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|    def setdefault(self, key, default=None):
   843|         0|            0|            0|  0.00%|        'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D'
   844|         0|            0|            0|  0.00%|        try:
   845|         0|            0|            0|  0.00%|            return self[key]
   846|         0|            0|            0|  0.00%|        except KeyError:
   847|         0|            0|            0|  0.00%|            self[key] = default
   848|         0|            0|            0|  0.00%|        return default
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|MutableMapping.register(dict)
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|### SEQUENCES ###
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|class Sequence(Reversible, Collection):
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|    """All the operations on a read-only sequence.
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|    Concrete subclasses must override __new__ or __init__,
   861|         0|            0|            0|  0.00%|    __getitem__, and __len__.
   862|         0|            0|            0|  0.00%|    """
   863|         0|            0|            0|  0.00%|
   864|         0|            0|            0|  0.00%|    __slots__ = ()
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|    @abstractmethod
   867|         0|            0|            0|  0.00%|    def __getitem__(self, index):
   868|         0|            0|            0|  0.00%|        raise IndexError
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    def __iter__(self):
   871|         0|            0|            0|  0.00%|        i = 0
   872|         0|            0|            0|  0.00%|        try:
   873|         0|            0|            0|  0.00%|            while True:
   874|         0|            0|            0|  0.00%|                v = self[i]
   875|         0|            0|            0|  0.00%|                yield v
   876|         0|            0|            0|  0.00%|                i += 1
   877|         0|            0|            0|  0.00%|        except IndexError:
   878|         0|            0|            0|  0.00%|            return
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|    def __contains__(self, value):
   881|         0|            0|            0|  0.00%|        for v in self:
   882|         0|            0|            0|  0.00%|            if v is value or v == value:
   883|         0|            0|            0|  0.00%|                return True
   884|         0|            0|            0|  0.00%|        return False
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|    def __reversed__(self):
   887|         0|            0|            0|  0.00%|        for i in reversed(range(len(self))):
   888|         0|            0|            0|  0.00%|            yield self[i]
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|    def index(self, value, start=0, stop=None):
   891|         0|            0|            0|  0.00%|        '''S.index(value, [start, [stop]]) -> integer -- return first index of value.
   892|         0|            0|            0|  0.00%|           Raises ValueError if the value is not present.
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|           Supporting start and stop arguments is optional, but
   895|         0|            0|            0|  0.00%|           recommended.
   896|         0|            0|            0|  0.00%|        '''
   897|         0|            0|            0|  0.00%|        if start is not None and start < 0:
   898|         0|            0|            0|  0.00%|            start = max(len(self) + start, 0)
   899|         0|            0|            0|  0.00%|        if stop is not None and stop < 0:
   900|         0|            0|            0|  0.00%|            stop += len(self)
   901|         0|            0|            0|  0.00%|
   902|         0|            0|            0|  0.00%|        i = start
   903|         0|            0|            0|  0.00%|        while stop is None or i < stop:
   904|         0|            0|            0|  0.00%|            try:
   905|         0|            0|            0|  0.00%|                v = self[i]
   906|         0|            0|            0|  0.00%|                if v is value or v == value:
   907|         0|            0|            0|  0.00%|                    return i
   908|         0|            0|            0|  0.00%|            except IndexError:
   909|         0|            0|            0|  0.00%|                break
   910|         0|            0|            0|  0.00%|            i += 1
   911|         0|            0|            0|  0.00%|        raise ValueError
   912|         0|            0|            0|  0.00%|
   913|         0|            0|            0|  0.00%|    def count(self, value):
   914|         0|            0|            0|  0.00%|        'S.count(value) -> integer -- return number of occurrences of value'
   915|         0|            0|            0|  0.00%|        return sum(1 for v in self if v is value or v == value)
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|Sequence.register(tuple)
   918|         0|            0|            0|  0.00%|Sequence.register(str)
   919|         0|            0|            0|  0.00%|Sequence.register(range)
   920|         0|            0|            0|  0.00%|Sequence.register(memoryview)
   921|         0|            0|            0|  0.00%|
   922|         0|            0|            0|  0.00%|
   923|         0|            0|            0|  0.00%|class ByteString(Sequence):
   924|         0|            0|            0|  0.00%|
   925|         0|            0|            0|  0.00%|    """This unifies bytes and bytearray.
   926|         0|            0|            0|  0.00%|
   927|         0|            0|            0|  0.00%|    XXX Should add all their methods.
   928|         0|            0|            0|  0.00%|    """
   929|         0|            0|            0|  0.00%|
   930|         0|            0|            0|  0.00%|    __slots__ = ()
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|ByteString.register(bytes)
   933|         0|            0|            0|  0.00%|ByteString.register(bytearray)
   934|         0|            0|            0|  0.00%|
   935|         0|            0|            0|  0.00%|
   936|         0|            0|            0|  0.00%|class MutableSequence(Sequence):
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|    __slots__ = ()
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|    """All the operations on a read-write sequence.
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|    Concrete subclasses must provide __new__ or __init__,
   943|         0|            0|            0|  0.00%|    __getitem__, __setitem__, __delitem__, __len__, and insert().
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|    """
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|    @abstractmethod
   948|         0|            0|            0|  0.00%|    def __setitem__(self, index, value):
   949|         0|            0|            0|  0.00%|        raise IndexError
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|    @abstractmethod
   952|         0|            0|            0|  0.00%|    def __delitem__(self, index):
   953|         0|            0|            0|  0.00%|        raise IndexError
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|    @abstractmethod
   956|         0|            0|            0|  0.00%|    def insert(self, index, value):
   957|         0|            0|            0|  0.00%|        'S.insert(index, value) -- insert value before index'
   958|         0|            0|            0|  0.00%|        raise IndexError
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|    def append(self, value):
   961|         0|            0|            0|  0.00%|        'S.append(value) -- append value to the end of the sequence'
   962|         0|            0|            0|  0.00%|        self.insert(len(self), value)
   963|         0|            0|            0|  0.00%|
   964|         0|            0|            0|  0.00%|    def clear(self):
   965|         0|            0|            0|  0.00%|        'S.clear() -> None -- remove all items from S'
   966|         0|            0|            0|  0.00%|        try:
   967|         0|            0|            0|  0.00%|            while True:
   968|         0|            0|            0|  0.00%|                self.pop()
   969|         0|            0|            0|  0.00%|        except IndexError:
   970|         0|            0|            0|  0.00%|            pass
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|    def reverse(self):
   973|         0|            0|            0|  0.00%|        'S.reverse() -- reverse *IN PLACE*'
   974|         0|            0|            0|  0.00%|        n = len(self)
   975|         0|            0|            0|  0.00%|        for i in range(n//2):
   976|         0|            0|            0|  0.00%|            self[i], self[n-i-1] = self[n-i-1], self[i]
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|    def extend(self, values):
   979|         0|            0|            0|  0.00%|        'S.extend(iterable) -- extend sequence by appending elements from the iterable'
   980|         0|            0|            0|  0.00%|        if values is self:
   981|         0|            0|            0|  0.00%|            values = list(values)
   982|         0|            0|            0|  0.00%|        for v in values:
   983|         0|            0|            0|  0.00%|            self.append(v)
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|    def pop(self, index=-1):
   986|         0|            0|            0|  0.00%|        '''S.pop([index]) -> item -- remove and return item at index (default last).
   987|         0|            0|            0|  0.00%|           Raise IndexError if list is empty or index is out of range.
   988|         0|            0|            0|  0.00%|        '''
   989|         0|            0|            0|  0.00%|        v = self[index]
   990|         0|            0|            0|  0.00%|        del self[index]
   991|         0|            0|            0|  0.00%|        return v
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    def remove(self, value):
   994|         0|            0|            0|  0.00%|        '''S.remove(value) -- remove first occurrence of value.
   995|         0|            0|            0|  0.00%|           Raise ValueError if the value is not present.
   996|         0|            0|            0|  0.00%|        '''
   997|         0|            0|            0|  0.00%|        del self[self.index(value)]
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|    def __iadd__(self, values):
  1000|         0|            0|            0|  0.00%|        self.extend(values)
  1001|         0|            0|            0|  0.00%|        return self
  1002|         0|            0|            0|  0.00%|
  1003|         0|            0|            0|  0.00%|MutableSequence.register(list)
  1004|         0|            0|            0|  0.00%|MutableSequence.register(bytearray)  # Multiply inheriting, see ByteString
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\lib\copyreg.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Helper to provide extensibility for pickle.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|This is only useful to add pickle support for extension types defined in
     4|         0|            0|            0|  0.00%|C, not for instances of user-defined classes.
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|__all__ = ["pickle", "constructor",
     8|         0|            0|            0|  0.00%|           "add_extension", "remove_extension", "clear_extension_cache"]
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|dispatch_table = {}
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|def pickle(ob_type, pickle_function, constructor_ob=None):
    13|         0|            0|            0|  0.00%|    if not callable(pickle_function):
    14|         0|            0|            0|  0.00%|        raise TypeError("reduction functions must be callable")
    15|         0|            0|            0|  0.00%|    dispatch_table[ob_type] = pickle_function
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|    # The constructor_ob function is a vestige of safe for unpickling.
    18|         0|            0|            0|  0.00%|    # There is no reason for the caller to pass it anymore.
    19|         0|            0|            0|  0.00%|    if constructor_ob is not None:
    20|         0|            0|            0|  0.00%|        constructor(constructor_ob)
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|def constructor(object):
    23|         0|            0|            0|  0.00%|    if not callable(object):
    24|         0|            0|            0|  0.00%|        raise TypeError("constructors must be callable")
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|# Example: provide pickling support for complex numbers.
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|try:
    29|         0|            0|            0|  0.00%|    complex
    30|         0|            0|            0|  0.00%|except NameError:
    31|         0|            0|            0|  0.00%|    pass
    32|         0|            0|            0|  0.00%|else:
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|    def pickle_complex(c):
    35|         0|            0|            0|  0.00%|        return complex, (c.real, c.imag)
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|    pickle(complex, pickle_complex, complex)
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|# Support for pickling new-style objects
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|def _reconstructor(cls, base, state):
    42|         0|            0|            0|  0.00%|    if base is object:
    43|         0|            0|            0|  0.00%|        obj = object.__new__(cls)
    44|         0|            0|            0|  0.00%|    else:
    45|         0|            0|            0|  0.00%|        obj = base.__new__(cls, state)
    46|         0|            0|            0|  0.00%|        if base.__init__ != object.__init__:
    47|         0|            0|            0|  0.00%|            base.__init__(obj, state)
    48|         0|            0|            0|  0.00%|    return obj
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|_HEAPTYPE = 1<<9
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|# Python code for object.__reduce_ex__ for protocols 0 and 1
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|def _reduce_ex(self, proto):
    55|         0|            0|            0|  0.00%|    assert proto < 2
    56|         0|            0|            0|  0.00%|    cls = self.__class__
    57|         0|            0|            0|  0.00%|    for base in cls.__mro__:
    58|         0|            0|            0|  0.00%|        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:
    59|         0|            0|            0|  0.00%|            break
    60|         0|            0|            0|  0.00%|    else:
    61|         0|            0|            0|  0.00%|        base = object # not really reachable
    62|         0|            0|            0|  0.00%|    if base is object:
    63|         0|            0|            0|  0.00%|        state = None
    64|         0|            0|            0|  0.00%|    else:
    65|         0|            0|            0|  0.00%|        if base is cls:
    66|         0|            0|            0|  0.00%|            raise TypeError(f"cannot pickle {cls.__name__!r} object")
    67|         0|            0|            0|  0.00%|        state = base(self)
    68|         0|            0|            0|  0.00%|    args = (cls, base, state)
    69|         0|            0|            0|  0.00%|    try:
    70|         0|            0|            0|  0.00%|        getstate = self.__getstate__
    71|         0|            0|            0|  0.00%|    except AttributeError:
    72|         0|            0|            0|  0.00%|        if getattr(self, "__slots__", None):
    73|         0|            0|            0|  0.00%|            raise TypeError(f"cannot pickle {cls.__name__!r} object: "
    74|         0|            0|            0|  0.00%|                            f"a class that defines __slots__ without "
    75|         0|            0|            0|  0.00%|                            f"defining __getstate__ cannot be pickled "
    76|         0|            0|            0|  0.00%|                            f"with protocol {proto}") from None
    77|         0|            0|            0|  0.00%|        try:
    78|         0|            0|            0|  0.00%|            dict = self.__dict__
    79|         0|            0|            0|  0.00%|        except AttributeError:
    80|         0|            0|            0|  0.00%|            dict = None
    81|         0|            0|            0|  0.00%|    else:
    82|         0|            0|            0|  0.00%|        dict = getstate()
    83|         0|            0|            0|  0.00%|    if dict:
    84|         0|            0|            0|  0.00%|        return _reconstructor, args, dict
    85|         0|            0|            0|  0.00%|    else:
    86|         0|            0|            0|  0.00%|        return _reconstructor, args
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|# Helper for __reduce_ex__ protocol 2
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|def __newobj__(cls, *args):
    91|         0|            0|            0|  0.00%|    return cls.__new__(cls, *args)
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|def __newobj_ex__(cls, args, kwargs):
    94|         0|            0|            0|  0.00%|    """Used by pickle protocol 4, instead of __newobj__ to allow classes with
    95|         0|            0|            0|  0.00%|    keyword-only arguments to be pickled correctly.
    96|         0|            0|            0|  0.00%|    """
    97|         0|            0|            0|  0.00%|    return cls.__new__(cls, *args, **kwargs)
    98|         0|            0|            0|  0.00%|
    99|         3|            0|            0|  0.00%|def _slotnames(cls):
   100|         0|            0|            0|  0.00%|    """Return a list of slot names for a given class.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    This needs to find slots defined by the class and its bases, so we
   103|         0|            0|            0|  0.00%|    can't simply return the __slots__ attribute.  We must walk down
   104|         0|            0|            0|  0.00%|    the Method Resolution Order and concatenate the __slots__ of each
   105|         0|            0|            0|  0.00%|    class found there.  (This assumes classes don't modify their
   106|         0|            0|            0|  0.00%|    __slots__ attribute to misrepresent their slots after the class is
   107|         0|            0|            0|  0.00%|    defined.)
   108|         0|            0|            0|  0.00%|    """
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|    # Get the value from a cache in the class if possible
   111|         3|            0|            0|  0.00%|    names = cls.__dict__.get("__slotnames__")
   112|         3|            0|            0|  0.00%|    if names is not None:
   113|         0|            0|            0|  0.00%|        return names
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|    # Not cached -- calculate the value
   116|         3|            0|            0|  0.00%|    names = []
   117|         3|            0|            0|  0.00%|    if not hasattr(cls, "__slots__"):
   118|         0|            0|            0|  0.00%|        # This class has no slots
   119|         3|            0|            0|  0.00%|        pass
   120|         0|            0|            0|  0.00%|    else:
   121|         0|            0|            0|  0.00%|        # Slots found -- gather slot names from all base classes
   122|         0|            0|            0|  0.00%|        for c in cls.__mro__:
   123|         0|            0|            0|  0.00%|            if "__slots__" in c.__dict__:
   124|         0|            0|            0|  0.00%|                slots = c.__dict__['__slots__']
   125|         0|            0|            0|  0.00%|                # if class has a single slot, it can be given as a string
   126|         0|            0|            0|  0.00%|                if isinstance(slots, str):
   127|         0|            0|            0|  0.00%|                    slots = (slots,)
   128|         0|            0|            0|  0.00%|                for name in slots:
   129|         0|            0|            0|  0.00%|                    # special descriptors
   130|         0|            0|            0|  0.00%|                    if name in ("__dict__", "__weakref__"):
   131|         0|            0|            0|  0.00%|                        continue
   132|         0|            0|            0|  0.00%|                    # mangled names
   133|         0|            0|            0|  0.00%|                    elif name.startswith('__') and not name.endswith('__'):
   134|         0|            0|            0|  0.00%|                        stripped = c.__name__.lstrip('_')
   135|         0|            0|            0|  0.00%|                        if stripped:
   136|         0|            0|            0|  0.00%|                            names.append('_%s%s' % (stripped, name))
   137|         0|            0|            0|  0.00%|                        else:
   138|         0|            0|            0|  0.00%|                            names.append(name)
   139|         0|            0|            0|  0.00%|                    else:
   140|         0|            0|            0|  0.00%|                        names.append(name)
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|    # Cache the outcome in the class if at all possible
   143|         3|            0|            0|  0.00%|    try:
   144|         3|            0|            0|  0.00%|        cls.__slotnames__ = names
   145|         0|            0|            0|  0.00%|    except:
   146|         0|            0|            0|  0.00%|        pass # But don't die if we can't
   147|         0|            0|            0|  0.00%|
   148|         3|            0|            0|  0.00%|    return names
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|# A registry of extension codes.  This is an ad-hoc compression
   151|         0|            0|            0|  0.00%|# mechanism.  Whenever a global reference to <module>, <name> is about
   152|         0|            0|            0|  0.00%|# to be pickled, the (<module>, <name>) tuple is looked up here to see
   153|         0|            0|            0|  0.00%|# if it is a registered extension code for it.  Extension codes are
   154|         0|            0|            0|  0.00%|# universal, so that the meaning of a pickle does not depend on
   155|         0|            0|            0|  0.00%|# context.  (There are also some codes reserved for local use that
   156|         0|            0|            0|  0.00%|# don't have this restriction.)  Codes are positive ints; 0 is
   157|         0|            0|            0|  0.00%|# reserved.
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|_extension_registry = {}                # key -> code
   160|         0|            0|            0|  0.00%|_inverted_registry = {}                 # code -> key
   161|         0|            0|            0|  0.00%|_extension_cache = {}                   # code -> object
   162|         0|            0|            0|  0.00%|# Don't ever rebind those names:  pickling grabs a reference to them when
   163|         0|            0|            0|  0.00%|# it's initialized, and won't see a rebinding.
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|def add_extension(module, name, code):
   166|         0|            0|            0|  0.00%|    """Register an extension code."""
   167|         0|            0|            0|  0.00%|    code = int(code)
   168|         0|            0|            0|  0.00%|    if not 1 <= code <= 0x7fffffff:
   169|         0|            0|            0|  0.00%|        raise ValueError("code out of range")
   170|         0|            0|            0|  0.00%|    key = (module, name)
   171|         0|            0|            0|  0.00%|    if (_extension_registry.get(key) == code and
   172|         0|            0|            0|  0.00%|        _inverted_registry.get(code) == key):
   173|         0|            0|            0|  0.00%|        return # Redundant registrations are benign
   174|         0|            0|            0|  0.00%|    if key in _extension_registry:
   175|         0|            0|            0|  0.00%|        raise ValueError("key %s is already registered with code %s" %
   176|         0|            0|            0|  0.00%|                         (key, _extension_registry[key]))
   177|         0|            0|            0|  0.00%|    if code in _inverted_registry:
   178|         0|            0|            0|  0.00%|        raise ValueError("code %s is already in use for key %s" %
   179|         0|            0|            0|  0.00%|                         (code, _inverted_registry[code]))
   180|         0|            0|            0|  0.00%|    _extension_registry[key] = code
   181|         0|            0|            0|  0.00%|    _inverted_registry[code] = key
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|def remove_extension(module, name, code):
   184|         0|            0|            0|  0.00%|    """Unregister an extension code.  For testing only."""
   185|         0|            0|            0|  0.00%|    key = (module, name)
   186|         0|            0|            0|  0.00%|    if (_extension_registry.get(key) != code or
   187|         0|            0|            0|  0.00%|        _inverted_registry.get(code) != key):
   188|         0|            0|            0|  0.00%|        raise ValueError("key %s is not registered with code %s" %
   189|         0|            0|            0|  0.00%|                         (key, code))
   190|         0|            0|            0|  0.00%|    del _extension_registry[key]
   191|         0|            0|            0|  0.00%|    del _inverted_registry[code]
   192|         0|            0|            0|  0.00%|    if code in _extension_cache:
   193|         0|            0|            0|  0.00%|        del _extension_cache[code]
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|def clear_extension_cache():
   196|         0|            0|            0|  0.00%|    _extension_cache.clear()
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|# Standard extension code assignments
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|# Reserved ranges
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|# First  Last Count  Purpose
   203|         0|            0|            0|  0.00%|#     1   127   127  Reserved for Python standard library
   204|         0|            0|            0|  0.00%|#   128   191    64  Reserved for Zope
   205|         0|            0|            0|  0.00%|#   192   239    48  Reserved for 3rd parties
   206|         0|            0|            0|  0.00%|#   240   255    16  Reserved for private use (will never be assigned)
   207|         0|            0|            0|  0.00%|#   256   Inf   Inf  Reserved for future assignment
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|# Extension codes are assigned by the Python Software Foundation.
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\csc.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Compressed Sparse Column matrix format"""
     2|         0|            0|            0|  0.00%|__docformat__ = "restructuredtext en"
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|__all__ = ['csc_matrix', 'isspmatrix_csc']
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|import numpy as np
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from .base import spmatrix
    10|         0|            0|            0|  0.00%|from ._sparsetools import csc_tocsr, expandptr
    11|         0|            0|            0|  0.00%|from .sputils import upcast, get_index_dtype
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|from .compressed import _cs_matrix
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|class csc_matrix(_cs_matrix):
    17|         0|            0|            0|  0.00%|    """
    18|         0|            0|            0|  0.00%|    Compressed Sparse Column matrix
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|    This can be instantiated in several ways:
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|        csc_matrix(D)
    23|         0|            0|            0|  0.00%|            with a dense matrix or rank-2 ndarray D
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|        csc_matrix(S)
    26|         0|            0|            0|  0.00%|            with another sparse matrix S (equivalent to S.tocsc())
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|        csc_matrix((M, N), [dtype])
    29|         0|            0|            0|  0.00%|            to construct an empty matrix with shape (M, N)
    30|         0|            0|            0|  0.00%|            dtype is optional, defaulting to dtype='d'.
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|        csc_matrix((data, (row_ind, col_ind)), [shape=(M, N)])
    33|         0|            0|            0|  0.00%|            where ``data``, ``row_ind`` and ``col_ind`` satisfy the
    34|         0|            0|            0|  0.00%|            relationship ``a[row_ind[k], col_ind[k]] = data[k]``.
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|        csc_matrix((data, indices, indptr), [shape=(M, N)])
    37|         0|            0|            0|  0.00%|            is the standard CSC representation where the row indices for
    38|         0|            0|            0|  0.00%|            column i are stored in ``indices[indptr[i]:indptr[i+1]]``
    39|         0|            0|            0|  0.00%|            and their corresponding values are stored in
    40|         0|            0|            0|  0.00%|            ``data[indptr[i]:indptr[i+1]]``.  If the shape parameter is
    41|         0|            0|            0|  0.00%|            not supplied, the matrix dimensions are inferred from
    42|         0|            0|            0|  0.00%|            the index arrays.
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    Attributes
    45|         0|            0|            0|  0.00%|    ----------
    46|         0|            0|            0|  0.00%|    dtype : dtype
    47|         0|            0|            0|  0.00%|        Data type of the matrix
    48|         0|            0|            0|  0.00%|    shape : 2-tuple
    49|         0|            0|            0|  0.00%|        Shape of the matrix
    50|         0|            0|            0|  0.00%|    ndim : int
    51|         0|            0|            0|  0.00%|        Number of dimensions (this is always 2)
    52|         0|            0|            0|  0.00%|    nnz
    53|         0|            0|            0|  0.00%|        Number of stored values, including explicit zeros
    54|         0|            0|            0|  0.00%|    data
    55|         0|            0|            0|  0.00%|        Data array of the matrix
    56|         0|            0|            0|  0.00%|    indices
    57|         0|            0|            0|  0.00%|        CSC format index array
    58|         0|            0|            0|  0.00%|    indptr
    59|         0|            0|            0|  0.00%|        CSC format index pointer array
    60|         0|            0|            0|  0.00%|    has_sorted_indices
    61|         0|            0|            0|  0.00%|        Whether indices are sorted
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    Notes
    64|         0|            0|            0|  0.00%|    -----
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    Sparse matrices can be used in arithmetic operations: they support
    67|         0|            0|            0|  0.00%|    addition, subtraction, multiplication, division, and matrix power.
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|    Advantages of the CSC format
    70|         0|            0|            0|  0.00%|        - efficient arithmetic operations CSC + CSC, CSC * CSC, etc.
    71|         0|            0|            0|  0.00%|        - efficient column slicing
    72|         0|            0|            0|  0.00%|        - fast matrix vector products (CSR, BSR may be faster)
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|    Disadvantages of the CSC format
    75|         0|            0|            0|  0.00%|      - slow row slicing operations (consider CSR)
    76|         0|            0|            0|  0.00%|      - changes to the sparsity structure are expensive (consider LIL or DOK)
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    Examples
    80|         0|            0|            0|  0.00%|    --------
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    >>> import numpy as np
    83|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csc_matrix
    84|         0|            0|            0|  0.00%|    >>> csc_matrix((3, 4), dtype=np.int8).toarray()
    85|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0],
    86|         0|            0|            0|  0.00%|           [0, 0, 0, 0],
    87|         0|            0|            0|  0.00%|           [0, 0, 0, 0]], dtype=int8)
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    >>> row = np.array([0, 2, 2, 0, 1, 2])
    90|         0|            0|            0|  0.00%|    >>> col = np.array([0, 0, 1, 2, 2, 2])
    91|         0|            0|            0|  0.00%|    >>> data = np.array([1, 2, 3, 4, 5, 6])
    92|         0|            0|            0|  0.00%|    >>> csc_matrix((data, (row, col)), shape=(3, 3)).toarray()
    93|         0|            0|            0|  0.00%|    array([[1, 0, 4],
    94|         0|            0|            0|  0.00%|           [0, 0, 5],
    95|         0|            0|            0|  0.00%|           [2, 3, 6]])
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|    >>> indptr = np.array([0, 2, 3, 6])
    98|         0|            0|            0|  0.00%|    >>> indices = np.array([0, 2, 2, 0, 1, 2])
    99|         0|            0|            0|  0.00%|    >>> data = np.array([1, 2, 3, 4, 5, 6])
   100|         0|            0|            0|  0.00%|    >>> csc_matrix((data, indices, indptr), shape=(3, 3)).toarray()
   101|         0|            0|            0|  0.00%|    array([[1, 0, 4],
   102|         0|            0|            0|  0.00%|           [0, 0, 5],
   103|         0|            0|            0|  0.00%|           [2, 3, 6]])
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|    """
   106|         0|            0|            0|  0.00%|    format = 'csc'
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|    def transpose(self, axes=None, copy=False):
   109|         0|            0|            0|  0.00%|        if axes is not None:
   110|         0|            0|            0|  0.00%|            raise ValueError(("Sparse matrices do not support "
   111|         0|            0|            0|  0.00%|                              "an 'axes' parameter because swapping "
   112|         0|            0|            0|  0.00%|                              "dimensions is the only logical permutation."))
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|        M, N = self.shape
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|        from .csr import csr_matrix
   117|         0|            0|            0|  0.00%|        return csr_matrix((self.data, self.indices,
   118|         0|            0|            0|  0.00%|                           self.indptr), (N, M), copy=copy)
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    transpose.__doc__ = spmatrix.transpose.__doc__
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|    def __iter__(self):
   123|         0|            0|            0|  0.00%|        yield from self.tocsr()
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    def tocsc(self, copy=False):
   126|         0|            0|            0|  0.00%|        if copy:
   127|         0|            0|            0|  0.00%|            return self.copy()
   128|         0|            0|            0|  0.00%|        else:
   129|         0|            0|            0|  0.00%|            return self
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|    tocsc.__doc__ = spmatrix.tocsc.__doc__
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    def tocsr(self, copy=False):
   134|         0|            0|            0|  0.00%|        M,N = self.shape
   135|         0|            0|            0|  0.00%|        idx_dtype = get_index_dtype((self.indptr, self.indices),
   136|         0|            0|            0|  0.00%|                                    maxval=max(self.nnz, N))
   137|         0|            0|            0|  0.00%|        indptr = np.empty(M + 1, dtype=idx_dtype)
   138|         0|            0|            0|  0.00%|        indices = np.empty(self.nnz, dtype=idx_dtype)
   139|         0|            0|            0|  0.00%|        data = np.empty(self.nnz, dtype=upcast(self.dtype))
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|        csc_tocsr(M, N,
   142|         0|            0|            0|  0.00%|                  self.indptr.astype(idx_dtype),
   143|         0|            0|            0|  0.00%|                  self.indices.astype(idx_dtype),
   144|         0|            0|            0|  0.00%|                  self.data,
   145|         0|            0|            0|  0.00%|                  indptr,
   146|         0|            0|            0|  0.00%|                  indices,
   147|         0|            0|            0|  0.00%|                  data)
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|        from .csr import csr_matrix
   150|         0|            0|            0|  0.00%|        A = csr_matrix((data, indices, indptr), shape=self.shape, copy=False)
   151|         0|            0|            0|  0.00%|        A.has_sorted_indices = True
   152|         0|            0|            0|  0.00%|        return A
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|    tocsr.__doc__ = spmatrix.tocsr.__doc__
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|    def nonzero(self):
   157|         0|            0|            0|  0.00%|        # CSC can't use _cs_matrix's .nonzero method because it
   158|         0|            0|            0|  0.00%|        # returns the indices sorted for self transposed.
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|        # Get row and col indices, from _cs_matrix.tocoo
   161|         0|            0|            0|  0.00%|        major_dim, minor_dim = self._swap(self.shape)
   162|         0|            0|            0|  0.00%|        minor_indices = self.indices
   163|         0|            0|            0|  0.00%|        major_indices = np.empty(len(minor_indices), dtype=self.indices.dtype)
   164|         0|            0|            0|  0.00%|        expandptr(major_dim, self.indptr, major_indices)
   165|         0|            0|            0|  0.00%|        row, col = self._swap((major_indices, minor_indices))
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|        # Remove explicit zeros
   168|         0|            0|            0|  0.00%|        nz_mask = self.data != 0
   169|         0|            0|            0|  0.00%|        row = row[nz_mask]
   170|         0|            0|            0|  0.00%|        col = col[nz_mask]
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|        # Sort them to be in C-style order
   173|         0|            0|            0|  0.00%|        ind = np.argsort(row, kind='mergesort')
   174|         0|            0|            0|  0.00%|        row = row[ind]
   175|         0|            0|            0|  0.00%|        col = col[ind]
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|        return row, col
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|    nonzero.__doc__ = _cs_matrix.nonzero.__doc__
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    def getrow(self, i):
   182|         0|            0|            0|  0.00%|        """Returns a copy of row i of the matrix, as a (1 x n)
   183|         0|            0|            0|  0.00%|        CSR matrix (row vector).
   184|         0|            0|            0|  0.00%|        """
   185|         0|            0|            0|  0.00%|        M, N = self.shape
   186|         0|            0|            0|  0.00%|        i = int(i)
   187|         0|            0|            0|  0.00%|        if i < 0:
   188|         0|            0|            0|  0.00%|            i += M
   189|         0|            0|            0|  0.00%|        if i < 0 or i >= M:
   190|         0|            0|            0|  0.00%|            raise IndexError('index (%d) out of range' % i)
   191|         0|            0|            0|  0.00%|        return self._get_submatrix(minor=i).tocsr()
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    def getcol(self, i):
   194|         0|            0|            0|  0.00%|        """Returns a copy of column i of the matrix, as a (m x 1)
   195|         0|            0|            0|  0.00%|        CSC matrix (column vector).
   196|         0|            0|            0|  0.00%|        """
   197|         0|            0|            0|  0.00%|        M, N = self.shape
   198|         0|            0|            0|  0.00%|        i = int(i)
   199|         0|            0|            0|  0.00%|        if i < 0:
   200|         0|            0|            0|  0.00%|            i += N
   201|         0|            0|            0|  0.00%|        if i < 0 or i >= N:
   202|         0|            0|            0|  0.00%|            raise IndexError('index (%d) out of range' % i)
   203|         0|            0|            0|  0.00%|        return self._get_submatrix(major=i, copy=True)
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|    def _get_intXarray(self, row, col):
   206|         0|            0|            0|  0.00%|        return self._major_index_fancy(col)._get_submatrix(minor=row)
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|    def _get_intXslice(self, row, col):
   209|         0|            0|            0|  0.00%|        if col.step in (1, None):
   210|         0|            0|            0|  0.00%|            return self._get_submatrix(major=col, minor=row, copy=True)
   211|         0|            0|            0|  0.00%|        return self._major_slice(col)._get_submatrix(minor=row)
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    def _get_sliceXint(self, row, col):
   214|         0|            0|            0|  0.00%|        if row.step in (1, None):
   215|         0|            0|            0|  0.00%|            return self._get_submatrix(major=col, minor=row, copy=True)
   216|         0|            0|            0|  0.00%|        return self._get_submatrix(major=col)._minor_slice(row)
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|    def _get_sliceXarray(self, row, col):
   219|         0|            0|            0|  0.00%|        return self._major_index_fancy(col)._minor_slice(row)
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|    def _get_arrayXint(self, row, col):
   222|         0|            0|            0|  0.00%|        return self._get_submatrix(major=col)._minor_index_fancy(row)
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    def _get_arrayXslice(self, row, col):
   225|         0|            0|            0|  0.00%|        return self._major_slice(col)._minor_index_fancy(row)
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    # these functions are used by the parent class (_cs_matrix)
   228|         0|            0|            0|  0.00%|    # to remove redudancy between csc_matrix and csr_matrix
   229|        12|            0|            0|  0.00%|    def _swap(self, x):
   230|         0|            0|            0|  0.00%|        """swap the members of x if this is a column-oriented matrix
   231|         0|            0|            0|  0.00%|        """
   232|        12|            0|            0|  0.00%|        return x[1], x[0]
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|def isspmatrix_csc(x):
   236|         0|            0|            0|  0.00%|    """Is x of csc_matrix type?
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|    Parameters
   239|         0|            0|            0|  0.00%|    ----------
   240|         0|            0|            0|  0.00%|    x
   241|         0|            0|            0|  0.00%|        object to check for being a csc matrix
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    Returns
   244|         0|            0|            0|  0.00%|    -------
   245|         0|            0|            0|  0.00%|    bool
   246|         0|            0|            0|  0.00%|        True if x is a csc matrix, False otherwise
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    Examples
   249|         0|            0|            0|  0.00%|    --------
   250|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csc_matrix, isspmatrix_csc
   251|         0|            0|            0|  0.00%|    >>> isspmatrix_csc(csc_matrix([[5]]))
   252|         0|            0|            0|  0.00%|    True
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
   255|         0|            0|            0|  0.00%|    >>> isspmatrix_csc(csr_matrix([[5]]))
   256|         0|            0|            0|  0.00%|    False
   257|         0|            0|            0|  0.00%|    """
   258|         0|            0|            0|  0.00%|    return isinstance(x, csc_matrix)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\extract.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Functions to extract parts of sparse matrices
     2|         0|            0|            0|  0.00%|"""
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|__docformat__ = "restructuredtext en"
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|__all__ = ['find', 'tril', 'triu']
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from .coo import coo_matrix
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         4|            0|            0|  0.00%|def find(A):
    13|         0|            0|            0|  0.00%|    """Return the indices and values of the nonzero elements of a matrix
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|    Parameters
    16|         0|            0|            0|  0.00%|    ----------
    17|         0|            0|            0|  0.00%|    A : dense or sparse matrix
    18|         0|            0|            0|  0.00%|        Matrix whose nonzero elements are desired.
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|    Returns
    21|         0|            0|            0|  0.00%|    -------
    22|         0|            0|            0|  0.00%|    (I,J,V) : tuple of arrays
    23|         0|            0|            0|  0.00%|        I,J, and V contain the row indices, column indices, and values
    24|         0|            0|            0|  0.00%|        of the nonzero matrix entries.
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    Examples
    28|         0|            0|            0|  0.00%|    --------
    29|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csr_matrix, find
    30|         0|            0|            0|  0.00%|    >>> A = csr_matrix([[7.0, 8.0, 0],[0, 0, 9.0]])
    31|         0|            0|            0|  0.00%|    >>> find(A)
    32|         0|            0|            0|  0.00%|    (array([0, 0, 1], dtype=int32), array([0, 1, 2], dtype=int32), array([ 7.,  8.,  9.]))
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|    """
    35|         0|            0|            0|  0.00%|
    36|         4|            0|            0|  0.00%|    A = coo_matrix(A, copy=True)
(call)|         4|   0.00199389|  0.000498474|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:126 __init__
    37|         4|            0|            0|  0.00%|    A.sum_duplicates()
(call)|         4|   0.00199389|  0.000498474|  0.01%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\scipy\sparse\coo.py:526 sum_duplicates
    38|         0|            0|            0|  0.00%|    # remove explicit zeros
    39|         4|            0|            0|  0.00%|    nz_mask = A.data != 0
    40|         4|            0|            0|  0.00%|    return A.row[nz_mask], A.col[nz_mask], A.data[nz_mask]
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|def tril(A, k=0, format=None):
    44|         0|            0|            0|  0.00%|    """Return the lower triangular portion of a matrix in sparse format
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    Returns the elements on or below the k-th diagonal of the matrix A.
    47|         0|            0|            0|  0.00%|        - k = 0 corresponds to the main diagonal
    48|         0|            0|            0|  0.00%|        - k > 0 is above the main diagonal
    49|         0|            0|            0|  0.00%|        - k < 0 is below the main diagonal
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    Parameters
    52|         0|            0|            0|  0.00%|    ----------
    53|         0|            0|            0|  0.00%|    A : dense or sparse matrix
    54|         0|            0|            0|  0.00%|        Matrix whose lower trianglar portion is desired.
    55|         0|            0|            0|  0.00%|    k : integer : optional
    56|         0|            0|            0|  0.00%|        The top-most diagonal of the lower triangle.
    57|         0|            0|            0|  0.00%|    format : string
    58|         0|            0|            0|  0.00%|        Sparse format of the result, e.g. format="csr", etc.
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    Returns
    61|         0|            0|            0|  0.00%|    -------
    62|         0|            0|            0|  0.00%|    L : sparse matrix
    63|         0|            0|            0|  0.00%|        Lower triangular portion of A in sparse format.
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    See Also
    66|         0|            0|            0|  0.00%|    --------
    67|         0|            0|            0|  0.00%|    triu : upper triangle in sparse format
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|    Examples
    70|         0|            0|            0|  0.00%|    --------
    71|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csr_matrix, tril
    72|         0|            0|            0|  0.00%|    >>> A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
    73|         0|            0|            0|  0.00%|    ...                dtype='int32')
    74|         0|            0|            0|  0.00%|    >>> A.toarray()
    75|         0|            0|            0|  0.00%|    array([[1, 2, 0, 0, 3],
    76|         0|            0|            0|  0.00%|           [4, 5, 0, 6, 7],
    77|         0|            0|            0|  0.00%|           [0, 0, 8, 9, 0]])
    78|         0|            0|            0|  0.00%|    >>> tril(A).toarray()
    79|         0|            0|            0|  0.00%|    array([[1, 0, 0, 0, 0],
    80|         0|            0|            0|  0.00%|           [4, 5, 0, 0, 0],
    81|         0|            0|            0|  0.00%|           [0, 0, 8, 0, 0]])
    82|         0|            0|            0|  0.00%|    >>> tril(A).nnz
    83|         0|            0|            0|  0.00%|    4
    84|         0|            0|            0|  0.00%|    >>> tril(A, k=1).toarray()
    85|         0|            0|            0|  0.00%|    array([[1, 2, 0, 0, 0],
    86|         0|            0|            0|  0.00%|           [4, 5, 0, 0, 0],
    87|         0|            0|            0|  0.00%|           [0, 0, 8, 9, 0]])
    88|         0|            0|            0|  0.00%|    >>> tril(A, k=-1).toarray()
    89|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0, 0],
    90|         0|            0|            0|  0.00%|           [4, 0, 0, 0, 0],
    91|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0]])
    92|         0|            0|            0|  0.00%|    >>> tril(A, format='csc')
    93|         0|            0|            0|  0.00%|    <3x5 sparse matrix of type '<class 'numpy.int32'>'
    94|         0|            0|            0|  0.00%|            with 4 stored elements in Compressed Sparse Column format>
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    """
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    # convert to COOrdinate format where things are easy
    99|         0|            0|            0|  0.00%|    A = coo_matrix(A, copy=False)
   100|         0|            0|            0|  0.00%|    mask = A.row + k >= A.col
   101|         0|            0|            0|  0.00%|    return _masked_coo(A, mask).asformat(format)
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|def triu(A, k=0, format=None):
   105|         0|            0|            0|  0.00%|    """Return the upper triangular portion of a matrix in sparse format
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|    Returns the elements on or above the k-th diagonal of the matrix A.
   108|         0|            0|            0|  0.00%|        - k = 0 corresponds to the main diagonal
   109|         0|            0|            0|  0.00%|        - k > 0 is above the main diagonal
   110|         0|            0|            0|  0.00%|        - k < 0 is below the main diagonal
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|    Parameters
   113|         0|            0|            0|  0.00%|    ----------
   114|         0|            0|            0|  0.00%|    A : dense or sparse matrix
   115|         0|            0|            0|  0.00%|        Matrix whose upper trianglar portion is desired.
   116|         0|            0|            0|  0.00%|    k : integer : optional
   117|         0|            0|            0|  0.00%|        The bottom-most diagonal of the upper triangle.
   118|         0|            0|            0|  0.00%|    format : string
   119|         0|            0|            0|  0.00%|        Sparse format of the result, e.g. format="csr", etc.
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|    Returns
   122|         0|            0|            0|  0.00%|    -------
   123|         0|            0|            0|  0.00%|    L : sparse matrix
   124|         0|            0|            0|  0.00%|        Upper triangular portion of A in sparse format.
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|    See Also
   127|         0|            0|            0|  0.00%|    --------
   128|         0|            0|            0|  0.00%|    tril : lower triangle in sparse format
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|    Examples
   131|         0|            0|            0|  0.00%|    --------
   132|         0|            0|            0|  0.00%|    >>> from scipy.sparse import csr_matrix, triu
   133|         0|            0|            0|  0.00%|    >>> A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
   134|         0|            0|            0|  0.00%|    ...                dtype='int32')
   135|         0|            0|            0|  0.00%|    >>> A.toarray()
   136|         0|            0|            0|  0.00%|    array([[1, 2, 0, 0, 3],
   137|         0|            0|            0|  0.00%|           [4, 5, 0, 6, 7],
   138|         0|            0|            0|  0.00%|           [0, 0, 8, 9, 0]])
   139|         0|            0|            0|  0.00%|    >>> triu(A).toarray()
   140|         0|            0|            0|  0.00%|    array([[1, 2, 0, 0, 3],
   141|         0|            0|            0|  0.00%|           [0, 5, 0, 6, 7],
   142|         0|            0|            0|  0.00%|           [0, 0, 8, 9, 0]])
   143|         0|            0|            0|  0.00%|    >>> triu(A).nnz
   144|         0|            0|            0|  0.00%|    8
   145|         0|            0|            0|  0.00%|    >>> triu(A, k=1).toarray()
   146|         0|            0|            0|  0.00%|    array([[0, 2, 0, 0, 3],
   147|         0|            0|            0|  0.00%|           [0, 0, 0, 6, 7],
   148|         0|            0|            0|  0.00%|           [0, 0, 0, 9, 0]])
   149|         0|            0|            0|  0.00%|    >>> triu(A, k=-1).toarray()
   150|         0|            0|            0|  0.00%|    array([[1, 2, 0, 0, 3],
   151|         0|            0|            0|  0.00%|           [4, 5, 0, 6, 7],
   152|         0|            0|            0|  0.00%|           [0, 0, 8, 9, 0]])
   153|         0|            0|            0|  0.00%|    >>> triu(A, format='csc')
   154|         0|            0|            0|  0.00%|    <3x5 sparse matrix of type '<class 'numpy.int32'>'
   155|         0|            0|            0|  0.00%|            with 8 stored elements in Compressed Sparse Column format>
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    """
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|    # convert to COOrdinate format where things are easy
   160|         0|            0|            0|  0.00%|    A = coo_matrix(A, copy=False)
   161|         0|            0|            0|  0.00%|    mask = A.row + k <= A.col
   162|         0|            0|            0|  0.00%|    return _masked_coo(A, mask).asformat(format)
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|def _masked_coo(A, mask):
   166|         0|            0|            0|  0.00%|    row = A.row[mask]
   167|         0|            0|            0|  0.00%|    col = A.col[mask]
   168|         0|            0|            0|  0.00%|    data = A.data[mask]
   169|         0|            0|            0|  0.00%|    return coo_matrix((data, (row, col)), shape=A.shape, dtype=A.dtype)
File: C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\utils\fixes.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Compatibility fixes for older version of python, numpy and scipy
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|If you add content to this file, please give the version of the package
     4|         0|            0|            0|  0.00%|at which the fix is no longer needed.
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|# Authors: Emmanuelle Gouillart <emmanuelle.gouillart@normalesup.org>
     7|         0|            0|            0|  0.00%|#          Gael Varoquaux <gael.varoquaux@normalesup.org>
     8|         0|            0|            0|  0.00%|#          Fabian Pedregosa <fpedregosa@acm.org>
     9|         0|            0|            0|  0.00%|#          Lars Buitinck
    10|         0|            0|            0|  0.00%|#
    11|         0|            0|            0|  0.00%|# License: BSD 3 clause
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|from functools import update_wrapper
    14|         0|            0|            0|  0.00%|import functools
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|import sklearn
    17|         0|            0|            0|  0.00%|import numpy as np
    18|         0|            0|            0|  0.00%|import scipy.sparse as sp
    19|         0|            0|            0|  0.00%|import scipy
    20|         0|            0|            0|  0.00%|import scipy.stats
    21|         0|            0|            0|  0.00%|from scipy.sparse.linalg import lsqr as sparse_lsqr  # noqa
    22|         0|            0|            0|  0.00%|import threadpoolctl
    23|         0|            0|            0|  0.00%|from .._config import config_context, get_config
    24|         0|            0|            0|  0.00%|from ..externals._packaging.version import parse as parse_version
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|np_version = parse_version(np.__version__)
    28|         0|            0|            0|  0.00%|sp_version = parse_version(scipy.__version__)
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|if sp_version >= parse_version("1.4"):
    32|         0|            0|            0|  0.00%|    from scipy.sparse.linalg import lobpcg
    33|         0|            0|            0|  0.00%|else:
    34|         0|            0|            0|  0.00%|    # Backport of lobpcg functionality from scipy 1.4.0, can be removed
    35|         0|            0|            0|  0.00%|    # once support for sp_version < parse_version('1.4') is dropped
    36|         0|            0|            0|  0.00%|    # mypy error: Name 'lobpcg' already defined (possibly by an import)
    37|         0|            0|            0|  0.00%|    from ..externals._lobpcg import lobpcg  # type: ignore  # noqa
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|def _object_dtype_isnan(X):
    41|         0|            0|            0|  0.00%|    return X != X
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|# TODO: replace by copy=False, when only scipy > 1.1 is supported.
    45|         4|            0|            0|  0.00%|def _astype_copy_false(X):
    46|         0|            0|            0|  0.00%|    """Returns the copy=False parameter for
    47|         0|            0|            0|  0.00%|    {ndarray, csr_matrix, csc_matrix}.astype when possible,
    48|         0|            0|            0|  0.00%|    otherwise don't specify
    49|         0|            0|            0|  0.00%|    """
    50|         4|            0|            0|  0.00%|    if sp_version >= parse_version("1.1") or not sp.issparse(X):
(call)|         4|  0.000997305|  0.000249326|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:65 parse
(call)|         4|            0|            0|  0.00%|# C:\Users\Gael\AppData\Local\Programs\Python\Python38\venv\lib\site-packages\sklearn\externals\_packaging\version.py:110 __ge__
    51|         4|            0|            0|  0.00%|        return {"copy": False}
    52|         0|            0|            0|  0.00%|    else:
    53|         0|            0|            0|  0.00%|        return {}
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|def _joblib_parallel_args(**kwargs):
    57|         0|            0|            0|  0.00%|    """Set joblib.Parallel arguments in a compatible way for 0.11 and 0.12+
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|    For joblib 0.11 this maps both ``prefer`` and ``require`` parameters to
    60|         0|            0|            0|  0.00%|    a specific ``backend``.
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    Parameters
    63|         0|            0|            0|  0.00%|    ----------
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    prefer : str in {'processes', 'threads'} or None
    66|         0|            0|            0|  0.00%|        Soft hint to choose the default backend if no specific backend
    67|         0|            0|            0|  0.00%|        was selected with the parallel_backend context manager.
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|    require : 'sharedmem' or None
    70|         0|            0|            0|  0.00%|        Hard condstraint to select the backend. If set to 'sharedmem',
    71|         0|            0|            0|  0.00%|        the selected backend will be single-host and thread-based even
    72|         0|            0|            0|  0.00%|        if the user asked for a non-thread based backend with
    73|         0|            0|            0|  0.00%|        parallel_backend.
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    See joblib.Parallel documentation for more details
    76|         0|            0|            0|  0.00%|    """
    77|         0|            0|            0|  0.00%|    import joblib
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    if parse_version(joblib.__version__) >= parse_version("0.12"):
    80|         0|            0|            0|  0.00%|        return kwargs
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    extra_args = set(kwargs.keys()).difference({"prefer", "require"})
    83|         0|            0|            0|  0.00%|    if extra_args:
    84|         0|            0|            0|  0.00%|        raise NotImplementedError(
    85|         0|            0|            0|  0.00%|            "unhandled arguments %s with joblib %s"
    86|         0|            0|            0|  0.00%|            % (list(extra_args), joblib.__version__)
    87|         0|            0|            0|  0.00%|        )
    88|         0|            0|            0|  0.00%|    args = {}
    89|         0|            0|            0|  0.00%|    if "prefer" in kwargs:
    90|         0|            0|            0|  0.00%|        prefer = kwargs["prefer"]
    91|         0|            0|            0|  0.00%|        if prefer not in ["threads", "processes", None]:
    92|         0|            0|            0|  0.00%|            raise ValueError("prefer=%s is not supported" % prefer)
    93|         0|            0|            0|  0.00%|        args["backend"] = {
    94|         0|            0|            0|  0.00%|            "threads": "threading",
    95|         0|            0|            0|  0.00%|            "processes": "multiprocessing",
    96|         0|            0|            0|  0.00%|            None: None,
    97|         0|            0|            0|  0.00%|        }[prefer]
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    if "require" in kwargs:
   100|         0|            0|            0|  0.00%|        require = kwargs["require"]
   101|         0|            0|            0|  0.00%|        if require not in [None, "sharedmem"]:
   102|         0|            0|            0|  0.00%|            raise ValueError("require=%s is not supported" % require)
   103|         0|            0|            0|  0.00%|        if require == "sharedmem":
   104|         0|            0|            0|  0.00%|            args["backend"] = "threading"
   105|         0|            0|            0|  0.00%|    return args
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|class loguniform(scipy.stats.reciprocal):
   109|         0|            0|            0|  0.00%|    """A class supporting log-uniform random variables.
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    Parameters
   112|         0|            0|            0|  0.00%|    ----------
   113|         0|            0|            0|  0.00%|    low : float
   114|         0|            0|            0|  0.00%|        The minimum value
   115|         0|            0|            0|  0.00%|    high : float
   116|         0|            0|            0|  0.00%|        The maximum value
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    Methods
   119|         0|            0|            0|  0.00%|    -------
   120|         0|            0|            0|  0.00%|    rvs(self, size=None, random_state=None)
   121|         0|            0|            0|  0.00%|        Generate log-uniform random variables
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    The most useful method for Scikit-learn usage is highlighted here.
   124|         0|            0|            0|  0.00%|    For a full list, see
   125|         0|            0|            0|  0.00%|    `scipy.stats.reciprocal
   126|         0|            0|            0|  0.00%|    <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.reciprocal.html>`_.
   127|         0|            0|            0|  0.00%|    This list includes all functions of ``scipy.stats`` continuous
   128|         0|            0|            0|  0.00%|    distributions such as ``pdf``.
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|    Notes
   131|         0|            0|            0|  0.00%|    -----
   132|         0|            0|            0|  0.00%|    This class generates values between ``low`` and ``high`` or
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|        low <= loguniform(low, high).rvs() <= high
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|    The logarithmic probability density function (PDF) is uniform. When
   137|         0|            0|            0|  0.00%|    ``x`` is a uniformly distributed random variable between 0 and 1, ``10**x``
   138|         0|            0|            0|  0.00%|    are random variables that are equally likely to be returned.
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    This class is an alias to ``scipy.stats.reciprocal``, which uses the
   141|         0|            0|            0|  0.00%|    reciprocal distribution:
   142|         0|            0|            0|  0.00%|    https://en.wikipedia.org/wiki/Reciprocal_distribution
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    Examples
   145|         0|            0|            0|  0.00%|    --------
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    >>> from sklearn.utils.fixes import loguniform
   148|         0|            0|            0|  0.00%|    >>> rv = loguniform(1e-3, 1e1)
   149|         0|            0|            0|  0.00%|    >>> rvs = rv.rvs(random_state=42, size=1000)
   150|         0|            0|            0|  0.00%|    >>> rvs.min()  # doctest: +SKIP
   151|         0|            0|            0|  0.00%|    0.0010435856341129003
   152|         0|            0|            0|  0.00%|    >>> rvs.max()  # doctest: +SKIP
   153|         0|            0|            0|  0.00%|    9.97403052786026
   154|         0|            0|            0|  0.00%|    """
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|def _take_along_axis(arr, indices, axis):
   158|         0|            0|            0|  0.00%|    """Implements a simplified version of np.take_along_axis if numpy
   159|         0|            0|            0|  0.00%|    version < 1.15"""
   160|         0|            0|            0|  0.00%|    if np_version >= parse_version("1.15"):
   161|         0|            0|            0|  0.00%|        return np.take_along_axis(arr=arr, indices=indices, axis=axis)
   162|         0|            0|            0|  0.00%|    else:
   163|         0|            0|            0|  0.00%|        if axis is None:
   164|         0|            0|            0|  0.00%|            arr = arr.flatten()
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|        if not np.issubdtype(indices.dtype, np.intp):
   167|         0|            0|            0|  0.00%|            raise IndexError("`indices` must be an integer array")
   168|         0|            0|            0|  0.00%|        if arr.ndim != indices.ndim:
   169|         0|            0|            0|  0.00%|            raise ValueError(
   170|         0|            0|            0|  0.00%|                "`indices` and `arr` must have the same number of dimensions"
   171|         0|            0|            0|  0.00%|            )
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|        shape_ones = (1,) * indices.ndim
   174|         0|            0|            0|  0.00%|        dest_dims = list(range(axis)) + [None] + list(range(axis + 1, indices.ndim))
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|        # build a fancy index, consisting of orthogonal aranges, with the
   177|         0|            0|            0|  0.00%|        # requested index inserted at the right location
   178|         0|            0|            0|  0.00%|        fancy_index = []
   179|         0|            0|            0|  0.00%|        for dim, n in zip(dest_dims, arr.shape):
   180|         0|            0|            0|  0.00%|            if dim is None:
   181|         0|            0|            0|  0.00%|                fancy_index.append(indices)
   182|         0|            0|            0|  0.00%|            else:
   183|         0|            0|            0|  0.00%|                ind_shape = shape_ones[:dim] + (-1,) + shape_ones[dim + 1 :]
   184|         0|            0|            0|  0.00%|                fancy_index.append(np.arange(n).reshape(ind_shape))
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|        fancy_index = tuple(fancy_index)
   187|         0|            0|            0|  0.00%|        return arr[fancy_index]
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|# remove when https://github.com/joblib/joblib/issues/1071 is fixed
   191|         0|            0|            0|  0.00%|def delayed(function):
   192|         0|            0|            0|  0.00%|    """Decorator used to capture the arguments of a function."""
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|    @functools.wraps(function)
   195|         0|            0|            0|  0.00%|    def delayed_function(*args, **kwargs):
   196|         0|            0|            0|  0.00%|        return _FuncWrapper(function), args, kwargs
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    return delayed_function
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|class _FuncWrapper:
   202|         0|            0|            0|  0.00%|    """ "Load the global configuration before calling the function."""
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|    def __init__(self, function):
   205|         0|            0|            0|  0.00%|        self.function = function
   206|         0|            0|            0|  0.00%|        self.config = get_config()
   207|         0|            0|            0|  0.00%|        update_wrapper(self, self.function)
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    def __call__(self, *args, **kwargs):
   210|         0|            0|            0|  0.00%|        with config_context(**self.config):
   211|         0|            0|            0|  0.00%|            return self.function(*args, **kwargs)
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0):
   215|         0|            0|            0|  0.00%|    """Implements a simplified linspace function as of numpy version >= 1.16.
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|    As of numpy 1.16, the arguments start and stop can be array-like and
   218|         0|            0|            0|  0.00%|    there is an optional argument `axis`.
   219|         0|            0|            0|  0.00%|    For simplicity, we only allow 1d array-like to be passed to start and stop.
   220|         0|            0|            0|  0.00%|    See: https://github.com/numpy/numpy/pull/12388 and numpy 1.16 release
   221|         0|            0|            0|  0.00%|    notes about start and stop arrays for linspace logspace and geomspace.
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    Returns
   224|         0|            0|            0|  0.00%|    -------
   225|         0|            0|            0|  0.00%|    out : ndarray of shape (num, n_start) or (num,)
   226|         0|            0|            0|  0.00%|        The output array with `n_start=start.shape[0]` columns.
   227|         0|            0|            0|  0.00%|    """
   228|         0|            0|            0|  0.00%|    if np_version < parse_version("1.16"):
   229|         0|            0|            0|  0.00%|        start = np.asanyarray(start) * 1.0
   230|         0|            0|            0|  0.00%|        stop = np.asanyarray(stop) * 1.0
   231|         0|            0|            0|  0.00%|        dt = np.result_type(start, stop, float(num))
   232|         0|            0|            0|  0.00%|        if dtype is None:
   233|         0|            0|            0|  0.00%|            dtype = dt
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|        if start.ndim == 0 == stop.ndim:
   236|         0|            0|            0|  0.00%|            return np.linspace(
   237|         0|            0|            0|  0.00%|                start=start,
   238|         0|            0|            0|  0.00%|                stop=stop,
   239|         0|            0|            0|  0.00%|                num=num,
   240|         0|            0|            0|  0.00%|                endpoint=endpoint,
   241|         0|            0|            0|  0.00%|                retstep=retstep,
   242|         0|            0|            0|  0.00%|                dtype=dtype,
   243|         0|            0|            0|  0.00%|            )
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|        if start.ndim != 1 or stop.ndim != 1 or start.shape != stop.shape:
   246|         0|            0|            0|  0.00%|            raise ValueError("start and stop must be 1d array-like of same shape.")
   247|         0|            0|            0|  0.00%|        n_start = start.shape[0]
   248|         0|            0|            0|  0.00%|        out = np.empty((num, n_start), dtype=dtype)
   249|         0|            0|            0|  0.00%|        step = np.empty(n_start, dtype=np.float)
   250|         0|            0|            0|  0.00%|        for i in range(n_start):
   251|         0|            0|            0|  0.00%|            out[:, i], step[i] = np.linspace(
   252|         0|            0|            0|  0.00%|                start=start[i],
   253|         0|            0|            0|  0.00%|                stop=stop[i],
   254|         0|            0|            0|  0.00%|                num=num,
   255|         0|            0|            0|  0.00%|                endpoint=endpoint,
   256|         0|            0|            0|  0.00%|                retstep=True,
   257|         0|            0|            0|  0.00%|                dtype=dtype,
   258|         0|            0|            0|  0.00%|            )
   259|         0|            0|            0|  0.00%|        if axis != 0:
   260|         0|            0|            0|  0.00%|            out = np.moveaxis(out, 0, axis)
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|        if retstep:
   263|         0|            0|            0|  0.00%|            return out, step
   264|         0|            0|            0|  0.00%|        else:
   265|         0|            0|            0|  0.00%|            return out
   266|         0|            0|            0|  0.00%|    else:
   267|         0|            0|            0|  0.00%|        return np.linspace(
   268|         0|            0|            0|  0.00%|            start=start,
   269|         0|            0|            0|  0.00%|            stop=stop,
   270|         0|            0|            0|  0.00%|            num=num,
   271|         0|            0|            0|  0.00%|            endpoint=endpoint,
   272|         0|            0|            0|  0.00%|            retstep=retstep,
   273|         0|            0|            0|  0.00%|            dtype=dtype,
   274|         0|            0|            0|  0.00%|            axis=axis,
   275|         0|            0|            0|  0.00%|        )
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|# compatibility fix for threadpoolctl >= 3.0.0
   279|         0|            0|            0|  0.00%|# since version 3 it's possible to setup a global threadpool controller to avoid
   280|         0|            0|            0|  0.00%|# looping through all loaded shared libraries each time.
   281|         0|            0|            0|  0.00%|# the global controller is created during the first call to threadpoolctl.
   282|         0|            0|            0|  0.00%|def _get_threadpool_controller():
   283|         0|            0|            0|  0.00%|    if not hasattr(threadpoolctl, "ThreadpoolController"):
   284|         0|            0|            0|  0.00%|        return None
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|    if not hasattr(sklearn, "_sklearn_threadpool_controller"):
   287|         0|            0|            0|  0.00%|        sklearn._sklearn_threadpool_controller = threadpoolctl.ThreadpoolController()
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|    return sklearn._sklearn_threadpool_controller
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|def threadpool_limits(limits=None, user_api=None):
   293|         0|            0|            0|  0.00%|    controller = _get_threadpool_controller()
   294|         0|            0|            0|  0.00%|    if controller is not None:
   295|         0|            0|            0|  0.00%|        return controller.limit(limits=limits, user_api=user_api)
   296|         0|            0|            0|  0.00%|    else:
   297|         0|            0|            0|  0.00%|        return threadpoolctl.threadpool_limits(limits=limits, user_api=user_api)
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|threadpool_limits.__doc__ = threadpoolctl.threadpool_limits.__doc__
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|def threadpool_info():
   304|         0|            0|            0|  0.00%|    controller = _get_threadpool_controller()
   305|         0|            0|            0|  0.00%|    if controller is not None:
   306|         0|            0|            0|  0.00%|        return controller.info()
   307|         0|            0|            0|  0.00%|    else:
   308|         0|            0|            0|  0.00%|        return threadpoolctl.threadpool_info()
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|threadpool_info.__doc__ = threadpoolctl.threadpool_info.__doc__
File: <string>
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         8|            0|            0|  0.00%|
File: D:/Thèse/Codes/Articles/MPDHP/Experiments.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import os
     2|         0|            0|            0|  0.00%|os.environ['OPENBLAS_NUM_THREADS'] = '1'
     3|         0|            0|            0|  0.00%|os.environ['MKL_NUM_THREADS'] = '1'
     4|         0|            0|            0|  0.00%|import numpy as np
     5|         0|            0|            0|  0.00%|import sys
     6|         0|            0|            0|  0.00%|from Generate_data import generate
     7|         0|            0|            0|  0.00%|from MPDHP import run_fit
     8|         0|            0|            0|  0.00%|import time
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|np.random.seed(1111)
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|def ensureFolder(folder):
    13|         0|            0|            0|  0.00%|    curfol = "./"
    14|         0|            0|            0|  0.00%|    for fol in folder.split("/")[:-1]:
    15|         0|            0|            0|  0.00%|        if fol not in os.listdir(curfol) and fol!="":
    16|         0|            0|            0|  0.00%|            os.mkdir(curfol+fol)
    17|         0|            0|            0|  0.00%|        curfol += fol+"/"
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|def readObservations(folder, name_ds, output_folder):
    20|         0|            0|            0|  0.00%|    ensureFolder(output_folder)
    21|         0|            0|            0|  0.00%|    dataFile = folder+name_ds
    22|         0|            0|            0|  0.00%|    observations = []
    23|         0|            0|            0|  0.00%|    wdToIndex, index = {}, 0
    24|         0|            0|            0|  0.00%|    with open(dataFile, "r", encoding="utf-8") as f:
    25|         0|            0|            0|  0.00%|        for i, line in enumerate(f):
    26|         0|            0|            0|  0.00%|            l = line.replace("\n", "").split("\t")
    27|         0|            0|            0|  0.00%|            timestamp = float(l[0])
    28|         0|            0|            0|  0.00%|            words = l[1].split(",")
    29|         0|            0|            0|  0.00%|            try:
    30|         0|            0|            0|  0.00%|                clusTxt = l[2]
    31|         0|            0|            0|  0.00%|                clusTmp = l[3]
    32|         0|            0|            0|  0.00%|            except:
    33|         0|            0|            0|  0.00%|                clusTxt = None
    34|         0|            0|            0|  0.00%|                clusTmp = None
    35|         0|            0|            0|  0.00%|            uniquewords, cntwords = np.unique(words, return_counts=True)
    36|         0|            0|            0|  0.00%|            for un in uniquewords:
    37|         0|            0|            0|  0.00%|                if un not in wdToIndex:
    38|         0|            0|            0|  0.00%|                    wdToIndex[un] = index
    39|         0|            0|            0|  0.00%|                    index += 1
    40|         0|            0|            0|  0.00%|            uniquewords = [wdToIndex[un] for un in uniquewords]
    41|         0|            0|            0|  0.00%|            uniquewords, cntwords = np.array(uniquewords, dtype=int), np.array(cntwords, dtype=int)
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|            tup = (i, timestamp, (uniquewords, cntwords), (clusTxt, clusTmp))
    44|         0|            0|            0|  0.00%|            observations.append(tup)
    45|         0|            0|            0|  0.00%|    with open(output_folder+name_ds.replace("_events.txt", "")+"_indexWords.txt", "w+", encoding="utf-8") as f:
    46|         0|            0|            0|  0.00%|        for wd in wdToIndex:
    47|         0|            0|            0|  0.00%|            f.write(f"{wdToIndex[wd]}\t{wd}\n")
    48|         0|            0|            0|  0.00%|    V = len(wdToIndex)
    49|         0|            0|            0|  0.00%|    indexToWd = {idx: wd for wd, idx in wdToIndex.items()}
    50|         0|            0|            0|  0.00%|    return observations, V, indexToWd
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|def getData(params):
    53|         0|            0|            0|  0.00%|    (folder, DS, nbClasses, run_time, multivariate,
    54|         0|            0|            0|  0.00%|     overlap_voc, overlap_temp, perc_rand,
    55|         0|            0|            0|  0.00%|     voc_per_class, words_per_obs, theta0,
    56|         0|            0|            0|  0.00%|     lamb0_poisson, lamb0_classes, alpha0, means, sigs) = params
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|    name_ds = f"Obs_nbclasses={nbClasses}_lg={run_time}_overlapvoc={overlap_voc}_overlaptemp={overlap_temp}" \
    59|         0|            0|            0|  0.00%|              f"_percrandomizedclus={perc_rand}_vocperclass={voc_per_class}_wordsperevent={words_per_obs}_DS={DS}"+"_events.txt"
    60|         0|            0|            0|  0.00%|    output_folder = folder.replace("data/", "output/")
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    observations, vocabulary_size, indexToWd = readObservations(folder, name_ds, output_folder)
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    return name_ds, observations, vocabulary_size
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|try:
    68|         0|            0|            0|  0.00%|    RW = sys.argv[1]
    69|         0|            0|            0|  0.00%|    XP = sys.argv[2]
    70|         0|            0|            0|  0.00%|except:
    71|         0|            0|            0|  0.00%|    RW = "0"
    72|         0|            0|            0|  0.00%|    XP = "6"
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|if RW=="0":
    76|         0|            0|            0|  0.00%|    nbClasses = 2
    77|         0|            0|            0|  0.00%|    num_obs = 50000
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    overlap_voc = 0.2  # Proportion of voc in common between a clusters and its direct neighbours
    80|         0|            0|            0|  0.00%|    overlap_temp = 0.2  # Overlap between the kernels of the simulating process
    81|         0|            0|            0|  0.00%|    perc_rand = 0.  # Percentage of events to which assign random textual cluster
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|    voc_per_class = 1000  # Number of words available for each cluster
    84|         0|            0|            0|  0.00%|    words_per_obs = 5  # Twitter or headlines typically have few named entities
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    lamb0_poisson = 0.01  # Cannot be inferred
    87|         0|            0|            0|  0.00%|    lamb0_classes = 0.1  # Cannot be inferred
    88|         0|            0|            0|  0.00%|    theta0 = 10.  # Has already been documented for RW in LDA like models, DHP, etc ~0.01, 0.001 ; here it's 10 to ease computing the overlap_voc
    89|         0|            0|            0|  0.00%|    alpha0 = 1.  # Uniform beta or Dirichlet prior
    90|         0|            0|            0|  0.00%|    means = np.array([3, 5, 7, 11, 13])
    91|         0|            0|            0|  0.00%|    sigs = np.array([0.5, 0.5, 0.5, 0.5, 0.5])
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    arrR = [1., 0., 0.5, 1.5]
    94|         0|            0|            0|  0.00%|    nbDS = 10
    95|         0|            0|            0|  0.00%|    sample_num = 2000  # Typically 5 active clusters, so 25*5 parameters to infer using 2000*5 samples => ~80 samples per parameter
    96|         0|            0|            0|  0.00%|    particle_num = 10  # Like 10 simultaneous runs
    97|         0|            0|            0|  0.00%|    multivariate = True
    98|         0|            0|            0|  0.00%|    printRes = True
    99|         0|            0|            0|  0.00%|    eval_on_go = True
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    folder = "data/Synth/"
   102|         0|            0|            0|  0.00%|    output_folder = "output/Synth/"
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    # Overlap voc vs overlap temp
   105|         0|            0|            0|  0.00%|    def XP1(folder, output_folder):
   106|         0|            0|            0|  0.00%|        folder += "XP1/"
   107|         0|            0|            0|  0.00%|        output_folder += "XP1/"
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|        overlaps_voc = np.linspace(0, 1, 6)
   110|         0|            0|            0|  0.00%|        overlaps_temp = np.linspace(0, 1, 6)
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|        t = time.time()
   113|         0|            0|            0|  0.00%|        i = 0
   114|         0|            0|            0|  0.00%|        nbRunsTot = nbDS*len(overlaps_voc)*len(overlaps_temp)*len(arrR)
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|        for DS in range(nbDS):
   117|         0|            0|            0|  0.00%|            for overlap_voc in overlaps_voc:
   118|         0|            0|            0|  0.00%|                for overlap_temp in overlaps_temp:
   119|         0|            0|            0|  0.00%|                    overlap_voc = np.round(overlap_voc, 2)
   120|         0|            0|            0|  0.00%|                    overlap_temp = np.round(overlap_temp, 2)
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|                    params = (folder, DS, nbClasses, num_obs, multivariate,
   123|         0|            0|            0|  0.00%|                              overlap_voc, overlap_temp, perc_rand,
   124|         0|            0|            0|  0.00%|                              voc_per_class, words_per_obs, theta0,
   125|         0|            0|            0|  0.00%|                              lamb0_poisson, lamb0_classes, alpha0, means, sigs)
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|                    success = generate(params)
   128|         0|            0|            0|  0.00%|                    if success==-1: continue
   129|         0|            0|            0|  0.00%|                    name_ds, observations, vocabulary_size = getData(params)
   130|         0|            0|            0|  0.00%|                    name_ds = name_ds.replace("_events.txt", "")
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|                    for r in arrR:
   133|         0|            0|            0|  0.00%|                        print(f"DS {DS} - overlap voc = {overlap_voc} - overlap temp = {overlap_temp} - r = {r}")
   134|         0|            0|            0|  0.00%|                        r = np.round(r, 2)
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|                        name_output = f"{name_ds}_r={r}" \
   137|         0|            0|            0|  0.00%|                                      f"_theta0={theta0}_alpha0={alpha0}_lamb0={lamb0_classes}" \
   138|         0|            0|            0|  0.00%|                                      f"_samplenum={sample_num}_particlenum={particle_num}"
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|                        run_fit(observations, output_folder, name_output, lamb0_poisson, means, sigs, r=r,
   141|         0|            0|            0|  0.00%|                                theta0=theta0, alpha0=alpha0, sample_num=sample_num, particle_num=particle_num,
   142|         0|            0|            0|  0.00%|                                printRes=printRes, vocabulary_size=vocabulary_size, multivariate=multivariate,
   143|         0|            0|            0|  0.00%|                                eval_on_go=eval_on_go)
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|                        i += 1
   146|         0|            0|            0|  0.00%|                        print(f"------------------------- r={r} - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - "
   147|         0|            0|            0|  0.00%|                              f"ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|    # nbClasses vs lamb0
   150|         0|            0|            0|  0.00%|    def XP2(folder, output_folder):
   151|         0|            0|            0|  0.00%|        folder += "XP2/"
   152|         0|            0|            0|  0.00%|        output_folder += "XP2/"
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|        arrNbClasses = list(range(2, 10))
   155|         0|            0|            0|  0.00%|        arrLambPoisson = np.logspace(-4, 1, 6)
   156|         0|            0|            0|  0.00%|        arrR = [1.]
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|        t = time.time()
   159|         0|            0|            0|  0.00%|        i = 0
   160|         0|            0|            0|  0.00%|        nbRunsTot = nbDS*len(arrNbClasses)*len(arrLambPoisson)*len(arrR)
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|        num_obs = 100000
   163|         0|            0|            0|  0.00%|        for DS in range(nbDS):
   164|         0|            0|            0|  0.00%|            for nbClasses in arrNbClasses:
   165|         0|            0|            0|  0.00%|                for lamb0_poisson in arrLambPoisson:
   166|         0|            0|            0|  0.00%|                    lamb0_poisson = np.round(lamb0_poisson, 5)
   167|         0|            0|            0|  0.00%|                    nbClasses = int(nbClasses)
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|                    params = (folder, DS, nbClasses, num_obs, multivariate,
   170|         0|            0|            0|  0.00%|                              overlap_voc, overlap_temp, perc_rand,
   171|         0|            0|            0|  0.00%|                              voc_per_class, words_per_obs, theta0,
   172|         0|            0|            0|  0.00%|                              lamb0_poisson, lamb0_classes, alpha0, means, sigs)
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|                    success = generate(params)
   175|         0|            0|            0|  0.00%|                    if success==-1: continue
   176|         0|            0|            0|  0.00%|                    name_ds, observations, vocabulary_size = getData(params)
   177|         0|            0|            0|  0.00%|                    name_ds = name_ds.replace("_events.txt", "")
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|                    for r in arrR:
   180|         0|            0|            0|  0.00%|                        print(f"DS {DS} - lamb0_poisson = {lamb0_poisson} - nbClasses = {nbClasses} - r = {r}")
   181|         0|            0|            0|  0.00%|                        r = np.round(r, 2)
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|                        name_output = f"{name_ds}_r={r}" \
   184|         0|            0|            0|  0.00%|                                      f"_theta0={theta0}_alpha0={alpha0}_lamb0={lamb0_classes}" \
   185|         0|            0|            0|  0.00%|                                      f"_samplenum={sample_num}_particlenum={particle_num}"
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|                        run_fit(observations, output_folder, name_output, lamb0_poisson, means, sigs, r=r,
   188|         0|            0|            0|  0.00%|                                theta0=theta0, alpha0=alpha0, sample_num=sample_num, particle_num=particle_num,
   189|         0|            0|            0|  0.00%|                                printRes=printRes, vocabulary_size=vocabulary_size, multivariate=multivariate,
   190|         0|            0|            0|  0.00%|                                eval_on_go=eval_on_go)
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|                        i += 1
   193|         0|            0|            0|  0.00%|                        print(f"------------------------- r={r} - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - "
   194|         0|            0|            0|  0.00%|                              f"ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|    # Words per obs vs overlap voc
   197|         0|            0|            0|  0.00%|    def XP3(folder, output_folder):
   198|         0|            0|            0|  0.00%|        folder += "XP3/"
   199|         0|            0|            0|  0.00%|        output_folder += "XP3/"
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|        arr_words_per_obs = [1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 20]
   202|         0|            0|            0|  0.00%|        arr_overlap_voc = np.linspace(0, 1, 6)
   203|         0|            0|            0|  0.00%|        arrR = [1.]
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|        t = time.time()
   206|         0|            0|            0|  0.00%|        i = 0
   207|         0|            0|            0|  0.00%|        nbRunsTot = nbDS*len(arr_words_per_obs)*len(arr_overlap_voc)*len(arrR)
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|        for DS in range(nbDS):
   210|         0|            0|            0|  0.00%|            for words_per_obs in arr_words_per_obs:
   211|         0|            0|            0|  0.00%|                for overlap_voc in arr_overlap_voc:
   212|         0|            0|            0|  0.00%|                    words_per_obs = int(words_per_obs)
   213|         0|            0|            0|  0.00%|                    overlap_voc = np.round(overlap_voc, 3)
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|                    params = (folder, DS, nbClasses, num_obs, multivariate,
   216|         0|            0|            0|  0.00%|                              overlap_voc, overlap_temp, perc_rand,
   217|         0|            0|            0|  0.00%|                              voc_per_class, words_per_obs, theta0,
   218|         0|            0|            0|  0.00%|                              lamb0_poisson, lamb0_classes, alpha0, means, sigs)
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|                    success = generate(params)
   221|         0|            0|            0|  0.00%|                    if success==-1: continue
   222|         0|            0|            0|  0.00%|                    name_ds, observations, vocabulary_size = getData(params)
   223|         0|            0|            0|  0.00%|                    name_ds = name_ds.replace("_events.txt", "")
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|                    for r in arrR:
   226|         0|            0|            0|  0.00%|                        print(f"DS {DS} - words per obs = {words_per_obs} - overlap_voc = {overlap_voc} - r = {r}")
   227|         0|            0|            0|  0.00%|                        r = np.round(r, 2)
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|                        name_output = f"{name_ds}_r={r}" \
   230|         0|            0|            0|  0.00%|                                      f"_theta0={theta0}_alpha0={alpha0}_lamb0={lamb0_classes}" \
   231|         0|            0|            0|  0.00%|                                      f"_samplenum={sample_num}_particlenum={particle_num}"
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|                        run_fit(observations, output_folder, name_output, lamb0_poisson, means, sigs, r=r,
   234|         0|            0|            0|  0.00%|                                theta0=theta0, alpha0=alpha0, sample_num=sample_num, particle_num=particle_num,
   235|         0|            0|            0|  0.00%|                                printRes=printRes, vocabulary_size=vocabulary_size, multivariate=multivariate,
   236|         0|            0|            0|  0.00%|                                eval_on_go=eval_on_go)
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|                        i += 1
   240|         0|            0|            0|  0.00%|                        print(f"------------------------- r={r} - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - "
   241|         0|            0|            0|  0.00%|                              f"ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    # Perc decorr vs r
   244|         0|            0|            0|  0.00%|    def XP4(folder, output_folder):
   245|         0|            0|            0|  0.00%|        folder += "XP4/"
   246|         0|            0|            0|  0.00%|        output_folder += "XP4/"
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|        arr_perc_rand = np.linspace(0, 1, 6)
   249|         0|            0|            0|  0.00%|        arrR = np.linspace(0, 3, 16)
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|        t = time.time()
   252|         0|            0|            0|  0.00%|        i = 0
   253|         0|            0|            0|  0.00%|        nbRunsTot = nbDS*len(arr_perc_rand)*len(arrR)
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|        for DS in range(nbDS):
   256|         0|            0|            0|  0.00%|            for perc_rand in arr_perc_rand:
   257|         0|            0|            0|  0.00%|                perc_rand = np.round(perc_rand, 2)
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|                params = (folder, DS, nbClasses, num_obs, multivariate,
   260|         0|            0|            0|  0.00%|                          overlap_voc, overlap_temp, perc_rand,
   261|         0|            0|            0|  0.00%|                          voc_per_class, words_per_obs, theta0,
   262|         0|            0|            0|  0.00%|                          lamb0_poisson, lamb0_classes, alpha0, means, sigs)
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|                success = generate(params)
   265|         0|            0|            0|  0.00%|                if success==-1: continue
   266|         0|            0|            0|  0.00%|                name_ds, observations, vocabulary_size = getData(params)
   267|         0|            0|            0|  0.00%|                name_ds = name_ds.replace("_events.txt", "")
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|                for r in arrR:
   270|         0|            0|            0|  0.00%|                    print(f"DS {DS} - perc rand = {perc_rand} - r = {r}")
   271|         0|            0|            0|  0.00%|                    r = np.round(r, 2)
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|                    name_output = f"{name_ds}_r={r}" \
   274|         0|            0|            0|  0.00%|                                  f"_theta0={theta0}_alpha0={alpha0}_lamb0={lamb0_classes}" \
   275|         0|            0|            0|  0.00%|                                  f"_samplenum={sample_num}_particlenum={particle_num}"
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|                    run_fit(observations, output_folder, name_output, lamb0_poisson, means, sigs, r=r,
   278|         0|            0|            0|  0.00%|                            theta0=theta0, alpha0=alpha0, sample_num=sample_num, particle_num=particle_num,
   279|         0|            0|            0|  0.00%|                            printRes=printRes, vocabulary_size=vocabulary_size, multivariate=multivariate,
   280|         0|            0|            0|  0.00%|                            eval_on_go=eval_on_go)
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|                    i += 1
   284|         0|            0|            0|  0.00%|                    print(f"------------------------- r={r} - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - "
   285|         0|            0|            0|  0.00%|                          f"ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|    # Univariate
   288|         0|            0|            0|  0.00%|    def XP5(folder, output_folder):
   289|         0|            0|            0|  0.00%|        folder += "XP5/"
   290|         0|            0|            0|  0.00%|        output_folder += "XP5/"
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|        overlaps_voc = np.linspace(0, 1, 6)
   293|         0|            0|            0|  0.00%|        overlaps_temp = np.linspace(0, 1, 6)
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|        t = time.time()
   296|         0|            0|            0|  0.00%|        i = 0
   297|         0|            0|            0|  0.00%|        nbRunsTot = nbDS*len(overlaps_voc)*len(overlaps_temp)*len(arrR)
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|        multivariate = False
   300|         0|            0|            0|  0.00%|        for DS in range(nbDS):
   301|         0|            0|            0|  0.00%|            for overlap_voc in overlaps_voc:
   302|         0|            0|            0|  0.00%|                for overlap_temp in overlaps_temp:
   303|         0|            0|            0|  0.00%|                    overlap_voc = np.round(overlap_voc, 1)
   304|         0|            0|            0|  0.00%|                    overlap_temp = np.round(overlap_temp, 1)
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|                    params = (folder, DS, nbClasses, num_obs, multivariate,
   307|         0|            0|            0|  0.00%|                              overlap_voc, overlap_temp, perc_rand,
   308|         0|            0|            0|  0.00%|                              voc_per_class, words_per_obs, theta0,
   309|         0|            0|            0|  0.00%|                              lamb0_poisson, lamb0_classes, alpha0, means, sigs)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|                    success = generate(params)
   312|         0|            0|            0|  0.00%|                    if success==-1: continue
   313|         0|            0|            0|  0.00%|                    name_ds, observations, vocabulary_size = getData(params)
   314|         0|            0|            0|  0.00%|                    name_ds = name_ds.replace("_events.txt", "")
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|                    for r in arrR:
   317|         0|            0|            0|  0.00%|                        print(f"DS {DS} - Univariate - overlap voc = {overlap_voc} - overlap temp = {overlap_temp} - r = {r}")
   318|         0|            0|            0|  0.00%|                        r = np.round(r, 2)
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|                        name_output = f"{name_ds}_r={r}" \
   321|         0|            0|            0|  0.00%|                                      f"_theta0={theta0}_alpha0={alpha0}_lamb0={lamb0_classes}" \
   322|         0|            0|            0|  0.00%|                                      f"_samplenum={sample_num}_particlenum={particle_num}"
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|                        run_fit(observations, output_folder, name_output, lamb0_poisson, means, sigs, r=r,
   325|         0|            0|            0|  0.00%|                                theta0=theta0, alpha0=alpha0, sample_num=sample_num, particle_num=particle_num,
   326|         0|            0|            0|  0.00%|                                printRes=printRes, vocabulary_size=vocabulary_size, multivariate=multivariate,
   327|         0|            0|            0|  0.00%|                                eval_on_go=eval_on_go)
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|                        i += 1
   330|         0|            0|            0|  0.00%|                        print(f"------------------------- r={r} - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - "
   331|         0|            0|            0|  0.00%|                              f"ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    # Num part vs num sample
   334|         0|            0|            0|  0.00%|    def XP6(folder, output_folder):
   335|         0|            0|            0|  0.00%|        folder += "XP6/"
   336|         0|            0|            0|  0.00%|        output_folder += "XP6/"
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|        num_part = [1, 2, 4, 8, 12, 16, 20, 25]
   339|         0|            0|            0|  0.00%|        num_part = [5]  # ===================================================
   340|         0|            0|            0|  0.00%|        lamb0_poisson = 1.  # ===================================================
   341|         0|            0|            0|  0.00%|        overlap_temp = 0.5  # ===================================================
   342|         0|            0|            0|  0.00%|        num_obs = 1000  #  # ===================================================
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|        num_sample = np.logspace(1, 5, 5)
   345|         0|            0|            0|  0.00%|        arrR = [1.]
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|        t = time.time()
   348|         0|            0|            0|  0.00%|        i = 0
   349|         0|            0|            0|  0.00%|        nbRunsTot = nbDS*len(num_part)*len(num_sample)*len(arrR)
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|        for DS in range(nbDS):
   352|         0|            0|            0|  0.00%|            for particle_num in num_part:
   353|         0|            0|            0|  0.00%|                for sample_num in num_sample:
   354|         0|            0|            0|  0.00%|                    sample_num = int(sample_num)
   355|         0|            0|            0|  0.00%|                    particle_num = int(particle_num)
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|                    params = (folder, DS, nbClasses, num_obs, multivariate,
   358|         0|            0|            0|  0.00%|                              overlap_voc, overlap_temp, perc_rand,
   359|         0|            0|            0|  0.00%|                              voc_per_class, words_per_obs, theta0,
   360|         0|            0|            0|  0.00%|                              lamb0_poisson, lamb0_classes, alpha0, means, sigs)
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|                    success = generate(params)
   363|         0|            0|            0|  0.00%|                    if success==-1: continue
   364|         0|            0|            0|  0.00%|                    name_ds, observations, vocabulary_size = getData(params)
   365|         0|            0|            0|  0.00%|                    name_ds = name_ds.replace("_events.txt", "")
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|                    for r in arrR:
   368|         0|            0|            0|  0.00%|                        print(f"DS {DS} - Univariate - particles = {particle_num} - sample num = {sample_num} - r = {r}")
   369|         0|            0|            0|  0.00%|                        r = np.round(r, 2)
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|                        import pprofile
   372|         0|            0|            0|  0.00%|                        profiler = pprofile.Profile()
   373|         0|            0|            0|  0.00%|                        with profiler:
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|                            name_output = f"{name_ds}_r={r}" \
   376|         0|            0|            0|  0.00%|                                          f"_theta0={theta0}_alpha0={alpha0}_lamb0={lamb0_classes}" \
   377|         0|            0|            0|  0.00%|                                          f"_samplenum={sample_num}_particlenum={particle_num}"
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|                            run_fit(observations, output_folder, name_output, lamb0_poisson, means, sigs, r=r,
(call)|         1|      35.0978|      35.0978|100.00%|# D:\Thèse\Codes\Articles\MPDHP\MPDHP.py:614 run_fit
   380|         0|            0|            0|  0.00%|                                    theta0=theta0, alpha0=alpha0, sample_num=sample_num, particle_num=particle_num,
   381|         0|            0|            0|  0.00%|                                    printRes=printRes, vocabulary_size=vocabulary_size, multivariate=multivariate,
   382|         0|            0|            0|  0.00%|                                    eval_on_go=eval_on_go)
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|                            i += 1
   385|         0|            0|            0|  0.00%|                            print(f"------------------------- r={r} - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - "
(call)|         2|            0|            0|  0.00%|# <__array_function__ internals>:177 round_
   386|         0|            0|            0|  0.00%|                                  f"ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|                        profiler.print_stats()
   389|         0|            0|            0|  0.00%|                        profiler.dump_stats("Benchmark.txt")
   390|         0|            0|            0|  0.00%|                        pause()
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    if XP=="1":
   394|         0|            0|            0|  0.00%|        XP1(folder, output_folder)
   395|         0|            0|            0|  0.00%|    if XP=="2":
   396|         0|            0|            0|  0.00%|        XP2(folder, output_folder)
   397|         0|            0|            0|  0.00%|    if XP=="3":
   398|         0|            0|            0|  0.00%|        XP3(folder, output_folder)
   399|         0|            0|            0|  0.00%|    if XP=="4":
   400|         0|            0|            0|  0.00%|        XP4(folder, output_folder)
   401|         0|            0|            0|  0.00%|    if XP=="5":
   402|         0|            0|            0|  0.00%|        XP5(folder, output_folder)
   403|         0|            0|            0|  0.00%|    if XP=="6":
   404|         0|            0|            0|  0.00%|        XP6(folder, output_folder)
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|else:
   407|         0|            0|            0|  0.00%|    lamb0_poisson = 0.01  # Set at ~2sigma
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    means = None
   410|         0|            0|            0|  0.00%|    sigs = None
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    try:
   413|         0|            0|            0|  0.00%|        timescale = sys.argv[3]
   414|         0|            0|            0|  0.00%|        theta0 = float(sys.argv[4])
   415|         0|            0|            0|  0.00%|    except:
   416|         0|            0|            0|  0.00%|        timescale = "min"
   417|         0|            0|            0|  0.00%|        theta0 = 0.1  # Has already been documented for RW in LDA like models, DHP, etc ~0.1, 0.01 ; here it's 10 to ease computing the overlap_voc
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|    if timescale=="min":
   420|         0|            0|            0|  0.00%|        lamb0_poisson /= 1
   421|         0|            0|            0|  0.00%|        means = [10*(i) for i in range(9)]  # Until 90min
   422|         0|            0|            0|  0.00%|        sigs = [5 for i in range(9)]
   423|         0|            0|            0|  0.00%|    elif timescale=="h":
   424|         0|            0|            0|  0.00%|        lamb0_poisson /= 10
   425|         0|            0|            0|  0.00%|        means = [120*(i) for i in range(5)]  # Until 600min
   426|         0|            0|            0|  0.00%|        sigs = [60 for i in range(5)]
   427|         0|            0|            0|  0.00%|    elif timescale=="d":
   428|         0|            0|            0|  0.00%|        lamb0_poisson /= 10000
   429|         0|            0|            0|  0.00%|        means = [3600*24*(i) for i in range(7)]  # Until 86400min
   430|         0|            0|            0|  0.00%|        sigs = [3600*24/2 for i in range(7)]
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    means = np.array(means)
   433|         0|            0|            0|  0.00%|    sigs = np.array(sigs)
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    alpha0 = 1.  # Uniform beta or Dirichlet prior
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|    arrR = [1., 0., 1.5, 0.5]
   438|         0|            0|            0|  0.00%|    sample_num = 20000  # Typically 5 active clusters, so 25*len(mean) parameters to infer using sample_num*len(mean) samples => ~sample_num/25 samples per float
   439|         0|            0|            0|  0.00%|    particle_num = 20  # Like 10 simultaneous runs
   440|         0|            0|            0|  0.00%|    multivariate = True
   441|         0|            0|            0|  0.00%|    printRes = True
   442|         0|            0|            0|  0.00%|    eval_on_go = False
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|    folder = "data/Covid/"
   445|         0|            0|            0|  0.00%|    output_folder = "output/Covid/"
   446|         0|            0|            0|  0.00%|    lg = XP
   447|         0|            0|            0|  0.00%|    name_ds = f"COVID-19-events_{lg}.txt"
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    t = time.time()
   450|         0|            0|            0|  0.00%|    i = 0
   451|         0|            0|            0|  0.00%|    nbRunsTot = len(arrR)
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    for r in arrR:
   454|         0|            0|            0|  0.00%|        name_output = f"COVID-19-events_{lg}_timescale={timescale}_theta0={np.round(theta0,3)}_lamb0={lamb0_poisson}_" \
   455|         0|            0|            0|  0.00%|                      f"r={np.round(r,1)}_multi={multivariate}_samples={sample_num}_parts={particle_num}"
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|        # import pprofile
   458|         0|            0|            0|  0.00%|        # profiler = pprofile.Profile()
   459|         0|            0|            0|  0.00%|        # with profiler:
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|        observations, vocabulary_size, indexToWd = readObservations(folder, name_ds, output_folder)
   462|         0|            0|            0|  0.00%|        DHP = run_fit(observations, output_folder, name_output, lamb0_poisson, means, sigs, r=r, theta0=theta0, alpha0=alpha0,
   463|         0|            0|            0|  0.00%|                sample_num=sample_num, particle_num=particle_num, printRes=printRes,
   464|         0|            0|            0|  0.00%|                vocabulary_size=vocabulary_size, multivariate=multivariate, eval_on_go=eval_on_go, indexToWd=indexToWd)
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|        # profiler.print_stats()
   468|         0|            0|            0|  0.00%|        # profiler.dump_stats("Benchmark.txt")
   469|         0|            0|            0|  0.00%|        # pause()
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|        i += 1
   472|         0|            0|            0|  0.00%|        print(f"------------------------- r={r} - REMAINING TIME: {np.round((time.time()-t)*(nbRunsTot-i)/((i+1e-20)*3600), 2)}h - "
   473|         0|            0|            0|  0.00%|              f"ELAPSED TIME: {np.round((time.time()-t)/(3600), 2)}h")
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|        for c in DHP.particles[0].active_clusters:
   477|         0|            0|            0|  0.00%|            wds = [idx for _, idx in reversed(sorted(zip(DHP.particles[0].clusters[c].word_distribution, list(range(len(DHP.particles[0].clusters[c].word_distribution))))))]
   478|         0|            0|            0|  0.00%|            print([indexToWd[idx] for idx in wds][:10],
   479|         0|            0|            0|  0.00%|                len(DHP.particles[0].clusters[c].word_distribution.nonzero()[0]), vocabulary_size)
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|
